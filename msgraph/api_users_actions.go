/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// UsersActionsApiService UsersActionsApi service
type UsersActionsApiService service

type ApiUsersGetAvailableExtensionPropertiesRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	inlineObject1193 *InlineObject1193
}

func (r ApiUsersGetAvailableExtensionPropertiesRequest) InlineObject1193(inlineObject1193 InlineObject1193) ApiUsersGetAvailableExtensionPropertiesRequest {
	r.inlineObject1193 = &inlineObject1193
	return r
}

func (r ApiUsersGetAvailableExtensionPropertiesRequest) Execute() ([]MicrosoftGraphExtensionProperty, *_nethttp.Response, error) {
	return r.ApiService.UsersGetAvailableExtensionPropertiesExecute(r)
}

/*
UsersGetAvailableExtensionProperties Invoke action getAvailableExtensionProperties

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsersGetAvailableExtensionPropertiesRequest
*/
func (a *UsersActionsApiService) UsersGetAvailableExtensionProperties(ctx _context.Context) ApiUsersGetAvailableExtensionPropertiesRequest {
	return ApiUsersGetAvailableExtensionPropertiesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []MicrosoftGraphExtensionProperty
func (a *UsersActionsApiService) UsersGetAvailableExtensionPropertiesExecute(r ApiUsersGetAvailableExtensionPropertiesRequest) ([]MicrosoftGraphExtensionProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []MicrosoftGraphExtensionProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersGetAvailableExtensionProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/microsoft.graph.getAvailableExtensionProperties"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1193 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1193 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1193
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersGetByIdsRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	inlineObject1194 *InlineObject1194
}

func (r ApiUsersGetByIdsRequest) InlineObject1194(inlineObject1194 InlineObject1194) ApiUsersGetByIdsRequest {
	r.inlineObject1194 = &inlineObject1194
	return r
}

func (r ApiUsersGetByIdsRequest) Execute() ([]MicrosoftGraphDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.UsersGetByIdsExecute(r)
}

/*
UsersGetByIds Invoke action getByIds

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsersGetByIdsRequest
*/
func (a *UsersActionsApiService) UsersGetByIds(ctx _context.Context) ApiUsersGetByIdsRequest {
	return ApiUsersGetByIdsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []MicrosoftGraphDirectoryObject
func (a *UsersActionsApiService) UsersGetByIdsExecute(r ApiUsersGetByIdsRequest) ([]MicrosoftGraphDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []MicrosoftGraphDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersGetByIds")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/microsoft.graph.getByIds"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1194 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1194 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1194
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserAssignLicenseRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	inlineObject1079 *InlineObject1079
}

func (r ApiUsersUserAssignLicenseRequest) InlineObject1079(inlineObject1079 InlineObject1079) ApiUsersUserAssignLicenseRequest {
	r.inlineObject1079 = &inlineObject1079
	return r
}

func (r ApiUsersUserAssignLicenseRequest) Execute() (AnyOfmicrosoftGraphUser, *_nethttp.Response, error) {
	return r.ApiService.UsersUserAssignLicenseExecute(r)
}

/*
UsersUserAssignLicense Invoke action assignLicense

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @return ApiUsersUserAssignLicenseRequest
*/
func (a *UsersActionsApiService) UsersUserAssignLicense(ctx _context.Context, userId string) ApiUsersUserAssignLicenseRequest {
	return ApiUsersUserAssignLicenseRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphUser
func (a *UsersActionsApiService) UsersUserAssignLicenseExecute(r ApiUsersUserAssignLicenseRequest) (AnyOfmicrosoftGraphUser, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphUser
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserAssignLicense")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/microsoft.graph.assignLicense"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1079 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1079 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1079
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserCalendarCalendarViewEventAcceptRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	inlineObject861 *InlineObject861
}

func (r ApiUsersUserCalendarCalendarViewEventAcceptRequest) InlineObject861(inlineObject861 InlineObject861) ApiUsersUserCalendarCalendarViewEventAcceptRequest {
	r.inlineObject861 = &inlineObject861
	return r
}

func (r ApiUsersUserCalendarCalendarViewEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarCalendarViewEventAcceptExecute(r)
}

/*
UsersUserCalendarCalendarViewEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @return ApiUsersUserCalendarCalendarViewEventAcceptRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarCalendarViewEventAccept(ctx _context.Context, userId string, eventId string) ApiUsersUserCalendarCalendarViewEventAcceptRequest {
	return ApiUsersUserCalendarCalendarViewEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarCalendarViewEventAcceptExecute(r ApiUsersUserCalendarCalendarViewEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarCalendarViewEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendar/calendarView/{event-id}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject861 == nil {
		return nil, reportError("inlineObject861 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject861
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	inlineObject853 *InlineObject853
}

func (r ApiUsersUserCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest) InlineObject853(inlineObject853 InlineObject853) ApiUsersUserCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest {
	r.inlineObject853 = &inlineObject853
	return r
}

func (r ApiUsersUserCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest) Execute() (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarCalendarViewEventAttachmentsCreateUploadSessionExecute(r)
}

/*
UsersUserCalendarCalendarViewEventAttachmentsCreateUploadSession Invoke action createUploadSession

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @return ApiUsersUserCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarCalendarViewEventAttachmentsCreateUploadSession(ctx _context.Context, userId string, eventId string) ApiUsersUserCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest {
	return ApiUsersUserCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphUploadSession
func (a *UsersActionsApiService) UsersUserCalendarCalendarViewEventAttachmentsCreateUploadSessionExecute(r ApiUsersUserCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest) (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphUploadSession
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarCalendarViewEventAttachmentsCreateUploadSession")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendar/calendarView/{event-id}/attachments/microsoft.graph.createUploadSession"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject853 == nil {
		return localVarReturnValue, nil, reportError("inlineObject853 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject853
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserCalendarCalendarViewEventCalendarGetScheduleRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	inlineObject854 *InlineObject854
}

func (r ApiUsersUserCalendarCalendarViewEventCalendarGetScheduleRequest) InlineObject854(inlineObject854 InlineObject854) ApiUsersUserCalendarCalendarViewEventCalendarGetScheduleRequest {
	r.inlineObject854 = &inlineObject854
	return r
}

func (r ApiUsersUserCalendarCalendarViewEventCalendarGetScheduleRequest) Execute() ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarCalendarViewEventCalendarGetScheduleExecute(r)
}

/*
UsersUserCalendarCalendarViewEventCalendarGetSchedule Invoke action getSchedule

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @return ApiUsersUserCalendarCalendarViewEventCalendarGetScheduleRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarCalendarViewEventCalendarGetSchedule(ctx _context.Context, userId string, eventId string) ApiUsersUserCalendarCalendarViewEventCalendarGetScheduleRequest {
	return ApiUsersUserCalendarCalendarViewEventCalendarGetScheduleRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return []*AnyOfmicrosoftGraphScheduleInformation
func (a *UsersActionsApiService) UsersUserCalendarCalendarViewEventCalendarGetScheduleExecute(r ApiUsersUserCalendarCalendarViewEventCalendarGetScheduleRequest) ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []*AnyOfmicrosoftGraphScheduleInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarCalendarViewEventCalendarGetSchedule")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendar/calendarView/{event-id}/calendar/microsoft.graph.getSchedule"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject854 == nil {
		return localVarReturnValue, nil, reportError("inlineObject854 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject854
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserCalendarCalendarViewEventCancelRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	inlineObject862 *InlineObject862
}

func (r ApiUsersUserCalendarCalendarViewEventCancelRequest) InlineObject862(inlineObject862 InlineObject862) ApiUsersUserCalendarCalendarViewEventCancelRequest {
	r.inlineObject862 = &inlineObject862
	return r
}

func (r ApiUsersUserCalendarCalendarViewEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarCalendarViewEventCancelExecute(r)
}

/*
UsersUserCalendarCalendarViewEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @return ApiUsersUserCalendarCalendarViewEventCancelRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarCalendarViewEventCancel(ctx _context.Context, userId string, eventId string) ApiUsersUserCalendarCalendarViewEventCancelRequest {
	return ApiUsersUserCalendarCalendarViewEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarCalendarViewEventCancelExecute(r ApiUsersUserCalendarCalendarViewEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarCalendarViewEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendar/calendarView/{event-id}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject862 == nil {
		return nil, reportError("inlineObject862 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject862
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarCalendarViewEventDeclineRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	inlineObject863 *InlineObject863
}

func (r ApiUsersUserCalendarCalendarViewEventDeclineRequest) InlineObject863(inlineObject863 InlineObject863) ApiUsersUserCalendarCalendarViewEventDeclineRequest {
	r.inlineObject863 = &inlineObject863
	return r
}

func (r ApiUsersUserCalendarCalendarViewEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarCalendarViewEventDeclineExecute(r)
}

/*
UsersUserCalendarCalendarViewEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @return ApiUsersUserCalendarCalendarViewEventDeclineRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarCalendarViewEventDecline(ctx _context.Context, userId string, eventId string) ApiUsersUserCalendarCalendarViewEventDeclineRequest {
	return ApiUsersUserCalendarCalendarViewEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarCalendarViewEventDeclineExecute(r ApiUsersUserCalendarCalendarViewEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarCalendarViewEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendar/calendarView/{event-id}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject863 == nil {
		return nil, reportError("inlineObject863 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject863
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarCalendarViewEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
}


func (r ApiUsersUserCalendarCalendarViewEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarCalendarViewEventDismissReminderExecute(r)
}

/*
UsersUserCalendarCalendarViewEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @return ApiUsersUserCalendarCalendarViewEventDismissReminderRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarCalendarViewEventDismissReminder(ctx _context.Context, userId string, eventId string) ApiUsersUserCalendarCalendarViewEventDismissReminderRequest {
	return ApiUsersUserCalendarCalendarViewEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarCalendarViewEventDismissReminderExecute(r ApiUsersUserCalendarCalendarViewEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarCalendarViewEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendar/calendarView/{event-id}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarCalendarViewEventForwardRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	inlineObject864 *InlineObject864
}

func (r ApiUsersUserCalendarCalendarViewEventForwardRequest) InlineObject864(inlineObject864 InlineObject864) ApiUsersUserCalendarCalendarViewEventForwardRequest {
	r.inlineObject864 = &inlineObject864
	return r
}

func (r ApiUsersUserCalendarCalendarViewEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarCalendarViewEventForwardExecute(r)
}

/*
UsersUserCalendarCalendarViewEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @return ApiUsersUserCalendarCalendarViewEventForwardRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarCalendarViewEventForward(ctx _context.Context, userId string, eventId string) ApiUsersUserCalendarCalendarViewEventForwardRequest {
	return ApiUsersUserCalendarCalendarViewEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarCalendarViewEventForwardExecute(r ApiUsersUserCalendarCalendarViewEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarCalendarViewEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendar/calendarView/{event-id}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject864 == nil {
		return nil, reportError("inlineObject864 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject864
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarCalendarViewEventInstancesEventAcceptRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
	inlineObject855 *InlineObject855
}

func (r ApiUsersUserCalendarCalendarViewEventInstancesEventAcceptRequest) InlineObject855(inlineObject855 InlineObject855) ApiUsersUserCalendarCalendarViewEventInstancesEventAcceptRequest {
	r.inlineObject855 = &inlineObject855
	return r
}

func (r ApiUsersUserCalendarCalendarViewEventInstancesEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarCalendarViewEventInstancesEventAcceptExecute(r)
}

/*
UsersUserCalendarCalendarViewEventInstancesEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarCalendarViewEventInstancesEventAcceptRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarCalendarViewEventInstancesEventAccept(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserCalendarCalendarViewEventInstancesEventAcceptRequest {
	return ApiUsersUserCalendarCalendarViewEventInstancesEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarCalendarViewEventInstancesEventAcceptExecute(r ApiUsersUserCalendarCalendarViewEventInstancesEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarCalendarViewEventInstancesEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendar/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject855 == nil {
		return nil, reportError("inlineObject855 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject855
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarCalendarViewEventInstancesEventCancelRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
	inlineObject856 *InlineObject856
}

func (r ApiUsersUserCalendarCalendarViewEventInstancesEventCancelRequest) InlineObject856(inlineObject856 InlineObject856) ApiUsersUserCalendarCalendarViewEventInstancesEventCancelRequest {
	r.inlineObject856 = &inlineObject856
	return r
}

func (r ApiUsersUserCalendarCalendarViewEventInstancesEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarCalendarViewEventInstancesEventCancelExecute(r)
}

/*
UsersUserCalendarCalendarViewEventInstancesEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarCalendarViewEventInstancesEventCancelRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarCalendarViewEventInstancesEventCancel(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserCalendarCalendarViewEventInstancesEventCancelRequest {
	return ApiUsersUserCalendarCalendarViewEventInstancesEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarCalendarViewEventInstancesEventCancelExecute(r ApiUsersUserCalendarCalendarViewEventInstancesEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarCalendarViewEventInstancesEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendar/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject856 == nil {
		return nil, reportError("inlineObject856 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject856
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarCalendarViewEventInstancesEventDeclineRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
	inlineObject857 *InlineObject857
}

func (r ApiUsersUserCalendarCalendarViewEventInstancesEventDeclineRequest) InlineObject857(inlineObject857 InlineObject857) ApiUsersUserCalendarCalendarViewEventInstancesEventDeclineRequest {
	r.inlineObject857 = &inlineObject857
	return r
}

func (r ApiUsersUserCalendarCalendarViewEventInstancesEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarCalendarViewEventInstancesEventDeclineExecute(r)
}

/*
UsersUserCalendarCalendarViewEventInstancesEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarCalendarViewEventInstancesEventDeclineRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarCalendarViewEventInstancesEventDecline(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserCalendarCalendarViewEventInstancesEventDeclineRequest {
	return ApiUsersUserCalendarCalendarViewEventInstancesEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarCalendarViewEventInstancesEventDeclineExecute(r ApiUsersUserCalendarCalendarViewEventInstancesEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarCalendarViewEventInstancesEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendar/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject857 == nil {
		return nil, reportError("inlineObject857 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject857
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarCalendarViewEventInstancesEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
}


func (r ApiUsersUserCalendarCalendarViewEventInstancesEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarCalendarViewEventInstancesEventDismissReminderExecute(r)
}

/*
UsersUserCalendarCalendarViewEventInstancesEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarCalendarViewEventInstancesEventDismissReminderRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarCalendarViewEventInstancesEventDismissReminder(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserCalendarCalendarViewEventInstancesEventDismissReminderRequest {
	return ApiUsersUserCalendarCalendarViewEventInstancesEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarCalendarViewEventInstancesEventDismissReminderExecute(r ApiUsersUserCalendarCalendarViewEventInstancesEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarCalendarViewEventInstancesEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendar/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarCalendarViewEventInstancesEventForwardRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
	inlineObject858 *InlineObject858
}

func (r ApiUsersUserCalendarCalendarViewEventInstancesEventForwardRequest) InlineObject858(inlineObject858 InlineObject858) ApiUsersUserCalendarCalendarViewEventInstancesEventForwardRequest {
	r.inlineObject858 = &inlineObject858
	return r
}

func (r ApiUsersUserCalendarCalendarViewEventInstancesEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarCalendarViewEventInstancesEventForwardExecute(r)
}

/*
UsersUserCalendarCalendarViewEventInstancesEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarCalendarViewEventInstancesEventForwardRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarCalendarViewEventInstancesEventForward(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserCalendarCalendarViewEventInstancesEventForwardRequest {
	return ApiUsersUserCalendarCalendarViewEventInstancesEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarCalendarViewEventInstancesEventForwardExecute(r ApiUsersUserCalendarCalendarViewEventInstancesEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarCalendarViewEventInstancesEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendar/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject858 == nil {
		return nil, reportError("inlineObject858 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject858
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarCalendarViewEventInstancesEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
	inlineObject859 *InlineObject859
}

func (r ApiUsersUserCalendarCalendarViewEventInstancesEventSnoozeReminderRequest) InlineObject859(inlineObject859 InlineObject859) ApiUsersUserCalendarCalendarViewEventInstancesEventSnoozeReminderRequest {
	r.inlineObject859 = &inlineObject859
	return r
}

func (r ApiUsersUserCalendarCalendarViewEventInstancesEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarCalendarViewEventInstancesEventSnoozeReminderExecute(r)
}

/*
UsersUserCalendarCalendarViewEventInstancesEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarCalendarViewEventInstancesEventSnoozeReminderRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarCalendarViewEventInstancesEventSnoozeReminder(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserCalendarCalendarViewEventInstancesEventSnoozeReminderRequest {
	return ApiUsersUserCalendarCalendarViewEventInstancesEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarCalendarViewEventInstancesEventSnoozeReminderExecute(r ApiUsersUserCalendarCalendarViewEventInstancesEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarCalendarViewEventInstancesEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendar/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject859 == nil {
		return nil, reportError("inlineObject859 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject859
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
	inlineObject860 *InlineObject860
}

func (r ApiUsersUserCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest) InlineObject860(inlineObject860 InlineObject860) ApiUsersUserCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest {
	r.inlineObject860 = &inlineObject860
	return r
}

func (r ApiUsersUserCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarCalendarViewEventInstancesEventTentativelyAcceptExecute(r)
}

/*
UsersUserCalendarCalendarViewEventInstancesEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarCalendarViewEventInstancesEventTentativelyAccept(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest {
	return ApiUsersUserCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarCalendarViewEventInstancesEventTentativelyAcceptExecute(r ApiUsersUserCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarCalendarViewEventInstancesEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendar/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject860 == nil {
		return nil, reportError("inlineObject860 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject860
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarCalendarViewEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	inlineObject865 *InlineObject865
}

func (r ApiUsersUserCalendarCalendarViewEventSnoozeReminderRequest) InlineObject865(inlineObject865 InlineObject865) ApiUsersUserCalendarCalendarViewEventSnoozeReminderRequest {
	r.inlineObject865 = &inlineObject865
	return r
}

func (r ApiUsersUserCalendarCalendarViewEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarCalendarViewEventSnoozeReminderExecute(r)
}

/*
UsersUserCalendarCalendarViewEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @return ApiUsersUserCalendarCalendarViewEventSnoozeReminderRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarCalendarViewEventSnoozeReminder(ctx _context.Context, userId string, eventId string) ApiUsersUserCalendarCalendarViewEventSnoozeReminderRequest {
	return ApiUsersUserCalendarCalendarViewEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarCalendarViewEventSnoozeReminderExecute(r ApiUsersUserCalendarCalendarViewEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarCalendarViewEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendar/calendarView/{event-id}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject865 == nil {
		return nil, reportError("inlineObject865 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject865
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarCalendarViewEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	inlineObject866 *InlineObject866
}

func (r ApiUsersUserCalendarCalendarViewEventTentativelyAcceptRequest) InlineObject866(inlineObject866 InlineObject866) ApiUsersUserCalendarCalendarViewEventTentativelyAcceptRequest {
	r.inlineObject866 = &inlineObject866
	return r
}

func (r ApiUsersUserCalendarCalendarViewEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarCalendarViewEventTentativelyAcceptExecute(r)
}

/*
UsersUserCalendarCalendarViewEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @return ApiUsersUserCalendarCalendarViewEventTentativelyAcceptRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarCalendarViewEventTentativelyAccept(ctx _context.Context, userId string, eventId string) ApiUsersUserCalendarCalendarViewEventTentativelyAcceptRequest {
	return ApiUsersUserCalendarCalendarViewEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarCalendarViewEventTentativelyAcceptExecute(r ApiUsersUserCalendarCalendarViewEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarCalendarViewEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendar/calendarView/{event-id}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject866 == nil {
		return nil, reportError("inlineObject866 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject866
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarEventsEventAcceptRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	inlineObject875 *InlineObject875
}

func (r ApiUsersUserCalendarEventsEventAcceptRequest) InlineObject875(inlineObject875 InlineObject875) ApiUsersUserCalendarEventsEventAcceptRequest {
	r.inlineObject875 = &inlineObject875
	return r
}

func (r ApiUsersUserCalendarEventsEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarEventsEventAcceptExecute(r)
}

/*
UsersUserCalendarEventsEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @return ApiUsersUserCalendarEventsEventAcceptRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarEventsEventAccept(ctx _context.Context, userId string, eventId string) ApiUsersUserCalendarEventsEventAcceptRequest {
	return ApiUsersUserCalendarEventsEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarEventsEventAcceptExecute(r ApiUsersUserCalendarEventsEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarEventsEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendar/events/{event-id}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject875 == nil {
		return nil, reportError("inlineObject875 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject875
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarEventsEventAttachmentsCreateUploadSessionRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	inlineObject867 *InlineObject867
}

func (r ApiUsersUserCalendarEventsEventAttachmentsCreateUploadSessionRequest) InlineObject867(inlineObject867 InlineObject867) ApiUsersUserCalendarEventsEventAttachmentsCreateUploadSessionRequest {
	r.inlineObject867 = &inlineObject867
	return r
}

func (r ApiUsersUserCalendarEventsEventAttachmentsCreateUploadSessionRequest) Execute() (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarEventsEventAttachmentsCreateUploadSessionExecute(r)
}

/*
UsersUserCalendarEventsEventAttachmentsCreateUploadSession Invoke action createUploadSession

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @return ApiUsersUserCalendarEventsEventAttachmentsCreateUploadSessionRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarEventsEventAttachmentsCreateUploadSession(ctx _context.Context, userId string, eventId string) ApiUsersUserCalendarEventsEventAttachmentsCreateUploadSessionRequest {
	return ApiUsersUserCalendarEventsEventAttachmentsCreateUploadSessionRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphUploadSession
func (a *UsersActionsApiService) UsersUserCalendarEventsEventAttachmentsCreateUploadSessionExecute(r ApiUsersUserCalendarEventsEventAttachmentsCreateUploadSessionRequest) (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphUploadSession
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarEventsEventAttachmentsCreateUploadSession")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendar/events/{event-id}/attachments/microsoft.graph.createUploadSession"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject867 == nil {
		return localVarReturnValue, nil, reportError("inlineObject867 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject867
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserCalendarEventsEventCalendarGetScheduleRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	inlineObject868 *InlineObject868
}

func (r ApiUsersUserCalendarEventsEventCalendarGetScheduleRequest) InlineObject868(inlineObject868 InlineObject868) ApiUsersUserCalendarEventsEventCalendarGetScheduleRequest {
	r.inlineObject868 = &inlineObject868
	return r
}

func (r ApiUsersUserCalendarEventsEventCalendarGetScheduleRequest) Execute() ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarEventsEventCalendarGetScheduleExecute(r)
}

/*
UsersUserCalendarEventsEventCalendarGetSchedule Invoke action getSchedule

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @return ApiUsersUserCalendarEventsEventCalendarGetScheduleRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarEventsEventCalendarGetSchedule(ctx _context.Context, userId string, eventId string) ApiUsersUserCalendarEventsEventCalendarGetScheduleRequest {
	return ApiUsersUserCalendarEventsEventCalendarGetScheduleRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return []*AnyOfmicrosoftGraphScheduleInformation
func (a *UsersActionsApiService) UsersUserCalendarEventsEventCalendarGetScheduleExecute(r ApiUsersUserCalendarEventsEventCalendarGetScheduleRequest) ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []*AnyOfmicrosoftGraphScheduleInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarEventsEventCalendarGetSchedule")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendar/events/{event-id}/calendar/microsoft.graph.getSchedule"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject868 == nil {
		return localVarReturnValue, nil, reportError("inlineObject868 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject868
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserCalendarEventsEventCancelRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	inlineObject876 *InlineObject876
}

func (r ApiUsersUserCalendarEventsEventCancelRequest) InlineObject876(inlineObject876 InlineObject876) ApiUsersUserCalendarEventsEventCancelRequest {
	r.inlineObject876 = &inlineObject876
	return r
}

func (r ApiUsersUserCalendarEventsEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarEventsEventCancelExecute(r)
}

/*
UsersUserCalendarEventsEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @return ApiUsersUserCalendarEventsEventCancelRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarEventsEventCancel(ctx _context.Context, userId string, eventId string) ApiUsersUserCalendarEventsEventCancelRequest {
	return ApiUsersUserCalendarEventsEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarEventsEventCancelExecute(r ApiUsersUserCalendarEventsEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarEventsEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendar/events/{event-id}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject876 == nil {
		return nil, reportError("inlineObject876 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject876
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarEventsEventDeclineRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	inlineObject877 *InlineObject877
}

func (r ApiUsersUserCalendarEventsEventDeclineRequest) InlineObject877(inlineObject877 InlineObject877) ApiUsersUserCalendarEventsEventDeclineRequest {
	r.inlineObject877 = &inlineObject877
	return r
}

func (r ApiUsersUserCalendarEventsEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarEventsEventDeclineExecute(r)
}

/*
UsersUserCalendarEventsEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @return ApiUsersUserCalendarEventsEventDeclineRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarEventsEventDecline(ctx _context.Context, userId string, eventId string) ApiUsersUserCalendarEventsEventDeclineRequest {
	return ApiUsersUserCalendarEventsEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarEventsEventDeclineExecute(r ApiUsersUserCalendarEventsEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarEventsEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendar/events/{event-id}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject877 == nil {
		return nil, reportError("inlineObject877 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject877
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarEventsEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
}


func (r ApiUsersUserCalendarEventsEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarEventsEventDismissReminderExecute(r)
}

/*
UsersUserCalendarEventsEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @return ApiUsersUserCalendarEventsEventDismissReminderRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarEventsEventDismissReminder(ctx _context.Context, userId string, eventId string) ApiUsersUserCalendarEventsEventDismissReminderRequest {
	return ApiUsersUserCalendarEventsEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarEventsEventDismissReminderExecute(r ApiUsersUserCalendarEventsEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarEventsEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendar/events/{event-id}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarEventsEventForwardRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	inlineObject878 *InlineObject878
}

func (r ApiUsersUserCalendarEventsEventForwardRequest) InlineObject878(inlineObject878 InlineObject878) ApiUsersUserCalendarEventsEventForwardRequest {
	r.inlineObject878 = &inlineObject878
	return r
}

func (r ApiUsersUserCalendarEventsEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarEventsEventForwardExecute(r)
}

/*
UsersUserCalendarEventsEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @return ApiUsersUserCalendarEventsEventForwardRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarEventsEventForward(ctx _context.Context, userId string, eventId string) ApiUsersUserCalendarEventsEventForwardRequest {
	return ApiUsersUserCalendarEventsEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarEventsEventForwardExecute(r ApiUsersUserCalendarEventsEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarEventsEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendar/events/{event-id}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject878 == nil {
		return nil, reportError("inlineObject878 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject878
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarEventsEventInstancesEventAcceptRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
	inlineObject869 *InlineObject869
}

func (r ApiUsersUserCalendarEventsEventInstancesEventAcceptRequest) InlineObject869(inlineObject869 InlineObject869) ApiUsersUserCalendarEventsEventInstancesEventAcceptRequest {
	r.inlineObject869 = &inlineObject869
	return r
}

func (r ApiUsersUserCalendarEventsEventInstancesEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarEventsEventInstancesEventAcceptExecute(r)
}

/*
UsersUserCalendarEventsEventInstancesEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarEventsEventInstancesEventAcceptRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarEventsEventInstancesEventAccept(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserCalendarEventsEventInstancesEventAcceptRequest {
	return ApiUsersUserCalendarEventsEventInstancesEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarEventsEventInstancesEventAcceptExecute(r ApiUsersUserCalendarEventsEventInstancesEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarEventsEventInstancesEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendar/events/{event-id}/instances/{event-id1}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject869 == nil {
		return nil, reportError("inlineObject869 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject869
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarEventsEventInstancesEventCancelRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
	inlineObject870 *InlineObject870
}

func (r ApiUsersUserCalendarEventsEventInstancesEventCancelRequest) InlineObject870(inlineObject870 InlineObject870) ApiUsersUserCalendarEventsEventInstancesEventCancelRequest {
	r.inlineObject870 = &inlineObject870
	return r
}

func (r ApiUsersUserCalendarEventsEventInstancesEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarEventsEventInstancesEventCancelExecute(r)
}

/*
UsersUserCalendarEventsEventInstancesEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarEventsEventInstancesEventCancelRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarEventsEventInstancesEventCancel(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserCalendarEventsEventInstancesEventCancelRequest {
	return ApiUsersUserCalendarEventsEventInstancesEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarEventsEventInstancesEventCancelExecute(r ApiUsersUserCalendarEventsEventInstancesEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarEventsEventInstancesEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendar/events/{event-id}/instances/{event-id1}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject870 == nil {
		return nil, reportError("inlineObject870 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject870
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarEventsEventInstancesEventDeclineRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
	inlineObject871 *InlineObject871
}

func (r ApiUsersUserCalendarEventsEventInstancesEventDeclineRequest) InlineObject871(inlineObject871 InlineObject871) ApiUsersUserCalendarEventsEventInstancesEventDeclineRequest {
	r.inlineObject871 = &inlineObject871
	return r
}

func (r ApiUsersUserCalendarEventsEventInstancesEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarEventsEventInstancesEventDeclineExecute(r)
}

/*
UsersUserCalendarEventsEventInstancesEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarEventsEventInstancesEventDeclineRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarEventsEventInstancesEventDecline(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserCalendarEventsEventInstancesEventDeclineRequest {
	return ApiUsersUserCalendarEventsEventInstancesEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarEventsEventInstancesEventDeclineExecute(r ApiUsersUserCalendarEventsEventInstancesEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarEventsEventInstancesEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendar/events/{event-id}/instances/{event-id1}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject871 == nil {
		return nil, reportError("inlineObject871 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject871
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarEventsEventInstancesEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
}


func (r ApiUsersUserCalendarEventsEventInstancesEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarEventsEventInstancesEventDismissReminderExecute(r)
}

/*
UsersUserCalendarEventsEventInstancesEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarEventsEventInstancesEventDismissReminderRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarEventsEventInstancesEventDismissReminder(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserCalendarEventsEventInstancesEventDismissReminderRequest {
	return ApiUsersUserCalendarEventsEventInstancesEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarEventsEventInstancesEventDismissReminderExecute(r ApiUsersUserCalendarEventsEventInstancesEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarEventsEventInstancesEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendar/events/{event-id}/instances/{event-id1}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarEventsEventInstancesEventForwardRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
	inlineObject872 *InlineObject872
}

func (r ApiUsersUserCalendarEventsEventInstancesEventForwardRequest) InlineObject872(inlineObject872 InlineObject872) ApiUsersUserCalendarEventsEventInstancesEventForwardRequest {
	r.inlineObject872 = &inlineObject872
	return r
}

func (r ApiUsersUserCalendarEventsEventInstancesEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarEventsEventInstancesEventForwardExecute(r)
}

/*
UsersUserCalendarEventsEventInstancesEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarEventsEventInstancesEventForwardRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarEventsEventInstancesEventForward(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserCalendarEventsEventInstancesEventForwardRequest {
	return ApiUsersUserCalendarEventsEventInstancesEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarEventsEventInstancesEventForwardExecute(r ApiUsersUserCalendarEventsEventInstancesEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarEventsEventInstancesEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendar/events/{event-id}/instances/{event-id1}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject872 == nil {
		return nil, reportError("inlineObject872 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject872
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarEventsEventInstancesEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
	inlineObject873 *InlineObject873
}

func (r ApiUsersUserCalendarEventsEventInstancesEventSnoozeReminderRequest) InlineObject873(inlineObject873 InlineObject873) ApiUsersUserCalendarEventsEventInstancesEventSnoozeReminderRequest {
	r.inlineObject873 = &inlineObject873
	return r
}

func (r ApiUsersUserCalendarEventsEventInstancesEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarEventsEventInstancesEventSnoozeReminderExecute(r)
}

/*
UsersUserCalendarEventsEventInstancesEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarEventsEventInstancesEventSnoozeReminderRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarEventsEventInstancesEventSnoozeReminder(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserCalendarEventsEventInstancesEventSnoozeReminderRequest {
	return ApiUsersUserCalendarEventsEventInstancesEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarEventsEventInstancesEventSnoozeReminderExecute(r ApiUsersUserCalendarEventsEventInstancesEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarEventsEventInstancesEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendar/events/{event-id}/instances/{event-id1}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject873 == nil {
		return nil, reportError("inlineObject873 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject873
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarEventsEventInstancesEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
	inlineObject874 *InlineObject874
}

func (r ApiUsersUserCalendarEventsEventInstancesEventTentativelyAcceptRequest) InlineObject874(inlineObject874 InlineObject874) ApiUsersUserCalendarEventsEventInstancesEventTentativelyAcceptRequest {
	r.inlineObject874 = &inlineObject874
	return r
}

func (r ApiUsersUserCalendarEventsEventInstancesEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarEventsEventInstancesEventTentativelyAcceptExecute(r)
}

/*
UsersUserCalendarEventsEventInstancesEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarEventsEventInstancesEventTentativelyAcceptRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarEventsEventInstancesEventTentativelyAccept(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserCalendarEventsEventInstancesEventTentativelyAcceptRequest {
	return ApiUsersUserCalendarEventsEventInstancesEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarEventsEventInstancesEventTentativelyAcceptExecute(r ApiUsersUserCalendarEventsEventInstancesEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarEventsEventInstancesEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendar/events/{event-id}/instances/{event-id1}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject874 == nil {
		return nil, reportError("inlineObject874 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject874
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarEventsEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	inlineObject879 *InlineObject879
}

func (r ApiUsersUserCalendarEventsEventSnoozeReminderRequest) InlineObject879(inlineObject879 InlineObject879) ApiUsersUserCalendarEventsEventSnoozeReminderRequest {
	r.inlineObject879 = &inlineObject879
	return r
}

func (r ApiUsersUserCalendarEventsEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarEventsEventSnoozeReminderExecute(r)
}

/*
UsersUserCalendarEventsEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @return ApiUsersUserCalendarEventsEventSnoozeReminderRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarEventsEventSnoozeReminder(ctx _context.Context, userId string, eventId string) ApiUsersUserCalendarEventsEventSnoozeReminderRequest {
	return ApiUsersUserCalendarEventsEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarEventsEventSnoozeReminderExecute(r ApiUsersUserCalendarEventsEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarEventsEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendar/events/{event-id}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject879 == nil {
		return nil, reportError("inlineObject879 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject879
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarEventsEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	inlineObject880 *InlineObject880
}

func (r ApiUsersUserCalendarEventsEventTentativelyAcceptRequest) InlineObject880(inlineObject880 InlineObject880) ApiUsersUserCalendarEventsEventTentativelyAcceptRequest {
	r.inlineObject880 = &inlineObject880
	return r
}

func (r ApiUsersUserCalendarEventsEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarEventsEventTentativelyAcceptExecute(r)
}

/*
UsersUserCalendarEventsEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @return ApiUsersUserCalendarEventsEventTentativelyAcceptRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarEventsEventTentativelyAccept(ctx _context.Context, userId string, eventId string) ApiUsersUserCalendarEventsEventTentativelyAcceptRequest {
	return ApiUsersUserCalendarEventsEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarEventsEventTentativelyAcceptExecute(r ApiUsersUserCalendarEventsEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarEventsEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendar/events/{event-id}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject880 == nil {
		return nil, reportError("inlineObject880 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject880
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarGetScheduleRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	inlineObject881 *InlineObject881
}

func (r ApiUsersUserCalendarGetScheduleRequest) InlineObject881(inlineObject881 InlineObject881) ApiUsersUserCalendarGetScheduleRequest {
	r.inlineObject881 = &inlineObject881
	return r
}

func (r ApiUsersUserCalendarGetScheduleRequest) Execute() ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarGetScheduleExecute(r)
}

/*
UsersUserCalendarGetSchedule Invoke action getSchedule

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @return ApiUsersUserCalendarGetScheduleRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarGetSchedule(ctx _context.Context, userId string) ApiUsersUserCalendarGetScheduleRequest {
	return ApiUsersUserCalendarGetScheduleRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return []*AnyOfmicrosoftGraphScheduleInformation
func (a *UsersActionsApiService) UsersUserCalendarGetScheduleExecute(r ApiUsersUserCalendarGetScheduleRequest) ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []*AnyOfmicrosoftGraphScheduleInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarGetSchedule")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendar/microsoft.graph.getSchedule"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject881 == nil {
		return localVarReturnValue, nil, reportError("inlineObject881 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject881
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAcceptRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	inlineObject890 *InlineObject890
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAcceptRequest) InlineObject890(inlineObject890 InlineObject890) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAcceptRequest {
	r.inlineObject890 = &inlineObject890
	return r
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAcceptExecute(r)
}

/*
UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAcceptRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAccept(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAcceptRequest {
	return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAcceptExecute(r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject890 == nil {
		return nil, reportError("inlineObject890 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject890
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	inlineObject882 *InlineObject882
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest) InlineObject882(inlineObject882 InlineObject882) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest {
	r.inlineObject882 = &inlineObject882
	return r
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest) Execute() (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSessionExecute(r)
}

/*
UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSession Invoke action createUploadSession

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSession(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest {
	return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphUploadSession
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSessionExecute(r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest) (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphUploadSession
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSession")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/attachments/microsoft.graph.createUploadSession"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject882 == nil {
		return localVarReturnValue, nil, reportError("inlineObject882 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject882
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCalendarGetScheduleRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	inlineObject883 *InlineObject883
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCalendarGetScheduleRequest) InlineObject883(inlineObject883 InlineObject883) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCalendarGetScheduleRequest {
	r.inlineObject883 = &inlineObject883
	return r
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCalendarGetScheduleRequest) Execute() ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCalendarGetScheduleExecute(r)
}

/*
UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCalendarGetSchedule Invoke action getSchedule

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCalendarGetScheduleRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCalendarGetSchedule(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCalendarGetScheduleRequest {
	return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCalendarGetScheduleRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return []*AnyOfmicrosoftGraphScheduleInformation
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCalendarGetScheduleExecute(r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCalendarGetScheduleRequest) ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []*AnyOfmicrosoftGraphScheduleInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCalendarGetSchedule")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/calendar/microsoft.graph.getSchedule"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject883 == nil {
		return localVarReturnValue, nil, reportError("inlineObject883 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject883
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCancelRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	inlineObject891 *InlineObject891
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCancelRequest) InlineObject891(inlineObject891 InlineObject891) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCancelRequest {
	r.inlineObject891 = &inlineObject891
	return r
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCancelExecute(r)
}

/*
UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCancelRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCancel(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCancelRequest {
	return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCancelExecute(r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject891 == nil {
		return nil, reportError("inlineObject891 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject891
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventDeclineRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	inlineObject892 *InlineObject892
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventDeclineRequest) InlineObject892(inlineObject892 InlineObject892) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventDeclineRequest {
	r.inlineObject892 = &inlineObject892
	return r
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventDeclineExecute(r)
}

/*
UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventDeclineRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventDecline(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventDeclineRequest {
	return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventDeclineExecute(r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject892 == nil {
		return nil, reportError("inlineObject892 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject892
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
}


func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventDismissReminderExecute(r)
}

/*
UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventDismissReminderRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventDismissReminder(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventDismissReminderRequest {
	return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventDismissReminderExecute(r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventForwardRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	inlineObject893 *InlineObject893
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventForwardRequest) InlineObject893(inlineObject893 InlineObject893) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventForwardRequest {
	r.inlineObject893 = &inlineObject893
	return r
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventForwardExecute(r)
}

/*
UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventForwardRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventForward(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventForwardRequest {
	return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventForwardExecute(r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject893 == nil {
		return nil, reportError("inlineObject893 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject893
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventAcceptRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	eventId1 string
	inlineObject884 *InlineObject884
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventAcceptRequest) InlineObject884(inlineObject884 InlineObject884) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventAcceptRequest {
	r.inlineObject884 = &inlineObject884
	return r
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventAcceptExecute(r)
}

/*
UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventAcceptRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventAccept(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string, eventId1 string) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventAcceptRequest {
	return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventAcceptExecute(r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject884 == nil {
		return nil, reportError("inlineObject884 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject884
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventCancelRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	eventId1 string
	inlineObject885 *InlineObject885
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventCancelRequest) InlineObject885(inlineObject885 InlineObject885) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventCancelRequest {
	r.inlineObject885 = &inlineObject885
	return r
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventCancelExecute(r)
}

/*
UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventCancelRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventCancel(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string, eventId1 string) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventCancelRequest {
	return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventCancelExecute(r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject885 == nil {
		return nil, reportError("inlineObject885 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject885
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventDeclineRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	eventId1 string
	inlineObject886 *InlineObject886
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventDeclineRequest) InlineObject886(inlineObject886 InlineObject886) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventDeclineRequest {
	r.inlineObject886 = &inlineObject886
	return r
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventDeclineExecute(r)
}

/*
UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventDeclineRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventDecline(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string, eventId1 string) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventDeclineRequest {
	return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventDeclineExecute(r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject886 == nil {
		return nil, reportError("inlineObject886 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject886
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	eventId1 string
}


func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventDismissReminderExecute(r)
}

/*
UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventDismissReminderRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventDismissReminder(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string, eventId1 string) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventDismissReminderRequest {
	return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventDismissReminderExecute(r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventForwardRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	eventId1 string
	inlineObject887 *InlineObject887
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventForwardRequest) InlineObject887(inlineObject887 InlineObject887) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventForwardRequest {
	r.inlineObject887 = &inlineObject887
	return r
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventForwardExecute(r)
}

/*
UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventForwardRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventForward(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string, eventId1 string) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventForwardRequest {
	return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventForwardExecute(r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject887 == nil {
		return nil, reportError("inlineObject887 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject887
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	eventId1 string
	inlineObject888 *InlineObject888
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminderRequest) InlineObject888(inlineObject888 InlineObject888) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminderRequest {
	r.inlineObject888 = &inlineObject888
	return r
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminderExecute(r)
}

/*
UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminderRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminder(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string, eventId1 string) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminderRequest {
	return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminderExecute(r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject888 == nil {
		return nil, reportError("inlineObject888 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject888
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	eventId1 string
	inlineObject889 *InlineObject889
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest) InlineObject889(inlineObject889 InlineObject889) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest {
	r.inlineObject889 = &inlineObject889
	return r
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventTentativelyAcceptExecute(r)
}

/*
UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventTentativelyAccept(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string, eventId1 string) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest {
	return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventTentativelyAcceptExecute(r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject889 == nil {
		return nil, reportError("inlineObject889 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject889
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	inlineObject894 *InlineObject894
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventSnoozeReminderRequest) InlineObject894(inlineObject894 InlineObject894) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventSnoozeReminderRequest {
	r.inlineObject894 = &inlineObject894
	return r
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventSnoozeReminderExecute(r)
}

/*
UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventSnoozeReminderRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventSnoozeReminder(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventSnoozeReminderRequest {
	return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventSnoozeReminderExecute(r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject894 == nil {
		return nil, reportError("inlineObject894 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject894
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	inlineObject895 *InlineObject895
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventTentativelyAcceptRequest) InlineObject895(inlineObject895 InlineObject895) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventTentativelyAcceptRequest {
	r.inlineObject895 = &inlineObject895
	return r
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventTentativelyAcceptExecute(r)
}

/*
UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventTentativelyAcceptRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventTentativelyAccept(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventTentativelyAcceptRequest {
	return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventTentativelyAcceptExecute(r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject895 == nil {
		return nil, reportError("inlineObject895 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject895
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAcceptRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	inlineObject904 *InlineObject904
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAcceptRequest) InlineObject904(inlineObject904 InlineObject904) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAcceptRequest {
	r.inlineObject904 = &inlineObject904
	return r
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAcceptExecute(r)
}

/*
UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAcceptRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAccept(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAcceptRequest {
	return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAcceptExecute(r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject904 == nil {
		return nil, reportError("inlineObject904 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject904
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAttachmentsCreateUploadSessionRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	inlineObject896 *InlineObject896
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAttachmentsCreateUploadSessionRequest) InlineObject896(inlineObject896 InlineObject896) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAttachmentsCreateUploadSessionRequest {
	r.inlineObject896 = &inlineObject896
	return r
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAttachmentsCreateUploadSessionRequest) Execute() (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAttachmentsCreateUploadSessionExecute(r)
}

/*
UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAttachmentsCreateUploadSession Invoke action createUploadSession

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAttachmentsCreateUploadSessionRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAttachmentsCreateUploadSession(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAttachmentsCreateUploadSessionRequest {
	return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAttachmentsCreateUploadSessionRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphUploadSession
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAttachmentsCreateUploadSessionExecute(r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAttachmentsCreateUploadSessionRequest) (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphUploadSession
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAttachmentsCreateUploadSession")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/attachments/microsoft.graph.createUploadSession"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject896 == nil {
		return localVarReturnValue, nil, reportError("inlineObject896 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject896
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCalendarGetScheduleRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	inlineObject897 *InlineObject897
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCalendarGetScheduleRequest) InlineObject897(inlineObject897 InlineObject897) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCalendarGetScheduleRequest {
	r.inlineObject897 = &inlineObject897
	return r
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCalendarGetScheduleRequest) Execute() ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCalendarGetScheduleExecute(r)
}

/*
UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCalendarGetSchedule Invoke action getSchedule

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCalendarGetScheduleRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCalendarGetSchedule(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCalendarGetScheduleRequest {
	return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCalendarGetScheduleRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return []*AnyOfmicrosoftGraphScheduleInformation
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCalendarGetScheduleExecute(r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCalendarGetScheduleRequest) ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []*AnyOfmicrosoftGraphScheduleInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCalendarGetSchedule")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/calendar/microsoft.graph.getSchedule"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject897 == nil {
		return localVarReturnValue, nil, reportError("inlineObject897 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject897
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCancelRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	inlineObject905 *InlineObject905
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCancelRequest) InlineObject905(inlineObject905 InlineObject905) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCancelRequest {
	r.inlineObject905 = &inlineObject905
	return r
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCancelExecute(r)
}

/*
UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCancelRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCancel(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCancelRequest {
	return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCancelExecute(r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject905 == nil {
		return nil, reportError("inlineObject905 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject905
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventDeclineRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	inlineObject906 *InlineObject906
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventDeclineRequest) InlineObject906(inlineObject906 InlineObject906) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventDeclineRequest {
	r.inlineObject906 = &inlineObject906
	return r
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventDeclineExecute(r)
}

/*
UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventDeclineRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventDecline(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventDeclineRequest {
	return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventDeclineExecute(r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject906 == nil {
		return nil, reportError("inlineObject906 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject906
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
}


func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventDismissReminderExecute(r)
}

/*
UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventDismissReminderRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventDismissReminder(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventDismissReminderRequest {
	return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventDismissReminderExecute(r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventForwardRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	inlineObject907 *InlineObject907
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventForwardRequest) InlineObject907(inlineObject907 InlineObject907) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventForwardRequest {
	r.inlineObject907 = &inlineObject907
	return r
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventForwardExecute(r)
}

/*
UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventForwardRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventForward(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventForwardRequest {
	return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventForwardExecute(r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject907 == nil {
		return nil, reportError("inlineObject907 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject907
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventAcceptRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	eventId1 string
	inlineObject898 *InlineObject898
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventAcceptRequest) InlineObject898(inlineObject898 InlineObject898) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventAcceptRequest {
	r.inlineObject898 = &inlineObject898
	return r
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventAcceptExecute(r)
}

/*
UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventAcceptRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventAccept(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string, eventId1 string) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventAcceptRequest {
	return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventAcceptExecute(r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/instances/{event-id1}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject898 == nil {
		return nil, reportError("inlineObject898 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject898
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventCancelRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	eventId1 string
	inlineObject899 *InlineObject899
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventCancelRequest) InlineObject899(inlineObject899 InlineObject899) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventCancelRequest {
	r.inlineObject899 = &inlineObject899
	return r
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventCancelExecute(r)
}

/*
UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventCancelRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventCancel(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string, eventId1 string) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventCancelRequest {
	return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventCancelExecute(r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/instances/{event-id1}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject899 == nil {
		return nil, reportError("inlineObject899 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject899
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventDeclineRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	eventId1 string
	inlineObject900 *InlineObject900
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventDeclineRequest) InlineObject900(inlineObject900 InlineObject900) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventDeclineRequest {
	r.inlineObject900 = &inlineObject900
	return r
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventDeclineExecute(r)
}

/*
UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventDeclineRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventDecline(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string, eventId1 string) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventDeclineRequest {
	return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventDeclineExecute(r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/instances/{event-id1}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject900 == nil {
		return nil, reportError("inlineObject900 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject900
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	eventId1 string
}


func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventDismissReminderExecute(r)
}

/*
UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventDismissReminderRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventDismissReminder(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string, eventId1 string) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventDismissReminderRequest {
	return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventDismissReminderExecute(r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/instances/{event-id1}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventForwardRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	eventId1 string
	inlineObject901 *InlineObject901
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventForwardRequest) InlineObject901(inlineObject901 InlineObject901) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventForwardRequest {
	r.inlineObject901 = &inlineObject901
	return r
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventForwardExecute(r)
}

/*
UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventForwardRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventForward(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string, eventId1 string) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventForwardRequest {
	return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventForwardExecute(r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/instances/{event-id1}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject901 == nil {
		return nil, reportError("inlineObject901 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject901
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	eventId1 string
	inlineObject902 *InlineObject902
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventSnoozeReminderRequest) InlineObject902(inlineObject902 InlineObject902) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventSnoozeReminderRequest {
	r.inlineObject902 = &inlineObject902
	return r
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventSnoozeReminderExecute(r)
}

/*
UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventSnoozeReminderRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventSnoozeReminder(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string, eventId1 string) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventSnoozeReminderRequest {
	return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventSnoozeReminderExecute(r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/instances/{event-id1}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject902 == nil {
		return nil, reportError("inlineObject902 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject902
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	eventId1 string
	inlineObject903 *InlineObject903
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventTentativelyAcceptRequest) InlineObject903(inlineObject903 InlineObject903) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventTentativelyAcceptRequest {
	r.inlineObject903 = &inlineObject903
	return r
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventTentativelyAcceptExecute(r)
}

/*
UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventTentativelyAcceptRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventTentativelyAccept(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string, eventId1 string) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventTentativelyAcceptRequest {
	return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventTentativelyAcceptExecute(r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/instances/{event-id1}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject903 == nil {
		return nil, reportError("inlineObject903 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject903
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	inlineObject908 *InlineObject908
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventSnoozeReminderRequest) InlineObject908(inlineObject908 InlineObject908) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventSnoozeReminderRequest {
	r.inlineObject908 = &inlineObject908
	return r
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventSnoozeReminderExecute(r)
}

/*
UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventSnoozeReminderRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventSnoozeReminder(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventSnoozeReminderRequest {
	return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventSnoozeReminderExecute(r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject908 == nil {
		return nil, reportError("inlineObject908 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject908
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarGroupId string
	calendarId string
	eventId string
	inlineObject909 *InlineObject909
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventTentativelyAcceptRequest) InlineObject909(inlineObject909 InlineObject909) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventTentativelyAcceptRequest {
	r.inlineObject909 = &inlineObject909
	return r
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventTentativelyAcceptExecute(r)
}

/*
UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventTentativelyAcceptRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventTentativelyAccept(ctx _context.Context, userId string, calendarGroupId string, calendarId string, eventId string) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventTentativelyAcceptRequest {
	return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventTentativelyAcceptExecute(r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarEventsEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject909 == nil {
		return nil, reportError("inlineObject909 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject909
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarGetScheduleRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarGroupId string
	calendarId string
	inlineObject910 *InlineObject910
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarGetScheduleRequest) InlineObject910(inlineObject910 InlineObject910) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarGetScheduleRequest {
	r.inlineObject910 = &inlineObject910
	return r
}

func (r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarGetScheduleRequest) Execute() ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarGetScheduleExecute(r)
}

/*
UsersUserCalendarGroupsCalendarGroupCalendarsCalendarGetSchedule Invoke action getSchedule

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarGetScheduleRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarGetSchedule(ctx _context.Context, userId string, calendarGroupId string, calendarId string) ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarGetScheduleRequest {
	return ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarGetScheduleRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
	}
}

// Execute executes the request
//  @return []*AnyOfmicrosoftGraphScheduleInformation
func (a *UsersActionsApiService) UsersUserCalendarGroupsCalendarGroupCalendarsCalendarGetScheduleExecute(r ApiUsersUserCalendarGroupsCalendarGroupCalendarsCalendarGetScheduleRequest) ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []*AnyOfmicrosoftGraphScheduleInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarGroupsCalendarGroupCalendarsCalendarGetSchedule")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/microsoft.graph.getSchedule"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject910 == nil {
		return localVarReturnValue, nil, reportError("inlineObject910 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject910
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserCalendarViewEventAcceptRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	inlineObject960 *InlineObject960
}

func (r ApiUsersUserCalendarViewEventAcceptRequest) InlineObject960(inlineObject960 InlineObject960) ApiUsersUserCalendarViewEventAcceptRequest {
	r.inlineObject960 = &inlineObject960
	return r
}

func (r ApiUsersUserCalendarViewEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarViewEventAcceptExecute(r)
}

/*
UsersUserCalendarViewEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @return ApiUsersUserCalendarViewEventAcceptRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarViewEventAccept(ctx _context.Context, userId string, eventId string) ApiUsersUserCalendarViewEventAcceptRequest {
	return ApiUsersUserCalendarViewEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarViewEventAcceptExecute(r ApiUsersUserCalendarViewEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarViewEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarView/{event-id}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject960 == nil {
		return nil, reportError("inlineObject960 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject960
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarViewEventAttachmentsCreateUploadSessionRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	inlineObject940 *InlineObject940
}

func (r ApiUsersUserCalendarViewEventAttachmentsCreateUploadSessionRequest) InlineObject940(inlineObject940 InlineObject940) ApiUsersUserCalendarViewEventAttachmentsCreateUploadSessionRequest {
	r.inlineObject940 = &inlineObject940
	return r
}

func (r ApiUsersUserCalendarViewEventAttachmentsCreateUploadSessionRequest) Execute() (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarViewEventAttachmentsCreateUploadSessionExecute(r)
}

/*
UsersUserCalendarViewEventAttachmentsCreateUploadSession Invoke action createUploadSession

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @return ApiUsersUserCalendarViewEventAttachmentsCreateUploadSessionRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarViewEventAttachmentsCreateUploadSession(ctx _context.Context, userId string, eventId string) ApiUsersUserCalendarViewEventAttachmentsCreateUploadSessionRequest {
	return ApiUsersUserCalendarViewEventAttachmentsCreateUploadSessionRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphUploadSession
func (a *UsersActionsApiService) UsersUserCalendarViewEventAttachmentsCreateUploadSessionExecute(r ApiUsersUserCalendarViewEventAttachmentsCreateUploadSessionRequest) (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphUploadSession
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarViewEventAttachmentsCreateUploadSession")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarView/{event-id}/attachments/microsoft.graph.createUploadSession"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject940 == nil {
		return localVarReturnValue, nil, reportError("inlineObject940 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject940
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserCalendarViewEventCalendarCalendarViewEventAcceptRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
	inlineObject941 *InlineObject941
}

func (r ApiUsersUserCalendarViewEventCalendarCalendarViewEventAcceptRequest) InlineObject941(inlineObject941 InlineObject941) ApiUsersUserCalendarViewEventCalendarCalendarViewEventAcceptRequest {
	r.inlineObject941 = &inlineObject941
	return r
}

func (r ApiUsersUserCalendarViewEventCalendarCalendarViewEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarViewEventCalendarCalendarViewEventAcceptExecute(r)
}

/*
UsersUserCalendarViewEventCalendarCalendarViewEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarViewEventCalendarCalendarViewEventAcceptRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarViewEventCalendarCalendarViewEventAccept(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserCalendarViewEventCalendarCalendarViewEventAcceptRequest {
	return ApiUsersUserCalendarViewEventCalendarCalendarViewEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarViewEventCalendarCalendarViewEventAcceptExecute(r ApiUsersUserCalendarViewEventCalendarCalendarViewEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarViewEventCalendarCalendarViewEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarView/{event-id}/calendar/calendarView/{event-id1}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject941 == nil {
		return nil, reportError("inlineObject941 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject941
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarViewEventCalendarCalendarViewEventCancelRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
	inlineObject942 *InlineObject942
}

func (r ApiUsersUserCalendarViewEventCalendarCalendarViewEventCancelRequest) InlineObject942(inlineObject942 InlineObject942) ApiUsersUserCalendarViewEventCalendarCalendarViewEventCancelRequest {
	r.inlineObject942 = &inlineObject942
	return r
}

func (r ApiUsersUserCalendarViewEventCalendarCalendarViewEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarViewEventCalendarCalendarViewEventCancelExecute(r)
}

/*
UsersUserCalendarViewEventCalendarCalendarViewEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarViewEventCalendarCalendarViewEventCancelRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarViewEventCalendarCalendarViewEventCancel(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserCalendarViewEventCalendarCalendarViewEventCancelRequest {
	return ApiUsersUserCalendarViewEventCalendarCalendarViewEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarViewEventCalendarCalendarViewEventCancelExecute(r ApiUsersUserCalendarViewEventCalendarCalendarViewEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarViewEventCalendarCalendarViewEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarView/{event-id}/calendar/calendarView/{event-id1}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject942 == nil {
		return nil, reportError("inlineObject942 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject942
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarViewEventCalendarCalendarViewEventDeclineRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
	inlineObject943 *InlineObject943
}

func (r ApiUsersUserCalendarViewEventCalendarCalendarViewEventDeclineRequest) InlineObject943(inlineObject943 InlineObject943) ApiUsersUserCalendarViewEventCalendarCalendarViewEventDeclineRequest {
	r.inlineObject943 = &inlineObject943
	return r
}

func (r ApiUsersUserCalendarViewEventCalendarCalendarViewEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarViewEventCalendarCalendarViewEventDeclineExecute(r)
}

/*
UsersUserCalendarViewEventCalendarCalendarViewEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarViewEventCalendarCalendarViewEventDeclineRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarViewEventCalendarCalendarViewEventDecline(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserCalendarViewEventCalendarCalendarViewEventDeclineRequest {
	return ApiUsersUserCalendarViewEventCalendarCalendarViewEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarViewEventCalendarCalendarViewEventDeclineExecute(r ApiUsersUserCalendarViewEventCalendarCalendarViewEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarViewEventCalendarCalendarViewEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarView/{event-id}/calendar/calendarView/{event-id1}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject943 == nil {
		return nil, reportError("inlineObject943 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject943
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarViewEventCalendarCalendarViewEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
}


func (r ApiUsersUserCalendarViewEventCalendarCalendarViewEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarViewEventCalendarCalendarViewEventDismissReminderExecute(r)
}

/*
UsersUserCalendarViewEventCalendarCalendarViewEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarViewEventCalendarCalendarViewEventDismissReminderRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarViewEventCalendarCalendarViewEventDismissReminder(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserCalendarViewEventCalendarCalendarViewEventDismissReminderRequest {
	return ApiUsersUserCalendarViewEventCalendarCalendarViewEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarViewEventCalendarCalendarViewEventDismissReminderExecute(r ApiUsersUserCalendarViewEventCalendarCalendarViewEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarViewEventCalendarCalendarViewEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarView/{event-id}/calendar/calendarView/{event-id1}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarViewEventCalendarCalendarViewEventForwardRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
	inlineObject944 *InlineObject944
}

func (r ApiUsersUserCalendarViewEventCalendarCalendarViewEventForwardRequest) InlineObject944(inlineObject944 InlineObject944) ApiUsersUserCalendarViewEventCalendarCalendarViewEventForwardRequest {
	r.inlineObject944 = &inlineObject944
	return r
}

func (r ApiUsersUserCalendarViewEventCalendarCalendarViewEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarViewEventCalendarCalendarViewEventForwardExecute(r)
}

/*
UsersUserCalendarViewEventCalendarCalendarViewEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarViewEventCalendarCalendarViewEventForwardRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarViewEventCalendarCalendarViewEventForward(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserCalendarViewEventCalendarCalendarViewEventForwardRequest {
	return ApiUsersUserCalendarViewEventCalendarCalendarViewEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarViewEventCalendarCalendarViewEventForwardExecute(r ApiUsersUserCalendarViewEventCalendarCalendarViewEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarViewEventCalendarCalendarViewEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarView/{event-id}/calendar/calendarView/{event-id1}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject944 == nil {
		return nil, reportError("inlineObject944 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject944
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarViewEventCalendarCalendarViewEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
	inlineObject945 *InlineObject945
}

func (r ApiUsersUserCalendarViewEventCalendarCalendarViewEventSnoozeReminderRequest) InlineObject945(inlineObject945 InlineObject945) ApiUsersUserCalendarViewEventCalendarCalendarViewEventSnoozeReminderRequest {
	r.inlineObject945 = &inlineObject945
	return r
}

func (r ApiUsersUserCalendarViewEventCalendarCalendarViewEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarViewEventCalendarCalendarViewEventSnoozeReminderExecute(r)
}

/*
UsersUserCalendarViewEventCalendarCalendarViewEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarViewEventCalendarCalendarViewEventSnoozeReminderRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarViewEventCalendarCalendarViewEventSnoozeReminder(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserCalendarViewEventCalendarCalendarViewEventSnoozeReminderRequest {
	return ApiUsersUserCalendarViewEventCalendarCalendarViewEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarViewEventCalendarCalendarViewEventSnoozeReminderExecute(r ApiUsersUserCalendarViewEventCalendarCalendarViewEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarViewEventCalendarCalendarViewEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarView/{event-id}/calendar/calendarView/{event-id1}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject945 == nil {
		return nil, reportError("inlineObject945 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject945
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarViewEventCalendarCalendarViewEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
	inlineObject946 *InlineObject946
}

func (r ApiUsersUserCalendarViewEventCalendarCalendarViewEventTentativelyAcceptRequest) InlineObject946(inlineObject946 InlineObject946) ApiUsersUserCalendarViewEventCalendarCalendarViewEventTentativelyAcceptRequest {
	r.inlineObject946 = &inlineObject946
	return r
}

func (r ApiUsersUserCalendarViewEventCalendarCalendarViewEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarViewEventCalendarCalendarViewEventTentativelyAcceptExecute(r)
}

/*
UsersUserCalendarViewEventCalendarCalendarViewEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarViewEventCalendarCalendarViewEventTentativelyAcceptRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarViewEventCalendarCalendarViewEventTentativelyAccept(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserCalendarViewEventCalendarCalendarViewEventTentativelyAcceptRequest {
	return ApiUsersUserCalendarViewEventCalendarCalendarViewEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarViewEventCalendarCalendarViewEventTentativelyAcceptExecute(r ApiUsersUserCalendarViewEventCalendarCalendarViewEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarViewEventCalendarCalendarViewEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarView/{event-id}/calendar/calendarView/{event-id1}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject946 == nil {
		return nil, reportError("inlineObject946 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject946
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarViewEventCalendarEventsEventAcceptRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
	inlineObject947 *InlineObject947
}

func (r ApiUsersUserCalendarViewEventCalendarEventsEventAcceptRequest) InlineObject947(inlineObject947 InlineObject947) ApiUsersUserCalendarViewEventCalendarEventsEventAcceptRequest {
	r.inlineObject947 = &inlineObject947
	return r
}

func (r ApiUsersUserCalendarViewEventCalendarEventsEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarViewEventCalendarEventsEventAcceptExecute(r)
}

/*
UsersUserCalendarViewEventCalendarEventsEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarViewEventCalendarEventsEventAcceptRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarViewEventCalendarEventsEventAccept(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserCalendarViewEventCalendarEventsEventAcceptRequest {
	return ApiUsersUserCalendarViewEventCalendarEventsEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarViewEventCalendarEventsEventAcceptExecute(r ApiUsersUserCalendarViewEventCalendarEventsEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarViewEventCalendarEventsEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarView/{event-id}/calendar/events/{event-id1}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject947 == nil {
		return nil, reportError("inlineObject947 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject947
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarViewEventCalendarEventsEventCancelRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
	inlineObject948 *InlineObject948
}

func (r ApiUsersUserCalendarViewEventCalendarEventsEventCancelRequest) InlineObject948(inlineObject948 InlineObject948) ApiUsersUserCalendarViewEventCalendarEventsEventCancelRequest {
	r.inlineObject948 = &inlineObject948
	return r
}

func (r ApiUsersUserCalendarViewEventCalendarEventsEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarViewEventCalendarEventsEventCancelExecute(r)
}

/*
UsersUserCalendarViewEventCalendarEventsEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarViewEventCalendarEventsEventCancelRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarViewEventCalendarEventsEventCancel(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserCalendarViewEventCalendarEventsEventCancelRequest {
	return ApiUsersUserCalendarViewEventCalendarEventsEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarViewEventCalendarEventsEventCancelExecute(r ApiUsersUserCalendarViewEventCalendarEventsEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarViewEventCalendarEventsEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarView/{event-id}/calendar/events/{event-id1}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject948 == nil {
		return nil, reportError("inlineObject948 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject948
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarViewEventCalendarEventsEventDeclineRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
	inlineObject949 *InlineObject949
}

func (r ApiUsersUserCalendarViewEventCalendarEventsEventDeclineRequest) InlineObject949(inlineObject949 InlineObject949) ApiUsersUserCalendarViewEventCalendarEventsEventDeclineRequest {
	r.inlineObject949 = &inlineObject949
	return r
}

func (r ApiUsersUserCalendarViewEventCalendarEventsEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarViewEventCalendarEventsEventDeclineExecute(r)
}

/*
UsersUserCalendarViewEventCalendarEventsEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarViewEventCalendarEventsEventDeclineRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarViewEventCalendarEventsEventDecline(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserCalendarViewEventCalendarEventsEventDeclineRequest {
	return ApiUsersUserCalendarViewEventCalendarEventsEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarViewEventCalendarEventsEventDeclineExecute(r ApiUsersUserCalendarViewEventCalendarEventsEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarViewEventCalendarEventsEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarView/{event-id}/calendar/events/{event-id1}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject949 == nil {
		return nil, reportError("inlineObject949 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject949
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarViewEventCalendarEventsEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
}


func (r ApiUsersUserCalendarViewEventCalendarEventsEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarViewEventCalendarEventsEventDismissReminderExecute(r)
}

/*
UsersUserCalendarViewEventCalendarEventsEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarViewEventCalendarEventsEventDismissReminderRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarViewEventCalendarEventsEventDismissReminder(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserCalendarViewEventCalendarEventsEventDismissReminderRequest {
	return ApiUsersUserCalendarViewEventCalendarEventsEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarViewEventCalendarEventsEventDismissReminderExecute(r ApiUsersUserCalendarViewEventCalendarEventsEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarViewEventCalendarEventsEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarView/{event-id}/calendar/events/{event-id1}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarViewEventCalendarEventsEventForwardRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
	inlineObject950 *InlineObject950
}

func (r ApiUsersUserCalendarViewEventCalendarEventsEventForwardRequest) InlineObject950(inlineObject950 InlineObject950) ApiUsersUserCalendarViewEventCalendarEventsEventForwardRequest {
	r.inlineObject950 = &inlineObject950
	return r
}

func (r ApiUsersUserCalendarViewEventCalendarEventsEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarViewEventCalendarEventsEventForwardExecute(r)
}

/*
UsersUserCalendarViewEventCalendarEventsEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarViewEventCalendarEventsEventForwardRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarViewEventCalendarEventsEventForward(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserCalendarViewEventCalendarEventsEventForwardRequest {
	return ApiUsersUserCalendarViewEventCalendarEventsEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarViewEventCalendarEventsEventForwardExecute(r ApiUsersUserCalendarViewEventCalendarEventsEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarViewEventCalendarEventsEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarView/{event-id}/calendar/events/{event-id1}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject950 == nil {
		return nil, reportError("inlineObject950 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject950
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarViewEventCalendarEventsEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
	inlineObject951 *InlineObject951
}

func (r ApiUsersUserCalendarViewEventCalendarEventsEventSnoozeReminderRequest) InlineObject951(inlineObject951 InlineObject951) ApiUsersUserCalendarViewEventCalendarEventsEventSnoozeReminderRequest {
	r.inlineObject951 = &inlineObject951
	return r
}

func (r ApiUsersUserCalendarViewEventCalendarEventsEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarViewEventCalendarEventsEventSnoozeReminderExecute(r)
}

/*
UsersUserCalendarViewEventCalendarEventsEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarViewEventCalendarEventsEventSnoozeReminderRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarViewEventCalendarEventsEventSnoozeReminder(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserCalendarViewEventCalendarEventsEventSnoozeReminderRequest {
	return ApiUsersUserCalendarViewEventCalendarEventsEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarViewEventCalendarEventsEventSnoozeReminderExecute(r ApiUsersUserCalendarViewEventCalendarEventsEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarViewEventCalendarEventsEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarView/{event-id}/calendar/events/{event-id1}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject951 == nil {
		return nil, reportError("inlineObject951 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject951
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarViewEventCalendarEventsEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
	inlineObject952 *InlineObject952
}

func (r ApiUsersUserCalendarViewEventCalendarEventsEventTentativelyAcceptRequest) InlineObject952(inlineObject952 InlineObject952) ApiUsersUserCalendarViewEventCalendarEventsEventTentativelyAcceptRequest {
	r.inlineObject952 = &inlineObject952
	return r
}

func (r ApiUsersUserCalendarViewEventCalendarEventsEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarViewEventCalendarEventsEventTentativelyAcceptExecute(r)
}

/*
UsersUserCalendarViewEventCalendarEventsEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarViewEventCalendarEventsEventTentativelyAcceptRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarViewEventCalendarEventsEventTentativelyAccept(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserCalendarViewEventCalendarEventsEventTentativelyAcceptRequest {
	return ApiUsersUserCalendarViewEventCalendarEventsEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarViewEventCalendarEventsEventTentativelyAcceptExecute(r ApiUsersUserCalendarViewEventCalendarEventsEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarViewEventCalendarEventsEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarView/{event-id}/calendar/events/{event-id1}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject952 == nil {
		return nil, reportError("inlineObject952 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject952
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarViewEventCalendarGetScheduleRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	inlineObject953 *InlineObject953
}

func (r ApiUsersUserCalendarViewEventCalendarGetScheduleRequest) InlineObject953(inlineObject953 InlineObject953) ApiUsersUserCalendarViewEventCalendarGetScheduleRequest {
	r.inlineObject953 = &inlineObject953
	return r
}

func (r ApiUsersUserCalendarViewEventCalendarGetScheduleRequest) Execute() ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarViewEventCalendarGetScheduleExecute(r)
}

/*
UsersUserCalendarViewEventCalendarGetSchedule Invoke action getSchedule

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @return ApiUsersUserCalendarViewEventCalendarGetScheduleRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarViewEventCalendarGetSchedule(ctx _context.Context, userId string, eventId string) ApiUsersUserCalendarViewEventCalendarGetScheduleRequest {
	return ApiUsersUserCalendarViewEventCalendarGetScheduleRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return []*AnyOfmicrosoftGraphScheduleInformation
func (a *UsersActionsApiService) UsersUserCalendarViewEventCalendarGetScheduleExecute(r ApiUsersUserCalendarViewEventCalendarGetScheduleRequest) ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []*AnyOfmicrosoftGraphScheduleInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarViewEventCalendarGetSchedule")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarView/{event-id}/calendar/microsoft.graph.getSchedule"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject953 == nil {
		return localVarReturnValue, nil, reportError("inlineObject953 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject953
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserCalendarViewEventCancelRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	inlineObject961 *InlineObject961
}

func (r ApiUsersUserCalendarViewEventCancelRequest) InlineObject961(inlineObject961 InlineObject961) ApiUsersUserCalendarViewEventCancelRequest {
	r.inlineObject961 = &inlineObject961
	return r
}

func (r ApiUsersUserCalendarViewEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarViewEventCancelExecute(r)
}

/*
UsersUserCalendarViewEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @return ApiUsersUserCalendarViewEventCancelRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarViewEventCancel(ctx _context.Context, userId string, eventId string) ApiUsersUserCalendarViewEventCancelRequest {
	return ApiUsersUserCalendarViewEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarViewEventCancelExecute(r ApiUsersUserCalendarViewEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarViewEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarView/{event-id}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject961 == nil {
		return nil, reportError("inlineObject961 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject961
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarViewEventDeclineRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	inlineObject962 *InlineObject962
}

func (r ApiUsersUserCalendarViewEventDeclineRequest) InlineObject962(inlineObject962 InlineObject962) ApiUsersUserCalendarViewEventDeclineRequest {
	r.inlineObject962 = &inlineObject962
	return r
}

func (r ApiUsersUserCalendarViewEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarViewEventDeclineExecute(r)
}

/*
UsersUserCalendarViewEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @return ApiUsersUserCalendarViewEventDeclineRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarViewEventDecline(ctx _context.Context, userId string, eventId string) ApiUsersUserCalendarViewEventDeclineRequest {
	return ApiUsersUserCalendarViewEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarViewEventDeclineExecute(r ApiUsersUserCalendarViewEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarViewEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarView/{event-id}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject962 == nil {
		return nil, reportError("inlineObject962 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject962
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarViewEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
}


func (r ApiUsersUserCalendarViewEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarViewEventDismissReminderExecute(r)
}

/*
UsersUserCalendarViewEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @return ApiUsersUserCalendarViewEventDismissReminderRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarViewEventDismissReminder(ctx _context.Context, userId string, eventId string) ApiUsersUserCalendarViewEventDismissReminderRequest {
	return ApiUsersUserCalendarViewEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarViewEventDismissReminderExecute(r ApiUsersUserCalendarViewEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarViewEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarView/{event-id}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarViewEventForwardRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	inlineObject963 *InlineObject963
}

func (r ApiUsersUserCalendarViewEventForwardRequest) InlineObject963(inlineObject963 InlineObject963) ApiUsersUserCalendarViewEventForwardRequest {
	r.inlineObject963 = &inlineObject963
	return r
}

func (r ApiUsersUserCalendarViewEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarViewEventForwardExecute(r)
}

/*
UsersUserCalendarViewEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @return ApiUsersUserCalendarViewEventForwardRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarViewEventForward(ctx _context.Context, userId string, eventId string) ApiUsersUserCalendarViewEventForwardRequest {
	return ApiUsersUserCalendarViewEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarViewEventForwardExecute(r ApiUsersUserCalendarViewEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarViewEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarView/{event-id}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject963 == nil {
		return nil, reportError("inlineObject963 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject963
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarViewEventInstancesEventAcceptRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
	inlineObject954 *InlineObject954
}

func (r ApiUsersUserCalendarViewEventInstancesEventAcceptRequest) InlineObject954(inlineObject954 InlineObject954) ApiUsersUserCalendarViewEventInstancesEventAcceptRequest {
	r.inlineObject954 = &inlineObject954
	return r
}

func (r ApiUsersUserCalendarViewEventInstancesEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarViewEventInstancesEventAcceptExecute(r)
}

/*
UsersUserCalendarViewEventInstancesEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarViewEventInstancesEventAcceptRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarViewEventInstancesEventAccept(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserCalendarViewEventInstancesEventAcceptRequest {
	return ApiUsersUserCalendarViewEventInstancesEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarViewEventInstancesEventAcceptExecute(r ApiUsersUserCalendarViewEventInstancesEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarViewEventInstancesEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject954 == nil {
		return nil, reportError("inlineObject954 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject954
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarViewEventInstancesEventCancelRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
	inlineObject955 *InlineObject955
}

func (r ApiUsersUserCalendarViewEventInstancesEventCancelRequest) InlineObject955(inlineObject955 InlineObject955) ApiUsersUserCalendarViewEventInstancesEventCancelRequest {
	r.inlineObject955 = &inlineObject955
	return r
}

func (r ApiUsersUserCalendarViewEventInstancesEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarViewEventInstancesEventCancelExecute(r)
}

/*
UsersUserCalendarViewEventInstancesEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarViewEventInstancesEventCancelRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarViewEventInstancesEventCancel(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserCalendarViewEventInstancesEventCancelRequest {
	return ApiUsersUserCalendarViewEventInstancesEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarViewEventInstancesEventCancelExecute(r ApiUsersUserCalendarViewEventInstancesEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarViewEventInstancesEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject955 == nil {
		return nil, reportError("inlineObject955 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject955
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarViewEventInstancesEventDeclineRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
	inlineObject956 *InlineObject956
}

func (r ApiUsersUserCalendarViewEventInstancesEventDeclineRequest) InlineObject956(inlineObject956 InlineObject956) ApiUsersUserCalendarViewEventInstancesEventDeclineRequest {
	r.inlineObject956 = &inlineObject956
	return r
}

func (r ApiUsersUserCalendarViewEventInstancesEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarViewEventInstancesEventDeclineExecute(r)
}

/*
UsersUserCalendarViewEventInstancesEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarViewEventInstancesEventDeclineRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarViewEventInstancesEventDecline(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserCalendarViewEventInstancesEventDeclineRequest {
	return ApiUsersUserCalendarViewEventInstancesEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarViewEventInstancesEventDeclineExecute(r ApiUsersUserCalendarViewEventInstancesEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarViewEventInstancesEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject956 == nil {
		return nil, reportError("inlineObject956 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject956
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarViewEventInstancesEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
}


func (r ApiUsersUserCalendarViewEventInstancesEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarViewEventInstancesEventDismissReminderExecute(r)
}

/*
UsersUserCalendarViewEventInstancesEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarViewEventInstancesEventDismissReminderRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarViewEventInstancesEventDismissReminder(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserCalendarViewEventInstancesEventDismissReminderRequest {
	return ApiUsersUserCalendarViewEventInstancesEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarViewEventInstancesEventDismissReminderExecute(r ApiUsersUserCalendarViewEventInstancesEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarViewEventInstancesEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarViewEventInstancesEventForwardRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
	inlineObject957 *InlineObject957
}

func (r ApiUsersUserCalendarViewEventInstancesEventForwardRequest) InlineObject957(inlineObject957 InlineObject957) ApiUsersUserCalendarViewEventInstancesEventForwardRequest {
	r.inlineObject957 = &inlineObject957
	return r
}

func (r ApiUsersUserCalendarViewEventInstancesEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarViewEventInstancesEventForwardExecute(r)
}

/*
UsersUserCalendarViewEventInstancesEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarViewEventInstancesEventForwardRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarViewEventInstancesEventForward(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserCalendarViewEventInstancesEventForwardRequest {
	return ApiUsersUserCalendarViewEventInstancesEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarViewEventInstancesEventForwardExecute(r ApiUsersUserCalendarViewEventInstancesEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarViewEventInstancesEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject957 == nil {
		return nil, reportError("inlineObject957 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject957
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarViewEventInstancesEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
	inlineObject958 *InlineObject958
}

func (r ApiUsersUserCalendarViewEventInstancesEventSnoozeReminderRequest) InlineObject958(inlineObject958 InlineObject958) ApiUsersUserCalendarViewEventInstancesEventSnoozeReminderRequest {
	r.inlineObject958 = &inlineObject958
	return r
}

func (r ApiUsersUserCalendarViewEventInstancesEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarViewEventInstancesEventSnoozeReminderExecute(r)
}

/*
UsersUserCalendarViewEventInstancesEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarViewEventInstancesEventSnoozeReminderRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarViewEventInstancesEventSnoozeReminder(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserCalendarViewEventInstancesEventSnoozeReminderRequest {
	return ApiUsersUserCalendarViewEventInstancesEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarViewEventInstancesEventSnoozeReminderExecute(r ApiUsersUserCalendarViewEventInstancesEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarViewEventInstancesEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject958 == nil {
		return nil, reportError("inlineObject958 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject958
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarViewEventInstancesEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
	inlineObject959 *InlineObject959
}

func (r ApiUsersUserCalendarViewEventInstancesEventTentativelyAcceptRequest) InlineObject959(inlineObject959 InlineObject959) ApiUsersUserCalendarViewEventInstancesEventTentativelyAcceptRequest {
	r.inlineObject959 = &inlineObject959
	return r
}

func (r ApiUsersUserCalendarViewEventInstancesEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarViewEventInstancesEventTentativelyAcceptExecute(r)
}

/*
UsersUserCalendarViewEventInstancesEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarViewEventInstancesEventTentativelyAcceptRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarViewEventInstancesEventTentativelyAccept(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserCalendarViewEventInstancesEventTentativelyAcceptRequest {
	return ApiUsersUserCalendarViewEventInstancesEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarViewEventInstancesEventTentativelyAcceptExecute(r ApiUsersUserCalendarViewEventInstancesEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarViewEventInstancesEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject959 == nil {
		return nil, reportError("inlineObject959 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject959
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarViewEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	inlineObject964 *InlineObject964
}

func (r ApiUsersUserCalendarViewEventSnoozeReminderRequest) InlineObject964(inlineObject964 InlineObject964) ApiUsersUserCalendarViewEventSnoozeReminderRequest {
	r.inlineObject964 = &inlineObject964
	return r
}

func (r ApiUsersUserCalendarViewEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarViewEventSnoozeReminderExecute(r)
}

/*
UsersUserCalendarViewEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @return ApiUsersUserCalendarViewEventSnoozeReminderRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarViewEventSnoozeReminder(ctx _context.Context, userId string, eventId string) ApiUsersUserCalendarViewEventSnoozeReminderRequest {
	return ApiUsersUserCalendarViewEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarViewEventSnoozeReminderExecute(r ApiUsersUserCalendarViewEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarViewEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarView/{event-id}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject964 == nil {
		return nil, reportError("inlineObject964 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject964
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarViewEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	inlineObject965 *InlineObject965
}

func (r ApiUsersUserCalendarViewEventTentativelyAcceptRequest) InlineObject965(inlineObject965 InlineObject965) ApiUsersUserCalendarViewEventTentativelyAcceptRequest {
	r.inlineObject965 = &inlineObject965
	return r
}

func (r ApiUsersUserCalendarViewEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarViewEventTentativelyAcceptExecute(r)
}

/*
UsersUserCalendarViewEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @return ApiUsersUserCalendarViewEventTentativelyAcceptRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarViewEventTentativelyAccept(ctx _context.Context, userId string, eventId string) ApiUsersUserCalendarViewEventTentativelyAcceptRequest {
	return ApiUsersUserCalendarViewEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarViewEventTentativelyAcceptExecute(r ApiUsersUserCalendarViewEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarViewEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendarView/{event-id}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject965 == nil {
		return nil, reportError("inlineObject965 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject965
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarsCalendarCalendarViewEventAcceptRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarId string
	eventId string
	inlineObject919 *InlineObject919
}

func (r ApiUsersUserCalendarsCalendarCalendarViewEventAcceptRequest) InlineObject919(inlineObject919 InlineObject919) ApiUsersUserCalendarsCalendarCalendarViewEventAcceptRequest {
	r.inlineObject919 = &inlineObject919
	return r
}

func (r ApiUsersUserCalendarsCalendarCalendarViewEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarsCalendarCalendarViewEventAcceptExecute(r)
}

/*
UsersUserCalendarsCalendarCalendarViewEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersUserCalendarsCalendarCalendarViewEventAcceptRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarsCalendarCalendarViewEventAccept(ctx _context.Context, userId string, calendarId string, eventId string) ApiUsersUserCalendarsCalendarCalendarViewEventAcceptRequest {
	return ApiUsersUserCalendarsCalendarCalendarViewEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarsCalendarCalendarViewEventAcceptExecute(r ApiUsersUserCalendarsCalendarCalendarViewEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarsCalendarCalendarViewEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendars/{calendar-id}/calendarView/{event-id}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject919 == nil {
		return nil, reportError("inlineObject919 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject919
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarId string
	eventId string
	inlineObject911 *InlineObject911
}

func (r ApiUsersUserCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest) InlineObject911(inlineObject911 InlineObject911) ApiUsersUserCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest {
	r.inlineObject911 = &inlineObject911
	return r
}

func (r ApiUsersUserCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest) Execute() (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSessionExecute(r)
}

/*
UsersUserCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSession Invoke action createUploadSession

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersUserCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSession(ctx _context.Context, userId string, calendarId string, eventId string) ApiUsersUserCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest {
	return ApiUsersUserCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphUploadSession
func (a *UsersActionsApiService) UsersUserCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSessionExecute(r ApiUsersUserCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest) (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphUploadSession
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSession")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendars/{calendar-id}/calendarView/{event-id}/attachments/microsoft.graph.createUploadSession"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject911 == nil {
		return localVarReturnValue, nil, reportError("inlineObject911 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject911
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserCalendarsCalendarCalendarViewEventCalendarGetScheduleRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarId string
	eventId string
	inlineObject912 *InlineObject912
}

func (r ApiUsersUserCalendarsCalendarCalendarViewEventCalendarGetScheduleRequest) InlineObject912(inlineObject912 InlineObject912) ApiUsersUserCalendarsCalendarCalendarViewEventCalendarGetScheduleRequest {
	r.inlineObject912 = &inlineObject912
	return r
}

func (r ApiUsersUserCalendarsCalendarCalendarViewEventCalendarGetScheduleRequest) Execute() ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarsCalendarCalendarViewEventCalendarGetScheduleExecute(r)
}

/*
UsersUserCalendarsCalendarCalendarViewEventCalendarGetSchedule Invoke action getSchedule

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersUserCalendarsCalendarCalendarViewEventCalendarGetScheduleRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarsCalendarCalendarViewEventCalendarGetSchedule(ctx _context.Context, userId string, calendarId string, eventId string) ApiUsersUserCalendarsCalendarCalendarViewEventCalendarGetScheduleRequest {
	return ApiUsersUserCalendarsCalendarCalendarViewEventCalendarGetScheduleRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return []*AnyOfmicrosoftGraphScheduleInformation
func (a *UsersActionsApiService) UsersUserCalendarsCalendarCalendarViewEventCalendarGetScheduleExecute(r ApiUsersUserCalendarsCalendarCalendarViewEventCalendarGetScheduleRequest) ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []*AnyOfmicrosoftGraphScheduleInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarsCalendarCalendarViewEventCalendarGetSchedule")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendars/{calendar-id}/calendarView/{event-id}/calendar/microsoft.graph.getSchedule"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject912 == nil {
		return localVarReturnValue, nil, reportError("inlineObject912 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject912
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserCalendarsCalendarCalendarViewEventCancelRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarId string
	eventId string
	inlineObject920 *InlineObject920
}

func (r ApiUsersUserCalendarsCalendarCalendarViewEventCancelRequest) InlineObject920(inlineObject920 InlineObject920) ApiUsersUserCalendarsCalendarCalendarViewEventCancelRequest {
	r.inlineObject920 = &inlineObject920
	return r
}

func (r ApiUsersUserCalendarsCalendarCalendarViewEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarsCalendarCalendarViewEventCancelExecute(r)
}

/*
UsersUserCalendarsCalendarCalendarViewEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersUserCalendarsCalendarCalendarViewEventCancelRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarsCalendarCalendarViewEventCancel(ctx _context.Context, userId string, calendarId string, eventId string) ApiUsersUserCalendarsCalendarCalendarViewEventCancelRequest {
	return ApiUsersUserCalendarsCalendarCalendarViewEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarsCalendarCalendarViewEventCancelExecute(r ApiUsersUserCalendarsCalendarCalendarViewEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarsCalendarCalendarViewEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendars/{calendar-id}/calendarView/{event-id}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject920 == nil {
		return nil, reportError("inlineObject920 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject920
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarsCalendarCalendarViewEventDeclineRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarId string
	eventId string
	inlineObject921 *InlineObject921
}

func (r ApiUsersUserCalendarsCalendarCalendarViewEventDeclineRequest) InlineObject921(inlineObject921 InlineObject921) ApiUsersUserCalendarsCalendarCalendarViewEventDeclineRequest {
	r.inlineObject921 = &inlineObject921
	return r
}

func (r ApiUsersUserCalendarsCalendarCalendarViewEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarsCalendarCalendarViewEventDeclineExecute(r)
}

/*
UsersUserCalendarsCalendarCalendarViewEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersUserCalendarsCalendarCalendarViewEventDeclineRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarsCalendarCalendarViewEventDecline(ctx _context.Context, userId string, calendarId string, eventId string) ApiUsersUserCalendarsCalendarCalendarViewEventDeclineRequest {
	return ApiUsersUserCalendarsCalendarCalendarViewEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarsCalendarCalendarViewEventDeclineExecute(r ApiUsersUserCalendarsCalendarCalendarViewEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarsCalendarCalendarViewEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendars/{calendar-id}/calendarView/{event-id}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject921 == nil {
		return nil, reportError("inlineObject921 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject921
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarsCalendarCalendarViewEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarId string
	eventId string
}


func (r ApiUsersUserCalendarsCalendarCalendarViewEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarsCalendarCalendarViewEventDismissReminderExecute(r)
}

/*
UsersUserCalendarsCalendarCalendarViewEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersUserCalendarsCalendarCalendarViewEventDismissReminderRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarsCalendarCalendarViewEventDismissReminder(ctx _context.Context, userId string, calendarId string, eventId string) ApiUsersUserCalendarsCalendarCalendarViewEventDismissReminderRequest {
	return ApiUsersUserCalendarsCalendarCalendarViewEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarsCalendarCalendarViewEventDismissReminderExecute(r ApiUsersUserCalendarsCalendarCalendarViewEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarsCalendarCalendarViewEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendars/{calendar-id}/calendarView/{event-id}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarsCalendarCalendarViewEventForwardRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarId string
	eventId string
	inlineObject922 *InlineObject922
}

func (r ApiUsersUserCalendarsCalendarCalendarViewEventForwardRequest) InlineObject922(inlineObject922 InlineObject922) ApiUsersUserCalendarsCalendarCalendarViewEventForwardRequest {
	r.inlineObject922 = &inlineObject922
	return r
}

func (r ApiUsersUserCalendarsCalendarCalendarViewEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarsCalendarCalendarViewEventForwardExecute(r)
}

/*
UsersUserCalendarsCalendarCalendarViewEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersUserCalendarsCalendarCalendarViewEventForwardRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarsCalendarCalendarViewEventForward(ctx _context.Context, userId string, calendarId string, eventId string) ApiUsersUserCalendarsCalendarCalendarViewEventForwardRequest {
	return ApiUsersUserCalendarsCalendarCalendarViewEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarsCalendarCalendarViewEventForwardExecute(r ApiUsersUserCalendarsCalendarCalendarViewEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarsCalendarCalendarViewEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendars/{calendar-id}/calendarView/{event-id}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject922 == nil {
		return nil, reportError("inlineObject922 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject922
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventAcceptRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarId string
	eventId string
	eventId1 string
	inlineObject913 *InlineObject913
}

func (r ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventAcceptRequest) InlineObject913(inlineObject913 InlineObject913) ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventAcceptRequest {
	r.inlineObject913 = &inlineObject913
	return r
}

func (r ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarsCalendarCalendarViewEventInstancesEventAcceptExecute(r)
}

/*
UsersUserCalendarsCalendarCalendarViewEventInstancesEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventAcceptRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarsCalendarCalendarViewEventInstancesEventAccept(ctx _context.Context, userId string, calendarId string, eventId string, eventId1 string) ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventAcceptRequest {
	return ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarsCalendarCalendarViewEventInstancesEventAcceptExecute(r ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarsCalendarCalendarViewEventInstancesEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendars/{calendar-id}/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject913 == nil {
		return nil, reportError("inlineObject913 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject913
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventCancelRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarId string
	eventId string
	eventId1 string
	inlineObject914 *InlineObject914
}

func (r ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventCancelRequest) InlineObject914(inlineObject914 InlineObject914) ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventCancelRequest {
	r.inlineObject914 = &inlineObject914
	return r
}

func (r ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarsCalendarCalendarViewEventInstancesEventCancelExecute(r)
}

/*
UsersUserCalendarsCalendarCalendarViewEventInstancesEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventCancelRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarsCalendarCalendarViewEventInstancesEventCancel(ctx _context.Context, userId string, calendarId string, eventId string, eventId1 string) ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventCancelRequest {
	return ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarsCalendarCalendarViewEventInstancesEventCancelExecute(r ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarsCalendarCalendarViewEventInstancesEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendars/{calendar-id}/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject914 == nil {
		return nil, reportError("inlineObject914 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject914
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventDeclineRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarId string
	eventId string
	eventId1 string
	inlineObject915 *InlineObject915
}

func (r ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventDeclineRequest) InlineObject915(inlineObject915 InlineObject915) ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventDeclineRequest {
	r.inlineObject915 = &inlineObject915
	return r
}

func (r ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarsCalendarCalendarViewEventInstancesEventDeclineExecute(r)
}

/*
UsersUserCalendarsCalendarCalendarViewEventInstancesEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventDeclineRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarsCalendarCalendarViewEventInstancesEventDecline(ctx _context.Context, userId string, calendarId string, eventId string, eventId1 string) ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventDeclineRequest {
	return ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarsCalendarCalendarViewEventInstancesEventDeclineExecute(r ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarsCalendarCalendarViewEventInstancesEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendars/{calendar-id}/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject915 == nil {
		return nil, reportError("inlineObject915 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject915
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarId string
	eventId string
	eventId1 string
}


func (r ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarsCalendarCalendarViewEventInstancesEventDismissReminderExecute(r)
}

/*
UsersUserCalendarsCalendarCalendarViewEventInstancesEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventDismissReminderRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarsCalendarCalendarViewEventInstancesEventDismissReminder(ctx _context.Context, userId string, calendarId string, eventId string, eventId1 string) ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventDismissReminderRequest {
	return ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarsCalendarCalendarViewEventInstancesEventDismissReminderExecute(r ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarsCalendarCalendarViewEventInstancesEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendars/{calendar-id}/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventForwardRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarId string
	eventId string
	eventId1 string
	inlineObject916 *InlineObject916
}

func (r ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventForwardRequest) InlineObject916(inlineObject916 InlineObject916) ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventForwardRequest {
	r.inlineObject916 = &inlineObject916
	return r
}

func (r ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarsCalendarCalendarViewEventInstancesEventForwardExecute(r)
}

/*
UsersUserCalendarsCalendarCalendarViewEventInstancesEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventForwardRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarsCalendarCalendarViewEventInstancesEventForward(ctx _context.Context, userId string, calendarId string, eventId string, eventId1 string) ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventForwardRequest {
	return ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarsCalendarCalendarViewEventInstancesEventForwardExecute(r ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarsCalendarCalendarViewEventInstancesEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendars/{calendar-id}/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject916 == nil {
		return nil, reportError("inlineObject916 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject916
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarId string
	eventId string
	eventId1 string
	inlineObject917 *InlineObject917
}

func (r ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminderRequest) InlineObject917(inlineObject917 InlineObject917) ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminderRequest {
	r.inlineObject917 = &inlineObject917
	return r
}

func (r ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminderExecute(r)
}

/*
UsersUserCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminderRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminder(ctx _context.Context, userId string, calendarId string, eventId string, eventId1 string) ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminderRequest {
	return ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminderExecute(r ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendars/{calendar-id}/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject917 == nil {
		return nil, reportError("inlineObject917 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject917
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarId string
	eventId string
	eventId1 string
	inlineObject918 *InlineObject918
}

func (r ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest) InlineObject918(inlineObject918 InlineObject918) ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest {
	r.inlineObject918 = &inlineObject918
	return r
}

func (r ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarsCalendarCalendarViewEventInstancesEventTentativelyAcceptExecute(r)
}

/*
UsersUserCalendarsCalendarCalendarViewEventInstancesEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarsCalendarCalendarViewEventInstancesEventTentativelyAccept(ctx _context.Context, userId string, calendarId string, eventId string, eventId1 string) ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest {
	return ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarsCalendarCalendarViewEventInstancesEventTentativelyAcceptExecute(r ApiUsersUserCalendarsCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarsCalendarCalendarViewEventInstancesEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendars/{calendar-id}/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject918 == nil {
		return nil, reportError("inlineObject918 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject918
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarsCalendarCalendarViewEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarId string
	eventId string
	inlineObject923 *InlineObject923
}

func (r ApiUsersUserCalendarsCalendarCalendarViewEventSnoozeReminderRequest) InlineObject923(inlineObject923 InlineObject923) ApiUsersUserCalendarsCalendarCalendarViewEventSnoozeReminderRequest {
	r.inlineObject923 = &inlineObject923
	return r
}

func (r ApiUsersUserCalendarsCalendarCalendarViewEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarsCalendarCalendarViewEventSnoozeReminderExecute(r)
}

/*
UsersUserCalendarsCalendarCalendarViewEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersUserCalendarsCalendarCalendarViewEventSnoozeReminderRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarsCalendarCalendarViewEventSnoozeReminder(ctx _context.Context, userId string, calendarId string, eventId string) ApiUsersUserCalendarsCalendarCalendarViewEventSnoozeReminderRequest {
	return ApiUsersUserCalendarsCalendarCalendarViewEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarsCalendarCalendarViewEventSnoozeReminderExecute(r ApiUsersUserCalendarsCalendarCalendarViewEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarsCalendarCalendarViewEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendars/{calendar-id}/calendarView/{event-id}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject923 == nil {
		return nil, reportError("inlineObject923 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject923
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarsCalendarCalendarViewEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarId string
	eventId string
	inlineObject924 *InlineObject924
}

func (r ApiUsersUserCalendarsCalendarCalendarViewEventTentativelyAcceptRequest) InlineObject924(inlineObject924 InlineObject924) ApiUsersUserCalendarsCalendarCalendarViewEventTentativelyAcceptRequest {
	r.inlineObject924 = &inlineObject924
	return r
}

func (r ApiUsersUserCalendarsCalendarCalendarViewEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarsCalendarCalendarViewEventTentativelyAcceptExecute(r)
}

/*
UsersUserCalendarsCalendarCalendarViewEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersUserCalendarsCalendarCalendarViewEventTentativelyAcceptRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarsCalendarCalendarViewEventTentativelyAccept(ctx _context.Context, userId string, calendarId string, eventId string) ApiUsersUserCalendarsCalendarCalendarViewEventTentativelyAcceptRequest {
	return ApiUsersUserCalendarsCalendarCalendarViewEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarsCalendarCalendarViewEventTentativelyAcceptExecute(r ApiUsersUserCalendarsCalendarCalendarViewEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarsCalendarCalendarViewEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendars/{calendar-id}/calendarView/{event-id}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject924 == nil {
		return nil, reportError("inlineObject924 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject924
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarsCalendarEventsEventAcceptRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarId string
	eventId string
	inlineObject933 *InlineObject933
}

func (r ApiUsersUserCalendarsCalendarEventsEventAcceptRequest) InlineObject933(inlineObject933 InlineObject933) ApiUsersUserCalendarsCalendarEventsEventAcceptRequest {
	r.inlineObject933 = &inlineObject933
	return r
}

func (r ApiUsersUserCalendarsCalendarEventsEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarsCalendarEventsEventAcceptExecute(r)
}

/*
UsersUserCalendarsCalendarEventsEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersUserCalendarsCalendarEventsEventAcceptRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarsCalendarEventsEventAccept(ctx _context.Context, userId string, calendarId string, eventId string) ApiUsersUserCalendarsCalendarEventsEventAcceptRequest {
	return ApiUsersUserCalendarsCalendarEventsEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarsCalendarEventsEventAcceptExecute(r ApiUsersUserCalendarsCalendarEventsEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarsCalendarEventsEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendars/{calendar-id}/events/{event-id}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject933 == nil {
		return nil, reportError("inlineObject933 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject933
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarsCalendarEventsEventAttachmentsCreateUploadSessionRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarId string
	eventId string
	inlineObject925 *InlineObject925
}

func (r ApiUsersUserCalendarsCalendarEventsEventAttachmentsCreateUploadSessionRequest) InlineObject925(inlineObject925 InlineObject925) ApiUsersUserCalendarsCalendarEventsEventAttachmentsCreateUploadSessionRequest {
	r.inlineObject925 = &inlineObject925
	return r
}

func (r ApiUsersUserCalendarsCalendarEventsEventAttachmentsCreateUploadSessionRequest) Execute() (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarsCalendarEventsEventAttachmentsCreateUploadSessionExecute(r)
}

/*
UsersUserCalendarsCalendarEventsEventAttachmentsCreateUploadSession Invoke action createUploadSession

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersUserCalendarsCalendarEventsEventAttachmentsCreateUploadSessionRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarsCalendarEventsEventAttachmentsCreateUploadSession(ctx _context.Context, userId string, calendarId string, eventId string) ApiUsersUserCalendarsCalendarEventsEventAttachmentsCreateUploadSessionRequest {
	return ApiUsersUserCalendarsCalendarEventsEventAttachmentsCreateUploadSessionRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphUploadSession
func (a *UsersActionsApiService) UsersUserCalendarsCalendarEventsEventAttachmentsCreateUploadSessionExecute(r ApiUsersUserCalendarsCalendarEventsEventAttachmentsCreateUploadSessionRequest) (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphUploadSession
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarsCalendarEventsEventAttachmentsCreateUploadSession")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendars/{calendar-id}/events/{event-id}/attachments/microsoft.graph.createUploadSession"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject925 == nil {
		return localVarReturnValue, nil, reportError("inlineObject925 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject925
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserCalendarsCalendarEventsEventCalendarGetScheduleRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarId string
	eventId string
	inlineObject926 *InlineObject926
}

func (r ApiUsersUserCalendarsCalendarEventsEventCalendarGetScheduleRequest) InlineObject926(inlineObject926 InlineObject926) ApiUsersUserCalendarsCalendarEventsEventCalendarGetScheduleRequest {
	r.inlineObject926 = &inlineObject926
	return r
}

func (r ApiUsersUserCalendarsCalendarEventsEventCalendarGetScheduleRequest) Execute() ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarsCalendarEventsEventCalendarGetScheduleExecute(r)
}

/*
UsersUserCalendarsCalendarEventsEventCalendarGetSchedule Invoke action getSchedule

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersUserCalendarsCalendarEventsEventCalendarGetScheduleRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarsCalendarEventsEventCalendarGetSchedule(ctx _context.Context, userId string, calendarId string, eventId string) ApiUsersUserCalendarsCalendarEventsEventCalendarGetScheduleRequest {
	return ApiUsersUserCalendarsCalendarEventsEventCalendarGetScheduleRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return []*AnyOfmicrosoftGraphScheduleInformation
func (a *UsersActionsApiService) UsersUserCalendarsCalendarEventsEventCalendarGetScheduleExecute(r ApiUsersUserCalendarsCalendarEventsEventCalendarGetScheduleRequest) ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []*AnyOfmicrosoftGraphScheduleInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarsCalendarEventsEventCalendarGetSchedule")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendars/{calendar-id}/events/{event-id}/calendar/microsoft.graph.getSchedule"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject926 == nil {
		return localVarReturnValue, nil, reportError("inlineObject926 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject926
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserCalendarsCalendarEventsEventCancelRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarId string
	eventId string
	inlineObject934 *InlineObject934
}

func (r ApiUsersUserCalendarsCalendarEventsEventCancelRequest) InlineObject934(inlineObject934 InlineObject934) ApiUsersUserCalendarsCalendarEventsEventCancelRequest {
	r.inlineObject934 = &inlineObject934
	return r
}

func (r ApiUsersUserCalendarsCalendarEventsEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarsCalendarEventsEventCancelExecute(r)
}

/*
UsersUserCalendarsCalendarEventsEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersUserCalendarsCalendarEventsEventCancelRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarsCalendarEventsEventCancel(ctx _context.Context, userId string, calendarId string, eventId string) ApiUsersUserCalendarsCalendarEventsEventCancelRequest {
	return ApiUsersUserCalendarsCalendarEventsEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarsCalendarEventsEventCancelExecute(r ApiUsersUserCalendarsCalendarEventsEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarsCalendarEventsEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendars/{calendar-id}/events/{event-id}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject934 == nil {
		return nil, reportError("inlineObject934 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject934
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarsCalendarEventsEventDeclineRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarId string
	eventId string
	inlineObject935 *InlineObject935
}

func (r ApiUsersUserCalendarsCalendarEventsEventDeclineRequest) InlineObject935(inlineObject935 InlineObject935) ApiUsersUserCalendarsCalendarEventsEventDeclineRequest {
	r.inlineObject935 = &inlineObject935
	return r
}

func (r ApiUsersUserCalendarsCalendarEventsEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarsCalendarEventsEventDeclineExecute(r)
}

/*
UsersUserCalendarsCalendarEventsEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersUserCalendarsCalendarEventsEventDeclineRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarsCalendarEventsEventDecline(ctx _context.Context, userId string, calendarId string, eventId string) ApiUsersUserCalendarsCalendarEventsEventDeclineRequest {
	return ApiUsersUserCalendarsCalendarEventsEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarsCalendarEventsEventDeclineExecute(r ApiUsersUserCalendarsCalendarEventsEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarsCalendarEventsEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendars/{calendar-id}/events/{event-id}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject935 == nil {
		return nil, reportError("inlineObject935 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject935
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarsCalendarEventsEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarId string
	eventId string
}


func (r ApiUsersUserCalendarsCalendarEventsEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarsCalendarEventsEventDismissReminderExecute(r)
}

/*
UsersUserCalendarsCalendarEventsEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersUserCalendarsCalendarEventsEventDismissReminderRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarsCalendarEventsEventDismissReminder(ctx _context.Context, userId string, calendarId string, eventId string) ApiUsersUserCalendarsCalendarEventsEventDismissReminderRequest {
	return ApiUsersUserCalendarsCalendarEventsEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarsCalendarEventsEventDismissReminderExecute(r ApiUsersUserCalendarsCalendarEventsEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarsCalendarEventsEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendars/{calendar-id}/events/{event-id}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarsCalendarEventsEventForwardRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarId string
	eventId string
	inlineObject936 *InlineObject936
}

func (r ApiUsersUserCalendarsCalendarEventsEventForwardRequest) InlineObject936(inlineObject936 InlineObject936) ApiUsersUserCalendarsCalendarEventsEventForwardRequest {
	r.inlineObject936 = &inlineObject936
	return r
}

func (r ApiUsersUserCalendarsCalendarEventsEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarsCalendarEventsEventForwardExecute(r)
}

/*
UsersUserCalendarsCalendarEventsEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersUserCalendarsCalendarEventsEventForwardRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarsCalendarEventsEventForward(ctx _context.Context, userId string, calendarId string, eventId string) ApiUsersUserCalendarsCalendarEventsEventForwardRequest {
	return ApiUsersUserCalendarsCalendarEventsEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarsCalendarEventsEventForwardExecute(r ApiUsersUserCalendarsCalendarEventsEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarsCalendarEventsEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendars/{calendar-id}/events/{event-id}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject936 == nil {
		return nil, reportError("inlineObject936 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject936
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarsCalendarEventsEventInstancesEventAcceptRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarId string
	eventId string
	eventId1 string
	inlineObject927 *InlineObject927
}

func (r ApiUsersUserCalendarsCalendarEventsEventInstancesEventAcceptRequest) InlineObject927(inlineObject927 InlineObject927) ApiUsersUserCalendarsCalendarEventsEventInstancesEventAcceptRequest {
	r.inlineObject927 = &inlineObject927
	return r
}

func (r ApiUsersUserCalendarsCalendarEventsEventInstancesEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarsCalendarEventsEventInstancesEventAcceptExecute(r)
}

/*
UsersUserCalendarsCalendarEventsEventInstancesEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarsCalendarEventsEventInstancesEventAcceptRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarsCalendarEventsEventInstancesEventAccept(ctx _context.Context, userId string, calendarId string, eventId string, eventId1 string) ApiUsersUserCalendarsCalendarEventsEventInstancesEventAcceptRequest {
	return ApiUsersUserCalendarsCalendarEventsEventInstancesEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarsCalendarEventsEventInstancesEventAcceptExecute(r ApiUsersUserCalendarsCalendarEventsEventInstancesEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarsCalendarEventsEventInstancesEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendars/{calendar-id}/events/{event-id}/instances/{event-id1}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject927 == nil {
		return nil, reportError("inlineObject927 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject927
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarsCalendarEventsEventInstancesEventCancelRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarId string
	eventId string
	eventId1 string
	inlineObject928 *InlineObject928
}

func (r ApiUsersUserCalendarsCalendarEventsEventInstancesEventCancelRequest) InlineObject928(inlineObject928 InlineObject928) ApiUsersUserCalendarsCalendarEventsEventInstancesEventCancelRequest {
	r.inlineObject928 = &inlineObject928
	return r
}

func (r ApiUsersUserCalendarsCalendarEventsEventInstancesEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarsCalendarEventsEventInstancesEventCancelExecute(r)
}

/*
UsersUserCalendarsCalendarEventsEventInstancesEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarsCalendarEventsEventInstancesEventCancelRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarsCalendarEventsEventInstancesEventCancel(ctx _context.Context, userId string, calendarId string, eventId string, eventId1 string) ApiUsersUserCalendarsCalendarEventsEventInstancesEventCancelRequest {
	return ApiUsersUserCalendarsCalendarEventsEventInstancesEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarsCalendarEventsEventInstancesEventCancelExecute(r ApiUsersUserCalendarsCalendarEventsEventInstancesEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarsCalendarEventsEventInstancesEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendars/{calendar-id}/events/{event-id}/instances/{event-id1}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject928 == nil {
		return nil, reportError("inlineObject928 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject928
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarsCalendarEventsEventInstancesEventDeclineRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarId string
	eventId string
	eventId1 string
	inlineObject929 *InlineObject929
}

func (r ApiUsersUserCalendarsCalendarEventsEventInstancesEventDeclineRequest) InlineObject929(inlineObject929 InlineObject929) ApiUsersUserCalendarsCalendarEventsEventInstancesEventDeclineRequest {
	r.inlineObject929 = &inlineObject929
	return r
}

func (r ApiUsersUserCalendarsCalendarEventsEventInstancesEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarsCalendarEventsEventInstancesEventDeclineExecute(r)
}

/*
UsersUserCalendarsCalendarEventsEventInstancesEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarsCalendarEventsEventInstancesEventDeclineRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarsCalendarEventsEventInstancesEventDecline(ctx _context.Context, userId string, calendarId string, eventId string, eventId1 string) ApiUsersUserCalendarsCalendarEventsEventInstancesEventDeclineRequest {
	return ApiUsersUserCalendarsCalendarEventsEventInstancesEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarsCalendarEventsEventInstancesEventDeclineExecute(r ApiUsersUserCalendarsCalendarEventsEventInstancesEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarsCalendarEventsEventInstancesEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendars/{calendar-id}/events/{event-id}/instances/{event-id1}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject929 == nil {
		return nil, reportError("inlineObject929 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject929
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarsCalendarEventsEventInstancesEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarId string
	eventId string
	eventId1 string
}


func (r ApiUsersUserCalendarsCalendarEventsEventInstancesEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarsCalendarEventsEventInstancesEventDismissReminderExecute(r)
}

/*
UsersUserCalendarsCalendarEventsEventInstancesEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarsCalendarEventsEventInstancesEventDismissReminderRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarsCalendarEventsEventInstancesEventDismissReminder(ctx _context.Context, userId string, calendarId string, eventId string, eventId1 string) ApiUsersUserCalendarsCalendarEventsEventInstancesEventDismissReminderRequest {
	return ApiUsersUserCalendarsCalendarEventsEventInstancesEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarsCalendarEventsEventInstancesEventDismissReminderExecute(r ApiUsersUserCalendarsCalendarEventsEventInstancesEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarsCalendarEventsEventInstancesEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendars/{calendar-id}/events/{event-id}/instances/{event-id1}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarsCalendarEventsEventInstancesEventForwardRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarId string
	eventId string
	eventId1 string
	inlineObject930 *InlineObject930
}

func (r ApiUsersUserCalendarsCalendarEventsEventInstancesEventForwardRequest) InlineObject930(inlineObject930 InlineObject930) ApiUsersUserCalendarsCalendarEventsEventInstancesEventForwardRequest {
	r.inlineObject930 = &inlineObject930
	return r
}

func (r ApiUsersUserCalendarsCalendarEventsEventInstancesEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarsCalendarEventsEventInstancesEventForwardExecute(r)
}

/*
UsersUserCalendarsCalendarEventsEventInstancesEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarsCalendarEventsEventInstancesEventForwardRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarsCalendarEventsEventInstancesEventForward(ctx _context.Context, userId string, calendarId string, eventId string, eventId1 string) ApiUsersUserCalendarsCalendarEventsEventInstancesEventForwardRequest {
	return ApiUsersUserCalendarsCalendarEventsEventInstancesEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarsCalendarEventsEventInstancesEventForwardExecute(r ApiUsersUserCalendarsCalendarEventsEventInstancesEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarsCalendarEventsEventInstancesEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendars/{calendar-id}/events/{event-id}/instances/{event-id1}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject930 == nil {
		return nil, reportError("inlineObject930 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject930
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarsCalendarEventsEventInstancesEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarId string
	eventId string
	eventId1 string
	inlineObject931 *InlineObject931
}

func (r ApiUsersUserCalendarsCalendarEventsEventInstancesEventSnoozeReminderRequest) InlineObject931(inlineObject931 InlineObject931) ApiUsersUserCalendarsCalendarEventsEventInstancesEventSnoozeReminderRequest {
	r.inlineObject931 = &inlineObject931
	return r
}

func (r ApiUsersUserCalendarsCalendarEventsEventInstancesEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarsCalendarEventsEventInstancesEventSnoozeReminderExecute(r)
}

/*
UsersUserCalendarsCalendarEventsEventInstancesEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarsCalendarEventsEventInstancesEventSnoozeReminderRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarsCalendarEventsEventInstancesEventSnoozeReminder(ctx _context.Context, userId string, calendarId string, eventId string, eventId1 string) ApiUsersUserCalendarsCalendarEventsEventInstancesEventSnoozeReminderRequest {
	return ApiUsersUserCalendarsCalendarEventsEventInstancesEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarsCalendarEventsEventInstancesEventSnoozeReminderExecute(r ApiUsersUserCalendarsCalendarEventsEventInstancesEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarsCalendarEventsEventInstancesEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendars/{calendar-id}/events/{event-id}/instances/{event-id1}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject931 == nil {
		return nil, reportError("inlineObject931 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject931
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarsCalendarEventsEventInstancesEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarId string
	eventId string
	eventId1 string
	inlineObject932 *InlineObject932
}

func (r ApiUsersUserCalendarsCalendarEventsEventInstancesEventTentativelyAcceptRequest) InlineObject932(inlineObject932 InlineObject932) ApiUsersUserCalendarsCalendarEventsEventInstancesEventTentativelyAcceptRequest {
	r.inlineObject932 = &inlineObject932
	return r
}

func (r ApiUsersUserCalendarsCalendarEventsEventInstancesEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarsCalendarEventsEventInstancesEventTentativelyAcceptExecute(r)
}

/*
UsersUserCalendarsCalendarEventsEventInstancesEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserCalendarsCalendarEventsEventInstancesEventTentativelyAcceptRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarsCalendarEventsEventInstancesEventTentativelyAccept(ctx _context.Context, userId string, calendarId string, eventId string, eventId1 string) ApiUsersUserCalendarsCalendarEventsEventInstancesEventTentativelyAcceptRequest {
	return ApiUsersUserCalendarsCalendarEventsEventInstancesEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarsCalendarEventsEventInstancesEventTentativelyAcceptExecute(r ApiUsersUserCalendarsCalendarEventsEventInstancesEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarsCalendarEventsEventInstancesEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendars/{calendar-id}/events/{event-id}/instances/{event-id1}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject932 == nil {
		return nil, reportError("inlineObject932 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject932
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarsCalendarEventsEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarId string
	eventId string
	inlineObject937 *InlineObject937
}

func (r ApiUsersUserCalendarsCalendarEventsEventSnoozeReminderRequest) InlineObject937(inlineObject937 InlineObject937) ApiUsersUserCalendarsCalendarEventsEventSnoozeReminderRequest {
	r.inlineObject937 = &inlineObject937
	return r
}

func (r ApiUsersUserCalendarsCalendarEventsEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarsCalendarEventsEventSnoozeReminderExecute(r)
}

/*
UsersUserCalendarsCalendarEventsEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersUserCalendarsCalendarEventsEventSnoozeReminderRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarsCalendarEventsEventSnoozeReminder(ctx _context.Context, userId string, calendarId string, eventId string) ApiUsersUserCalendarsCalendarEventsEventSnoozeReminderRequest {
	return ApiUsersUserCalendarsCalendarEventsEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarsCalendarEventsEventSnoozeReminderExecute(r ApiUsersUserCalendarsCalendarEventsEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarsCalendarEventsEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendars/{calendar-id}/events/{event-id}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject937 == nil {
		return nil, reportError("inlineObject937 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject937
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarsCalendarEventsEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarId string
	eventId string
	inlineObject938 *InlineObject938
}

func (r ApiUsersUserCalendarsCalendarEventsEventTentativelyAcceptRequest) InlineObject938(inlineObject938 InlineObject938) ApiUsersUserCalendarsCalendarEventsEventTentativelyAcceptRequest {
	r.inlineObject938 = &inlineObject938
	return r
}

func (r ApiUsersUserCalendarsCalendarEventsEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarsCalendarEventsEventTentativelyAcceptExecute(r)
}

/*
UsersUserCalendarsCalendarEventsEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiUsersUserCalendarsCalendarEventsEventTentativelyAcceptRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarsCalendarEventsEventTentativelyAccept(ctx _context.Context, userId string, calendarId string, eventId string) ApiUsersUserCalendarsCalendarEventsEventTentativelyAcceptRequest {
	return ApiUsersUserCalendarsCalendarEventsEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserCalendarsCalendarEventsEventTentativelyAcceptExecute(r ApiUsersUserCalendarsCalendarEventsEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarsCalendarEventsEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendars/{calendar-id}/events/{event-id}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject938 == nil {
		return nil, reportError("inlineObject938 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject938
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCalendarsCalendarGetScheduleRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	calendarId string
	inlineObject939 *InlineObject939
}

func (r ApiUsersUserCalendarsCalendarGetScheduleRequest) InlineObject939(inlineObject939 InlineObject939) ApiUsersUserCalendarsCalendarGetScheduleRequest {
	r.inlineObject939 = &inlineObject939
	return r
}

func (r ApiUsersUserCalendarsCalendarGetScheduleRequest) Execute() ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserCalendarsCalendarGetScheduleExecute(r)
}

/*
UsersUserCalendarsCalendarGetSchedule Invoke action getSchedule

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param calendarId key: id of calendar
 @return ApiUsersUserCalendarsCalendarGetScheduleRequest
*/
func (a *UsersActionsApiService) UsersUserCalendarsCalendarGetSchedule(ctx _context.Context, userId string, calendarId string) ApiUsersUserCalendarsCalendarGetScheduleRequest {
	return ApiUsersUserCalendarsCalendarGetScheduleRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		calendarId: calendarId,
	}
}

// Execute executes the request
//  @return []*AnyOfmicrosoftGraphScheduleInformation
func (a *UsersActionsApiService) UsersUserCalendarsCalendarGetScheduleExecute(r ApiUsersUserCalendarsCalendarGetScheduleRequest) ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []*AnyOfmicrosoftGraphScheduleInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCalendarsCalendarGetSchedule")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/calendars/{calendar-id}/microsoft.graph.getSchedule"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject939 == nil {
		return localVarReturnValue, nil, reportError("inlineObject939 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject939
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserChangePasswordRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	inlineObject1080 *InlineObject1080
}

func (r ApiUsersUserChangePasswordRequest) InlineObject1080(inlineObject1080 InlineObject1080) ApiUsersUserChangePasswordRequest {
	r.inlineObject1080 = &inlineObject1080
	return r
}

func (r ApiUsersUserChangePasswordRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserChangePasswordExecute(r)
}

/*
UsersUserChangePassword Invoke action changePassword

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @return ApiUsersUserChangePasswordRequest
*/
func (a *UsersActionsApiService) UsersUserChangePassword(ctx _context.Context, userId string) ApiUsersUserChangePasswordRequest {
	return ApiUsersUserChangePasswordRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserChangePasswordExecute(r ApiUsersUserChangePasswordRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserChangePassword")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/microsoft.graph.changePassword"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1080 == nil {
		return nil, reportError("inlineObject1080 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1080
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserCheckMemberGroupsRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	inlineObject1081 *InlineObject1081
}

func (r ApiUsersUserCheckMemberGroupsRequest) InlineObject1081(inlineObject1081 InlineObject1081) ApiUsersUserCheckMemberGroupsRequest {
	r.inlineObject1081 = &inlineObject1081
	return r
}

func (r ApiUsersUserCheckMemberGroupsRequest) Execute() ([]string, *_nethttp.Response, error) {
	return r.ApiService.UsersUserCheckMemberGroupsExecute(r)
}

/*
UsersUserCheckMemberGroups Invoke action checkMemberGroups

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @return ApiUsersUserCheckMemberGroupsRequest
*/
func (a *UsersActionsApiService) UsersUserCheckMemberGroups(ctx _context.Context, userId string) ApiUsersUserCheckMemberGroupsRequest {
	return ApiUsersUserCheckMemberGroupsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return []string
func (a *UsersActionsApiService) UsersUserCheckMemberGroupsExecute(r ApiUsersUserCheckMemberGroupsRequest) ([]string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCheckMemberGroups")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/microsoft.graph.checkMemberGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1081 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1081 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1081
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserCheckMemberObjectsRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	inlineObject1082 *InlineObject1082
}

func (r ApiUsersUserCheckMemberObjectsRequest) InlineObject1082(inlineObject1082 InlineObject1082) ApiUsersUserCheckMemberObjectsRequest {
	r.inlineObject1082 = &inlineObject1082
	return r
}

func (r ApiUsersUserCheckMemberObjectsRequest) Execute() ([]string, *_nethttp.Response, error) {
	return r.ApiService.UsersUserCheckMemberObjectsExecute(r)
}

/*
UsersUserCheckMemberObjects Invoke action checkMemberObjects

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @return ApiUsersUserCheckMemberObjectsRequest
*/
func (a *UsersActionsApiService) UsersUserCheckMemberObjects(ctx _context.Context, userId string) ApiUsersUserCheckMemberObjectsRequest {
	return ApiUsersUserCheckMemberObjectsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return []string
func (a *UsersActionsApiService) UsersUserCheckMemberObjectsExecute(r ApiUsersUserCheckMemberObjectsRequest) ([]string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserCheckMemberObjects")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/microsoft.graph.checkMemberObjects"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1082 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1082 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1082
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserEventsEventAcceptRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	inlineObject986 *InlineObject986
}

func (r ApiUsersUserEventsEventAcceptRequest) InlineObject986(inlineObject986 InlineObject986) ApiUsersUserEventsEventAcceptRequest {
	r.inlineObject986 = &inlineObject986
	return r
}

func (r ApiUsersUserEventsEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserEventsEventAcceptExecute(r)
}

/*
UsersUserEventsEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @return ApiUsersUserEventsEventAcceptRequest
*/
func (a *UsersActionsApiService) UsersUserEventsEventAccept(ctx _context.Context, userId string, eventId string) ApiUsersUserEventsEventAcceptRequest {
	return ApiUsersUserEventsEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserEventsEventAcceptExecute(r ApiUsersUserEventsEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserEventsEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/events/{event-id}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject986 == nil {
		return nil, reportError("inlineObject986 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject986
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserEventsEventAttachmentsCreateUploadSessionRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	inlineObject966 *InlineObject966
}

func (r ApiUsersUserEventsEventAttachmentsCreateUploadSessionRequest) InlineObject966(inlineObject966 InlineObject966) ApiUsersUserEventsEventAttachmentsCreateUploadSessionRequest {
	r.inlineObject966 = &inlineObject966
	return r
}

func (r ApiUsersUserEventsEventAttachmentsCreateUploadSessionRequest) Execute() (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	return r.ApiService.UsersUserEventsEventAttachmentsCreateUploadSessionExecute(r)
}

/*
UsersUserEventsEventAttachmentsCreateUploadSession Invoke action createUploadSession

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @return ApiUsersUserEventsEventAttachmentsCreateUploadSessionRequest
*/
func (a *UsersActionsApiService) UsersUserEventsEventAttachmentsCreateUploadSession(ctx _context.Context, userId string, eventId string) ApiUsersUserEventsEventAttachmentsCreateUploadSessionRequest {
	return ApiUsersUserEventsEventAttachmentsCreateUploadSessionRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphUploadSession
func (a *UsersActionsApiService) UsersUserEventsEventAttachmentsCreateUploadSessionExecute(r ApiUsersUserEventsEventAttachmentsCreateUploadSessionRequest) (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphUploadSession
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserEventsEventAttachmentsCreateUploadSession")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/events/{event-id}/attachments/microsoft.graph.createUploadSession"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject966 == nil {
		return localVarReturnValue, nil, reportError("inlineObject966 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject966
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserEventsEventCalendarCalendarViewEventAcceptRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
	inlineObject967 *InlineObject967
}

func (r ApiUsersUserEventsEventCalendarCalendarViewEventAcceptRequest) InlineObject967(inlineObject967 InlineObject967) ApiUsersUserEventsEventCalendarCalendarViewEventAcceptRequest {
	r.inlineObject967 = &inlineObject967
	return r
}

func (r ApiUsersUserEventsEventCalendarCalendarViewEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserEventsEventCalendarCalendarViewEventAcceptExecute(r)
}

/*
UsersUserEventsEventCalendarCalendarViewEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserEventsEventCalendarCalendarViewEventAcceptRequest
*/
func (a *UsersActionsApiService) UsersUserEventsEventCalendarCalendarViewEventAccept(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserEventsEventCalendarCalendarViewEventAcceptRequest {
	return ApiUsersUserEventsEventCalendarCalendarViewEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserEventsEventCalendarCalendarViewEventAcceptExecute(r ApiUsersUserEventsEventCalendarCalendarViewEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserEventsEventCalendarCalendarViewEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/events/{event-id}/calendar/calendarView/{event-id1}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject967 == nil {
		return nil, reportError("inlineObject967 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject967
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserEventsEventCalendarCalendarViewEventCancelRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
	inlineObject968 *InlineObject968
}

func (r ApiUsersUserEventsEventCalendarCalendarViewEventCancelRequest) InlineObject968(inlineObject968 InlineObject968) ApiUsersUserEventsEventCalendarCalendarViewEventCancelRequest {
	r.inlineObject968 = &inlineObject968
	return r
}

func (r ApiUsersUserEventsEventCalendarCalendarViewEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserEventsEventCalendarCalendarViewEventCancelExecute(r)
}

/*
UsersUserEventsEventCalendarCalendarViewEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserEventsEventCalendarCalendarViewEventCancelRequest
*/
func (a *UsersActionsApiService) UsersUserEventsEventCalendarCalendarViewEventCancel(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserEventsEventCalendarCalendarViewEventCancelRequest {
	return ApiUsersUserEventsEventCalendarCalendarViewEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserEventsEventCalendarCalendarViewEventCancelExecute(r ApiUsersUserEventsEventCalendarCalendarViewEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserEventsEventCalendarCalendarViewEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/events/{event-id}/calendar/calendarView/{event-id1}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject968 == nil {
		return nil, reportError("inlineObject968 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject968
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserEventsEventCalendarCalendarViewEventDeclineRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
	inlineObject969 *InlineObject969
}

func (r ApiUsersUserEventsEventCalendarCalendarViewEventDeclineRequest) InlineObject969(inlineObject969 InlineObject969) ApiUsersUserEventsEventCalendarCalendarViewEventDeclineRequest {
	r.inlineObject969 = &inlineObject969
	return r
}

func (r ApiUsersUserEventsEventCalendarCalendarViewEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserEventsEventCalendarCalendarViewEventDeclineExecute(r)
}

/*
UsersUserEventsEventCalendarCalendarViewEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserEventsEventCalendarCalendarViewEventDeclineRequest
*/
func (a *UsersActionsApiService) UsersUserEventsEventCalendarCalendarViewEventDecline(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserEventsEventCalendarCalendarViewEventDeclineRequest {
	return ApiUsersUserEventsEventCalendarCalendarViewEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserEventsEventCalendarCalendarViewEventDeclineExecute(r ApiUsersUserEventsEventCalendarCalendarViewEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserEventsEventCalendarCalendarViewEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/events/{event-id}/calendar/calendarView/{event-id1}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject969 == nil {
		return nil, reportError("inlineObject969 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject969
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserEventsEventCalendarCalendarViewEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
}


func (r ApiUsersUserEventsEventCalendarCalendarViewEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserEventsEventCalendarCalendarViewEventDismissReminderExecute(r)
}

/*
UsersUserEventsEventCalendarCalendarViewEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserEventsEventCalendarCalendarViewEventDismissReminderRequest
*/
func (a *UsersActionsApiService) UsersUserEventsEventCalendarCalendarViewEventDismissReminder(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserEventsEventCalendarCalendarViewEventDismissReminderRequest {
	return ApiUsersUserEventsEventCalendarCalendarViewEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserEventsEventCalendarCalendarViewEventDismissReminderExecute(r ApiUsersUserEventsEventCalendarCalendarViewEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserEventsEventCalendarCalendarViewEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/events/{event-id}/calendar/calendarView/{event-id1}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserEventsEventCalendarCalendarViewEventForwardRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
	inlineObject970 *InlineObject970
}

func (r ApiUsersUserEventsEventCalendarCalendarViewEventForwardRequest) InlineObject970(inlineObject970 InlineObject970) ApiUsersUserEventsEventCalendarCalendarViewEventForwardRequest {
	r.inlineObject970 = &inlineObject970
	return r
}

func (r ApiUsersUserEventsEventCalendarCalendarViewEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserEventsEventCalendarCalendarViewEventForwardExecute(r)
}

/*
UsersUserEventsEventCalendarCalendarViewEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserEventsEventCalendarCalendarViewEventForwardRequest
*/
func (a *UsersActionsApiService) UsersUserEventsEventCalendarCalendarViewEventForward(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserEventsEventCalendarCalendarViewEventForwardRequest {
	return ApiUsersUserEventsEventCalendarCalendarViewEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserEventsEventCalendarCalendarViewEventForwardExecute(r ApiUsersUserEventsEventCalendarCalendarViewEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserEventsEventCalendarCalendarViewEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/events/{event-id}/calendar/calendarView/{event-id1}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject970 == nil {
		return nil, reportError("inlineObject970 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject970
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserEventsEventCalendarCalendarViewEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
	inlineObject971 *InlineObject971
}

func (r ApiUsersUserEventsEventCalendarCalendarViewEventSnoozeReminderRequest) InlineObject971(inlineObject971 InlineObject971) ApiUsersUserEventsEventCalendarCalendarViewEventSnoozeReminderRequest {
	r.inlineObject971 = &inlineObject971
	return r
}

func (r ApiUsersUserEventsEventCalendarCalendarViewEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserEventsEventCalendarCalendarViewEventSnoozeReminderExecute(r)
}

/*
UsersUserEventsEventCalendarCalendarViewEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserEventsEventCalendarCalendarViewEventSnoozeReminderRequest
*/
func (a *UsersActionsApiService) UsersUserEventsEventCalendarCalendarViewEventSnoozeReminder(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserEventsEventCalendarCalendarViewEventSnoozeReminderRequest {
	return ApiUsersUserEventsEventCalendarCalendarViewEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserEventsEventCalendarCalendarViewEventSnoozeReminderExecute(r ApiUsersUserEventsEventCalendarCalendarViewEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserEventsEventCalendarCalendarViewEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/events/{event-id}/calendar/calendarView/{event-id1}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject971 == nil {
		return nil, reportError("inlineObject971 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject971
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserEventsEventCalendarCalendarViewEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
	inlineObject972 *InlineObject972
}

func (r ApiUsersUserEventsEventCalendarCalendarViewEventTentativelyAcceptRequest) InlineObject972(inlineObject972 InlineObject972) ApiUsersUserEventsEventCalendarCalendarViewEventTentativelyAcceptRequest {
	r.inlineObject972 = &inlineObject972
	return r
}

func (r ApiUsersUserEventsEventCalendarCalendarViewEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserEventsEventCalendarCalendarViewEventTentativelyAcceptExecute(r)
}

/*
UsersUserEventsEventCalendarCalendarViewEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserEventsEventCalendarCalendarViewEventTentativelyAcceptRequest
*/
func (a *UsersActionsApiService) UsersUserEventsEventCalendarCalendarViewEventTentativelyAccept(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserEventsEventCalendarCalendarViewEventTentativelyAcceptRequest {
	return ApiUsersUserEventsEventCalendarCalendarViewEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserEventsEventCalendarCalendarViewEventTentativelyAcceptExecute(r ApiUsersUserEventsEventCalendarCalendarViewEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserEventsEventCalendarCalendarViewEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/events/{event-id}/calendar/calendarView/{event-id1}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject972 == nil {
		return nil, reportError("inlineObject972 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject972
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserEventsEventCalendarEventsEventAcceptRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
	inlineObject973 *InlineObject973
}

func (r ApiUsersUserEventsEventCalendarEventsEventAcceptRequest) InlineObject973(inlineObject973 InlineObject973) ApiUsersUserEventsEventCalendarEventsEventAcceptRequest {
	r.inlineObject973 = &inlineObject973
	return r
}

func (r ApiUsersUserEventsEventCalendarEventsEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserEventsEventCalendarEventsEventAcceptExecute(r)
}

/*
UsersUserEventsEventCalendarEventsEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserEventsEventCalendarEventsEventAcceptRequest
*/
func (a *UsersActionsApiService) UsersUserEventsEventCalendarEventsEventAccept(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserEventsEventCalendarEventsEventAcceptRequest {
	return ApiUsersUserEventsEventCalendarEventsEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserEventsEventCalendarEventsEventAcceptExecute(r ApiUsersUserEventsEventCalendarEventsEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserEventsEventCalendarEventsEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/events/{event-id}/calendar/events/{event-id1}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject973 == nil {
		return nil, reportError("inlineObject973 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject973
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserEventsEventCalendarEventsEventCancelRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
	inlineObject974 *InlineObject974
}

func (r ApiUsersUserEventsEventCalendarEventsEventCancelRequest) InlineObject974(inlineObject974 InlineObject974) ApiUsersUserEventsEventCalendarEventsEventCancelRequest {
	r.inlineObject974 = &inlineObject974
	return r
}

func (r ApiUsersUserEventsEventCalendarEventsEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserEventsEventCalendarEventsEventCancelExecute(r)
}

/*
UsersUserEventsEventCalendarEventsEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserEventsEventCalendarEventsEventCancelRequest
*/
func (a *UsersActionsApiService) UsersUserEventsEventCalendarEventsEventCancel(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserEventsEventCalendarEventsEventCancelRequest {
	return ApiUsersUserEventsEventCalendarEventsEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserEventsEventCalendarEventsEventCancelExecute(r ApiUsersUserEventsEventCalendarEventsEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserEventsEventCalendarEventsEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/events/{event-id}/calendar/events/{event-id1}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject974 == nil {
		return nil, reportError("inlineObject974 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject974
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserEventsEventCalendarEventsEventDeclineRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
	inlineObject975 *InlineObject975
}

func (r ApiUsersUserEventsEventCalendarEventsEventDeclineRequest) InlineObject975(inlineObject975 InlineObject975) ApiUsersUserEventsEventCalendarEventsEventDeclineRequest {
	r.inlineObject975 = &inlineObject975
	return r
}

func (r ApiUsersUserEventsEventCalendarEventsEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserEventsEventCalendarEventsEventDeclineExecute(r)
}

/*
UsersUserEventsEventCalendarEventsEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserEventsEventCalendarEventsEventDeclineRequest
*/
func (a *UsersActionsApiService) UsersUserEventsEventCalendarEventsEventDecline(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserEventsEventCalendarEventsEventDeclineRequest {
	return ApiUsersUserEventsEventCalendarEventsEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserEventsEventCalendarEventsEventDeclineExecute(r ApiUsersUserEventsEventCalendarEventsEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserEventsEventCalendarEventsEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/events/{event-id}/calendar/events/{event-id1}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject975 == nil {
		return nil, reportError("inlineObject975 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject975
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserEventsEventCalendarEventsEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
}


func (r ApiUsersUserEventsEventCalendarEventsEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserEventsEventCalendarEventsEventDismissReminderExecute(r)
}

/*
UsersUserEventsEventCalendarEventsEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserEventsEventCalendarEventsEventDismissReminderRequest
*/
func (a *UsersActionsApiService) UsersUserEventsEventCalendarEventsEventDismissReminder(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserEventsEventCalendarEventsEventDismissReminderRequest {
	return ApiUsersUserEventsEventCalendarEventsEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserEventsEventCalendarEventsEventDismissReminderExecute(r ApiUsersUserEventsEventCalendarEventsEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserEventsEventCalendarEventsEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/events/{event-id}/calendar/events/{event-id1}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserEventsEventCalendarEventsEventForwardRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
	inlineObject976 *InlineObject976
}

func (r ApiUsersUserEventsEventCalendarEventsEventForwardRequest) InlineObject976(inlineObject976 InlineObject976) ApiUsersUserEventsEventCalendarEventsEventForwardRequest {
	r.inlineObject976 = &inlineObject976
	return r
}

func (r ApiUsersUserEventsEventCalendarEventsEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserEventsEventCalendarEventsEventForwardExecute(r)
}

/*
UsersUserEventsEventCalendarEventsEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserEventsEventCalendarEventsEventForwardRequest
*/
func (a *UsersActionsApiService) UsersUserEventsEventCalendarEventsEventForward(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserEventsEventCalendarEventsEventForwardRequest {
	return ApiUsersUserEventsEventCalendarEventsEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserEventsEventCalendarEventsEventForwardExecute(r ApiUsersUserEventsEventCalendarEventsEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserEventsEventCalendarEventsEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/events/{event-id}/calendar/events/{event-id1}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject976 == nil {
		return nil, reportError("inlineObject976 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject976
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserEventsEventCalendarEventsEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
	inlineObject977 *InlineObject977
}

func (r ApiUsersUserEventsEventCalendarEventsEventSnoozeReminderRequest) InlineObject977(inlineObject977 InlineObject977) ApiUsersUserEventsEventCalendarEventsEventSnoozeReminderRequest {
	r.inlineObject977 = &inlineObject977
	return r
}

func (r ApiUsersUserEventsEventCalendarEventsEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserEventsEventCalendarEventsEventSnoozeReminderExecute(r)
}

/*
UsersUserEventsEventCalendarEventsEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserEventsEventCalendarEventsEventSnoozeReminderRequest
*/
func (a *UsersActionsApiService) UsersUserEventsEventCalendarEventsEventSnoozeReminder(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserEventsEventCalendarEventsEventSnoozeReminderRequest {
	return ApiUsersUserEventsEventCalendarEventsEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserEventsEventCalendarEventsEventSnoozeReminderExecute(r ApiUsersUserEventsEventCalendarEventsEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserEventsEventCalendarEventsEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/events/{event-id}/calendar/events/{event-id1}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject977 == nil {
		return nil, reportError("inlineObject977 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject977
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserEventsEventCalendarEventsEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
	inlineObject978 *InlineObject978
}

func (r ApiUsersUserEventsEventCalendarEventsEventTentativelyAcceptRequest) InlineObject978(inlineObject978 InlineObject978) ApiUsersUserEventsEventCalendarEventsEventTentativelyAcceptRequest {
	r.inlineObject978 = &inlineObject978
	return r
}

func (r ApiUsersUserEventsEventCalendarEventsEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserEventsEventCalendarEventsEventTentativelyAcceptExecute(r)
}

/*
UsersUserEventsEventCalendarEventsEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserEventsEventCalendarEventsEventTentativelyAcceptRequest
*/
func (a *UsersActionsApiService) UsersUserEventsEventCalendarEventsEventTentativelyAccept(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserEventsEventCalendarEventsEventTentativelyAcceptRequest {
	return ApiUsersUserEventsEventCalendarEventsEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserEventsEventCalendarEventsEventTentativelyAcceptExecute(r ApiUsersUserEventsEventCalendarEventsEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserEventsEventCalendarEventsEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/events/{event-id}/calendar/events/{event-id1}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject978 == nil {
		return nil, reportError("inlineObject978 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject978
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserEventsEventCalendarGetScheduleRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	inlineObject979 *InlineObject979
}

func (r ApiUsersUserEventsEventCalendarGetScheduleRequest) InlineObject979(inlineObject979 InlineObject979) ApiUsersUserEventsEventCalendarGetScheduleRequest {
	r.inlineObject979 = &inlineObject979
	return r
}

func (r ApiUsersUserEventsEventCalendarGetScheduleRequest) Execute() ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserEventsEventCalendarGetScheduleExecute(r)
}

/*
UsersUserEventsEventCalendarGetSchedule Invoke action getSchedule

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @return ApiUsersUserEventsEventCalendarGetScheduleRequest
*/
func (a *UsersActionsApiService) UsersUserEventsEventCalendarGetSchedule(ctx _context.Context, userId string, eventId string) ApiUsersUserEventsEventCalendarGetScheduleRequest {
	return ApiUsersUserEventsEventCalendarGetScheduleRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return []*AnyOfmicrosoftGraphScheduleInformation
func (a *UsersActionsApiService) UsersUserEventsEventCalendarGetScheduleExecute(r ApiUsersUserEventsEventCalendarGetScheduleRequest) ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []*AnyOfmicrosoftGraphScheduleInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserEventsEventCalendarGetSchedule")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/events/{event-id}/calendar/microsoft.graph.getSchedule"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject979 == nil {
		return localVarReturnValue, nil, reportError("inlineObject979 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject979
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserEventsEventCancelRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	inlineObject987 *InlineObject987
}

func (r ApiUsersUserEventsEventCancelRequest) InlineObject987(inlineObject987 InlineObject987) ApiUsersUserEventsEventCancelRequest {
	r.inlineObject987 = &inlineObject987
	return r
}

func (r ApiUsersUserEventsEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserEventsEventCancelExecute(r)
}

/*
UsersUserEventsEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @return ApiUsersUserEventsEventCancelRequest
*/
func (a *UsersActionsApiService) UsersUserEventsEventCancel(ctx _context.Context, userId string, eventId string) ApiUsersUserEventsEventCancelRequest {
	return ApiUsersUserEventsEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserEventsEventCancelExecute(r ApiUsersUserEventsEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserEventsEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/events/{event-id}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject987 == nil {
		return nil, reportError("inlineObject987 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject987
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserEventsEventDeclineRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	inlineObject988 *InlineObject988
}

func (r ApiUsersUserEventsEventDeclineRequest) InlineObject988(inlineObject988 InlineObject988) ApiUsersUserEventsEventDeclineRequest {
	r.inlineObject988 = &inlineObject988
	return r
}

func (r ApiUsersUserEventsEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserEventsEventDeclineExecute(r)
}

/*
UsersUserEventsEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @return ApiUsersUserEventsEventDeclineRequest
*/
func (a *UsersActionsApiService) UsersUserEventsEventDecline(ctx _context.Context, userId string, eventId string) ApiUsersUserEventsEventDeclineRequest {
	return ApiUsersUserEventsEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserEventsEventDeclineExecute(r ApiUsersUserEventsEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserEventsEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/events/{event-id}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject988 == nil {
		return nil, reportError("inlineObject988 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject988
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserEventsEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
}


func (r ApiUsersUserEventsEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserEventsEventDismissReminderExecute(r)
}

/*
UsersUserEventsEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @return ApiUsersUserEventsEventDismissReminderRequest
*/
func (a *UsersActionsApiService) UsersUserEventsEventDismissReminder(ctx _context.Context, userId string, eventId string) ApiUsersUserEventsEventDismissReminderRequest {
	return ApiUsersUserEventsEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserEventsEventDismissReminderExecute(r ApiUsersUserEventsEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserEventsEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/events/{event-id}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserEventsEventForwardRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	inlineObject989 *InlineObject989
}

func (r ApiUsersUserEventsEventForwardRequest) InlineObject989(inlineObject989 InlineObject989) ApiUsersUserEventsEventForwardRequest {
	r.inlineObject989 = &inlineObject989
	return r
}

func (r ApiUsersUserEventsEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserEventsEventForwardExecute(r)
}

/*
UsersUserEventsEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @return ApiUsersUserEventsEventForwardRequest
*/
func (a *UsersActionsApiService) UsersUserEventsEventForward(ctx _context.Context, userId string, eventId string) ApiUsersUserEventsEventForwardRequest {
	return ApiUsersUserEventsEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserEventsEventForwardExecute(r ApiUsersUserEventsEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserEventsEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/events/{event-id}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject989 == nil {
		return nil, reportError("inlineObject989 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject989
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserEventsEventInstancesEventAcceptRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
	inlineObject980 *InlineObject980
}

func (r ApiUsersUserEventsEventInstancesEventAcceptRequest) InlineObject980(inlineObject980 InlineObject980) ApiUsersUserEventsEventInstancesEventAcceptRequest {
	r.inlineObject980 = &inlineObject980
	return r
}

func (r ApiUsersUserEventsEventInstancesEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserEventsEventInstancesEventAcceptExecute(r)
}

/*
UsersUserEventsEventInstancesEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserEventsEventInstancesEventAcceptRequest
*/
func (a *UsersActionsApiService) UsersUserEventsEventInstancesEventAccept(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserEventsEventInstancesEventAcceptRequest {
	return ApiUsersUserEventsEventInstancesEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserEventsEventInstancesEventAcceptExecute(r ApiUsersUserEventsEventInstancesEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserEventsEventInstancesEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/events/{event-id}/instances/{event-id1}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject980 == nil {
		return nil, reportError("inlineObject980 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject980
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserEventsEventInstancesEventCancelRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
	inlineObject981 *InlineObject981
}

func (r ApiUsersUserEventsEventInstancesEventCancelRequest) InlineObject981(inlineObject981 InlineObject981) ApiUsersUserEventsEventInstancesEventCancelRequest {
	r.inlineObject981 = &inlineObject981
	return r
}

func (r ApiUsersUserEventsEventInstancesEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserEventsEventInstancesEventCancelExecute(r)
}

/*
UsersUserEventsEventInstancesEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserEventsEventInstancesEventCancelRequest
*/
func (a *UsersActionsApiService) UsersUserEventsEventInstancesEventCancel(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserEventsEventInstancesEventCancelRequest {
	return ApiUsersUserEventsEventInstancesEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserEventsEventInstancesEventCancelExecute(r ApiUsersUserEventsEventInstancesEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserEventsEventInstancesEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/events/{event-id}/instances/{event-id1}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject981 == nil {
		return nil, reportError("inlineObject981 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject981
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserEventsEventInstancesEventDeclineRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
	inlineObject982 *InlineObject982
}

func (r ApiUsersUserEventsEventInstancesEventDeclineRequest) InlineObject982(inlineObject982 InlineObject982) ApiUsersUserEventsEventInstancesEventDeclineRequest {
	r.inlineObject982 = &inlineObject982
	return r
}

func (r ApiUsersUserEventsEventInstancesEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserEventsEventInstancesEventDeclineExecute(r)
}

/*
UsersUserEventsEventInstancesEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserEventsEventInstancesEventDeclineRequest
*/
func (a *UsersActionsApiService) UsersUserEventsEventInstancesEventDecline(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserEventsEventInstancesEventDeclineRequest {
	return ApiUsersUserEventsEventInstancesEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserEventsEventInstancesEventDeclineExecute(r ApiUsersUserEventsEventInstancesEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserEventsEventInstancesEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/events/{event-id}/instances/{event-id1}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject982 == nil {
		return nil, reportError("inlineObject982 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject982
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserEventsEventInstancesEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
}


func (r ApiUsersUserEventsEventInstancesEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserEventsEventInstancesEventDismissReminderExecute(r)
}

/*
UsersUserEventsEventInstancesEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserEventsEventInstancesEventDismissReminderRequest
*/
func (a *UsersActionsApiService) UsersUserEventsEventInstancesEventDismissReminder(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserEventsEventInstancesEventDismissReminderRequest {
	return ApiUsersUserEventsEventInstancesEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserEventsEventInstancesEventDismissReminderExecute(r ApiUsersUserEventsEventInstancesEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserEventsEventInstancesEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/events/{event-id}/instances/{event-id1}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserEventsEventInstancesEventForwardRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
	inlineObject983 *InlineObject983
}

func (r ApiUsersUserEventsEventInstancesEventForwardRequest) InlineObject983(inlineObject983 InlineObject983) ApiUsersUserEventsEventInstancesEventForwardRequest {
	r.inlineObject983 = &inlineObject983
	return r
}

func (r ApiUsersUserEventsEventInstancesEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserEventsEventInstancesEventForwardExecute(r)
}

/*
UsersUserEventsEventInstancesEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserEventsEventInstancesEventForwardRequest
*/
func (a *UsersActionsApiService) UsersUserEventsEventInstancesEventForward(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserEventsEventInstancesEventForwardRequest {
	return ApiUsersUserEventsEventInstancesEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserEventsEventInstancesEventForwardExecute(r ApiUsersUserEventsEventInstancesEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserEventsEventInstancesEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/events/{event-id}/instances/{event-id1}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject983 == nil {
		return nil, reportError("inlineObject983 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject983
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserEventsEventInstancesEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
	inlineObject984 *InlineObject984
}

func (r ApiUsersUserEventsEventInstancesEventSnoozeReminderRequest) InlineObject984(inlineObject984 InlineObject984) ApiUsersUserEventsEventInstancesEventSnoozeReminderRequest {
	r.inlineObject984 = &inlineObject984
	return r
}

func (r ApiUsersUserEventsEventInstancesEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserEventsEventInstancesEventSnoozeReminderExecute(r)
}

/*
UsersUserEventsEventInstancesEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserEventsEventInstancesEventSnoozeReminderRequest
*/
func (a *UsersActionsApiService) UsersUserEventsEventInstancesEventSnoozeReminder(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserEventsEventInstancesEventSnoozeReminderRequest {
	return ApiUsersUserEventsEventInstancesEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserEventsEventInstancesEventSnoozeReminderExecute(r ApiUsersUserEventsEventInstancesEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserEventsEventInstancesEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/events/{event-id}/instances/{event-id1}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject984 == nil {
		return nil, reportError("inlineObject984 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject984
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserEventsEventInstancesEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	eventId1 string
	inlineObject985 *InlineObject985
}

func (r ApiUsersUserEventsEventInstancesEventTentativelyAcceptRequest) InlineObject985(inlineObject985 InlineObject985) ApiUsersUserEventsEventInstancesEventTentativelyAcceptRequest {
	r.inlineObject985 = &inlineObject985
	return r
}

func (r ApiUsersUserEventsEventInstancesEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserEventsEventInstancesEventTentativelyAcceptExecute(r)
}

/*
UsersUserEventsEventInstancesEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiUsersUserEventsEventInstancesEventTentativelyAcceptRequest
*/
func (a *UsersActionsApiService) UsersUserEventsEventInstancesEventTentativelyAccept(ctx _context.Context, userId string, eventId string, eventId1 string) ApiUsersUserEventsEventInstancesEventTentativelyAcceptRequest {
	return ApiUsersUserEventsEventInstancesEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserEventsEventInstancesEventTentativelyAcceptExecute(r ApiUsersUserEventsEventInstancesEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserEventsEventInstancesEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/events/{event-id}/instances/{event-id1}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject985 == nil {
		return nil, reportError("inlineObject985 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject985
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserEventsEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	inlineObject990 *InlineObject990
}

func (r ApiUsersUserEventsEventSnoozeReminderRequest) InlineObject990(inlineObject990 InlineObject990) ApiUsersUserEventsEventSnoozeReminderRequest {
	r.inlineObject990 = &inlineObject990
	return r
}

func (r ApiUsersUserEventsEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserEventsEventSnoozeReminderExecute(r)
}

/*
UsersUserEventsEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @return ApiUsersUserEventsEventSnoozeReminderRequest
*/
func (a *UsersActionsApiService) UsersUserEventsEventSnoozeReminder(ctx _context.Context, userId string, eventId string) ApiUsersUserEventsEventSnoozeReminderRequest {
	return ApiUsersUserEventsEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserEventsEventSnoozeReminderExecute(r ApiUsersUserEventsEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserEventsEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/events/{event-id}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject990 == nil {
		return nil, reportError("inlineObject990 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject990
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserEventsEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	eventId string
	inlineObject991 *InlineObject991
}

func (r ApiUsersUserEventsEventTentativelyAcceptRequest) InlineObject991(inlineObject991 InlineObject991) ApiUsersUserEventsEventTentativelyAcceptRequest {
	r.inlineObject991 = &inlineObject991
	return r
}

func (r ApiUsersUserEventsEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserEventsEventTentativelyAcceptExecute(r)
}

/*
UsersUserEventsEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param eventId key: id of event
 @return ApiUsersUserEventsEventTentativelyAcceptRequest
*/
func (a *UsersActionsApiService) UsersUserEventsEventTentativelyAccept(ctx _context.Context, userId string, eventId string) ApiUsersUserEventsEventTentativelyAcceptRequest {
	return ApiUsersUserEventsEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserEventsEventTentativelyAcceptExecute(r ApiUsersUserEventsEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserEventsEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/events/{event-id}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject991 == nil {
		return nil, reportError("inlineObject991 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject991
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserExportPersonalDataRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	inlineObject1083 *InlineObject1083
}

func (r ApiUsersUserExportPersonalDataRequest) InlineObject1083(inlineObject1083 InlineObject1083) ApiUsersUserExportPersonalDataRequest {
	r.inlineObject1083 = &inlineObject1083
	return r
}

func (r ApiUsersUserExportPersonalDataRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserExportPersonalDataExecute(r)
}

/*
UsersUserExportPersonalData Invoke action exportPersonalData

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @return ApiUsersUserExportPersonalDataRequest
*/
func (a *UsersActionsApiService) UsersUserExportPersonalData(ctx _context.Context, userId string) ApiUsersUserExportPersonalDataRequest {
	return ApiUsersUserExportPersonalDataRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserExportPersonalDataExecute(r ApiUsersUserExportPersonalDataRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserExportPersonalData")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/microsoft.graph.exportPersonalData"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1083 == nil {
		return nil, reportError("inlineObject1083 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1083
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserFindMeetingTimesRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	inlineObject1084 *InlineObject1084
}

func (r ApiUsersUserFindMeetingTimesRequest) InlineObject1084(inlineObject1084 InlineObject1084) ApiUsersUserFindMeetingTimesRequest {
	r.inlineObject1084 = &inlineObject1084
	return r
}

func (r ApiUsersUserFindMeetingTimesRequest) Execute() (AnyOfmicrosoftGraphMeetingTimeSuggestionsResult, *_nethttp.Response, error) {
	return r.ApiService.UsersUserFindMeetingTimesExecute(r)
}

/*
UsersUserFindMeetingTimes Invoke action findMeetingTimes

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @return ApiUsersUserFindMeetingTimesRequest
*/
func (a *UsersActionsApiService) UsersUserFindMeetingTimes(ctx _context.Context, userId string) ApiUsersUserFindMeetingTimesRequest {
	return ApiUsersUserFindMeetingTimesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphMeetingTimeSuggestionsResult
func (a *UsersActionsApiService) UsersUserFindMeetingTimesExecute(r ApiUsersUserFindMeetingTimesRequest) (AnyOfmicrosoftGraphMeetingTimeSuggestionsResult, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphMeetingTimeSuggestionsResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserFindMeetingTimes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/microsoft.graph.findMeetingTimes"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1084 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1084 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1084
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserGetMailTipsRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	inlineObject1085 *InlineObject1085
}

func (r ApiUsersUserGetMailTipsRequest) InlineObject1085(inlineObject1085 InlineObject1085) ApiUsersUserGetMailTipsRequest {
	r.inlineObject1085 = &inlineObject1085
	return r
}

func (r ApiUsersUserGetMailTipsRequest) Execute() ([]MicrosoftGraphMailTips, *_nethttp.Response, error) {
	return r.ApiService.UsersUserGetMailTipsExecute(r)
}

/*
UsersUserGetMailTips Invoke action getMailTips

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @return ApiUsersUserGetMailTipsRequest
*/
func (a *UsersActionsApiService) UsersUserGetMailTips(ctx _context.Context, userId string) ApiUsersUserGetMailTipsRequest {
	return ApiUsersUserGetMailTipsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return []MicrosoftGraphMailTips
func (a *UsersActionsApiService) UsersUserGetMailTipsExecute(r ApiUsersUserGetMailTipsRequest) ([]MicrosoftGraphMailTips, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []MicrosoftGraphMailTips
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserGetMailTips")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/microsoft.graph.getMailTips"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1085 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1085 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1085
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserGetMemberGroupsRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	inlineObject1086 *InlineObject1086
}

func (r ApiUsersUserGetMemberGroupsRequest) InlineObject1086(inlineObject1086 InlineObject1086) ApiUsersUserGetMemberGroupsRequest {
	r.inlineObject1086 = &inlineObject1086
	return r
}

func (r ApiUsersUserGetMemberGroupsRequest) Execute() ([]string, *_nethttp.Response, error) {
	return r.ApiService.UsersUserGetMemberGroupsExecute(r)
}

/*
UsersUserGetMemberGroups Invoke action getMemberGroups

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @return ApiUsersUserGetMemberGroupsRequest
*/
func (a *UsersActionsApiService) UsersUserGetMemberGroups(ctx _context.Context, userId string) ApiUsersUserGetMemberGroupsRequest {
	return ApiUsersUserGetMemberGroupsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return []string
func (a *UsersActionsApiService) UsersUserGetMemberGroupsExecute(r ApiUsersUserGetMemberGroupsRequest) ([]string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserGetMemberGroups")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/microsoft.graph.getMemberGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1086 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1086 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1086
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserGetMemberObjectsRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	inlineObject1087 *InlineObject1087
}

func (r ApiUsersUserGetMemberObjectsRequest) InlineObject1087(inlineObject1087 InlineObject1087) ApiUsersUserGetMemberObjectsRequest {
	r.inlineObject1087 = &inlineObject1087
	return r
}

func (r ApiUsersUserGetMemberObjectsRequest) Execute() ([]string, *_nethttp.Response, error) {
	return r.ApiService.UsersUserGetMemberObjectsExecute(r)
}

/*
UsersUserGetMemberObjects Invoke action getMemberObjects

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @return ApiUsersUserGetMemberObjectsRequest
*/
func (a *UsersActionsApiService) UsersUserGetMemberObjects(ctx _context.Context, userId string) ApiUsersUserGetMemberObjectsRequest {
	return ApiUsersUserGetMemberObjectsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return []string
func (a *UsersActionsApiService) UsersUserGetMemberObjectsExecute(r ApiUsersUserGetMemberObjectsRequest) ([]string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserGetMemberObjects")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/microsoft.graph.getMemberObjects"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1087 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1087 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1087
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphCalendarSharingMessageAcceptRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sharedInsightId string
}


func (r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphCalendarSharingMessageAcceptRequest) Execute() (MicrosoftGraphCalendar, *_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphCalendarSharingMessageAcceptExecute(r)
}

/*
UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphCalendarSharingMessageAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphCalendarSharingMessageAcceptRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphCalendarSharingMessageAccept(ctx _context.Context, userId string, sharedInsightId string) ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphCalendarSharingMessageAcceptRequest {
	return ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphCalendarSharingMessageAcceptRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphCalendar
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphCalendarSharingMessageAcceptExecute(r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphCalendarSharingMessageAcceptRequest) (MicrosoftGraphCalendar, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphCalendar
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphCalendarSharingMessageAccept")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/lastSharedMethod/microsoft.graph.calendarSharingMessage/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphManagedAppProtectionTargetAppsRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sharedInsightId string
	inlineObject992 *InlineObject992
}

func (r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphManagedAppProtectionTargetAppsRequest) InlineObject992(inlineObject992 InlineObject992) ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphManagedAppProtectionTargetAppsRequest {
	r.inlineObject992 = &inlineObject992
	return r
}

func (r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphManagedAppProtectionTargetAppsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphManagedAppProtectionTargetAppsExecute(r)
}

/*
UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphManagedAppProtectionTargetApps Invoke action targetApps

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphManagedAppProtectionTargetAppsRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphManagedAppProtectionTargetApps(ctx _context.Context, userId string, sharedInsightId string) ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphManagedAppProtectionTargetAppsRequest {
	return ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphManagedAppProtectionTargetAppsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphManagedAppProtectionTargetAppsExecute(r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphManagedAppProtectionTargetAppsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphManagedAppProtectionTargetApps")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/lastSharedMethod/microsoft.graph.managedAppProtection/microsoft.graph.targetApps"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject992 == nil {
		return nil, reportError("inlineObject992 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject992
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphMobileAppContentFileCommitRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sharedInsightId string
	inlineObject993 *InlineObject993
}

func (r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphMobileAppContentFileCommitRequest) InlineObject993(inlineObject993 InlineObject993) ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphMobileAppContentFileCommitRequest {
	r.inlineObject993 = &inlineObject993
	return r
}

func (r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphMobileAppContentFileCommitRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphMobileAppContentFileCommitExecute(r)
}

/*
UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphMobileAppContentFileCommit Invoke action commit

Commits a file of a given app.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphMobileAppContentFileCommitRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphMobileAppContentFileCommit(ctx _context.Context, userId string, sharedInsightId string) ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphMobileAppContentFileCommitRequest {
	return ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphMobileAppContentFileCommitRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphMobileAppContentFileCommitExecute(r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphMobileAppContentFileCommitRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphMobileAppContentFileCommit")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/lastSharedMethod/microsoft.graph.mobileAppContentFile/microsoft.graph.commit"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject993 == nil {
		return nil, reportError("inlineObject993 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject993
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphMobileAppContentFileRenewUploadRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sharedInsightId string
}


func (r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphMobileAppContentFileRenewUploadRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphMobileAppContentFileRenewUploadExecute(r)
}

/*
UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphMobileAppContentFileRenewUpload Invoke action renewUpload

Renews the SAS URI for an application file upload.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphMobileAppContentFileRenewUploadRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphMobileAppContentFileRenewUpload(ctx _context.Context, userId string, sharedInsightId string) ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphMobileAppContentFileRenewUploadRequest {
	return ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphMobileAppContentFileRenewUploadRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphMobileAppContentFileRenewUploadExecute(r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphMobileAppContentFileRenewUploadRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphMobileAppContentFileRenewUpload")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/lastSharedMethod/microsoft.graph.mobileAppContentFile/microsoft.graph.renewUpload"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintDocumentCreateUploadSessionRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sharedInsightId string
	inlineObject994 *InlineObject994
}

func (r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintDocumentCreateUploadSessionRequest) InlineObject994(inlineObject994 InlineObject994) ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintDocumentCreateUploadSessionRequest {
	r.inlineObject994 = &inlineObject994
	return r
}

func (r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintDocumentCreateUploadSessionRequest) Execute() (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintDocumentCreateUploadSessionExecute(r)
}

/*
UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintDocumentCreateUploadSession Invoke action createUploadSession

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintDocumentCreateUploadSessionRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintDocumentCreateUploadSession(ctx _context.Context, userId string, sharedInsightId string) ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintDocumentCreateUploadSessionRequest {
	return ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintDocumentCreateUploadSessionRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphUploadSession
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintDocumentCreateUploadSessionExecute(r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintDocumentCreateUploadSessionRequest) (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphUploadSession
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintDocumentCreateUploadSession")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/lastSharedMethod/microsoft.graph.printDocument/microsoft.graph.createUploadSession"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject994 == nil {
		return localVarReturnValue, nil, reportError("inlineObject994 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject994
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobAbortRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sharedInsightId string
	inlineObject995 *InlineObject995
}

func (r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobAbortRequest) InlineObject995(inlineObject995 InlineObject995) ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobAbortRequest {
	r.inlineObject995 = &inlineObject995
	return r
}

func (r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobAbortRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobAbortExecute(r)
}

/*
UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobAbort Invoke action abort

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobAbortRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobAbort(ctx _context.Context, userId string, sharedInsightId string) ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobAbortRequest {
	return ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobAbortRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobAbortExecute(r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobAbortRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobAbort")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/lastSharedMethod/microsoft.graph.printJob/microsoft.graph.abort"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject995 == nil {
		return nil, reportError("inlineObject995 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject995
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobCancelRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sharedInsightId string
}


func (r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobCancelExecute(r)
}

/*
UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobCancelRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobCancel(ctx _context.Context, userId string, sharedInsightId string) ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobCancelRequest {
	return ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobCancelRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobCancelExecute(r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/lastSharedMethod/microsoft.graph.printJob/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobRedirectRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sharedInsightId string
	inlineObject996 *InlineObject996
}

func (r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobRedirectRequest) InlineObject996(inlineObject996 InlineObject996) ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobRedirectRequest {
	r.inlineObject996 = &inlineObject996
	return r
}

func (r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobRedirectRequest) Execute() (AnyOfmicrosoftGraphPrintJob, *_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobRedirectExecute(r)
}

/*
UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobRedirect Invoke action redirect

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobRedirectRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobRedirect(ctx _context.Context, userId string, sharedInsightId string) ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobRedirectRequest {
	return ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobRedirectRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphPrintJob
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobRedirectExecute(r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobRedirectRequest) (AnyOfmicrosoftGraphPrintJob, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphPrintJob
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobRedirect")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/lastSharedMethod/microsoft.graph.printJob/microsoft.graph.redirect"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject996 == nil {
		return localVarReturnValue, nil, reportError("inlineObject996 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject996
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobStartRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sharedInsightId string
}


func (r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobStartRequest) Execute() (AnyOfmicrosoftGraphPrintJobStatus, *_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobStartExecute(r)
}

/*
UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobStart Invoke action start

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobStartRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobStart(ctx _context.Context, userId string, sharedInsightId string) ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobStartRequest {
	return ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobStartRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphPrintJobStatus
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobStartExecute(r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobStartRequest) (AnyOfmicrosoftGraphPrintJobStatus, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphPrintJobStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobStart")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/lastSharedMethod/microsoft.graph.printJob/microsoft.graph.start"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestApproveRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sharedInsightId string
	inlineObject997 *InlineObject997
}

func (r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestApproveRequest) InlineObject997(inlineObject997 InlineObject997) ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestApproveRequest {
	r.inlineObject997 = &inlineObject997
	return r
}

func (r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestApproveRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestApproveExecute(r)
}

/*
UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestApprove Invoke action approve

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestApproveRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestApprove(ctx _context.Context, userId string, sharedInsightId string) ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestApproveRequest {
	return ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestApproveRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestApproveExecute(r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestApproveRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestApprove")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/lastSharedMethod/microsoft.graph.scheduleChangeRequest/microsoft.graph.approve"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject997 == nil {
		return nil, reportError("inlineObject997 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject997
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestDeclineRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sharedInsightId string
	inlineObject998 *InlineObject998
}

func (r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestDeclineRequest) InlineObject998(inlineObject998 InlineObject998) ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestDeclineRequest {
	r.inlineObject998 = &inlineObject998
	return r
}

func (r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestDeclineExecute(r)
}

/*
UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestDeclineRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestDecline(ctx _context.Context, userId string, sharedInsightId string) ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestDeclineRequest {
	return ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestDeclineRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestDeclineExecute(r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/lastSharedMethod/microsoft.graph.scheduleChangeRequest/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject998 == nil {
		return nil, reportError("inlineObject998 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject998
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionAssignRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sharedInsightId string
	inlineObject999 *InlineObject999
}

func (r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionAssignRequest) InlineObject999(inlineObject999 InlineObject999) ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionAssignRequest {
	r.inlineObject999 = &inlineObject999
	return r
}

func (r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionAssignRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionAssignExecute(r)
}

/*
UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionAssign Invoke action assign

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionAssignRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionAssign(ctx _context.Context, userId string, sharedInsightId string) ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionAssignRequest {
	return ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionAssignRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionAssignExecute(r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionAssignRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionAssign")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/lastSharedMethod/microsoft.graph.targetedManagedAppProtection/microsoft.graph.assign"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject999 == nil {
		return nil, reportError("inlineObject999 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject999
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sharedInsightId string
	inlineObject1000 *InlineObject1000
}

func (r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest) InlineObject1000(inlineObject1000 InlineObject1000) ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest {
	r.inlineObject1000 = &inlineObject1000
	return r
}

func (r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionTargetAppsExecute(r)
}

/*
UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionTargetApps Invoke action targetApps

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionTargetApps(ctx _context.Context, userId string, sharedInsightId string) ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest {
	return ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionTargetAppsExecute(r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionTargetApps")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/lastSharedMethod/microsoft.graph.targetedManagedAppProtection/microsoft.graph.targetApps"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1000 == nil {
		return nil, reportError("inlineObject1000 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1000
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWindowsInformationProtectionAssignRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sharedInsightId string
	inlineObject1001 *InlineObject1001
}

func (r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWindowsInformationProtectionAssignRequest) InlineObject1001(inlineObject1001 InlineObject1001) ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWindowsInformationProtectionAssignRequest {
	r.inlineObject1001 = &inlineObject1001
	return r
}

func (r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWindowsInformationProtectionAssignRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWindowsInformationProtectionAssignExecute(r)
}

/*
UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWindowsInformationProtectionAssign Invoke action assign

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWindowsInformationProtectionAssignRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWindowsInformationProtectionAssign(ctx _context.Context, userId string, sharedInsightId string) ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWindowsInformationProtectionAssignRequest {
	return ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWindowsInformationProtectionAssignRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWindowsInformationProtectionAssignExecute(r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWindowsInformationProtectionAssignRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWindowsInformationProtectionAssign")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/lastSharedMethod/microsoft.graph.windowsInformationProtection/microsoft.graph.assign"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1001 == nil {
		return nil, reportError("inlineObject1001 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1001
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeClearRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sharedInsightId string
	inlineObject1002 *InlineObject1002
}

func (r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeClearRequest) InlineObject1002(inlineObject1002 InlineObject1002) ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeClearRequest {
	r.inlineObject1002 = &inlineObject1002
	return r
}

func (r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeClearRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeClearExecute(r)
}

/*
UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeClear Invoke action clear

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeClearRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeClear(ctx _context.Context, userId string, sharedInsightId string) ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeClearRequest {
	return ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeClearRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeClearExecute(r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeClearRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeClear")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/lastSharedMethod/microsoft.graph.workbookRange/microsoft.graph.clear"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1002 == nil {
		return nil, reportError("inlineObject1002 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1002
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeDeleteRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sharedInsightId string
	inlineObject1003 *InlineObject1003
}

func (r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeDeleteRequest) InlineObject1003(inlineObject1003 InlineObject1003) ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeDeleteRequest {
	r.inlineObject1003 = &inlineObject1003
	return r
}

func (r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeDeleteExecute(r)
}

/*
UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeDelete Invoke action delete

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeDeleteRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeDelete(ctx _context.Context, userId string, sharedInsightId string) ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeDeleteRequest {
	return ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeDeleteRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeDeleteExecute(r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/lastSharedMethod/microsoft.graph.workbookRange/microsoft.graph.delete"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1003 == nil {
		return nil, reportError("inlineObject1003 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1003
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFillClearRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sharedInsightId string
}


func (r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFillClearRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFillClearExecute(r)
}

/*
UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFillClear Invoke action clear

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFillClearRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFillClear(ctx _context.Context, userId string, sharedInsightId string) ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFillClearRequest {
	return ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFillClearRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFillClearExecute(r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFillClearRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFillClear")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/lastSharedMethod/microsoft.graph.workbookRangeFill/microsoft.graph.clear"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFormatAutofitColumnsRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sharedInsightId string
}


func (r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFormatAutofitColumnsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFormatAutofitColumnsExecute(r)
}

/*
UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFormatAutofitColumns Invoke action autofitColumns

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFormatAutofitColumnsRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFormatAutofitColumns(ctx _context.Context, userId string, sharedInsightId string) ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFormatAutofitColumnsRequest {
	return ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFormatAutofitColumnsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFormatAutofitColumnsExecute(r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFormatAutofitColumnsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFormatAutofitColumns")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/lastSharedMethod/microsoft.graph.workbookRangeFormat/microsoft.graph.autofitColumns"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFormatAutofitRowsRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sharedInsightId string
}


func (r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFormatAutofitRowsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFormatAutofitRowsExecute(r)
}

/*
UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFormatAutofitRows Invoke action autofitRows

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFormatAutofitRowsRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFormatAutofitRows(ctx _context.Context, userId string, sharedInsightId string) ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFormatAutofitRowsRequest {
	return ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFormatAutofitRowsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFormatAutofitRowsExecute(r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFormatAutofitRowsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFormatAutofitRows")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/lastSharedMethod/microsoft.graph.workbookRangeFormat/microsoft.graph.autofitRows"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeInsertRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sharedInsightId string
	inlineObject1004 *InlineObject1004
}

func (r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeInsertRequest) InlineObject1004(inlineObject1004 InlineObject1004) ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeInsertRequest {
	r.inlineObject1004 = &inlineObject1004
	return r
}

func (r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeInsertRequest) Execute() (AnyOfmicrosoftGraphWorkbookRange, *_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeInsertExecute(r)
}

/*
UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeInsert Invoke action insert

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeInsertRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeInsert(ctx _context.Context, userId string, sharedInsightId string) ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeInsertRequest {
	return ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeInsertRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphWorkbookRange
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeInsertExecute(r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeInsertRequest) (AnyOfmicrosoftGraphWorkbookRange, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphWorkbookRange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeInsert")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/lastSharedMethod/microsoft.graph.workbookRange/microsoft.graph.insert"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1004 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1004 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1004
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeMergeRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sharedInsightId string
	inlineObject1005 *InlineObject1005
}

func (r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeMergeRequest) InlineObject1005(inlineObject1005 InlineObject1005) ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeMergeRequest {
	r.inlineObject1005 = &inlineObject1005
	return r
}

func (r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeMergeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeMergeExecute(r)
}

/*
UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeMerge Invoke action merge

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeMergeRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeMerge(ctx _context.Context, userId string, sharedInsightId string) ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeMergeRequest {
	return ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeMergeRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeMergeExecute(r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeMergeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeMerge")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/lastSharedMethod/microsoft.graph.workbookRange/microsoft.graph.merge"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1005 == nil {
		return nil, reportError("inlineObject1005 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1005
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeSortApplyRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sharedInsightId string
	inlineObject1006 *InlineObject1006
}

func (r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeSortApplyRequest) InlineObject1006(inlineObject1006 InlineObject1006) ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeSortApplyRequest {
	r.inlineObject1006 = &inlineObject1006
	return r
}

func (r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeSortApplyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeSortApplyExecute(r)
}

/*
UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeSortApply Invoke action apply

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeSortApplyRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeSortApply(ctx _context.Context, userId string, sharedInsightId string) ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeSortApplyRequest {
	return ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeSortApplyRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeSortApplyExecute(r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeSortApplyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeSortApply")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/lastSharedMethod/microsoft.graph.workbookRangeSort/microsoft.graph.apply"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1006 == nil {
		return nil, reportError("inlineObject1006 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1006
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeUnmergeRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sharedInsightId string
}


func (r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeUnmergeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeUnmergeExecute(r)
}

/*
UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeUnmerge Invoke action unmerge

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeUnmergeRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeUnmerge(ctx _context.Context, userId string, sharedInsightId string) ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeUnmergeRequest {
	return ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeUnmergeRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeUnmergeExecute(r ApiUsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeUnmergeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeUnmerge")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/lastSharedMethod/microsoft.graph.workbookRange/microsoft.graph.unmerge"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphCalendarSharingMessageAcceptRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sharedInsightId string
}


func (r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphCalendarSharingMessageAcceptRequest) Execute() (MicrosoftGraphCalendar, *_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphCalendarSharingMessageAcceptExecute(r)
}

/*
UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphCalendarSharingMessageAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphCalendarSharingMessageAcceptRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphCalendarSharingMessageAccept(ctx _context.Context, userId string, sharedInsightId string) ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphCalendarSharingMessageAcceptRequest {
	return ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphCalendarSharingMessageAcceptRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphCalendar
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphCalendarSharingMessageAcceptExecute(r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphCalendarSharingMessageAcceptRequest) (MicrosoftGraphCalendar, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphCalendar
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphCalendarSharingMessageAccept")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/resource/microsoft.graph.calendarSharingMessage/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphManagedAppProtectionTargetAppsRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sharedInsightId string
	inlineObject1007 *InlineObject1007
}

func (r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphManagedAppProtectionTargetAppsRequest) InlineObject1007(inlineObject1007 InlineObject1007) ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphManagedAppProtectionTargetAppsRequest {
	r.inlineObject1007 = &inlineObject1007
	return r
}

func (r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphManagedAppProtectionTargetAppsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphManagedAppProtectionTargetAppsExecute(r)
}

/*
UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphManagedAppProtectionTargetApps Invoke action targetApps

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphManagedAppProtectionTargetAppsRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphManagedAppProtectionTargetApps(ctx _context.Context, userId string, sharedInsightId string) ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphManagedAppProtectionTargetAppsRequest {
	return ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphManagedAppProtectionTargetAppsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphManagedAppProtectionTargetAppsExecute(r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphManagedAppProtectionTargetAppsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphManagedAppProtectionTargetApps")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/resource/microsoft.graph.managedAppProtection/microsoft.graph.targetApps"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1007 == nil {
		return nil, reportError("inlineObject1007 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1007
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphMobileAppContentFileCommitRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sharedInsightId string
	inlineObject1008 *InlineObject1008
}

func (r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphMobileAppContentFileCommitRequest) InlineObject1008(inlineObject1008 InlineObject1008) ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphMobileAppContentFileCommitRequest {
	r.inlineObject1008 = &inlineObject1008
	return r
}

func (r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphMobileAppContentFileCommitRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphMobileAppContentFileCommitExecute(r)
}

/*
UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphMobileAppContentFileCommit Invoke action commit

Commits a file of a given app.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphMobileAppContentFileCommitRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphMobileAppContentFileCommit(ctx _context.Context, userId string, sharedInsightId string) ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphMobileAppContentFileCommitRequest {
	return ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphMobileAppContentFileCommitRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphMobileAppContentFileCommitExecute(r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphMobileAppContentFileCommitRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphMobileAppContentFileCommit")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/resource/microsoft.graph.mobileAppContentFile/microsoft.graph.commit"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1008 == nil {
		return nil, reportError("inlineObject1008 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1008
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphMobileAppContentFileRenewUploadRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sharedInsightId string
}


func (r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphMobileAppContentFileRenewUploadRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphMobileAppContentFileRenewUploadExecute(r)
}

/*
UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphMobileAppContentFileRenewUpload Invoke action renewUpload

Renews the SAS URI for an application file upload.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphMobileAppContentFileRenewUploadRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphMobileAppContentFileRenewUpload(ctx _context.Context, userId string, sharedInsightId string) ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphMobileAppContentFileRenewUploadRequest {
	return ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphMobileAppContentFileRenewUploadRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphMobileAppContentFileRenewUploadExecute(r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphMobileAppContentFileRenewUploadRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphMobileAppContentFileRenewUpload")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/resource/microsoft.graph.mobileAppContentFile/microsoft.graph.renewUpload"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSessionRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sharedInsightId string
	inlineObject1009 *InlineObject1009
}

func (r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSessionRequest) InlineObject1009(inlineObject1009 InlineObject1009) ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSessionRequest {
	r.inlineObject1009 = &inlineObject1009
	return r
}

func (r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSessionRequest) Execute() (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSessionExecute(r)
}

/*
UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSession Invoke action createUploadSession

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSessionRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSession(ctx _context.Context, userId string, sharedInsightId string) ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSessionRequest {
	return ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSessionRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphUploadSession
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSessionExecute(r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSessionRequest) (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphUploadSession
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSession")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/resource/microsoft.graph.printDocument/microsoft.graph.createUploadSession"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1009 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1009 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1009
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobAbortRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sharedInsightId string
	inlineObject1010 *InlineObject1010
}

func (r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobAbortRequest) InlineObject1010(inlineObject1010 InlineObject1010) ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobAbortRequest {
	r.inlineObject1010 = &inlineObject1010
	return r
}

func (r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobAbortRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobAbortExecute(r)
}

/*
UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobAbort Invoke action abort

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobAbortRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobAbort(ctx _context.Context, userId string, sharedInsightId string) ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobAbortRequest {
	return ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobAbortRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobAbortExecute(r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobAbortRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobAbort")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/resource/microsoft.graph.printJob/microsoft.graph.abort"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1010 == nil {
		return nil, reportError("inlineObject1010 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1010
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobCancelRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sharedInsightId string
}


func (r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobCancelExecute(r)
}

/*
UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobCancelRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobCancel(ctx _context.Context, userId string, sharedInsightId string) ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobCancelRequest {
	return ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobCancelRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobCancelExecute(r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/resource/microsoft.graph.printJob/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobRedirectRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sharedInsightId string
	inlineObject1011 *InlineObject1011
}

func (r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobRedirectRequest) InlineObject1011(inlineObject1011 InlineObject1011) ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobRedirectRequest {
	r.inlineObject1011 = &inlineObject1011
	return r
}

func (r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobRedirectRequest) Execute() (AnyOfmicrosoftGraphPrintJob, *_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobRedirectExecute(r)
}

/*
UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobRedirect Invoke action redirect

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobRedirectRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobRedirect(ctx _context.Context, userId string, sharedInsightId string) ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobRedirectRequest {
	return ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobRedirectRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphPrintJob
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobRedirectExecute(r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobRedirectRequest) (AnyOfmicrosoftGraphPrintJob, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphPrintJob
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobRedirect")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/resource/microsoft.graph.printJob/microsoft.graph.redirect"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1011 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1011 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1011
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobStartRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sharedInsightId string
}


func (r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobStartRequest) Execute() (AnyOfmicrosoftGraphPrintJobStatus, *_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobStartExecute(r)
}

/*
UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobStart Invoke action start

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobStartRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobStart(ctx _context.Context, userId string, sharedInsightId string) ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobStartRequest {
	return ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobStartRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphPrintJobStatus
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobStartExecute(r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobStartRequest) (AnyOfmicrosoftGraphPrintJobStatus, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphPrintJobStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobStart")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/resource/microsoft.graph.printJob/microsoft.graph.start"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestApproveRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sharedInsightId string
	inlineObject1012 *InlineObject1012
}

func (r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestApproveRequest) InlineObject1012(inlineObject1012 InlineObject1012) ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestApproveRequest {
	r.inlineObject1012 = &inlineObject1012
	return r
}

func (r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestApproveRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestApproveExecute(r)
}

/*
UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestApprove Invoke action approve

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestApproveRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestApprove(ctx _context.Context, userId string, sharedInsightId string) ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestApproveRequest {
	return ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestApproveRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestApproveExecute(r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestApproveRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestApprove")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/resource/microsoft.graph.scheduleChangeRequest/microsoft.graph.approve"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1012 == nil {
		return nil, reportError("inlineObject1012 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1012
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestDeclineRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sharedInsightId string
	inlineObject1013 *InlineObject1013
}

func (r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestDeclineRequest) InlineObject1013(inlineObject1013 InlineObject1013) ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestDeclineRequest {
	r.inlineObject1013 = &inlineObject1013
	return r
}

func (r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestDeclineExecute(r)
}

/*
UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestDeclineRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestDecline(ctx _context.Context, userId string, sharedInsightId string) ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestDeclineRequest {
	return ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestDeclineRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestDeclineExecute(r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/resource/microsoft.graph.scheduleChangeRequest/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1013 == nil {
		return nil, reportError("inlineObject1013 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1013
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssignRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sharedInsightId string
	inlineObject1014 *InlineObject1014
}

func (r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssignRequest) InlineObject1014(inlineObject1014 InlineObject1014) ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssignRequest {
	r.inlineObject1014 = &inlineObject1014
	return r
}

func (r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssignRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssignExecute(r)
}

/*
UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssign Invoke action assign

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssignRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssign(ctx _context.Context, userId string, sharedInsightId string) ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssignRequest {
	return ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssignRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssignExecute(r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssignRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssign")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/resource/microsoft.graph.targetedManagedAppProtection/microsoft.graph.assign"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1014 == nil {
		return nil, reportError("inlineObject1014 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1014
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sharedInsightId string
	inlineObject1015 *InlineObject1015
}

func (r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest) InlineObject1015(inlineObject1015 InlineObject1015) ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest {
	r.inlineObject1015 = &inlineObject1015
	return r
}

func (r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsExecute(r)
}

/*
UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetApps Invoke action targetApps

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetApps(ctx _context.Context, userId string, sharedInsightId string) ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest {
	return ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsExecute(r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetApps")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/resource/microsoft.graph.targetedManagedAppProtection/microsoft.graph.targetApps"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1015 == nil {
		return nil, reportError("inlineObject1015 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1015
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWindowsInformationProtectionAssignRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sharedInsightId string
	inlineObject1016 *InlineObject1016
}

func (r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWindowsInformationProtectionAssignRequest) InlineObject1016(inlineObject1016 InlineObject1016) ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWindowsInformationProtectionAssignRequest {
	r.inlineObject1016 = &inlineObject1016
	return r
}

func (r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWindowsInformationProtectionAssignRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWindowsInformationProtectionAssignExecute(r)
}

/*
UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWindowsInformationProtectionAssign Invoke action assign

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWindowsInformationProtectionAssignRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWindowsInformationProtectionAssign(ctx _context.Context, userId string, sharedInsightId string) ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWindowsInformationProtectionAssignRequest {
	return ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWindowsInformationProtectionAssignRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWindowsInformationProtectionAssignExecute(r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWindowsInformationProtectionAssignRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWindowsInformationProtectionAssign")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/resource/microsoft.graph.windowsInformationProtection/microsoft.graph.assign"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1016 == nil {
		return nil, reportError("inlineObject1016 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1016
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeClearRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sharedInsightId string
	inlineObject1017 *InlineObject1017
}

func (r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeClearRequest) InlineObject1017(inlineObject1017 InlineObject1017) ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeClearRequest {
	r.inlineObject1017 = &inlineObject1017
	return r
}

func (r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeClearRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeClearExecute(r)
}

/*
UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeClear Invoke action clear

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeClearRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeClear(ctx _context.Context, userId string, sharedInsightId string) ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeClearRequest {
	return ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeClearRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeClearExecute(r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeClearRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeClear")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/resource/microsoft.graph.workbookRange/microsoft.graph.clear"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1017 == nil {
		return nil, reportError("inlineObject1017 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1017
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeDeleteRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sharedInsightId string
	inlineObject1018 *InlineObject1018
}

func (r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeDeleteRequest) InlineObject1018(inlineObject1018 InlineObject1018) ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeDeleteRequest {
	r.inlineObject1018 = &inlineObject1018
	return r
}

func (r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeDeleteExecute(r)
}

/*
UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeDelete Invoke action delete

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeDeleteRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeDelete(ctx _context.Context, userId string, sharedInsightId string) ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeDeleteRequest {
	return ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeDeleteRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeDeleteExecute(r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/resource/microsoft.graph.workbookRange/microsoft.graph.delete"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1018 == nil {
		return nil, reportError("inlineObject1018 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1018
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFillClearRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sharedInsightId string
}


func (r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFillClearRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFillClearExecute(r)
}

/*
UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFillClear Invoke action clear

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFillClearRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFillClear(ctx _context.Context, userId string, sharedInsightId string) ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFillClearRequest {
	return ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFillClearRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFillClearExecute(r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFillClearRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFillClear")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/resource/microsoft.graph.workbookRangeFill/microsoft.graph.clear"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitColumnsRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sharedInsightId string
}


func (r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitColumnsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitColumnsExecute(r)
}

/*
UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitColumns Invoke action autofitColumns

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitColumnsRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitColumns(ctx _context.Context, userId string, sharedInsightId string) ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitColumnsRequest {
	return ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitColumnsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitColumnsExecute(r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitColumnsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitColumns")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/resource/microsoft.graph.workbookRangeFormat/microsoft.graph.autofitColumns"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitRowsRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sharedInsightId string
}


func (r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitRowsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitRowsExecute(r)
}

/*
UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitRows Invoke action autofitRows

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitRowsRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitRows(ctx _context.Context, userId string, sharedInsightId string) ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitRowsRequest {
	return ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitRowsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitRowsExecute(r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitRowsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitRows")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/resource/microsoft.graph.workbookRangeFormat/microsoft.graph.autofitRows"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeInsertRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sharedInsightId string
	inlineObject1019 *InlineObject1019
}

func (r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeInsertRequest) InlineObject1019(inlineObject1019 InlineObject1019) ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeInsertRequest {
	r.inlineObject1019 = &inlineObject1019
	return r
}

func (r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeInsertRequest) Execute() (AnyOfmicrosoftGraphWorkbookRange, *_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeInsertExecute(r)
}

/*
UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeInsert Invoke action insert

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeInsertRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeInsert(ctx _context.Context, userId string, sharedInsightId string) ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeInsertRequest {
	return ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeInsertRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphWorkbookRange
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeInsertExecute(r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeInsertRequest) (AnyOfmicrosoftGraphWorkbookRange, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphWorkbookRange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeInsert")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/resource/microsoft.graph.workbookRange/microsoft.graph.insert"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1019 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1019 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1019
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeMergeRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sharedInsightId string
	inlineObject1020 *InlineObject1020
}

func (r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeMergeRequest) InlineObject1020(inlineObject1020 InlineObject1020) ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeMergeRequest {
	r.inlineObject1020 = &inlineObject1020
	return r
}

func (r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeMergeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeMergeExecute(r)
}

/*
UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeMerge Invoke action merge

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeMergeRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeMerge(ctx _context.Context, userId string, sharedInsightId string) ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeMergeRequest {
	return ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeMergeRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeMergeExecute(r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeMergeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeMerge")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/resource/microsoft.graph.workbookRange/microsoft.graph.merge"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1020 == nil {
		return nil, reportError("inlineObject1020 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1020
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeSortApplyRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sharedInsightId string
	inlineObject1021 *InlineObject1021
}

func (r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeSortApplyRequest) InlineObject1021(inlineObject1021 InlineObject1021) ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeSortApplyRequest {
	r.inlineObject1021 = &inlineObject1021
	return r
}

func (r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeSortApplyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeSortApplyExecute(r)
}

/*
UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeSortApply Invoke action apply

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeSortApplyRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeSortApply(ctx _context.Context, userId string, sharedInsightId string) ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeSortApplyRequest {
	return ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeSortApplyRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeSortApplyExecute(r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeSortApplyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeSortApply")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/resource/microsoft.graph.workbookRangeSort/microsoft.graph.apply"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1021 == nil {
		return nil, reportError("inlineObject1021 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1021
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeUnmergeRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sharedInsightId string
}


func (r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeUnmergeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeUnmergeExecute(r)
}

/*
UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeUnmerge Invoke action unmerge

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeUnmergeRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeUnmerge(ctx _context.Context, userId string, sharedInsightId string) ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeUnmergeRequest {
	return ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeUnmergeRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeUnmergeExecute(r ApiUsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeUnmergeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeUnmerge")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/resource/microsoft.graph.workbookRange/microsoft.graph.unmerge"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphCalendarSharingMessageAcceptRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	trendingId string
}


func (r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphCalendarSharingMessageAcceptRequest) Execute() (MicrosoftGraphCalendar, *_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsTrendingTrendingResourceMicrosoftGraphCalendarSharingMessageAcceptExecute(r)
}

/*
UsersUserInsightsTrendingTrendingResourceMicrosoftGraphCalendarSharingMessageAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param trendingId key: id of trending
 @return ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphCalendarSharingMessageAcceptRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsTrendingTrendingResourceMicrosoftGraphCalendarSharingMessageAccept(ctx _context.Context, userId string, trendingId string) ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphCalendarSharingMessageAcceptRequest {
	return ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphCalendarSharingMessageAcceptRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		trendingId: trendingId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphCalendar
func (a *UsersActionsApiService) UsersUserInsightsTrendingTrendingResourceMicrosoftGraphCalendarSharingMessageAcceptExecute(r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphCalendarSharingMessageAcceptRequest) (MicrosoftGraphCalendar, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphCalendar
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsTrendingTrendingResourceMicrosoftGraphCalendarSharingMessageAccept")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/trending/{trending-id}/resource/microsoft.graph.calendarSharingMessage/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphManagedAppProtectionTargetAppsRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	trendingId string
	inlineObject1022 *InlineObject1022
}

func (r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphManagedAppProtectionTargetAppsRequest) InlineObject1022(inlineObject1022 InlineObject1022) ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphManagedAppProtectionTargetAppsRequest {
	r.inlineObject1022 = &inlineObject1022
	return r
}

func (r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphManagedAppProtectionTargetAppsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsTrendingTrendingResourceMicrosoftGraphManagedAppProtectionTargetAppsExecute(r)
}

/*
UsersUserInsightsTrendingTrendingResourceMicrosoftGraphManagedAppProtectionTargetApps Invoke action targetApps

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param trendingId key: id of trending
 @return ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphManagedAppProtectionTargetAppsRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsTrendingTrendingResourceMicrosoftGraphManagedAppProtectionTargetApps(ctx _context.Context, userId string, trendingId string) ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphManagedAppProtectionTargetAppsRequest {
	return ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphManagedAppProtectionTargetAppsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		trendingId: trendingId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsTrendingTrendingResourceMicrosoftGraphManagedAppProtectionTargetAppsExecute(r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphManagedAppProtectionTargetAppsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsTrendingTrendingResourceMicrosoftGraphManagedAppProtectionTargetApps")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/trending/{trending-id}/resource/microsoft.graph.managedAppProtection/microsoft.graph.targetApps"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1022 == nil {
		return nil, reportError("inlineObject1022 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1022
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphMobileAppContentFileCommitRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	trendingId string
	inlineObject1023 *InlineObject1023
}

func (r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphMobileAppContentFileCommitRequest) InlineObject1023(inlineObject1023 InlineObject1023) ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphMobileAppContentFileCommitRequest {
	r.inlineObject1023 = &inlineObject1023
	return r
}

func (r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphMobileAppContentFileCommitRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsTrendingTrendingResourceMicrosoftGraphMobileAppContentFileCommitExecute(r)
}

/*
UsersUserInsightsTrendingTrendingResourceMicrosoftGraphMobileAppContentFileCommit Invoke action commit

Commits a file of a given app.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param trendingId key: id of trending
 @return ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphMobileAppContentFileCommitRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsTrendingTrendingResourceMicrosoftGraphMobileAppContentFileCommit(ctx _context.Context, userId string, trendingId string) ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphMobileAppContentFileCommitRequest {
	return ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphMobileAppContentFileCommitRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		trendingId: trendingId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsTrendingTrendingResourceMicrosoftGraphMobileAppContentFileCommitExecute(r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphMobileAppContentFileCommitRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsTrendingTrendingResourceMicrosoftGraphMobileAppContentFileCommit")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/trending/{trending-id}/resource/microsoft.graph.mobileAppContentFile/microsoft.graph.commit"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1023 == nil {
		return nil, reportError("inlineObject1023 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1023
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphMobileAppContentFileRenewUploadRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	trendingId string
}


func (r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphMobileAppContentFileRenewUploadRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsTrendingTrendingResourceMicrosoftGraphMobileAppContentFileRenewUploadExecute(r)
}

/*
UsersUserInsightsTrendingTrendingResourceMicrosoftGraphMobileAppContentFileRenewUpload Invoke action renewUpload

Renews the SAS URI for an application file upload.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param trendingId key: id of trending
 @return ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphMobileAppContentFileRenewUploadRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsTrendingTrendingResourceMicrosoftGraphMobileAppContentFileRenewUpload(ctx _context.Context, userId string, trendingId string) ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphMobileAppContentFileRenewUploadRequest {
	return ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphMobileAppContentFileRenewUploadRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		trendingId: trendingId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsTrendingTrendingResourceMicrosoftGraphMobileAppContentFileRenewUploadExecute(r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphMobileAppContentFileRenewUploadRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsTrendingTrendingResourceMicrosoftGraphMobileAppContentFileRenewUpload")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/trending/{trending-id}/resource/microsoft.graph.mobileAppContentFile/microsoft.graph.renewUpload"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintDocumentCreateUploadSessionRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	trendingId string
	inlineObject1024 *InlineObject1024
}

func (r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintDocumentCreateUploadSessionRequest) InlineObject1024(inlineObject1024 InlineObject1024) ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintDocumentCreateUploadSessionRequest {
	r.inlineObject1024 = &inlineObject1024
	return r
}

func (r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintDocumentCreateUploadSessionRequest) Execute() (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintDocumentCreateUploadSessionExecute(r)
}

/*
UsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintDocumentCreateUploadSession Invoke action createUploadSession

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param trendingId key: id of trending
 @return ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintDocumentCreateUploadSessionRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintDocumentCreateUploadSession(ctx _context.Context, userId string, trendingId string) ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintDocumentCreateUploadSessionRequest {
	return ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintDocumentCreateUploadSessionRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		trendingId: trendingId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphUploadSession
func (a *UsersActionsApiService) UsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintDocumentCreateUploadSessionExecute(r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintDocumentCreateUploadSessionRequest) (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphUploadSession
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintDocumentCreateUploadSession")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/trending/{trending-id}/resource/microsoft.graph.printDocument/microsoft.graph.createUploadSession"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1024 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1024 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1024
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintJobAbortRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	trendingId string
	inlineObject1025 *InlineObject1025
}

func (r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintJobAbortRequest) InlineObject1025(inlineObject1025 InlineObject1025) ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintJobAbortRequest {
	r.inlineObject1025 = &inlineObject1025
	return r
}

func (r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintJobAbortRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintJobAbortExecute(r)
}

/*
UsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintJobAbort Invoke action abort

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param trendingId key: id of trending
 @return ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintJobAbortRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintJobAbort(ctx _context.Context, userId string, trendingId string) ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintJobAbortRequest {
	return ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintJobAbortRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		trendingId: trendingId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintJobAbortExecute(r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintJobAbortRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintJobAbort")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/trending/{trending-id}/resource/microsoft.graph.printJob/microsoft.graph.abort"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1025 == nil {
		return nil, reportError("inlineObject1025 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1025
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintJobCancelRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	trendingId string
}


func (r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintJobCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintJobCancelExecute(r)
}

/*
UsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintJobCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param trendingId key: id of trending
 @return ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintJobCancelRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintJobCancel(ctx _context.Context, userId string, trendingId string) ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintJobCancelRequest {
	return ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintJobCancelRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		trendingId: trendingId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintJobCancelExecute(r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintJobCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintJobCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/trending/{trending-id}/resource/microsoft.graph.printJob/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintJobRedirectRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	trendingId string
	inlineObject1026 *InlineObject1026
}

func (r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintJobRedirectRequest) InlineObject1026(inlineObject1026 InlineObject1026) ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintJobRedirectRequest {
	r.inlineObject1026 = &inlineObject1026
	return r
}

func (r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintJobRedirectRequest) Execute() (AnyOfmicrosoftGraphPrintJob, *_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintJobRedirectExecute(r)
}

/*
UsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintJobRedirect Invoke action redirect

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param trendingId key: id of trending
 @return ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintJobRedirectRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintJobRedirect(ctx _context.Context, userId string, trendingId string) ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintJobRedirectRequest {
	return ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintJobRedirectRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		trendingId: trendingId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphPrintJob
func (a *UsersActionsApiService) UsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintJobRedirectExecute(r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintJobRedirectRequest) (AnyOfmicrosoftGraphPrintJob, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphPrintJob
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintJobRedirect")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/trending/{trending-id}/resource/microsoft.graph.printJob/microsoft.graph.redirect"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1026 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1026 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1026
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintJobStartRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	trendingId string
}


func (r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintJobStartRequest) Execute() (AnyOfmicrosoftGraphPrintJobStatus, *_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintJobStartExecute(r)
}

/*
UsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintJobStart Invoke action start

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param trendingId key: id of trending
 @return ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintJobStartRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintJobStart(ctx _context.Context, userId string, trendingId string) ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintJobStartRequest {
	return ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintJobStartRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		trendingId: trendingId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphPrintJobStatus
func (a *UsersActionsApiService) UsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintJobStartExecute(r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintJobStartRequest) (AnyOfmicrosoftGraphPrintJobStatus, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphPrintJobStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsTrendingTrendingResourceMicrosoftGraphPrintJobStart")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/trending/{trending-id}/resource/microsoft.graph.printJob/microsoft.graph.start"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestApproveRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	trendingId string
	inlineObject1027 *InlineObject1027
}

func (r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestApproveRequest) InlineObject1027(inlineObject1027 InlineObject1027) ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestApproveRequest {
	r.inlineObject1027 = &inlineObject1027
	return r
}

func (r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestApproveRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestApproveExecute(r)
}

/*
UsersUserInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestApprove Invoke action approve

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param trendingId key: id of trending
 @return ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestApproveRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestApprove(ctx _context.Context, userId string, trendingId string) ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestApproveRequest {
	return ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestApproveRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		trendingId: trendingId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestApproveExecute(r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestApproveRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestApprove")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/trending/{trending-id}/resource/microsoft.graph.scheduleChangeRequest/microsoft.graph.approve"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1027 == nil {
		return nil, reportError("inlineObject1027 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1027
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestDeclineRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	trendingId string
	inlineObject1028 *InlineObject1028
}

func (r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestDeclineRequest) InlineObject1028(inlineObject1028 InlineObject1028) ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestDeclineRequest {
	r.inlineObject1028 = &inlineObject1028
	return r
}

func (r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestDeclineExecute(r)
}

/*
UsersUserInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param trendingId key: id of trending
 @return ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestDeclineRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestDecline(ctx _context.Context, userId string, trendingId string) ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestDeclineRequest {
	return ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestDeclineRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		trendingId: trendingId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestDeclineExecute(r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/trending/{trending-id}/resource/microsoft.graph.scheduleChangeRequest/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1028 == nil {
		return nil, reportError("inlineObject1028 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1028
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionAssignRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	trendingId string
	inlineObject1029 *InlineObject1029
}

func (r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionAssignRequest) InlineObject1029(inlineObject1029 InlineObject1029) ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionAssignRequest {
	r.inlineObject1029 = &inlineObject1029
	return r
}

func (r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionAssignRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionAssignExecute(r)
}

/*
UsersUserInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionAssign Invoke action assign

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param trendingId key: id of trending
 @return ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionAssignRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionAssign(ctx _context.Context, userId string, trendingId string) ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionAssignRequest {
	return ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionAssignRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		trendingId: trendingId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionAssignExecute(r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionAssignRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionAssign")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/trending/{trending-id}/resource/microsoft.graph.targetedManagedAppProtection/microsoft.graph.assign"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1029 == nil {
		return nil, reportError("inlineObject1029 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1029
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	trendingId string
	inlineObject1030 *InlineObject1030
}

func (r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest) InlineObject1030(inlineObject1030 InlineObject1030) ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest {
	r.inlineObject1030 = &inlineObject1030
	return r
}

func (r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsExecute(r)
}

/*
UsersUserInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionTargetApps Invoke action targetApps

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param trendingId key: id of trending
 @return ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionTargetApps(ctx _context.Context, userId string, trendingId string) ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest {
	return ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		trendingId: trendingId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsExecute(r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionTargetApps")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/trending/{trending-id}/resource/microsoft.graph.targetedManagedAppProtection/microsoft.graph.targetApps"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1030 == nil {
		return nil, reportError("inlineObject1030 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1030
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWindowsInformationProtectionAssignRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	trendingId string
	inlineObject1031 *InlineObject1031
}

func (r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWindowsInformationProtectionAssignRequest) InlineObject1031(inlineObject1031 InlineObject1031) ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWindowsInformationProtectionAssignRequest {
	r.inlineObject1031 = &inlineObject1031
	return r
}

func (r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWindowsInformationProtectionAssignRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsTrendingTrendingResourceMicrosoftGraphWindowsInformationProtectionAssignExecute(r)
}

/*
UsersUserInsightsTrendingTrendingResourceMicrosoftGraphWindowsInformationProtectionAssign Invoke action assign

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param trendingId key: id of trending
 @return ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWindowsInformationProtectionAssignRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsTrendingTrendingResourceMicrosoftGraphWindowsInformationProtectionAssign(ctx _context.Context, userId string, trendingId string) ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWindowsInformationProtectionAssignRequest {
	return ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWindowsInformationProtectionAssignRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		trendingId: trendingId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsTrendingTrendingResourceMicrosoftGraphWindowsInformationProtectionAssignExecute(r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWindowsInformationProtectionAssignRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsTrendingTrendingResourceMicrosoftGraphWindowsInformationProtectionAssign")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/trending/{trending-id}/resource/microsoft.graph.windowsInformationProtection/microsoft.graph.assign"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1031 == nil {
		return nil, reportError("inlineObject1031 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1031
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeClearRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	trendingId string
	inlineObject1032 *InlineObject1032
}

func (r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeClearRequest) InlineObject1032(inlineObject1032 InlineObject1032) ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeClearRequest {
	r.inlineObject1032 = &inlineObject1032
	return r
}

func (r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeClearRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeClearExecute(r)
}

/*
UsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeClear Invoke action clear

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param trendingId key: id of trending
 @return ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeClearRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeClear(ctx _context.Context, userId string, trendingId string) ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeClearRequest {
	return ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeClearRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		trendingId: trendingId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeClearExecute(r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeClearRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeClear")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/trending/{trending-id}/resource/microsoft.graph.workbookRange/microsoft.graph.clear"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1032 == nil {
		return nil, reportError("inlineObject1032 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1032
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeDeleteRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	trendingId string
	inlineObject1033 *InlineObject1033
}

func (r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeDeleteRequest) InlineObject1033(inlineObject1033 InlineObject1033) ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeDeleteRequest {
	r.inlineObject1033 = &inlineObject1033
	return r
}

func (r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeDeleteExecute(r)
}

/*
UsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeDelete Invoke action delete

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param trendingId key: id of trending
 @return ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeDeleteRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeDelete(ctx _context.Context, userId string, trendingId string) ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeDeleteRequest {
	return ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeDeleteRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		trendingId: trendingId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeDeleteExecute(r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/trending/{trending-id}/resource/microsoft.graph.workbookRange/microsoft.graph.delete"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1033 == nil {
		return nil, reportError("inlineObject1033 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1033
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFillClearRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	trendingId string
}


func (r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFillClearRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFillClearExecute(r)
}

/*
UsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFillClear Invoke action clear

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param trendingId key: id of trending
 @return ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFillClearRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFillClear(ctx _context.Context, userId string, trendingId string) ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFillClearRequest {
	return ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFillClearRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		trendingId: trendingId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFillClearExecute(r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFillClearRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFillClear")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/trending/{trending-id}/resource/microsoft.graph.workbookRangeFill/microsoft.graph.clear"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFormatAutofitColumnsRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	trendingId string
}


func (r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFormatAutofitColumnsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFormatAutofitColumnsExecute(r)
}

/*
UsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFormatAutofitColumns Invoke action autofitColumns

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param trendingId key: id of trending
 @return ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFormatAutofitColumnsRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFormatAutofitColumns(ctx _context.Context, userId string, trendingId string) ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFormatAutofitColumnsRequest {
	return ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFormatAutofitColumnsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		trendingId: trendingId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFormatAutofitColumnsExecute(r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFormatAutofitColumnsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFormatAutofitColumns")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/trending/{trending-id}/resource/microsoft.graph.workbookRangeFormat/microsoft.graph.autofitColumns"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFormatAutofitRowsRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	trendingId string
}


func (r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFormatAutofitRowsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFormatAutofitRowsExecute(r)
}

/*
UsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFormatAutofitRows Invoke action autofitRows

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param trendingId key: id of trending
 @return ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFormatAutofitRowsRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFormatAutofitRows(ctx _context.Context, userId string, trendingId string) ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFormatAutofitRowsRequest {
	return ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFormatAutofitRowsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		trendingId: trendingId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFormatAutofitRowsExecute(r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFormatAutofitRowsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFormatAutofitRows")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/trending/{trending-id}/resource/microsoft.graph.workbookRangeFormat/microsoft.graph.autofitRows"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeInsertRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	trendingId string
	inlineObject1034 *InlineObject1034
}

func (r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeInsertRequest) InlineObject1034(inlineObject1034 InlineObject1034) ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeInsertRequest {
	r.inlineObject1034 = &inlineObject1034
	return r
}

func (r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeInsertRequest) Execute() (AnyOfmicrosoftGraphWorkbookRange, *_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeInsertExecute(r)
}

/*
UsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeInsert Invoke action insert

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param trendingId key: id of trending
 @return ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeInsertRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeInsert(ctx _context.Context, userId string, trendingId string) ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeInsertRequest {
	return ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeInsertRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		trendingId: trendingId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphWorkbookRange
func (a *UsersActionsApiService) UsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeInsertExecute(r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeInsertRequest) (AnyOfmicrosoftGraphWorkbookRange, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphWorkbookRange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeInsert")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/trending/{trending-id}/resource/microsoft.graph.workbookRange/microsoft.graph.insert"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1034 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1034 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1034
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeMergeRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	trendingId string
	inlineObject1035 *InlineObject1035
}

func (r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeMergeRequest) InlineObject1035(inlineObject1035 InlineObject1035) ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeMergeRequest {
	r.inlineObject1035 = &inlineObject1035
	return r
}

func (r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeMergeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeMergeExecute(r)
}

/*
UsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeMerge Invoke action merge

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param trendingId key: id of trending
 @return ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeMergeRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeMerge(ctx _context.Context, userId string, trendingId string) ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeMergeRequest {
	return ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeMergeRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		trendingId: trendingId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeMergeExecute(r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeMergeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeMerge")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/trending/{trending-id}/resource/microsoft.graph.workbookRange/microsoft.graph.merge"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1035 == nil {
		return nil, reportError("inlineObject1035 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1035
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeSortApplyRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	trendingId string
	inlineObject1036 *InlineObject1036
}

func (r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeSortApplyRequest) InlineObject1036(inlineObject1036 InlineObject1036) ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeSortApplyRequest {
	r.inlineObject1036 = &inlineObject1036
	return r
}

func (r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeSortApplyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeSortApplyExecute(r)
}

/*
UsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeSortApply Invoke action apply

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param trendingId key: id of trending
 @return ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeSortApplyRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeSortApply(ctx _context.Context, userId string, trendingId string) ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeSortApplyRequest {
	return ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeSortApplyRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		trendingId: trendingId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeSortApplyExecute(r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeSortApplyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeSortApply")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/trending/{trending-id}/resource/microsoft.graph.workbookRangeSort/microsoft.graph.apply"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1036 == nil {
		return nil, reportError("inlineObject1036 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1036
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeUnmergeRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	trendingId string
}


func (r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeUnmergeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeUnmergeExecute(r)
}

/*
UsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeUnmerge Invoke action unmerge

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param trendingId key: id of trending
 @return ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeUnmergeRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeUnmerge(ctx _context.Context, userId string, trendingId string) ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeUnmergeRequest {
	return ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeUnmergeRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		trendingId: trendingId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeUnmergeExecute(r ApiUsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeUnmergeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeUnmerge")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/trending/{trending-id}/resource/microsoft.graph.workbookRange/microsoft.graph.unmerge"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphCalendarSharingMessageAcceptRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	usedInsightId string
}


func (r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphCalendarSharingMessageAcceptRequest) Execute() (MicrosoftGraphCalendar, *_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphCalendarSharingMessageAcceptExecute(r)
}

/*
UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphCalendarSharingMessageAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param usedInsightId key: id of usedInsight
 @return ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphCalendarSharingMessageAcceptRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphCalendarSharingMessageAccept(ctx _context.Context, userId string, usedInsightId string) ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphCalendarSharingMessageAcceptRequest {
	return ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphCalendarSharingMessageAcceptRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphCalendar
func (a *UsersActionsApiService) UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphCalendarSharingMessageAcceptExecute(r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphCalendarSharingMessageAcceptRequest) (MicrosoftGraphCalendar, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphCalendar
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphCalendarSharingMessageAccept")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/used/{usedInsight-id}/resource/microsoft.graph.calendarSharingMessage/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphManagedAppProtectionTargetAppsRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	usedInsightId string
	inlineObject1037 *InlineObject1037
}

func (r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphManagedAppProtectionTargetAppsRequest) InlineObject1037(inlineObject1037 InlineObject1037) ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphManagedAppProtectionTargetAppsRequest {
	r.inlineObject1037 = &inlineObject1037
	return r
}

func (r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphManagedAppProtectionTargetAppsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphManagedAppProtectionTargetAppsExecute(r)
}

/*
UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphManagedAppProtectionTargetApps Invoke action targetApps

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param usedInsightId key: id of usedInsight
 @return ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphManagedAppProtectionTargetAppsRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphManagedAppProtectionTargetApps(ctx _context.Context, userId string, usedInsightId string) ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphManagedAppProtectionTargetAppsRequest {
	return ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphManagedAppProtectionTargetAppsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphManagedAppProtectionTargetAppsExecute(r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphManagedAppProtectionTargetAppsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphManagedAppProtectionTargetApps")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/used/{usedInsight-id}/resource/microsoft.graph.managedAppProtection/microsoft.graph.targetApps"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1037 == nil {
		return nil, reportError("inlineObject1037 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1037
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphMobileAppContentFileCommitRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	usedInsightId string
	inlineObject1038 *InlineObject1038
}

func (r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphMobileAppContentFileCommitRequest) InlineObject1038(inlineObject1038 InlineObject1038) ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphMobileAppContentFileCommitRequest {
	r.inlineObject1038 = &inlineObject1038
	return r
}

func (r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphMobileAppContentFileCommitRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphMobileAppContentFileCommitExecute(r)
}

/*
UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphMobileAppContentFileCommit Invoke action commit

Commits a file of a given app.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param usedInsightId key: id of usedInsight
 @return ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphMobileAppContentFileCommitRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphMobileAppContentFileCommit(ctx _context.Context, userId string, usedInsightId string) ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphMobileAppContentFileCommitRequest {
	return ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphMobileAppContentFileCommitRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphMobileAppContentFileCommitExecute(r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphMobileAppContentFileCommitRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphMobileAppContentFileCommit")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/used/{usedInsight-id}/resource/microsoft.graph.mobileAppContentFile/microsoft.graph.commit"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1038 == nil {
		return nil, reportError("inlineObject1038 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1038
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphMobileAppContentFileRenewUploadRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	usedInsightId string
}


func (r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphMobileAppContentFileRenewUploadRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphMobileAppContentFileRenewUploadExecute(r)
}

/*
UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphMobileAppContentFileRenewUpload Invoke action renewUpload

Renews the SAS URI for an application file upload.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param usedInsightId key: id of usedInsight
 @return ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphMobileAppContentFileRenewUploadRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphMobileAppContentFileRenewUpload(ctx _context.Context, userId string, usedInsightId string) ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphMobileAppContentFileRenewUploadRequest {
	return ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphMobileAppContentFileRenewUploadRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphMobileAppContentFileRenewUploadExecute(r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphMobileAppContentFileRenewUploadRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphMobileAppContentFileRenewUpload")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/used/{usedInsight-id}/resource/microsoft.graph.mobileAppContentFile/microsoft.graph.renewUpload"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSessionRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	usedInsightId string
	inlineObject1039 *InlineObject1039
}

func (r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSessionRequest) InlineObject1039(inlineObject1039 InlineObject1039) ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSessionRequest {
	r.inlineObject1039 = &inlineObject1039
	return r
}

func (r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSessionRequest) Execute() (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSessionExecute(r)
}

/*
UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSession Invoke action createUploadSession

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param usedInsightId key: id of usedInsight
 @return ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSessionRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSession(ctx _context.Context, userId string, usedInsightId string) ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSessionRequest {
	return ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSessionRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphUploadSession
func (a *UsersActionsApiService) UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSessionExecute(r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSessionRequest) (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphUploadSession
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSession")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/used/{usedInsight-id}/resource/microsoft.graph.printDocument/microsoft.graph.createUploadSession"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1039 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1039 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1039
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobAbortRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	usedInsightId string
	inlineObject1040 *InlineObject1040
}

func (r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobAbortRequest) InlineObject1040(inlineObject1040 InlineObject1040) ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobAbortRequest {
	r.inlineObject1040 = &inlineObject1040
	return r
}

func (r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobAbortRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobAbortExecute(r)
}

/*
UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobAbort Invoke action abort

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param usedInsightId key: id of usedInsight
 @return ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobAbortRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobAbort(ctx _context.Context, userId string, usedInsightId string) ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobAbortRequest {
	return ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobAbortRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobAbortExecute(r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobAbortRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobAbort")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/used/{usedInsight-id}/resource/microsoft.graph.printJob/microsoft.graph.abort"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1040 == nil {
		return nil, reportError("inlineObject1040 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1040
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobCancelRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	usedInsightId string
}


func (r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobCancelExecute(r)
}

/*
UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param usedInsightId key: id of usedInsight
 @return ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobCancelRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobCancel(ctx _context.Context, userId string, usedInsightId string) ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobCancelRequest {
	return ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobCancelRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobCancelExecute(r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/used/{usedInsight-id}/resource/microsoft.graph.printJob/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobRedirectRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	usedInsightId string
	inlineObject1041 *InlineObject1041
}

func (r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobRedirectRequest) InlineObject1041(inlineObject1041 InlineObject1041) ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobRedirectRequest {
	r.inlineObject1041 = &inlineObject1041
	return r
}

func (r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobRedirectRequest) Execute() (AnyOfmicrosoftGraphPrintJob, *_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobRedirectExecute(r)
}

/*
UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobRedirect Invoke action redirect

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param usedInsightId key: id of usedInsight
 @return ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobRedirectRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobRedirect(ctx _context.Context, userId string, usedInsightId string) ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobRedirectRequest {
	return ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobRedirectRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphPrintJob
func (a *UsersActionsApiService) UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobRedirectExecute(r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobRedirectRequest) (AnyOfmicrosoftGraphPrintJob, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphPrintJob
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobRedirect")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/used/{usedInsight-id}/resource/microsoft.graph.printJob/microsoft.graph.redirect"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1041 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1041 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1041
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobStartRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	usedInsightId string
}


func (r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobStartRequest) Execute() (AnyOfmicrosoftGraphPrintJobStatus, *_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobStartExecute(r)
}

/*
UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobStart Invoke action start

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param usedInsightId key: id of usedInsight
 @return ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobStartRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobStart(ctx _context.Context, userId string, usedInsightId string) ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobStartRequest {
	return ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobStartRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphPrintJobStatus
func (a *UsersActionsApiService) UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobStartExecute(r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobStartRequest) (AnyOfmicrosoftGraphPrintJobStatus, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphPrintJobStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobStart")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/used/{usedInsight-id}/resource/microsoft.graph.printJob/microsoft.graph.start"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestApproveRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	usedInsightId string
	inlineObject1042 *InlineObject1042
}

func (r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestApproveRequest) InlineObject1042(inlineObject1042 InlineObject1042) ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestApproveRequest {
	r.inlineObject1042 = &inlineObject1042
	return r
}

func (r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestApproveRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestApproveExecute(r)
}

/*
UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestApprove Invoke action approve

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param usedInsightId key: id of usedInsight
 @return ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestApproveRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestApprove(ctx _context.Context, userId string, usedInsightId string) ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestApproveRequest {
	return ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestApproveRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestApproveExecute(r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestApproveRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestApprove")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/used/{usedInsight-id}/resource/microsoft.graph.scheduleChangeRequest/microsoft.graph.approve"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1042 == nil {
		return nil, reportError("inlineObject1042 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1042
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestDeclineRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	usedInsightId string
	inlineObject1043 *InlineObject1043
}

func (r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestDeclineRequest) InlineObject1043(inlineObject1043 InlineObject1043) ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestDeclineRequest {
	r.inlineObject1043 = &inlineObject1043
	return r
}

func (r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestDeclineExecute(r)
}

/*
UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param usedInsightId key: id of usedInsight
 @return ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestDeclineRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestDecline(ctx _context.Context, userId string, usedInsightId string) ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestDeclineRequest {
	return ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestDeclineRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestDeclineExecute(r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/used/{usedInsight-id}/resource/microsoft.graph.scheduleChangeRequest/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1043 == nil {
		return nil, reportError("inlineObject1043 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1043
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssignRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	usedInsightId string
	inlineObject1044 *InlineObject1044
}

func (r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssignRequest) InlineObject1044(inlineObject1044 InlineObject1044) ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssignRequest {
	r.inlineObject1044 = &inlineObject1044
	return r
}

func (r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssignRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssignExecute(r)
}

/*
UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssign Invoke action assign

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param usedInsightId key: id of usedInsight
 @return ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssignRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssign(ctx _context.Context, userId string, usedInsightId string) ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssignRequest {
	return ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssignRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssignExecute(r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssignRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssign")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/used/{usedInsight-id}/resource/microsoft.graph.targetedManagedAppProtection/microsoft.graph.assign"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1044 == nil {
		return nil, reportError("inlineObject1044 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1044
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	usedInsightId string
	inlineObject1045 *InlineObject1045
}

func (r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest) InlineObject1045(inlineObject1045 InlineObject1045) ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest {
	r.inlineObject1045 = &inlineObject1045
	return r
}

func (r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsExecute(r)
}

/*
UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetApps Invoke action targetApps

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param usedInsightId key: id of usedInsight
 @return ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetApps(ctx _context.Context, userId string, usedInsightId string) ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest {
	return ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsExecute(r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetApps")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/used/{usedInsight-id}/resource/microsoft.graph.targetedManagedAppProtection/microsoft.graph.targetApps"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1045 == nil {
		return nil, reportError("inlineObject1045 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1045
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWindowsInformationProtectionAssignRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	usedInsightId string
	inlineObject1046 *InlineObject1046
}

func (r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWindowsInformationProtectionAssignRequest) InlineObject1046(inlineObject1046 InlineObject1046) ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWindowsInformationProtectionAssignRequest {
	r.inlineObject1046 = &inlineObject1046
	return r
}

func (r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWindowsInformationProtectionAssignRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWindowsInformationProtectionAssignExecute(r)
}

/*
UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWindowsInformationProtectionAssign Invoke action assign

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param usedInsightId key: id of usedInsight
 @return ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWindowsInformationProtectionAssignRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWindowsInformationProtectionAssign(ctx _context.Context, userId string, usedInsightId string) ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWindowsInformationProtectionAssignRequest {
	return ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWindowsInformationProtectionAssignRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWindowsInformationProtectionAssignExecute(r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWindowsInformationProtectionAssignRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWindowsInformationProtectionAssign")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/used/{usedInsight-id}/resource/microsoft.graph.windowsInformationProtection/microsoft.graph.assign"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1046 == nil {
		return nil, reportError("inlineObject1046 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1046
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeClearRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	usedInsightId string
	inlineObject1047 *InlineObject1047
}

func (r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeClearRequest) InlineObject1047(inlineObject1047 InlineObject1047) ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeClearRequest {
	r.inlineObject1047 = &inlineObject1047
	return r
}

func (r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeClearRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeClearExecute(r)
}

/*
UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeClear Invoke action clear

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param usedInsightId key: id of usedInsight
 @return ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeClearRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeClear(ctx _context.Context, userId string, usedInsightId string) ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeClearRequest {
	return ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeClearRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeClearExecute(r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeClearRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeClear")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/used/{usedInsight-id}/resource/microsoft.graph.workbookRange/microsoft.graph.clear"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1047 == nil {
		return nil, reportError("inlineObject1047 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1047
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeDeleteRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	usedInsightId string
	inlineObject1048 *InlineObject1048
}

func (r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeDeleteRequest) InlineObject1048(inlineObject1048 InlineObject1048) ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeDeleteRequest {
	r.inlineObject1048 = &inlineObject1048
	return r
}

func (r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeDeleteExecute(r)
}

/*
UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeDelete Invoke action delete

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param usedInsightId key: id of usedInsight
 @return ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeDeleteRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeDelete(ctx _context.Context, userId string, usedInsightId string) ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeDeleteRequest {
	return ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeDeleteRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeDeleteExecute(r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/used/{usedInsight-id}/resource/microsoft.graph.workbookRange/microsoft.graph.delete"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1048 == nil {
		return nil, reportError("inlineObject1048 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1048
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFillClearRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	usedInsightId string
}


func (r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFillClearRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFillClearExecute(r)
}

/*
UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFillClear Invoke action clear

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param usedInsightId key: id of usedInsight
 @return ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFillClearRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFillClear(ctx _context.Context, userId string, usedInsightId string) ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFillClearRequest {
	return ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFillClearRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFillClearExecute(r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFillClearRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFillClear")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/used/{usedInsight-id}/resource/microsoft.graph.workbookRangeFill/microsoft.graph.clear"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitColumnsRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	usedInsightId string
}


func (r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitColumnsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitColumnsExecute(r)
}

/*
UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitColumns Invoke action autofitColumns

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param usedInsightId key: id of usedInsight
 @return ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitColumnsRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitColumns(ctx _context.Context, userId string, usedInsightId string) ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitColumnsRequest {
	return ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitColumnsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitColumnsExecute(r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitColumnsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitColumns")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/used/{usedInsight-id}/resource/microsoft.graph.workbookRangeFormat/microsoft.graph.autofitColumns"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitRowsRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	usedInsightId string
}


func (r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitRowsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitRowsExecute(r)
}

/*
UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitRows Invoke action autofitRows

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param usedInsightId key: id of usedInsight
 @return ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitRowsRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitRows(ctx _context.Context, userId string, usedInsightId string) ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitRowsRequest {
	return ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitRowsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitRowsExecute(r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitRowsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitRows")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/used/{usedInsight-id}/resource/microsoft.graph.workbookRangeFormat/microsoft.graph.autofitRows"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeInsertRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	usedInsightId string
	inlineObject1049 *InlineObject1049
}

func (r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeInsertRequest) InlineObject1049(inlineObject1049 InlineObject1049) ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeInsertRequest {
	r.inlineObject1049 = &inlineObject1049
	return r
}

func (r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeInsertRequest) Execute() (AnyOfmicrosoftGraphWorkbookRange, *_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeInsertExecute(r)
}

/*
UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeInsert Invoke action insert

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param usedInsightId key: id of usedInsight
 @return ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeInsertRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeInsert(ctx _context.Context, userId string, usedInsightId string) ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeInsertRequest {
	return ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeInsertRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphWorkbookRange
func (a *UsersActionsApiService) UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeInsertExecute(r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeInsertRequest) (AnyOfmicrosoftGraphWorkbookRange, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphWorkbookRange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeInsert")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/used/{usedInsight-id}/resource/microsoft.graph.workbookRange/microsoft.graph.insert"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1049 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1049 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1049
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeMergeRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	usedInsightId string
	inlineObject1050 *InlineObject1050
}

func (r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeMergeRequest) InlineObject1050(inlineObject1050 InlineObject1050) ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeMergeRequest {
	r.inlineObject1050 = &inlineObject1050
	return r
}

func (r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeMergeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeMergeExecute(r)
}

/*
UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeMerge Invoke action merge

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param usedInsightId key: id of usedInsight
 @return ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeMergeRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeMerge(ctx _context.Context, userId string, usedInsightId string) ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeMergeRequest {
	return ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeMergeRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeMergeExecute(r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeMergeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeMerge")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/used/{usedInsight-id}/resource/microsoft.graph.workbookRange/microsoft.graph.merge"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1050 == nil {
		return nil, reportError("inlineObject1050 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1050
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeSortApplyRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	usedInsightId string
	inlineObject1051 *InlineObject1051
}

func (r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeSortApplyRequest) InlineObject1051(inlineObject1051 InlineObject1051) ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeSortApplyRequest {
	r.inlineObject1051 = &inlineObject1051
	return r
}

func (r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeSortApplyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeSortApplyExecute(r)
}

/*
UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeSortApply Invoke action apply

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param usedInsightId key: id of usedInsight
 @return ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeSortApplyRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeSortApply(ctx _context.Context, userId string, usedInsightId string) ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeSortApplyRequest {
	return ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeSortApplyRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeSortApplyExecute(r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeSortApplyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeSortApply")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/used/{usedInsight-id}/resource/microsoft.graph.workbookRangeSort/microsoft.graph.apply"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1051 == nil {
		return nil, reportError("inlineObject1051 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1051
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeUnmergeRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	usedInsightId string
}


func (r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeUnmergeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeUnmergeExecute(r)
}

/*
UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeUnmerge Invoke action unmerge

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param usedInsightId key: id of usedInsight
 @return ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeUnmergeRequest
*/
func (a *UsersActionsApiService) UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeUnmerge(ctx _context.Context, userId string, usedInsightId string) ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeUnmergeRequest {
	return ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeUnmergeRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeUnmergeExecute(r ApiUsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeUnmergeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeUnmerge")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/used/{usedInsight-id}/resource/microsoft.graph.workbookRange/microsoft.graph.unmerge"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserMailFoldersMailFolderChildFoldersMailFolderCopyRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	mailFolderId string
	mailFolderId1 string
	inlineObject1052 *InlineObject1052
}

func (r ApiUsersUserMailFoldersMailFolderChildFoldersMailFolderCopyRequest) InlineObject1052(inlineObject1052 InlineObject1052) ApiUsersUserMailFoldersMailFolderChildFoldersMailFolderCopyRequest {
	r.inlineObject1052 = &inlineObject1052
	return r
}

func (r ApiUsersUserMailFoldersMailFolderChildFoldersMailFolderCopyRequest) Execute() (AnyOfmicrosoftGraphMailFolder, *_nethttp.Response, error) {
	return r.ApiService.UsersUserMailFoldersMailFolderChildFoldersMailFolderCopyExecute(r)
}

/*
UsersUserMailFoldersMailFolderChildFoldersMailFolderCopy Invoke action copy

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param mailFolderId key: id of mailFolder
 @param mailFolderId1 key: id of mailFolder
 @return ApiUsersUserMailFoldersMailFolderChildFoldersMailFolderCopyRequest
*/
func (a *UsersActionsApiService) UsersUserMailFoldersMailFolderChildFoldersMailFolderCopy(ctx _context.Context, userId string, mailFolderId string, mailFolderId1 string) ApiUsersUserMailFoldersMailFolderChildFoldersMailFolderCopyRequest {
	return ApiUsersUserMailFoldersMailFolderChildFoldersMailFolderCopyRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		mailFolderId: mailFolderId,
		mailFolderId1: mailFolderId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphMailFolder
func (a *UsersActionsApiService) UsersUserMailFoldersMailFolderChildFoldersMailFolderCopyExecute(r ApiUsersUserMailFoldersMailFolderChildFoldersMailFolderCopyRequest) (AnyOfmicrosoftGraphMailFolder, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphMailFolder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserMailFoldersMailFolderChildFoldersMailFolderCopy")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/mailFolders/{mailFolder-id}/childFolders/{mailFolder-id1}/microsoft.graph.copy"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mailFolder-id"+"}", _neturl.PathEscape(parameterToString(r.mailFolderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mailFolder-id1"+"}", _neturl.PathEscape(parameterToString(r.mailFolderId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1052 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1052 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1052
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserMailFoldersMailFolderChildFoldersMailFolderMoveRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	mailFolderId string
	mailFolderId1 string
	inlineObject1053 *InlineObject1053
}

func (r ApiUsersUserMailFoldersMailFolderChildFoldersMailFolderMoveRequest) InlineObject1053(inlineObject1053 InlineObject1053) ApiUsersUserMailFoldersMailFolderChildFoldersMailFolderMoveRequest {
	r.inlineObject1053 = &inlineObject1053
	return r
}

func (r ApiUsersUserMailFoldersMailFolderChildFoldersMailFolderMoveRequest) Execute() (AnyOfmicrosoftGraphMailFolder, *_nethttp.Response, error) {
	return r.ApiService.UsersUserMailFoldersMailFolderChildFoldersMailFolderMoveExecute(r)
}

/*
UsersUserMailFoldersMailFolderChildFoldersMailFolderMove Invoke action move

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param mailFolderId key: id of mailFolder
 @param mailFolderId1 key: id of mailFolder
 @return ApiUsersUserMailFoldersMailFolderChildFoldersMailFolderMoveRequest
*/
func (a *UsersActionsApiService) UsersUserMailFoldersMailFolderChildFoldersMailFolderMove(ctx _context.Context, userId string, mailFolderId string, mailFolderId1 string) ApiUsersUserMailFoldersMailFolderChildFoldersMailFolderMoveRequest {
	return ApiUsersUserMailFoldersMailFolderChildFoldersMailFolderMoveRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		mailFolderId: mailFolderId,
		mailFolderId1: mailFolderId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphMailFolder
func (a *UsersActionsApiService) UsersUserMailFoldersMailFolderChildFoldersMailFolderMoveExecute(r ApiUsersUserMailFoldersMailFolderChildFoldersMailFolderMoveRequest) (AnyOfmicrosoftGraphMailFolder, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphMailFolder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserMailFoldersMailFolderChildFoldersMailFolderMove")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/mailFolders/{mailFolder-id}/childFolders/{mailFolder-id1}/microsoft.graph.move"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mailFolder-id"+"}", _neturl.PathEscape(parameterToString(r.mailFolderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mailFolder-id1"+"}", _neturl.PathEscape(parameterToString(r.mailFolderId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1053 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1053 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1053
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserMailFoldersMailFolderCopyRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	mailFolderId string
	inlineObject1063 *InlineObject1063
}

func (r ApiUsersUserMailFoldersMailFolderCopyRequest) InlineObject1063(inlineObject1063 InlineObject1063) ApiUsersUserMailFoldersMailFolderCopyRequest {
	r.inlineObject1063 = &inlineObject1063
	return r
}

func (r ApiUsersUserMailFoldersMailFolderCopyRequest) Execute() (AnyOfmicrosoftGraphMailFolder, *_nethttp.Response, error) {
	return r.ApiService.UsersUserMailFoldersMailFolderCopyExecute(r)
}

/*
UsersUserMailFoldersMailFolderCopy Invoke action copy

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param mailFolderId key: id of mailFolder
 @return ApiUsersUserMailFoldersMailFolderCopyRequest
*/
func (a *UsersActionsApiService) UsersUserMailFoldersMailFolderCopy(ctx _context.Context, userId string, mailFolderId string) ApiUsersUserMailFoldersMailFolderCopyRequest {
	return ApiUsersUserMailFoldersMailFolderCopyRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		mailFolderId: mailFolderId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphMailFolder
func (a *UsersActionsApiService) UsersUserMailFoldersMailFolderCopyExecute(r ApiUsersUserMailFoldersMailFolderCopyRequest) (AnyOfmicrosoftGraphMailFolder, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphMailFolder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserMailFoldersMailFolderCopy")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/mailFolders/{mailFolder-id}/microsoft.graph.copy"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mailFolder-id"+"}", _neturl.PathEscape(parameterToString(r.mailFolderId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1063 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1063 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1063
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserMailFoldersMailFolderMessagesMessageAttachmentsCreateUploadSessionRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	mailFolderId string
	messageId string
	inlineObject1054 *InlineObject1054
}

func (r ApiUsersUserMailFoldersMailFolderMessagesMessageAttachmentsCreateUploadSessionRequest) InlineObject1054(inlineObject1054 InlineObject1054) ApiUsersUserMailFoldersMailFolderMessagesMessageAttachmentsCreateUploadSessionRequest {
	r.inlineObject1054 = &inlineObject1054
	return r
}

func (r ApiUsersUserMailFoldersMailFolderMessagesMessageAttachmentsCreateUploadSessionRequest) Execute() (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	return r.ApiService.UsersUserMailFoldersMailFolderMessagesMessageAttachmentsCreateUploadSessionExecute(r)
}

/*
UsersUserMailFoldersMailFolderMessagesMessageAttachmentsCreateUploadSession Invoke action createUploadSession

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param mailFolderId key: id of mailFolder
 @param messageId key: id of message
 @return ApiUsersUserMailFoldersMailFolderMessagesMessageAttachmentsCreateUploadSessionRequest
*/
func (a *UsersActionsApiService) UsersUserMailFoldersMailFolderMessagesMessageAttachmentsCreateUploadSession(ctx _context.Context, userId string, mailFolderId string, messageId string) ApiUsersUserMailFoldersMailFolderMessagesMessageAttachmentsCreateUploadSessionRequest {
	return ApiUsersUserMailFoldersMailFolderMessagesMessageAttachmentsCreateUploadSessionRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		mailFolderId: mailFolderId,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphUploadSession
func (a *UsersActionsApiService) UsersUserMailFoldersMailFolderMessagesMessageAttachmentsCreateUploadSessionExecute(r ApiUsersUserMailFoldersMailFolderMessagesMessageAttachmentsCreateUploadSessionRequest) (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphUploadSession
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserMailFoldersMailFolderMessagesMessageAttachmentsCreateUploadSession")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/mailFolders/{mailFolder-id}/messages/{message-id}/attachments/microsoft.graph.createUploadSession"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mailFolder-id"+"}", _neturl.PathEscape(parameterToString(r.mailFolderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1054 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1054 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1054
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserMailFoldersMailFolderMessagesMessageCopyRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	mailFolderId string
	messageId string
	inlineObject1055 *InlineObject1055
}

func (r ApiUsersUserMailFoldersMailFolderMessagesMessageCopyRequest) InlineObject1055(inlineObject1055 InlineObject1055) ApiUsersUserMailFoldersMailFolderMessagesMessageCopyRequest {
	r.inlineObject1055 = &inlineObject1055
	return r
}

func (r ApiUsersUserMailFoldersMailFolderMessagesMessageCopyRequest) Execute() (AnyOfmicrosoftGraphMessage, *_nethttp.Response, error) {
	return r.ApiService.UsersUserMailFoldersMailFolderMessagesMessageCopyExecute(r)
}

/*
UsersUserMailFoldersMailFolderMessagesMessageCopy Invoke action copy

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param mailFolderId key: id of mailFolder
 @param messageId key: id of message
 @return ApiUsersUserMailFoldersMailFolderMessagesMessageCopyRequest
*/
func (a *UsersActionsApiService) UsersUserMailFoldersMailFolderMessagesMessageCopy(ctx _context.Context, userId string, mailFolderId string, messageId string) ApiUsersUserMailFoldersMailFolderMessagesMessageCopyRequest {
	return ApiUsersUserMailFoldersMailFolderMessagesMessageCopyRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		mailFolderId: mailFolderId,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphMessage
func (a *UsersActionsApiService) UsersUserMailFoldersMailFolderMessagesMessageCopyExecute(r ApiUsersUserMailFoldersMailFolderMessagesMessageCopyRequest) (AnyOfmicrosoftGraphMessage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserMailFoldersMailFolderMessagesMessageCopy")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/mailFolders/{mailFolder-id}/messages/{message-id}/microsoft.graph.copy"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mailFolder-id"+"}", _neturl.PathEscape(parameterToString(r.mailFolderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1055 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1055 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1055
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserMailFoldersMailFolderMessagesMessageCreateForwardRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	mailFolderId string
	messageId string
	inlineObject1056 *InlineObject1056
}

func (r ApiUsersUserMailFoldersMailFolderMessagesMessageCreateForwardRequest) InlineObject1056(inlineObject1056 InlineObject1056) ApiUsersUserMailFoldersMailFolderMessagesMessageCreateForwardRequest {
	r.inlineObject1056 = &inlineObject1056
	return r
}

func (r ApiUsersUserMailFoldersMailFolderMessagesMessageCreateForwardRequest) Execute() (AnyOfmicrosoftGraphMessage, *_nethttp.Response, error) {
	return r.ApiService.UsersUserMailFoldersMailFolderMessagesMessageCreateForwardExecute(r)
}

/*
UsersUserMailFoldersMailFolderMessagesMessageCreateForward Invoke action createForward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param mailFolderId key: id of mailFolder
 @param messageId key: id of message
 @return ApiUsersUserMailFoldersMailFolderMessagesMessageCreateForwardRequest
*/
func (a *UsersActionsApiService) UsersUserMailFoldersMailFolderMessagesMessageCreateForward(ctx _context.Context, userId string, mailFolderId string, messageId string) ApiUsersUserMailFoldersMailFolderMessagesMessageCreateForwardRequest {
	return ApiUsersUserMailFoldersMailFolderMessagesMessageCreateForwardRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		mailFolderId: mailFolderId,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphMessage
func (a *UsersActionsApiService) UsersUserMailFoldersMailFolderMessagesMessageCreateForwardExecute(r ApiUsersUserMailFoldersMailFolderMessagesMessageCreateForwardRequest) (AnyOfmicrosoftGraphMessage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserMailFoldersMailFolderMessagesMessageCreateForward")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/mailFolders/{mailFolder-id}/messages/{message-id}/microsoft.graph.createForward"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mailFolder-id"+"}", _neturl.PathEscape(parameterToString(r.mailFolderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1056 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1056 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1056
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserMailFoldersMailFolderMessagesMessageCreateReplyRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	mailFolderId string
	messageId string
	inlineObject1057 *InlineObject1057
}

func (r ApiUsersUserMailFoldersMailFolderMessagesMessageCreateReplyRequest) InlineObject1057(inlineObject1057 InlineObject1057) ApiUsersUserMailFoldersMailFolderMessagesMessageCreateReplyRequest {
	r.inlineObject1057 = &inlineObject1057
	return r
}

func (r ApiUsersUserMailFoldersMailFolderMessagesMessageCreateReplyRequest) Execute() (AnyOfmicrosoftGraphMessage, *_nethttp.Response, error) {
	return r.ApiService.UsersUserMailFoldersMailFolderMessagesMessageCreateReplyExecute(r)
}

/*
UsersUserMailFoldersMailFolderMessagesMessageCreateReply Invoke action createReply

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param mailFolderId key: id of mailFolder
 @param messageId key: id of message
 @return ApiUsersUserMailFoldersMailFolderMessagesMessageCreateReplyRequest
*/
func (a *UsersActionsApiService) UsersUserMailFoldersMailFolderMessagesMessageCreateReply(ctx _context.Context, userId string, mailFolderId string, messageId string) ApiUsersUserMailFoldersMailFolderMessagesMessageCreateReplyRequest {
	return ApiUsersUserMailFoldersMailFolderMessagesMessageCreateReplyRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		mailFolderId: mailFolderId,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphMessage
func (a *UsersActionsApiService) UsersUserMailFoldersMailFolderMessagesMessageCreateReplyExecute(r ApiUsersUserMailFoldersMailFolderMessagesMessageCreateReplyRequest) (AnyOfmicrosoftGraphMessage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserMailFoldersMailFolderMessagesMessageCreateReply")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/mailFolders/{mailFolder-id}/messages/{message-id}/microsoft.graph.createReply"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mailFolder-id"+"}", _neturl.PathEscape(parameterToString(r.mailFolderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1057 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1057 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1057
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserMailFoldersMailFolderMessagesMessageCreateReplyAllRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	mailFolderId string
	messageId string
	inlineObject1058 *InlineObject1058
}

func (r ApiUsersUserMailFoldersMailFolderMessagesMessageCreateReplyAllRequest) InlineObject1058(inlineObject1058 InlineObject1058) ApiUsersUserMailFoldersMailFolderMessagesMessageCreateReplyAllRequest {
	r.inlineObject1058 = &inlineObject1058
	return r
}

func (r ApiUsersUserMailFoldersMailFolderMessagesMessageCreateReplyAllRequest) Execute() (AnyOfmicrosoftGraphMessage, *_nethttp.Response, error) {
	return r.ApiService.UsersUserMailFoldersMailFolderMessagesMessageCreateReplyAllExecute(r)
}

/*
UsersUserMailFoldersMailFolderMessagesMessageCreateReplyAll Invoke action createReplyAll

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param mailFolderId key: id of mailFolder
 @param messageId key: id of message
 @return ApiUsersUserMailFoldersMailFolderMessagesMessageCreateReplyAllRequest
*/
func (a *UsersActionsApiService) UsersUserMailFoldersMailFolderMessagesMessageCreateReplyAll(ctx _context.Context, userId string, mailFolderId string, messageId string) ApiUsersUserMailFoldersMailFolderMessagesMessageCreateReplyAllRequest {
	return ApiUsersUserMailFoldersMailFolderMessagesMessageCreateReplyAllRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		mailFolderId: mailFolderId,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphMessage
func (a *UsersActionsApiService) UsersUserMailFoldersMailFolderMessagesMessageCreateReplyAllExecute(r ApiUsersUserMailFoldersMailFolderMessagesMessageCreateReplyAllRequest) (AnyOfmicrosoftGraphMessage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserMailFoldersMailFolderMessagesMessageCreateReplyAll")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/mailFolders/{mailFolder-id}/messages/{message-id}/microsoft.graph.createReplyAll"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mailFolder-id"+"}", _neturl.PathEscape(parameterToString(r.mailFolderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1058 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1058 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1058
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserMailFoldersMailFolderMessagesMessageForwardRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	mailFolderId string
	messageId string
	inlineObject1059 *InlineObject1059
}

func (r ApiUsersUserMailFoldersMailFolderMessagesMessageForwardRequest) InlineObject1059(inlineObject1059 InlineObject1059) ApiUsersUserMailFoldersMailFolderMessagesMessageForwardRequest {
	r.inlineObject1059 = &inlineObject1059
	return r
}

func (r ApiUsersUserMailFoldersMailFolderMessagesMessageForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserMailFoldersMailFolderMessagesMessageForwardExecute(r)
}

/*
UsersUserMailFoldersMailFolderMessagesMessageForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param mailFolderId key: id of mailFolder
 @param messageId key: id of message
 @return ApiUsersUserMailFoldersMailFolderMessagesMessageForwardRequest
*/
func (a *UsersActionsApiService) UsersUserMailFoldersMailFolderMessagesMessageForward(ctx _context.Context, userId string, mailFolderId string, messageId string) ApiUsersUserMailFoldersMailFolderMessagesMessageForwardRequest {
	return ApiUsersUserMailFoldersMailFolderMessagesMessageForwardRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		mailFolderId: mailFolderId,
		messageId: messageId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserMailFoldersMailFolderMessagesMessageForwardExecute(r ApiUsersUserMailFoldersMailFolderMessagesMessageForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserMailFoldersMailFolderMessagesMessageForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/mailFolders/{mailFolder-id}/messages/{message-id}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mailFolder-id"+"}", _neturl.PathEscape(parameterToString(r.mailFolderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1059 == nil {
		return nil, reportError("inlineObject1059 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1059
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserMailFoldersMailFolderMessagesMessageMicrosoftGraphCalendarSharingMessageAcceptRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	mailFolderId string
	messageId string
}


func (r ApiUsersUserMailFoldersMailFolderMessagesMessageMicrosoftGraphCalendarSharingMessageAcceptRequest) Execute() (MicrosoftGraphCalendar, *_nethttp.Response, error) {
	return r.ApiService.UsersUserMailFoldersMailFolderMessagesMessageMicrosoftGraphCalendarSharingMessageAcceptExecute(r)
}

/*
UsersUserMailFoldersMailFolderMessagesMessageMicrosoftGraphCalendarSharingMessageAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param mailFolderId key: id of mailFolder
 @param messageId key: id of message
 @return ApiUsersUserMailFoldersMailFolderMessagesMessageMicrosoftGraphCalendarSharingMessageAcceptRequest
*/
func (a *UsersActionsApiService) UsersUserMailFoldersMailFolderMessagesMessageMicrosoftGraphCalendarSharingMessageAccept(ctx _context.Context, userId string, mailFolderId string, messageId string) ApiUsersUserMailFoldersMailFolderMessagesMessageMicrosoftGraphCalendarSharingMessageAcceptRequest {
	return ApiUsersUserMailFoldersMailFolderMessagesMessageMicrosoftGraphCalendarSharingMessageAcceptRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		mailFolderId: mailFolderId,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphCalendar
func (a *UsersActionsApiService) UsersUserMailFoldersMailFolderMessagesMessageMicrosoftGraphCalendarSharingMessageAcceptExecute(r ApiUsersUserMailFoldersMailFolderMessagesMessageMicrosoftGraphCalendarSharingMessageAcceptRequest) (MicrosoftGraphCalendar, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphCalendar
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserMailFoldersMailFolderMessagesMessageMicrosoftGraphCalendarSharingMessageAccept")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/mailFolders/{mailFolder-id}/messages/{message-id}/microsoft.graph.calendarSharingMessage/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mailFolder-id"+"}", _neturl.PathEscape(parameterToString(r.mailFolderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserMailFoldersMailFolderMessagesMessageMoveRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	mailFolderId string
	messageId string
	inlineObject1060 *InlineObject1060
}

func (r ApiUsersUserMailFoldersMailFolderMessagesMessageMoveRequest) InlineObject1060(inlineObject1060 InlineObject1060) ApiUsersUserMailFoldersMailFolderMessagesMessageMoveRequest {
	r.inlineObject1060 = &inlineObject1060
	return r
}

func (r ApiUsersUserMailFoldersMailFolderMessagesMessageMoveRequest) Execute() (AnyOfmicrosoftGraphMessage, *_nethttp.Response, error) {
	return r.ApiService.UsersUserMailFoldersMailFolderMessagesMessageMoveExecute(r)
}

/*
UsersUserMailFoldersMailFolderMessagesMessageMove Invoke action move

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param mailFolderId key: id of mailFolder
 @param messageId key: id of message
 @return ApiUsersUserMailFoldersMailFolderMessagesMessageMoveRequest
*/
func (a *UsersActionsApiService) UsersUserMailFoldersMailFolderMessagesMessageMove(ctx _context.Context, userId string, mailFolderId string, messageId string) ApiUsersUserMailFoldersMailFolderMessagesMessageMoveRequest {
	return ApiUsersUserMailFoldersMailFolderMessagesMessageMoveRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		mailFolderId: mailFolderId,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphMessage
func (a *UsersActionsApiService) UsersUserMailFoldersMailFolderMessagesMessageMoveExecute(r ApiUsersUserMailFoldersMailFolderMessagesMessageMoveRequest) (AnyOfmicrosoftGraphMessage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserMailFoldersMailFolderMessagesMessageMove")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/mailFolders/{mailFolder-id}/messages/{message-id}/microsoft.graph.move"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mailFolder-id"+"}", _neturl.PathEscape(parameterToString(r.mailFolderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1060 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1060 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1060
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserMailFoldersMailFolderMessagesMessageReplyRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	mailFolderId string
	messageId string
	inlineObject1061 *InlineObject1061
}

func (r ApiUsersUserMailFoldersMailFolderMessagesMessageReplyRequest) InlineObject1061(inlineObject1061 InlineObject1061) ApiUsersUserMailFoldersMailFolderMessagesMessageReplyRequest {
	r.inlineObject1061 = &inlineObject1061
	return r
}

func (r ApiUsersUserMailFoldersMailFolderMessagesMessageReplyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserMailFoldersMailFolderMessagesMessageReplyExecute(r)
}

/*
UsersUserMailFoldersMailFolderMessagesMessageReply Invoke action reply

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param mailFolderId key: id of mailFolder
 @param messageId key: id of message
 @return ApiUsersUserMailFoldersMailFolderMessagesMessageReplyRequest
*/
func (a *UsersActionsApiService) UsersUserMailFoldersMailFolderMessagesMessageReply(ctx _context.Context, userId string, mailFolderId string, messageId string) ApiUsersUserMailFoldersMailFolderMessagesMessageReplyRequest {
	return ApiUsersUserMailFoldersMailFolderMessagesMessageReplyRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		mailFolderId: mailFolderId,
		messageId: messageId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserMailFoldersMailFolderMessagesMessageReplyExecute(r ApiUsersUserMailFoldersMailFolderMessagesMessageReplyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserMailFoldersMailFolderMessagesMessageReply")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/mailFolders/{mailFolder-id}/messages/{message-id}/microsoft.graph.reply"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mailFolder-id"+"}", _neturl.PathEscape(parameterToString(r.mailFolderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1061 == nil {
		return nil, reportError("inlineObject1061 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1061
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserMailFoldersMailFolderMessagesMessageReplyAllRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	mailFolderId string
	messageId string
	inlineObject1062 *InlineObject1062
}

func (r ApiUsersUserMailFoldersMailFolderMessagesMessageReplyAllRequest) InlineObject1062(inlineObject1062 InlineObject1062) ApiUsersUserMailFoldersMailFolderMessagesMessageReplyAllRequest {
	r.inlineObject1062 = &inlineObject1062
	return r
}

func (r ApiUsersUserMailFoldersMailFolderMessagesMessageReplyAllRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserMailFoldersMailFolderMessagesMessageReplyAllExecute(r)
}

/*
UsersUserMailFoldersMailFolderMessagesMessageReplyAll Invoke action replyAll

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param mailFolderId key: id of mailFolder
 @param messageId key: id of message
 @return ApiUsersUserMailFoldersMailFolderMessagesMessageReplyAllRequest
*/
func (a *UsersActionsApiService) UsersUserMailFoldersMailFolderMessagesMessageReplyAll(ctx _context.Context, userId string, mailFolderId string, messageId string) ApiUsersUserMailFoldersMailFolderMessagesMessageReplyAllRequest {
	return ApiUsersUserMailFoldersMailFolderMessagesMessageReplyAllRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		mailFolderId: mailFolderId,
		messageId: messageId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserMailFoldersMailFolderMessagesMessageReplyAllExecute(r ApiUsersUserMailFoldersMailFolderMessagesMessageReplyAllRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserMailFoldersMailFolderMessagesMessageReplyAll")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/mailFolders/{mailFolder-id}/messages/{message-id}/microsoft.graph.replyAll"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mailFolder-id"+"}", _neturl.PathEscape(parameterToString(r.mailFolderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1062 == nil {
		return nil, reportError("inlineObject1062 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1062
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserMailFoldersMailFolderMessagesMessageSendRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	mailFolderId string
	messageId string
}


func (r ApiUsersUserMailFoldersMailFolderMessagesMessageSendRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserMailFoldersMailFolderMessagesMessageSendExecute(r)
}

/*
UsersUserMailFoldersMailFolderMessagesMessageSend Invoke action send

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param mailFolderId key: id of mailFolder
 @param messageId key: id of message
 @return ApiUsersUserMailFoldersMailFolderMessagesMessageSendRequest
*/
func (a *UsersActionsApiService) UsersUserMailFoldersMailFolderMessagesMessageSend(ctx _context.Context, userId string, mailFolderId string, messageId string) ApiUsersUserMailFoldersMailFolderMessagesMessageSendRequest {
	return ApiUsersUserMailFoldersMailFolderMessagesMessageSendRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		mailFolderId: mailFolderId,
		messageId: messageId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserMailFoldersMailFolderMessagesMessageSendExecute(r ApiUsersUserMailFoldersMailFolderMessagesMessageSendRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserMailFoldersMailFolderMessagesMessageSend")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/mailFolders/{mailFolder-id}/messages/{message-id}/microsoft.graph.send"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mailFolder-id"+"}", _neturl.PathEscape(parameterToString(r.mailFolderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserMailFoldersMailFolderMoveRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	mailFolderId string
	inlineObject1064 *InlineObject1064
}

func (r ApiUsersUserMailFoldersMailFolderMoveRequest) InlineObject1064(inlineObject1064 InlineObject1064) ApiUsersUserMailFoldersMailFolderMoveRequest {
	r.inlineObject1064 = &inlineObject1064
	return r
}

func (r ApiUsersUserMailFoldersMailFolderMoveRequest) Execute() (AnyOfmicrosoftGraphMailFolder, *_nethttp.Response, error) {
	return r.ApiService.UsersUserMailFoldersMailFolderMoveExecute(r)
}

/*
UsersUserMailFoldersMailFolderMove Invoke action move

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param mailFolderId key: id of mailFolder
 @return ApiUsersUserMailFoldersMailFolderMoveRequest
*/
func (a *UsersActionsApiService) UsersUserMailFoldersMailFolderMove(ctx _context.Context, userId string, mailFolderId string) ApiUsersUserMailFoldersMailFolderMoveRequest {
	return ApiUsersUserMailFoldersMailFolderMoveRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		mailFolderId: mailFolderId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphMailFolder
func (a *UsersActionsApiService) UsersUserMailFoldersMailFolderMoveExecute(r ApiUsersUserMailFoldersMailFolderMoveRequest) (AnyOfmicrosoftGraphMailFolder, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphMailFolder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserMailFoldersMailFolderMove")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/mailFolders/{mailFolder-id}/microsoft.graph.move"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mailFolder-id"+"}", _neturl.PathEscape(parameterToString(r.mailFolderId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1064 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1064 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1064
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserManagedDevicesManagedDeviceBypassActivationLockRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	managedDeviceId string
}


func (r ApiUsersUserManagedDevicesManagedDeviceBypassActivationLockRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserManagedDevicesManagedDeviceBypassActivationLockExecute(r)
}

/*
UsersUserManagedDevicesManagedDeviceBypassActivationLock Invoke action bypassActivationLock

Bypass activation lock

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param managedDeviceId key: id of managedDevice
 @return ApiUsersUserManagedDevicesManagedDeviceBypassActivationLockRequest
*/
func (a *UsersActionsApiService) UsersUserManagedDevicesManagedDeviceBypassActivationLock(ctx _context.Context, userId string, managedDeviceId string) ApiUsersUserManagedDevicesManagedDeviceBypassActivationLockRequest {
	return ApiUsersUserManagedDevicesManagedDeviceBypassActivationLockRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserManagedDevicesManagedDeviceBypassActivationLockExecute(r ApiUsersUserManagedDevicesManagedDeviceBypassActivationLockRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserManagedDevicesManagedDeviceBypassActivationLock")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/managedDevices/{managedDevice-id}/microsoft.graph.bypassActivationLock"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserManagedDevicesManagedDeviceCleanWindowsDeviceRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	managedDeviceId string
	inlineObject1065 *InlineObject1065
}

func (r ApiUsersUserManagedDevicesManagedDeviceCleanWindowsDeviceRequest) InlineObject1065(inlineObject1065 InlineObject1065) ApiUsersUserManagedDevicesManagedDeviceCleanWindowsDeviceRequest {
	r.inlineObject1065 = &inlineObject1065
	return r
}

func (r ApiUsersUserManagedDevicesManagedDeviceCleanWindowsDeviceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserManagedDevicesManagedDeviceCleanWindowsDeviceExecute(r)
}

/*
UsersUserManagedDevicesManagedDeviceCleanWindowsDevice Invoke action cleanWindowsDevice

Clean Windows device

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param managedDeviceId key: id of managedDevice
 @return ApiUsersUserManagedDevicesManagedDeviceCleanWindowsDeviceRequest
*/
func (a *UsersActionsApiService) UsersUserManagedDevicesManagedDeviceCleanWindowsDevice(ctx _context.Context, userId string, managedDeviceId string) ApiUsersUserManagedDevicesManagedDeviceCleanWindowsDeviceRequest {
	return ApiUsersUserManagedDevicesManagedDeviceCleanWindowsDeviceRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserManagedDevicesManagedDeviceCleanWindowsDeviceExecute(r ApiUsersUserManagedDevicesManagedDeviceCleanWindowsDeviceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserManagedDevicesManagedDeviceCleanWindowsDevice")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/managedDevices/{managedDevice-id}/microsoft.graph.cleanWindowsDevice"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1065 == nil {
		return nil, reportError("inlineObject1065 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1065
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserManagedDevicesManagedDeviceDeleteUserFromSharedAppleDeviceRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	managedDeviceId string
	inlineObject1066 *InlineObject1066
}

func (r ApiUsersUserManagedDevicesManagedDeviceDeleteUserFromSharedAppleDeviceRequest) InlineObject1066(inlineObject1066 InlineObject1066) ApiUsersUserManagedDevicesManagedDeviceDeleteUserFromSharedAppleDeviceRequest {
	r.inlineObject1066 = &inlineObject1066
	return r
}

func (r ApiUsersUserManagedDevicesManagedDeviceDeleteUserFromSharedAppleDeviceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserManagedDevicesManagedDeviceDeleteUserFromSharedAppleDeviceExecute(r)
}

/*
UsersUserManagedDevicesManagedDeviceDeleteUserFromSharedAppleDevice Invoke action deleteUserFromSharedAppleDevice

Delete user from shared Apple device

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param managedDeviceId key: id of managedDevice
 @return ApiUsersUserManagedDevicesManagedDeviceDeleteUserFromSharedAppleDeviceRequest
*/
func (a *UsersActionsApiService) UsersUserManagedDevicesManagedDeviceDeleteUserFromSharedAppleDevice(ctx _context.Context, userId string, managedDeviceId string) ApiUsersUserManagedDevicesManagedDeviceDeleteUserFromSharedAppleDeviceRequest {
	return ApiUsersUserManagedDevicesManagedDeviceDeleteUserFromSharedAppleDeviceRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserManagedDevicesManagedDeviceDeleteUserFromSharedAppleDeviceExecute(r ApiUsersUserManagedDevicesManagedDeviceDeleteUserFromSharedAppleDeviceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserManagedDevicesManagedDeviceDeleteUserFromSharedAppleDevice")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/managedDevices/{managedDevice-id}/microsoft.graph.deleteUserFromSharedAppleDevice"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1066 == nil {
		return nil, reportError("inlineObject1066 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1066
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserManagedDevicesManagedDeviceDisableLostModeRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	managedDeviceId string
}


func (r ApiUsersUserManagedDevicesManagedDeviceDisableLostModeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserManagedDevicesManagedDeviceDisableLostModeExecute(r)
}

/*
UsersUserManagedDevicesManagedDeviceDisableLostMode Invoke action disableLostMode

Disable lost mode

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param managedDeviceId key: id of managedDevice
 @return ApiUsersUserManagedDevicesManagedDeviceDisableLostModeRequest
*/
func (a *UsersActionsApiService) UsersUserManagedDevicesManagedDeviceDisableLostMode(ctx _context.Context, userId string, managedDeviceId string) ApiUsersUserManagedDevicesManagedDeviceDisableLostModeRequest {
	return ApiUsersUserManagedDevicesManagedDeviceDisableLostModeRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserManagedDevicesManagedDeviceDisableLostModeExecute(r ApiUsersUserManagedDevicesManagedDeviceDisableLostModeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserManagedDevicesManagedDeviceDisableLostMode")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/managedDevices/{managedDevice-id}/microsoft.graph.disableLostMode"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserManagedDevicesManagedDeviceLocateDeviceRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	managedDeviceId string
}


func (r ApiUsersUserManagedDevicesManagedDeviceLocateDeviceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserManagedDevicesManagedDeviceLocateDeviceExecute(r)
}

/*
UsersUserManagedDevicesManagedDeviceLocateDevice Invoke action locateDevice

Locate a device

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param managedDeviceId key: id of managedDevice
 @return ApiUsersUserManagedDevicesManagedDeviceLocateDeviceRequest
*/
func (a *UsersActionsApiService) UsersUserManagedDevicesManagedDeviceLocateDevice(ctx _context.Context, userId string, managedDeviceId string) ApiUsersUserManagedDevicesManagedDeviceLocateDeviceRequest {
	return ApiUsersUserManagedDevicesManagedDeviceLocateDeviceRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserManagedDevicesManagedDeviceLocateDeviceExecute(r ApiUsersUserManagedDevicesManagedDeviceLocateDeviceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserManagedDevicesManagedDeviceLocateDevice")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/managedDevices/{managedDevice-id}/microsoft.graph.locateDevice"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserManagedDevicesManagedDeviceLogoutSharedAppleDeviceActiveUserRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	managedDeviceId string
}


func (r ApiUsersUserManagedDevicesManagedDeviceLogoutSharedAppleDeviceActiveUserRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserManagedDevicesManagedDeviceLogoutSharedAppleDeviceActiveUserExecute(r)
}

/*
UsersUserManagedDevicesManagedDeviceLogoutSharedAppleDeviceActiveUser Invoke action logoutSharedAppleDeviceActiveUser

Logout shared Apple device active user

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param managedDeviceId key: id of managedDevice
 @return ApiUsersUserManagedDevicesManagedDeviceLogoutSharedAppleDeviceActiveUserRequest
*/
func (a *UsersActionsApiService) UsersUserManagedDevicesManagedDeviceLogoutSharedAppleDeviceActiveUser(ctx _context.Context, userId string, managedDeviceId string) ApiUsersUserManagedDevicesManagedDeviceLogoutSharedAppleDeviceActiveUserRequest {
	return ApiUsersUserManagedDevicesManagedDeviceLogoutSharedAppleDeviceActiveUserRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserManagedDevicesManagedDeviceLogoutSharedAppleDeviceActiveUserExecute(r ApiUsersUserManagedDevicesManagedDeviceLogoutSharedAppleDeviceActiveUserRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserManagedDevicesManagedDeviceLogoutSharedAppleDeviceActiveUser")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/managedDevices/{managedDevice-id}/microsoft.graph.logoutSharedAppleDeviceActiveUser"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserManagedDevicesManagedDeviceRebootNowRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	managedDeviceId string
}


func (r ApiUsersUserManagedDevicesManagedDeviceRebootNowRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserManagedDevicesManagedDeviceRebootNowExecute(r)
}

/*
UsersUserManagedDevicesManagedDeviceRebootNow Invoke action rebootNow

Reboot device

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param managedDeviceId key: id of managedDevice
 @return ApiUsersUserManagedDevicesManagedDeviceRebootNowRequest
*/
func (a *UsersActionsApiService) UsersUserManagedDevicesManagedDeviceRebootNow(ctx _context.Context, userId string, managedDeviceId string) ApiUsersUserManagedDevicesManagedDeviceRebootNowRequest {
	return ApiUsersUserManagedDevicesManagedDeviceRebootNowRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserManagedDevicesManagedDeviceRebootNowExecute(r ApiUsersUserManagedDevicesManagedDeviceRebootNowRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserManagedDevicesManagedDeviceRebootNow")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/managedDevices/{managedDevice-id}/microsoft.graph.rebootNow"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserManagedDevicesManagedDeviceRecoverPasscodeRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	managedDeviceId string
}


func (r ApiUsersUserManagedDevicesManagedDeviceRecoverPasscodeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserManagedDevicesManagedDeviceRecoverPasscodeExecute(r)
}

/*
UsersUserManagedDevicesManagedDeviceRecoverPasscode Invoke action recoverPasscode

Recover passcode

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param managedDeviceId key: id of managedDevice
 @return ApiUsersUserManagedDevicesManagedDeviceRecoverPasscodeRequest
*/
func (a *UsersActionsApiService) UsersUserManagedDevicesManagedDeviceRecoverPasscode(ctx _context.Context, userId string, managedDeviceId string) ApiUsersUserManagedDevicesManagedDeviceRecoverPasscodeRequest {
	return ApiUsersUserManagedDevicesManagedDeviceRecoverPasscodeRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserManagedDevicesManagedDeviceRecoverPasscodeExecute(r ApiUsersUserManagedDevicesManagedDeviceRecoverPasscodeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserManagedDevicesManagedDeviceRecoverPasscode")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/managedDevices/{managedDevice-id}/microsoft.graph.recoverPasscode"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserManagedDevicesManagedDeviceRemoteLockRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	managedDeviceId string
}


func (r ApiUsersUserManagedDevicesManagedDeviceRemoteLockRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserManagedDevicesManagedDeviceRemoteLockExecute(r)
}

/*
UsersUserManagedDevicesManagedDeviceRemoteLock Invoke action remoteLock

Remote lock

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param managedDeviceId key: id of managedDevice
 @return ApiUsersUserManagedDevicesManagedDeviceRemoteLockRequest
*/
func (a *UsersActionsApiService) UsersUserManagedDevicesManagedDeviceRemoteLock(ctx _context.Context, userId string, managedDeviceId string) ApiUsersUserManagedDevicesManagedDeviceRemoteLockRequest {
	return ApiUsersUserManagedDevicesManagedDeviceRemoteLockRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserManagedDevicesManagedDeviceRemoteLockExecute(r ApiUsersUserManagedDevicesManagedDeviceRemoteLockRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserManagedDevicesManagedDeviceRemoteLock")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/managedDevices/{managedDevice-id}/microsoft.graph.remoteLock"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserManagedDevicesManagedDeviceRequestRemoteAssistanceRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	managedDeviceId string
}


func (r ApiUsersUserManagedDevicesManagedDeviceRequestRemoteAssistanceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserManagedDevicesManagedDeviceRequestRemoteAssistanceExecute(r)
}

/*
UsersUserManagedDevicesManagedDeviceRequestRemoteAssistance Invoke action requestRemoteAssistance

Request remote assistance

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param managedDeviceId key: id of managedDevice
 @return ApiUsersUserManagedDevicesManagedDeviceRequestRemoteAssistanceRequest
*/
func (a *UsersActionsApiService) UsersUserManagedDevicesManagedDeviceRequestRemoteAssistance(ctx _context.Context, userId string, managedDeviceId string) ApiUsersUserManagedDevicesManagedDeviceRequestRemoteAssistanceRequest {
	return ApiUsersUserManagedDevicesManagedDeviceRequestRemoteAssistanceRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserManagedDevicesManagedDeviceRequestRemoteAssistanceExecute(r ApiUsersUserManagedDevicesManagedDeviceRequestRemoteAssistanceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserManagedDevicesManagedDeviceRequestRemoteAssistance")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/managedDevices/{managedDevice-id}/microsoft.graph.requestRemoteAssistance"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserManagedDevicesManagedDeviceResetPasscodeRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	managedDeviceId string
}


func (r ApiUsersUserManagedDevicesManagedDeviceResetPasscodeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserManagedDevicesManagedDeviceResetPasscodeExecute(r)
}

/*
UsersUserManagedDevicesManagedDeviceResetPasscode Invoke action resetPasscode

Reset passcode

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param managedDeviceId key: id of managedDevice
 @return ApiUsersUserManagedDevicesManagedDeviceResetPasscodeRequest
*/
func (a *UsersActionsApiService) UsersUserManagedDevicesManagedDeviceResetPasscode(ctx _context.Context, userId string, managedDeviceId string) ApiUsersUserManagedDevicesManagedDeviceResetPasscodeRequest {
	return ApiUsersUserManagedDevicesManagedDeviceResetPasscodeRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserManagedDevicesManagedDeviceResetPasscodeExecute(r ApiUsersUserManagedDevicesManagedDeviceResetPasscodeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserManagedDevicesManagedDeviceResetPasscode")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/managedDevices/{managedDevice-id}/microsoft.graph.resetPasscode"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserManagedDevicesManagedDeviceRetireRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	managedDeviceId string
}


func (r ApiUsersUserManagedDevicesManagedDeviceRetireRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserManagedDevicesManagedDeviceRetireExecute(r)
}

/*
UsersUserManagedDevicesManagedDeviceRetire Invoke action retire

Retire a device

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param managedDeviceId key: id of managedDevice
 @return ApiUsersUserManagedDevicesManagedDeviceRetireRequest
*/
func (a *UsersActionsApiService) UsersUserManagedDevicesManagedDeviceRetire(ctx _context.Context, userId string, managedDeviceId string) ApiUsersUserManagedDevicesManagedDeviceRetireRequest {
	return ApiUsersUserManagedDevicesManagedDeviceRetireRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserManagedDevicesManagedDeviceRetireExecute(r ApiUsersUserManagedDevicesManagedDeviceRetireRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserManagedDevicesManagedDeviceRetire")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/managedDevices/{managedDevice-id}/microsoft.graph.retire"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserManagedDevicesManagedDeviceShutDownRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	managedDeviceId string
}


func (r ApiUsersUserManagedDevicesManagedDeviceShutDownRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserManagedDevicesManagedDeviceShutDownExecute(r)
}

/*
UsersUserManagedDevicesManagedDeviceShutDown Invoke action shutDown

Shut down device

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param managedDeviceId key: id of managedDevice
 @return ApiUsersUserManagedDevicesManagedDeviceShutDownRequest
*/
func (a *UsersActionsApiService) UsersUserManagedDevicesManagedDeviceShutDown(ctx _context.Context, userId string, managedDeviceId string) ApiUsersUserManagedDevicesManagedDeviceShutDownRequest {
	return ApiUsersUserManagedDevicesManagedDeviceShutDownRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserManagedDevicesManagedDeviceShutDownExecute(r ApiUsersUserManagedDevicesManagedDeviceShutDownRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserManagedDevicesManagedDeviceShutDown")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/managedDevices/{managedDevice-id}/microsoft.graph.shutDown"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserManagedDevicesManagedDeviceSyncDeviceRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	managedDeviceId string
}


func (r ApiUsersUserManagedDevicesManagedDeviceSyncDeviceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserManagedDevicesManagedDeviceSyncDeviceExecute(r)
}

/*
UsersUserManagedDevicesManagedDeviceSyncDevice Invoke action syncDevice

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param managedDeviceId key: id of managedDevice
 @return ApiUsersUserManagedDevicesManagedDeviceSyncDeviceRequest
*/
func (a *UsersActionsApiService) UsersUserManagedDevicesManagedDeviceSyncDevice(ctx _context.Context, userId string, managedDeviceId string) ApiUsersUserManagedDevicesManagedDeviceSyncDeviceRequest {
	return ApiUsersUserManagedDevicesManagedDeviceSyncDeviceRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserManagedDevicesManagedDeviceSyncDeviceExecute(r ApiUsersUserManagedDevicesManagedDeviceSyncDeviceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserManagedDevicesManagedDeviceSyncDevice")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/managedDevices/{managedDevice-id}/microsoft.graph.syncDevice"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserManagedDevicesManagedDeviceUpdateWindowsDeviceAccountRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	managedDeviceId string
	inlineObject1067 *InlineObject1067
}

func (r ApiUsersUserManagedDevicesManagedDeviceUpdateWindowsDeviceAccountRequest) InlineObject1067(inlineObject1067 InlineObject1067) ApiUsersUserManagedDevicesManagedDeviceUpdateWindowsDeviceAccountRequest {
	r.inlineObject1067 = &inlineObject1067
	return r
}

func (r ApiUsersUserManagedDevicesManagedDeviceUpdateWindowsDeviceAccountRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserManagedDevicesManagedDeviceUpdateWindowsDeviceAccountExecute(r)
}

/*
UsersUserManagedDevicesManagedDeviceUpdateWindowsDeviceAccount Invoke action updateWindowsDeviceAccount

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param managedDeviceId key: id of managedDevice
 @return ApiUsersUserManagedDevicesManagedDeviceUpdateWindowsDeviceAccountRequest
*/
func (a *UsersActionsApiService) UsersUserManagedDevicesManagedDeviceUpdateWindowsDeviceAccount(ctx _context.Context, userId string, managedDeviceId string) ApiUsersUserManagedDevicesManagedDeviceUpdateWindowsDeviceAccountRequest {
	return ApiUsersUserManagedDevicesManagedDeviceUpdateWindowsDeviceAccountRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserManagedDevicesManagedDeviceUpdateWindowsDeviceAccountExecute(r ApiUsersUserManagedDevicesManagedDeviceUpdateWindowsDeviceAccountRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserManagedDevicesManagedDeviceUpdateWindowsDeviceAccount")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/managedDevices/{managedDevice-id}/microsoft.graph.updateWindowsDeviceAccount"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1067 == nil {
		return nil, reportError("inlineObject1067 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1067
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserManagedDevicesManagedDeviceWindowsDefenderScanRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	managedDeviceId string
	inlineObject1068 *InlineObject1068
}

func (r ApiUsersUserManagedDevicesManagedDeviceWindowsDefenderScanRequest) InlineObject1068(inlineObject1068 InlineObject1068) ApiUsersUserManagedDevicesManagedDeviceWindowsDefenderScanRequest {
	r.inlineObject1068 = &inlineObject1068
	return r
}

func (r ApiUsersUserManagedDevicesManagedDeviceWindowsDefenderScanRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserManagedDevicesManagedDeviceWindowsDefenderScanExecute(r)
}

/*
UsersUserManagedDevicesManagedDeviceWindowsDefenderScan Invoke action windowsDefenderScan

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param managedDeviceId key: id of managedDevice
 @return ApiUsersUserManagedDevicesManagedDeviceWindowsDefenderScanRequest
*/
func (a *UsersActionsApiService) UsersUserManagedDevicesManagedDeviceWindowsDefenderScan(ctx _context.Context, userId string, managedDeviceId string) ApiUsersUserManagedDevicesManagedDeviceWindowsDefenderScanRequest {
	return ApiUsersUserManagedDevicesManagedDeviceWindowsDefenderScanRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserManagedDevicesManagedDeviceWindowsDefenderScanExecute(r ApiUsersUserManagedDevicesManagedDeviceWindowsDefenderScanRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserManagedDevicesManagedDeviceWindowsDefenderScan")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/managedDevices/{managedDevice-id}/microsoft.graph.windowsDefenderScan"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1068 == nil {
		return nil, reportError("inlineObject1068 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1068
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserManagedDevicesManagedDeviceWindowsDefenderUpdateSignaturesRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	managedDeviceId string
}


func (r ApiUsersUserManagedDevicesManagedDeviceWindowsDefenderUpdateSignaturesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserManagedDevicesManagedDeviceWindowsDefenderUpdateSignaturesExecute(r)
}

/*
UsersUserManagedDevicesManagedDeviceWindowsDefenderUpdateSignatures Invoke action windowsDefenderUpdateSignatures

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param managedDeviceId key: id of managedDevice
 @return ApiUsersUserManagedDevicesManagedDeviceWindowsDefenderUpdateSignaturesRequest
*/
func (a *UsersActionsApiService) UsersUserManagedDevicesManagedDeviceWindowsDefenderUpdateSignatures(ctx _context.Context, userId string, managedDeviceId string) ApiUsersUserManagedDevicesManagedDeviceWindowsDefenderUpdateSignaturesRequest {
	return ApiUsersUserManagedDevicesManagedDeviceWindowsDefenderUpdateSignaturesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserManagedDevicesManagedDeviceWindowsDefenderUpdateSignaturesExecute(r ApiUsersUserManagedDevicesManagedDeviceWindowsDefenderUpdateSignaturesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserManagedDevicesManagedDeviceWindowsDefenderUpdateSignatures")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/managedDevices/{managedDevice-id}/microsoft.graph.windowsDefenderUpdateSignatures"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserManagedDevicesManagedDeviceWipeRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	managedDeviceId string
	inlineObject1069 *InlineObject1069
}

func (r ApiUsersUserManagedDevicesManagedDeviceWipeRequest) InlineObject1069(inlineObject1069 InlineObject1069) ApiUsersUserManagedDevicesManagedDeviceWipeRequest {
	r.inlineObject1069 = &inlineObject1069
	return r
}

func (r ApiUsersUserManagedDevicesManagedDeviceWipeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserManagedDevicesManagedDeviceWipeExecute(r)
}

/*
UsersUserManagedDevicesManagedDeviceWipe Invoke action wipe

Wipe a device

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param managedDeviceId key: id of managedDevice
 @return ApiUsersUserManagedDevicesManagedDeviceWipeRequest
*/
func (a *UsersActionsApiService) UsersUserManagedDevicesManagedDeviceWipe(ctx _context.Context, userId string, managedDeviceId string) ApiUsersUserManagedDevicesManagedDeviceWipeRequest {
	return ApiUsersUserManagedDevicesManagedDeviceWipeRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserManagedDevicesManagedDeviceWipeExecute(r ApiUsersUserManagedDevicesManagedDeviceWipeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserManagedDevicesManagedDeviceWipe")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/managedDevices/{managedDevice-id}/microsoft.graph.wipe"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1069 == nil {
		return nil, reportError("inlineObject1069 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1069
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserMessagesMessageAttachmentsCreateUploadSessionRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	messageId string
	inlineObject1070 *InlineObject1070
}

func (r ApiUsersUserMessagesMessageAttachmentsCreateUploadSessionRequest) InlineObject1070(inlineObject1070 InlineObject1070) ApiUsersUserMessagesMessageAttachmentsCreateUploadSessionRequest {
	r.inlineObject1070 = &inlineObject1070
	return r
}

func (r ApiUsersUserMessagesMessageAttachmentsCreateUploadSessionRequest) Execute() (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	return r.ApiService.UsersUserMessagesMessageAttachmentsCreateUploadSessionExecute(r)
}

/*
UsersUserMessagesMessageAttachmentsCreateUploadSession Invoke action createUploadSession

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param messageId key: id of message
 @return ApiUsersUserMessagesMessageAttachmentsCreateUploadSessionRequest
*/
func (a *UsersActionsApiService) UsersUserMessagesMessageAttachmentsCreateUploadSession(ctx _context.Context, userId string, messageId string) ApiUsersUserMessagesMessageAttachmentsCreateUploadSessionRequest {
	return ApiUsersUserMessagesMessageAttachmentsCreateUploadSessionRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphUploadSession
func (a *UsersActionsApiService) UsersUserMessagesMessageAttachmentsCreateUploadSessionExecute(r ApiUsersUserMessagesMessageAttachmentsCreateUploadSessionRequest) (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphUploadSession
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserMessagesMessageAttachmentsCreateUploadSession")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/messages/{message-id}/attachments/microsoft.graph.createUploadSession"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1070 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1070 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1070
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserMessagesMessageCopyRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	messageId string
	inlineObject1071 *InlineObject1071
}

func (r ApiUsersUserMessagesMessageCopyRequest) InlineObject1071(inlineObject1071 InlineObject1071) ApiUsersUserMessagesMessageCopyRequest {
	r.inlineObject1071 = &inlineObject1071
	return r
}

func (r ApiUsersUserMessagesMessageCopyRequest) Execute() (AnyOfmicrosoftGraphMessage, *_nethttp.Response, error) {
	return r.ApiService.UsersUserMessagesMessageCopyExecute(r)
}

/*
UsersUserMessagesMessageCopy Invoke action copy

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param messageId key: id of message
 @return ApiUsersUserMessagesMessageCopyRequest
*/
func (a *UsersActionsApiService) UsersUserMessagesMessageCopy(ctx _context.Context, userId string, messageId string) ApiUsersUserMessagesMessageCopyRequest {
	return ApiUsersUserMessagesMessageCopyRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphMessage
func (a *UsersActionsApiService) UsersUserMessagesMessageCopyExecute(r ApiUsersUserMessagesMessageCopyRequest) (AnyOfmicrosoftGraphMessage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserMessagesMessageCopy")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/messages/{message-id}/microsoft.graph.copy"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1071 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1071 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1071
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserMessagesMessageCreateForwardRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	messageId string
	inlineObject1072 *InlineObject1072
}

func (r ApiUsersUserMessagesMessageCreateForwardRequest) InlineObject1072(inlineObject1072 InlineObject1072) ApiUsersUserMessagesMessageCreateForwardRequest {
	r.inlineObject1072 = &inlineObject1072
	return r
}

func (r ApiUsersUserMessagesMessageCreateForwardRequest) Execute() (AnyOfmicrosoftGraphMessage, *_nethttp.Response, error) {
	return r.ApiService.UsersUserMessagesMessageCreateForwardExecute(r)
}

/*
UsersUserMessagesMessageCreateForward Invoke action createForward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param messageId key: id of message
 @return ApiUsersUserMessagesMessageCreateForwardRequest
*/
func (a *UsersActionsApiService) UsersUserMessagesMessageCreateForward(ctx _context.Context, userId string, messageId string) ApiUsersUserMessagesMessageCreateForwardRequest {
	return ApiUsersUserMessagesMessageCreateForwardRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphMessage
func (a *UsersActionsApiService) UsersUserMessagesMessageCreateForwardExecute(r ApiUsersUserMessagesMessageCreateForwardRequest) (AnyOfmicrosoftGraphMessage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserMessagesMessageCreateForward")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/messages/{message-id}/microsoft.graph.createForward"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1072 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1072 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1072
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserMessagesMessageCreateReplyRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	messageId string
	inlineObject1073 *InlineObject1073
}

func (r ApiUsersUserMessagesMessageCreateReplyRequest) InlineObject1073(inlineObject1073 InlineObject1073) ApiUsersUserMessagesMessageCreateReplyRequest {
	r.inlineObject1073 = &inlineObject1073
	return r
}

func (r ApiUsersUserMessagesMessageCreateReplyRequest) Execute() (AnyOfmicrosoftGraphMessage, *_nethttp.Response, error) {
	return r.ApiService.UsersUserMessagesMessageCreateReplyExecute(r)
}

/*
UsersUserMessagesMessageCreateReply Invoke action createReply

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param messageId key: id of message
 @return ApiUsersUserMessagesMessageCreateReplyRequest
*/
func (a *UsersActionsApiService) UsersUserMessagesMessageCreateReply(ctx _context.Context, userId string, messageId string) ApiUsersUserMessagesMessageCreateReplyRequest {
	return ApiUsersUserMessagesMessageCreateReplyRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphMessage
func (a *UsersActionsApiService) UsersUserMessagesMessageCreateReplyExecute(r ApiUsersUserMessagesMessageCreateReplyRequest) (AnyOfmicrosoftGraphMessage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserMessagesMessageCreateReply")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/messages/{message-id}/microsoft.graph.createReply"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1073 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1073 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1073
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserMessagesMessageCreateReplyAllRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	messageId string
	inlineObject1074 *InlineObject1074
}

func (r ApiUsersUserMessagesMessageCreateReplyAllRequest) InlineObject1074(inlineObject1074 InlineObject1074) ApiUsersUserMessagesMessageCreateReplyAllRequest {
	r.inlineObject1074 = &inlineObject1074
	return r
}

func (r ApiUsersUserMessagesMessageCreateReplyAllRequest) Execute() (AnyOfmicrosoftGraphMessage, *_nethttp.Response, error) {
	return r.ApiService.UsersUserMessagesMessageCreateReplyAllExecute(r)
}

/*
UsersUserMessagesMessageCreateReplyAll Invoke action createReplyAll

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param messageId key: id of message
 @return ApiUsersUserMessagesMessageCreateReplyAllRequest
*/
func (a *UsersActionsApiService) UsersUserMessagesMessageCreateReplyAll(ctx _context.Context, userId string, messageId string) ApiUsersUserMessagesMessageCreateReplyAllRequest {
	return ApiUsersUserMessagesMessageCreateReplyAllRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphMessage
func (a *UsersActionsApiService) UsersUserMessagesMessageCreateReplyAllExecute(r ApiUsersUserMessagesMessageCreateReplyAllRequest) (AnyOfmicrosoftGraphMessage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserMessagesMessageCreateReplyAll")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/messages/{message-id}/microsoft.graph.createReplyAll"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1074 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1074 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1074
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserMessagesMessageForwardRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	messageId string
	inlineObject1075 *InlineObject1075
}

func (r ApiUsersUserMessagesMessageForwardRequest) InlineObject1075(inlineObject1075 InlineObject1075) ApiUsersUserMessagesMessageForwardRequest {
	r.inlineObject1075 = &inlineObject1075
	return r
}

func (r ApiUsersUserMessagesMessageForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserMessagesMessageForwardExecute(r)
}

/*
UsersUserMessagesMessageForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param messageId key: id of message
 @return ApiUsersUserMessagesMessageForwardRequest
*/
func (a *UsersActionsApiService) UsersUserMessagesMessageForward(ctx _context.Context, userId string, messageId string) ApiUsersUserMessagesMessageForwardRequest {
	return ApiUsersUserMessagesMessageForwardRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		messageId: messageId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserMessagesMessageForwardExecute(r ApiUsersUserMessagesMessageForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserMessagesMessageForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/messages/{message-id}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1075 == nil {
		return nil, reportError("inlineObject1075 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1075
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserMessagesMessageMicrosoftGraphCalendarSharingMessageAcceptRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	messageId string
}


func (r ApiUsersUserMessagesMessageMicrosoftGraphCalendarSharingMessageAcceptRequest) Execute() (MicrosoftGraphCalendar, *_nethttp.Response, error) {
	return r.ApiService.UsersUserMessagesMessageMicrosoftGraphCalendarSharingMessageAcceptExecute(r)
}

/*
UsersUserMessagesMessageMicrosoftGraphCalendarSharingMessageAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param messageId key: id of message
 @return ApiUsersUserMessagesMessageMicrosoftGraphCalendarSharingMessageAcceptRequest
*/
func (a *UsersActionsApiService) UsersUserMessagesMessageMicrosoftGraphCalendarSharingMessageAccept(ctx _context.Context, userId string, messageId string) ApiUsersUserMessagesMessageMicrosoftGraphCalendarSharingMessageAcceptRequest {
	return ApiUsersUserMessagesMessageMicrosoftGraphCalendarSharingMessageAcceptRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphCalendar
func (a *UsersActionsApiService) UsersUserMessagesMessageMicrosoftGraphCalendarSharingMessageAcceptExecute(r ApiUsersUserMessagesMessageMicrosoftGraphCalendarSharingMessageAcceptRequest) (MicrosoftGraphCalendar, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphCalendar
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserMessagesMessageMicrosoftGraphCalendarSharingMessageAccept")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/messages/{message-id}/microsoft.graph.calendarSharingMessage/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserMessagesMessageMoveRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	messageId string
	inlineObject1076 *InlineObject1076
}

func (r ApiUsersUserMessagesMessageMoveRequest) InlineObject1076(inlineObject1076 InlineObject1076) ApiUsersUserMessagesMessageMoveRequest {
	r.inlineObject1076 = &inlineObject1076
	return r
}

func (r ApiUsersUserMessagesMessageMoveRequest) Execute() (AnyOfmicrosoftGraphMessage, *_nethttp.Response, error) {
	return r.ApiService.UsersUserMessagesMessageMoveExecute(r)
}

/*
UsersUserMessagesMessageMove Invoke action move

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param messageId key: id of message
 @return ApiUsersUserMessagesMessageMoveRequest
*/
func (a *UsersActionsApiService) UsersUserMessagesMessageMove(ctx _context.Context, userId string, messageId string) ApiUsersUserMessagesMessageMoveRequest {
	return ApiUsersUserMessagesMessageMoveRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphMessage
func (a *UsersActionsApiService) UsersUserMessagesMessageMoveExecute(r ApiUsersUserMessagesMessageMoveRequest) (AnyOfmicrosoftGraphMessage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserMessagesMessageMove")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/messages/{message-id}/microsoft.graph.move"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1076 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1076 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1076
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserMessagesMessageReplyRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	messageId string
	inlineObject1077 *InlineObject1077
}

func (r ApiUsersUserMessagesMessageReplyRequest) InlineObject1077(inlineObject1077 InlineObject1077) ApiUsersUserMessagesMessageReplyRequest {
	r.inlineObject1077 = &inlineObject1077
	return r
}

func (r ApiUsersUserMessagesMessageReplyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserMessagesMessageReplyExecute(r)
}

/*
UsersUserMessagesMessageReply Invoke action reply

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param messageId key: id of message
 @return ApiUsersUserMessagesMessageReplyRequest
*/
func (a *UsersActionsApiService) UsersUserMessagesMessageReply(ctx _context.Context, userId string, messageId string) ApiUsersUserMessagesMessageReplyRequest {
	return ApiUsersUserMessagesMessageReplyRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		messageId: messageId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserMessagesMessageReplyExecute(r ApiUsersUserMessagesMessageReplyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserMessagesMessageReply")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/messages/{message-id}/microsoft.graph.reply"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1077 == nil {
		return nil, reportError("inlineObject1077 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1077
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserMessagesMessageReplyAllRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	messageId string
	inlineObject1078 *InlineObject1078
}

func (r ApiUsersUserMessagesMessageReplyAllRequest) InlineObject1078(inlineObject1078 InlineObject1078) ApiUsersUserMessagesMessageReplyAllRequest {
	r.inlineObject1078 = &inlineObject1078
	return r
}

func (r ApiUsersUserMessagesMessageReplyAllRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserMessagesMessageReplyAllExecute(r)
}

/*
UsersUserMessagesMessageReplyAll Invoke action replyAll

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param messageId key: id of message
 @return ApiUsersUserMessagesMessageReplyAllRequest
*/
func (a *UsersActionsApiService) UsersUserMessagesMessageReplyAll(ctx _context.Context, userId string, messageId string) ApiUsersUserMessagesMessageReplyAllRequest {
	return ApiUsersUserMessagesMessageReplyAllRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		messageId: messageId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserMessagesMessageReplyAllExecute(r ApiUsersUserMessagesMessageReplyAllRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserMessagesMessageReplyAll")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/messages/{message-id}/microsoft.graph.replyAll"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1078 == nil {
		return nil, reportError("inlineObject1078 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1078
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserMessagesMessageSendRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	messageId string
}


func (r ApiUsersUserMessagesMessageSendRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserMessagesMessageSendExecute(r)
}

/*
UsersUserMessagesMessageSend Invoke action send

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param messageId key: id of message
 @return ApiUsersUserMessagesMessageSendRequest
*/
func (a *UsersActionsApiService) UsersUserMessagesMessageSend(ctx _context.Context, userId string, messageId string) ApiUsersUserMessagesMessageSendRequest {
	return ApiUsersUserMessagesMessageSendRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		messageId: messageId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserMessagesMessageSendExecute(r ApiUsersUserMessagesMessageSendRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserMessagesMessageSend")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/messages/{message-id}/microsoft.graph.send"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteNotebooksGetNotebookFromWebUrlRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	inlineObject1112 *InlineObject1112
}

func (r ApiUsersUserOnenoteNotebooksGetNotebookFromWebUrlRequest) InlineObject1112(inlineObject1112 InlineObject1112) ApiUsersUserOnenoteNotebooksGetNotebookFromWebUrlRequest {
	r.inlineObject1112 = &inlineObject1112
	return r
}

func (r ApiUsersUserOnenoteNotebooksGetNotebookFromWebUrlRequest) Execute() (AnyOfmicrosoftGraphCopyNotebookModel, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteNotebooksGetNotebookFromWebUrlExecute(r)
}

/*
UsersUserOnenoteNotebooksGetNotebookFromWebUrl Invoke action getNotebookFromWebUrl

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @return ApiUsersUserOnenoteNotebooksGetNotebookFromWebUrlRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteNotebooksGetNotebookFromWebUrl(ctx _context.Context, userId string) ApiUsersUserOnenoteNotebooksGetNotebookFromWebUrlRequest {
	return ApiUsersUserOnenoteNotebooksGetNotebookFromWebUrlRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphCopyNotebookModel
func (a *UsersActionsApiService) UsersUserOnenoteNotebooksGetNotebookFromWebUrlExecute(r ApiUsersUserOnenoteNotebooksGetNotebookFromWebUrlRequest) (AnyOfmicrosoftGraphCopyNotebookModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphCopyNotebookModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteNotebooksGetNotebookFromWebUrl")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/notebooks/microsoft.graph.getNotebookFromWebUrl"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1112 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1112 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1112
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteNotebooksNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	notebookId string
	inlineObject1091 *InlineObject1091
}

func (r ApiUsersUserOnenoteNotebooksNotebookCopyNotebookRequest) InlineObject1091(inlineObject1091 InlineObject1091) ApiUsersUserOnenoteNotebooksNotebookCopyNotebookRequest {
	r.inlineObject1091 = &inlineObject1091
	return r
}

func (r ApiUsersUserOnenoteNotebooksNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteNotebooksNotebookCopyNotebookExecute(r)
}

/*
UsersUserOnenoteNotebooksNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param notebookId key: id of notebook
 @return ApiUsersUserOnenoteNotebooksNotebookCopyNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteNotebooksNotebookCopyNotebook(ctx _context.Context, userId string, notebookId string) ApiUsersUserOnenoteNotebooksNotebookCopyNotebookRequest {
	return ApiUsersUserOnenoteNotebooksNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		notebookId: notebookId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteNotebooksNotebookCopyNotebookExecute(r ApiUsersUserOnenoteNotebooksNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteNotebooksNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/notebooks/{notebook-id}/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1091 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1091 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1091
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	notebookId string
	sectionGroupId string
	inlineObject1092 *InlineObject1092
}

func (r ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) InlineObject1092(inlineObject1092 InlineObject1092) ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest {
	r.inlineObject1092 = &inlineObject1092
	return r
}

func (r ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookExecute(r)
}

/*
UsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param notebookId key: id of notebook
 @param sectionGroupId key: id of sectionGroup
 @return ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupParentNotebookCopyNotebook(ctx _context.Context, userId string, notebookId string, sectionGroupId string) ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest {
	return ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		notebookId: notebookId,
		sectionGroupId: sectionGroupId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookExecute(r ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/notebooks/{notebook-id}/sectionGroups/{sectionGroup-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1092 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1092 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1092
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	notebookId string
	sectionGroupId string
	onenoteSectionId string
	inlineObject1093 *InlineObject1093
}

func (r ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) InlineObject1093(inlineObject1093 InlineObject1093) ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject1093 = &inlineObject1093
	return r
}

func (r ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
UsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param notebookId key: id of notebook
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @return ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, userId string, notebookId string, sectionGroupId string, onenoteSectionId string) ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		notebookId: notebookId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/notebooks/{notebook-id}/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1093 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1093 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1093
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	notebookId string
	sectionGroupId string
	onenoteSectionId string
	inlineObject1094 *InlineObject1094
}

func (r ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject1094(inlineObject1094 InlineObject1094) ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject1094 = &inlineObject1094
	return r
}

func (r ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
UsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param notebookId key: id of notebook
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @return ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, userId string, notebookId string, sectionGroupId string, onenoteSectionId string) ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		notebookId: notebookId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/notebooks/{notebook-id}/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1094 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1094 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1094
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	notebookId string
	sectionGroupId string
	onenoteSectionId string
	onenotePageId string
	inlineObject1095 *InlineObject1095
}

func (r ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) InlineObject1095(inlineObject1095 InlineObject1095) ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest {
	r.inlineObject1095 = &inlineObject1095
	return r
}

func (r ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionExecute(r)
}

/*
UsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSection Invoke action copyToSection

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param notebookId key: id of notebook
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSection(ctx _context.Context, userId string, notebookId string, sectionGroupId string, onenoteSectionId string, onenotePageId string) ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest {
	return ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		notebookId: notebookId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionExecute(r ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSection")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/notebooks/{notebook-id}/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/pages/{onenotePage-id}/microsoft.graph.copyToSection"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1095 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1095 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1095
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	notebookId string
	sectionGroupId string
	onenoteSectionId string
	onenotePageId string
	inlineObject1096 *InlineObject1096
}

func (r ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) InlineObject1096(inlineObject1096 InlineObject1096) ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest {
	r.inlineObject1096 = &inlineObject1096
	return r
}

func (r ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentExecute(r)
}

/*
UsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent Invoke action onenotePatchContent

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param notebookId key: id of notebook
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent(ctx _context.Context, userId string, notebookId string, sectionGroupId string, onenoteSectionId string, onenotePageId string) ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest {
	return ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		notebookId: notebookId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentExecute(r ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/notebooks/{notebook-id}/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/pages/{onenotePage-id}/microsoft.graph.onenotePatchContent"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1096 == nil {
		return nil, reportError("inlineObject1096 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1096
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	notebookId string
	sectionGroupId string
	onenoteSectionId string
	onenotePageId string
	inlineObject1097 *InlineObject1097
}

func (r ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest) InlineObject1097(inlineObject1097 InlineObject1097) ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest {
	r.inlineObject1097 = &inlineObject1097
	return r
}

func (r ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookExecute(r)
}

/*
UsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param notebookId key: id of notebook
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebook(ctx _context.Context, userId string, notebookId string, sectionGroupId string, onenoteSectionId string, onenotePageId string) ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest {
	return ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		notebookId: notebookId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookExecute(r ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/notebooks/{notebook-id}/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1097 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1097 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1097
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	notebookId string
	sectionGroupId string
	onenoteSectionId string
	onenotePageId string
	inlineObject1098 *InlineObject1098
}

func (r ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest) InlineObject1098(inlineObject1098 InlineObject1098) ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest {
	r.inlineObject1098 = &inlineObject1098
	return r
}

func (r ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookExecute(r)
}

/*
UsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param notebookId key: id of notebook
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebook(ctx _context.Context, userId string, notebookId string, sectionGroupId string, onenoteSectionId string, onenotePageId string) ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest {
	return ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		notebookId: notebookId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookExecute(r ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/notebooks/{notebook-id}/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentSection/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1098 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1098 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1098
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	notebookId string
	sectionGroupId string
	onenoteSectionId string
	onenotePageId string
	inlineObject1099 *InlineObject1099
}

func (r ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest) InlineObject1099(inlineObject1099 InlineObject1099) ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest {
	r.inlineObject1099 = &inlineObject1099
	return r
}

func (r ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupExecute(r)
}

/*
UsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param notebookId key: id of notebook
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroup(ctx _context.Context, userId string, notebookId string, sectionGroupId string, onenoteSectionId string, onenotePageId string) ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest {
	return ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		notebookId: notebookId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupExecute(r ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/notebooks/{notebook-id}/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentSection/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1099 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1099 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1099
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	notebookId string
	sectionGroupId string
	onenoteSectionId string
	inlineObject1100 *InlineObject1100
}

func (r ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest) InlineObject1100(inlineObject1100 InlineObject1100) ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest {
	r.inlineObject1100 = &inlineObject1100
	return r
}

func (r ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookExecute(r)
}

/*
UsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param notebookId key: id of notebook
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @return ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebook(ctx _context.Context, userId string, notebookId string, sectionGroupId string, onenoteSectionId string) ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest {
	return ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		notebookId: notebookId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookExecute(r ApiUsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/notebooks/{notebook-id}/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1100 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1100 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1100
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	notebookId string
	onenoteSectionId string
	inlineObject1101 *InlineObject1101
}

func (r ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToNotebookRequest) InlineObject1101(inlineObject1101 InlineObject1101) ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject1101 = &inlineObject1101
	return r
}

func (r ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param notebookId key: id of notebook
 @param onenoteSectionId key: id of onenoteSection
 @return ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, userId string, notebookId string, onenoteSectionId string) ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		notebookId: notebookId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToNotebookExecute(r ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/notebooks/{notebook-id}/sections/{onenoteSection-id}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1101 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1101 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1101
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	notebookId string
	onenoteSectionId string
	inlineObject1102 *InlineObject1102
}

func (r ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject1102(inlineObject1102 InlineObject1102) ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject1102 = &inlineObject1102
	return r
}

func (r ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param notebookId key: id of notebook
 @param onenoteSectionId key: id of onenoteSection
 @return ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, userId string, notebookId string, onenoteSectionId string) ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		notebookId: notebookId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/notebooks/{notebook-id}/sections/{onenoteSection-id}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1102 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1102 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1102
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	notebookId string
	onenoteSectionId string
	onenotePageId string
	inlineObject1103 *InlineObject1103
}

func (r ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) InlineObject1103(inlineObject1103 InlineObject1103) ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest {
	r.inlineObject1103 = &inlineObject1103
	return r
}

func (r ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionExecute(r)
}

/*
UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSection Invoke action copyToSection

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param notebookId key: id of notebook
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSection(ctx _context.Context, userId string, notebookId string, onenoteSectionId string, onenotePageId string) ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest {
	return ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		notebookId: notebookId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionExecute(r ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSection")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/notebooks/{notebook-id}/sections/{onenoteSection-id}/pages/{onenotePage-id}/microsoft.graph.copyToSection"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1103 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1103 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1103
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	notebookId string
	onenoteSectionId string
	onenotePageId string
	inlineObject1104 *InlineObject1104
}

func (r ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) InlineObject1104(inlineObject1104 InlineObject1104) ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest {
	r.inlineObject1104 = &inlineObject1104
	return r
}

func (r ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentExecute(r)
}

/*
UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent Invoke action onenotePatchContent

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param notebookId key: id of notebook
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent(ctx _context.Context, userId string, notebookId string, onenoteSectionId string, onenotePageId string) ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest {
	return ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		notebookId: notebookId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentExecute(r ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/notebooks/{notebook-id}/sections/{onenoteSection-id}/pages/{onenotePage-id}/microsoft.graph.onenotePatchContent"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1104 == nil {
		return nil, reportError("inlineObject1104 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1104
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	notebookId string
	onenoteSectionId string
	onenotePageId string
	inlineObject1105 *InlineObject1105
}

func (r ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest) InlineObject1105(inlineObject1105 InlineObject1105) ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest {
	r.inlineObject1105 = &inlineObject1105
	return r
}

func (r ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookExecute(r)
}

/*
UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param notebookId key: id of notebook
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebook(ctx _context.Context, userId string, notebookId string, onenoteSectionId string, onenotePageId string) ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest {
	return ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		notebookId: notebookId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookExecute(r ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/notebooks/{notebook-id}/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1105 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1105 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1105
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	notebookId string
	onenoteSectionId string
	onenotePageId string
	inlineObject1106 *InlineObject1106
}

func (r ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest) InlineObject1106(inlineObject1106 InlineObject1106) ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest {
	r.inlineObject1106 = &inlineObject1106
	return r
}

func (r ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookExecute(r)
}

/*
UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param notebookId key: id of notebook
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebook(ctx _context.Context, userId string, notebookId string, onenoteSectionId string, onenotePageId string) ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest {
	return ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		notebookId: notebookId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookExecute(r ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/notebooks/{notebook-id}/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentSection/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1106 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1106 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1106
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	notebookId string
	onenoteSectionId string
	onenotePageId string
	inlineObject1107 *InlineObject1107
}

func (r ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest) InlineObject1107(inlineObject1107 InlineObject1107) ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest {
	r.inlineObject1107 = &inlineObject1107
	return r
}

func (r ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupExecute(r)
}

/*
UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param notebookId key: id of notebook
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroup(ctx _context.Context, userId string, notebookId string, onenoteSectionId string, onenotePageId string) ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest {
	return ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		notebookId: notebookId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupExecute(r ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/notebooks/{notebook-id}/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentSection/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1107 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1107 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1107
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	notebookId string
	onenoteSectionId string
	inlineObject1108 *InlineObject1108
}

func (r ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest) InlineObject1108(inlineObject1108 InlineObject1108) ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest {
	r.inlineObject1108 = &inlineObject1108
	return r
}

func (r ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentNotebookCopyNotebookExecute(r)
}

/*
UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param notebookId key: id of notebook
 @param onenoteSectionId key: id of onenoteSection
 @return ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentNotebookCopyNotebook(ctx _context.Context, userId string, notebookId string, onenoteSectionId string) ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest {
	return ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		notebookId: notebookId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentNotebookCopyNotebookExecute(r ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/notebooks/{notebook-id}/sections/{onenoteSection-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1108 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1108 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1108
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	notebookId string
	onenoteSectionId string
	inlineObject1109 *InlineObject1109
}

func (r ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest) InlineObject1109(inlineObject1109 InlineObject1109) ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest {
	r.inlineObject1109 = &inlineObject1109
	return r
}

func (r ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookExecute(r)
}

/*
UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param notebookId key: id of notebook
 @param onenoteSectionId key: id of onenoteSection
 @return ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebook(ctx _context.Context, userId string, notebookId string, onenoteSectionId string) ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest {
	return ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		notebookId: notebookId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookExecute(r ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/notebooks/{notebook-id}/sections/{onenoteSection-id}/parentSectionGroup/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1109 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1109 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1109
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	notebookId string
	onenoteSectionId string
	onenoteSectionId1 string
	inlineObject1110 *InlineObject1110
}

func (r ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) InlineObject1110(inlineObject1110 InlineObject1110) ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject1110 = &inlineObject1110
	return r
}

func (r ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param notebookId key: id of notebook
 @param onenoteSectionId key: id of onenoteSection
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, userId string, notebookId string, onenoteSectionId string, onenoteSectionId1 string) ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		notebookId: notebookId,
		onenoteSectionId: onenoteSectionId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/notebooks/{notebook-id}/sections/{onenoteSection-id}/parentSectionGroup/sections/{onenoteSection-id1}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1110 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1110 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1110
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	notebookId string
	onenoteSectionId string
	onenoteSectionId1 string
	inlineObject1111 *InlineObject1111
}

func (r ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject1111(inlineObject1111 InlineObject1111) ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject1111 = &inlineObject1111
	return r
}

func (r ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param notebookId key: id of notebook
 @param onenoteSectionId key: id of onenoteSection
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, userId string, notebookId string, onenoteSectionId string, onenoteSectionId1 string) ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		notebookId: notebookId,
		onenoteSectionId: onenoteSectionId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiUsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/notebooks/{notebook-id}/sections/{onenoteSection-id}/parentSectionGroup/sections/{onenoteSection-id1}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1111 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1111 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1111
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenotePagesOnenotePageCopyToSectionRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenotePageId string
	inlineObject1113 *InlineObject1113
}

func (r ApiUsersUserOnenotePagesOnenotePageCopyToSectionRequest) InlineObject1113(inlineObject1113 InlineObject1113) ApiUsersUserOnenotePagesOnenotePageCopyToSectionRequest {
	r.inlineObject1113 = &inlineObject1113
	return r
}

func (r ApiUsersUserOnenotePagesOnenotePageCopyToSectionRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenotePagesOnenotePageCopyToSectionExecute(r)
}

/*
UsersUserOnenotePagesOnenotePageCopyToSection Invoke action copyToSection

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenotePageId key: id of onenotePage
 @return ApiUsersUserOnenotePagesOnenotePageCopyToSectionRequest
*/
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageCopyToSection(ctx _context.Context, userId string, onenotePageId string) ApiUsersUserOnenotePagesOnenotePageCopyToSectionRequest {
	return ApiUsersUserOnenotePagesOnenotePageCopyToSectionRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageCopyToSectionExecute(r ApiUsersUserOnenotePagesOnenotePageCopyToSectionRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenotePagesOnenotePageCopyToSection")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/pages/{onenotePage-id}/microsoft.graph.copyToSection"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1113 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1113 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1113
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenotePagesOnenotePageOnenotePatchContentRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenotePageId string
	inlineObject1114 *InlineObject1114
}

func (r ApiUsersUserOnenotePagesOnenotePageOnenotePatchContentRequest) InlineObject1114(inlineObject1114 InlineObject1114) ApiUsersUserOnenotePagesOnenotePageOnenotePatchContentRequest {
	r.inlineObject1114 = &inlineObject1114
	return r
}

func (r ApiUsersUserOnenotePagesOnenotePageOnenotePatchContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenotePagesOnenotePageOnenotePatchContentExecute(r)
}

/*
UsersUserOnenotePagesOnenotePageOnenotePatchContent Invoke action onenotePatchContent

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenotePageId key: id of onenotePage
 @return ApiUsersUserOnenotePagesOnenotePageOnenotePatchContentRequest
*/
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageOnenotePatchContent(ctx _context.Context, userId string, onenotePageId string) ApiUsersUserOnenotePagesOnenotePageOnenotePatchContentRequest {
	return ApiUsersUserOnenotePagesOnenotePageOnenotePatchContentRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageOnenotePatchContentExecute(r ApiUsersUserOnenotePagesOnenotePageOnenotePatchContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenotePagesOnenotePageOnenotePatchContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/pages/{onenotePage-id}/microsoft.graph.onenotePatchContent"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1114 == nil {
		return nil, reportError("inlineObject1114 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1114
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserOnenotePagesOnenotePageParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenotePageId string
	inlineObject1115 *InlineObject1115
}

func (r ApiUsersUserOnenotePagesOnenotePageParentNotebookCopyNotebookRequest) InlineObject1115(inlineObject1115 InlineObject1115) ApiUsersUserOnenotePagesOnenotePageParentNotebookCopyNotebookRequest {
	r.inlineObject1115 = &inlineObject1115
	return r
}

func (r ApiUsersUserOnenotePagesOnenotePageParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenotePagesOnenotePageParentNotebookCopyNotebookExecute(r)
}

/*
UsersUserOnenotePagesOnenotePageParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenotePageId key: id of onenotePage
 @return ApiUsersUserOnenotePagesOnenotePageParentNotebookCopyNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentNotebookCopyNotebook(ctx _context.Context, userId string, onenotePageId string) ApiUsersUserOnenotePagesOnenotePageParentNotebookCopyNotebookRequest {
	return ApiUsersUserOnenotePagesOnenotePageParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentNotebookCopyNotebookExecute(r ApiUsersUserOnenotePagesOnenotePageParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenotePagesOnenotePageParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/pages/{onenotePage-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1115 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1115 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1115
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenotePageId string
	sectionGroupId string
	inlineObject1116 *InlineObject1116
}

func (r ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) InlineObject1116(inlineObject1116 InlineObject1116) ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest {
	r.inlineObject1116 = &inlineObject1116
	return r
}

func (r ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookExecute(r)
}

/*
UsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenotePageId key: id of onenotePage
 @param sectionGroupId key: id of sectionGroup
 @return ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebook(ctx _context.Context, userId string, onenotePageId string, sectionGroupId string) ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest {
	return ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenotePageId: onenotePageId,
		sectionGroupId: sectionGroupId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookExecute(r ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/pages/{onenotePage-id}/parentNotebook/sectionGroups/{sectionGroup-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1116 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1116 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1116
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenotePageId string
	sectionGroupId string
	onenoteSectionId string
	inlineObject1117 *InlineObject1117
}

func (r ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) InlineObject1117(inlineObject1117 InlineObject1117) ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject1117 = &inlineObject1117
	return r
}

func (r ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
UsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenotePageId key: id of onenotePage
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @return ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, userId string, onenotePageId string, sectionGroupId string, onenoteSectionId string) ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenotePageId: onenotePageId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/pages/{onenotePage-id}/parentNotebook/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1117 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1117 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1117
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenotePageId string
	sectionGroupId string
	onenoteSectionId string
	inlineObject1118 *InlineObject1118
}

func (r ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject1118(inlineObject1118 InlineObject1118) ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject1118 = &inlineObject1118
	return r
}

func (r ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
UsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenotePageId key: id of onenotePage
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @return ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, userId string, onenotePageId string, sectionGroupId string, onenoteSectionId string) ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenotePageId: onenotePageId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/pages/{onenotePage-id}/parentNotebook/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1118 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1118 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1118
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenotePageId string
	sectionGroupId string
	onenoteSectionId string
	onenotePageId1 string
	inlineObject1119 *InlineObject1119
}

func (r ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) InlineObject1119(inlineObject1119 InlineObject1119) ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest {
	r.inlineObject1119 = &inlineObject1119
	return r
}

func (r ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionExecute(r)
}

/*
UsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSection Invoke action copyToSection

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenotePageId key: id of onenotePage
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId1 key: id of onenotePage
 @return ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest
*/
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSection(ctx _context.Context, userId string, onenotePageId string, sectionGroupId string, onenoteSectionId string, onenotePageId1 string) ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest {
	return ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenotePageId: onenotePageId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId1: onenotePageId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionExecute(r ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSection")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/pages/{onenotePage-id}/parentNotebook/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/pages/{onenotePage-id1}/microsoft.graph.copyToSection"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id1"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1119 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1119 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1119
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenotePageId string
	sectionGroupId string
	onenoteSectionId string
	onenotePageId1 string
	inlineObject1120 *InlineObject1120
}

func (r ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) InlineObject1120(inlineObject1120 InlineObject1120) ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest {
	r.inlineObject1120 = &inlineObject1120
	return r
}

func (r ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentExecute(r)
}

/*
UsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent Invoke action onenotePatchContent

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenotePageId key: id of onenotePage
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId1 key: id of onenotePage
 @return ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest
*/
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent(ctx _context.Context, userId string, onenotePageId string, sectionGroupId string, onenoteSectionId string, onenotePageId1 string) ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest {
	return ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenotePageId: onenotePageId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId1: onenotePageId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentExecute(r ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/pages/{onenotePage-id}/parentNotebook/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/pages/{onenotePage-id1}/microsoft.graph.onenotePatchContent"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id1"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1120 == nil {
		return nil, reportError("inlineObject1120 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1120
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenotePageId string
	sectionGroupId string
	onenoteSectionId string
	inlineObject1121 *InlineObject1121
}

func (r ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest) InlineObject1121(inlineObject1121 InlineObject1121) ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest {
	r.inlineObject1121 = &inlineObject1121
	return r
}

func (r ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookExecute(r)
}

/*
UsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenotePageId key: id of onenotePage
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @return ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebook(ctx _context.Context, userId string, onenotePageId string, sectionGroupId string, onenoteSectionId string) ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest {
	return ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenotePageId: onenotePageId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookExecute(r ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/pages/{onenotePage-id}/parentNotebook/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1121 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1121 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1121
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenotePageId string
	onenoteSectionId string
	inlineObject1122 *InlineObject1122
}

func (r ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) InlineObject1122(inlineObject1122 InlineObject1122) ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject1122 = &inlineObject1122
	return r
}

func (r ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
UsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId key: id of onenoteSection
 @return ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, userId string, onenotePageId string, onenoteSectionId string) ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenotePageId: onenotePageId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/pages/{onenotePage-id}/parentNotebook/sections/{onenoteSection-id}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1122 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1122 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1122
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenotePageId string
	onenoteSectionId string
	inlineObject1123 *InlineObject1123
}

func (r ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject1123(inlineObject1123 InlineObject1123) ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject1123 = &inlineObject1123
	return r
}

func (r ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
UsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId key: id of onenoteSection
 @return ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, userId string, onenotePageId string, onenoteSectionId string) ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenotePageId: onenotePageId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/pages/{onenotePage-id}/parentNotebook/sections/{onenoteSection-id}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1123 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1123 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1123
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenotePageId string
	onenoteSectionId string
	onenotePageId1 string
	inlineObject1124 *InlineObject1124
}

func (r ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) InlineObject1124(inlineObject1124 InlineObject1124) ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest {
	r.inlineObject1124 = &inlineObject1124
	return r
}

func (r ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionExecute(r)
}

/*
UsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSection Invoke action copyToSection

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId1 key: id of onenotePage
 @return ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest
*/
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSection(ctx _context.Context, userId string, onenotePageId string, onenoteSectionId string, onenotePageId1 string) ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest {
	return ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenotePageId: onenotePageId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId1: onenotePageId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionExecute(r ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSection")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/pages/{onenotePage-id}/parentNotebook/sections/{onenoteSection-id}/pages/{onenotePage-id1}/microsoft.graph.copyToSection"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id1"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1124 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1124 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1124
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenotePageId string
	onenoteSectionId string
	onenotePageId1 string
	inlineObject1125 *InlineObject1125
}

func (r ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) InlineObject1125(inlineObject1125 InlineObject1125) ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest {
	r.inlineObject1125 = &inlineObject1125
	return r
}

func (r ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentExecute(r)
}

/*
UsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent Invoke action onenotePatchContent

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId1 key: id of onenotePage
 @return ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest
*/
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent(ctx _context.Context, userId string, onenotePageId string, onenoteSectionId string, onenotePageId1 string) ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest {
	return ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenotePageId: onenotePageId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId1: onenotePageId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentExecute(r ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/pages/{onenotePage-id}/parentNotebook/sections/{onenoteSection-id}/pages/{onenotePage-id1}/microsoft.graph.onenotePatchContent"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id1"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1125 == nil {
		return nil, reportError("inlineObject1125 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1125
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenotePageId string
	onenoteSectionId string
	inlineObject1126 *InlineObject1126
}

func (r ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest) InlineObject1126(inlineObject1126 InlineObject1126) ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest {
	r.inlineObject1126 = &inlineObject1126
	return r
}

func (r ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookExecute(r)
}

/*
UsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId key: id of onenoteSection
 @return ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebook(ctx _context.Context, userId string, onenotePageId string, onenoteSectionId string) ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest {
	return ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenotePageId: onenotePageId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookExecute(r ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/pages/{onenotePage-id}/parentNotebook/sections/{onenoteSection-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1126 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1126 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1126
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenotePageId string
	onenoteSectionId string
	inlineObject1127 *InlineObject1127
}

func (r ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest) InlineObject1127(inlineObject1127 InlineObject1127) ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest {
	r.inlineObject1127 = &inlineObject1127
	return r
}

func (r ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookExecute(r)
}

/*
UsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId key: id of onenoteSection
 @return ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebook(ctx _context.Context, userId string, onenotePageId string, onenoteSectionId string) ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest {
	return ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenotePageId: onenotePageId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookExecute(r ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/pages/{onenotePage-id}/parentNotebook/sections/{onenoteSection-id}/parentSectionGroup/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1127 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1127 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1127
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenotePageId string
	onenoteSectionId string
	onenoteSectionId1 string
	inlineObject1128 *InlineObject1128
}

func (r ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) InlineObject1128(inlineObject1128 InlineObject1128) ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject1128 = &inlineObject1128
	return r
}

func (r ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
UsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId key: id of onenoteSection
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, userId string, onenotePageId string, onenoteSectionId string, onenoteSectionId1 string) ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenotePageId: onenotePageId,
		onenoteSectionId: onenoteSectionId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/pages/{onenotePage-id}/parentNotebook/sections/{onenoteSection-id}/parentSectionGroup/sections/{onenoteSection-id1}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1128 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1128 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1128
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenotePageId string
	onenoteSectionId string
	onenoteSectionId1 string
	inlineObject1129 *InlineObject1129
}

func (r ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject1129(inlineObject1129 InlineObject1129) ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject1129 = &inlineObject1129
	return r
}

func (r ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
UsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId key: id of onenoteSection
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, userId string, onenotePageId string, onenoteSectionId string, onenoteSectionId1 string) ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenotePageId: onenotePageId,
		onenoteSectionId: onenoteSectionId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiUsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/pages/{onenotePage-id}/parentNotebook/sections/{onenoteSection-id}/parentSectionGroup/sections/{onenoteSection-id1}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1129 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1129 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1129
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenotePagesOnenotePageParentSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenotePageId string
	inlineObject1130 *InlineObject1130
}

func (r ApiUsersUserOnenotePagesOnenotePageParentSectionCopyToNotebookRequest) InlineObject1130(inlineObject1130 InlineObject1130) ApiUsersUserOnenotePagesOnenotePageParentSectionCopyToNotebookRequest {
	r.inlineObject1130 = &inlineObject1130
	return r
}

func (r ApiUsersUserOnenotePagesOnenotePageParentSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenotePagesOnenotePageParentSectionCopyToNotebookExecute(r)
}

/*
UsersUserOnenotePagesOnenotePageParentSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenotePageId key: id of onenotePage
 @return ApiUsersUserOnenotePagesOnenotePageParentSectionCopyToNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentSectionCopyToNotebook(ctx _context.Context, userId string, onenotePageId string) ApiUsersUserOnenotePagesOnenotePageParentSectionCopyToNotebookRequest {
	return ApiUsersUserOnenotePagesOnenotePageParentSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentSectionCopyToNotebookExecute(r ApiUsersUserOnenotePagesOnenotePageParentSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenotePagesOnenotePageParentSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/pages/{onenotePage-id}/parentSection/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1130 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1130 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1130
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenotePagesOnenotePageParentSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenotePageId string
	inlineObject1131 *InlineObject1131
}

func (r ApiUsersUserOnenotePagesOnenotePageParentSectionCopyToSectionGroupRequest) InlineObject1131(inlineObject1131 InlineObject1131) ApiUsersUserOnenotePagesOnenotePageParentSectionCopyToSectionGroupRequest {
	r.inlineObject1131 = &inlineObject1131
	return r
}

func (r ApiUsersUserOnenotePagesOnenotePageParentSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenotePagesOnenotePageParentSectionCopyToSectionGroupExecute(r)
}

/*
UsersUserOnenotePagesOnenotePageParentSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenotePageId key: id of onenotePage
 @return ApiUsersUserOnenotePagesOnenotePageParentSectionCopyToSectionGroupRequest
*/
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentSectionCopyToSectionGroup(ctx _context.Context, userId string, onenotePageId string) ApiUsersUserOnenotePagesOnenotePageParentSectionCopyToSectionGroupRequest {
	return ApiUsersUserOnenotePagesOnenotePageParentSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentSectionCopyToSectionGroupExecute(r ApiUsersUserOnenotePagesOnenotePageParentSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenotePagesOnenotePageParentSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/pages/{onenotePage-id}/parentSection/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1131 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1131 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1131
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenotePagesOnenotePageParentSectionPagesOnenotePageCopyToSectionRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenotePageId string
	onenotePageId1 string
	inlineObject1132 *InlineObject1132
}

func (r ApiUsersUserOnenotePagesOnenotePageParentSectionPagesOnenotePageCopyToSectionRequest) InlineObject1132(inlineObject1132 InlineObject1132) ApiUsersUserOnenotePagesOnenotePageParentSectionPagesOnenotePageCopyToSectionRequest {
	r.inlineObject1132 = &inlineObject1132
	return r
}

func (r ApiUsersUserOnenotePagesOnenotePageParentSectionPagesOnenotePageCopyToSectionRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenotePagesOnenotePageParentSectionPagesOnenotePageCopyToSectionExecute(r)
}

/*
UsersUserOnenotePagesOnenotePageParentSectionPagesOnenotePageCopyToSection Invoke action copyToSection

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenotePageId key: id of onenotePage
 @param onenotePageId1 key: id of onenotePage
 @return ApiUsersUserOnenotePagesOnenotePageParentSectionPagesOnenotePageCopyToSectionRequest
*/
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentSectionPagesOnenotePageCopyToSection(ctx _context.Context, userId string, onenotePageId string, onenotePageId1 string) ApiUsersUserOnenotePagesOnenotePageParentSectionPagesOnenotePageCopyToSectionRequest {
	return ApiUsersUserOnenotePagesOnenotePageParentSectionPagesOnenotePageCopyToSectionRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenotePageId: onenotePageId,
		onenotePageId1: onenotePageId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentSectionPagesOnenotePageCopyToSectionExecute(r ApiUsersUserOnenotePagesOnenotePageParentSectionPagesOnenotePageCopyToSectionRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenotePagesOnenotePageParentSectionPagesOnenotePageCopyToSection")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/pages/{onenotePage-id}/parentSection/pages/{onenotePage-id1}/microsoft.graph.copyToSection"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id1"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1132 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1132 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1132
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenotePagesOnenotePageParentSectionPagesOnenotePageOnenotePatchContentRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenotePageId string
	onenotePageId1 string
	inlineObject1133 *InlineObject1133
}

func (r ApiUsersUserOnenotePagesOnenotePageParentSectionPagesOnenotePageOnenotePatchContentRequest) InlineObject1133(inlineObject1133 InlineObject1133) ApiUsersUserOnenotePagesOnenotePageParentSectionPagesOnenotePageOnenotePatchContentRequest {
	r.inlineObject1133 = &inlineObject1133
	return r
}

func (r ApiUsersUserOnenotePagesOnenotePageParentSectionPagesOnenotePageOnenotePatchContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenotePagesOnenotePageParentSectionPagesOnenotePageOnenotePatchContentExecute(r)
}

/*
UsersUserOnenotePagesOnenotePageParentSectionPagesOnenotePageOnenotePatchContent Invoke action onenotePatchContent

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenotePageId key: id of onenotePage
 @param onenotePageId1 key: id of onenotePage
 @return ApiUsersUserOnenotePagesOnenotePageParentSectionPagesOnenotePageOnenotePatchContentRequest
*/
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentSectionPagesOnenotePageOnenotePatchContent(ctx _context.Context, userId string, onenotePageId string, onenotePageId1 string) ApiUsersUserOnenotePagesOnenotePageParentSectionPagesOnenotePageOnenotePatchContentRequest {
	return ApiUsersUserOnenotePagesOnenotePageParentSectionPagesOnenotePageOnenotePatchContentRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenotePageId: onenotePageId,
		onenotePageId1: onenotePageId1,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentSectionPagesOnenotePageOnenotePatchContentExecute(r ApiUsersUserOnenotePagesOnenotePageParentSectionPagesOnenotePageOnenotePatchContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenotePagesOnenotePageParentSectionPagesOnenotePageOnenotePatchContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/pages/{onenotePage-id}/parentSection/pages/{onenotePage-id1}/microsoft.graph.onenotePatchContent"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id1"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1133 == nil {
		return nil, reportError("inlineObject1133 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1133
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserOnenotePagesOnenotePageParentSectionParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenotePageId string
	inlineObject1134 *InlineObject1134
}

func (r ApiUsersUserOnenotePagesOnenotePageParentSectionParentNotebookCopyNotebookRequest) InlineObject1134(inlineObject1134 InlineObject1134) ApiUsersUserOnenotePagesOnenotePageParentSectionParentNotebookCopyNotebookRequest {
	r.inlineObject1134 = &inlineObject1134
	return r
}

func (r ApiUsersUserOnenotePagesOnenotePageParentSectionParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenotePagesOnenotePageParentSectionParentNotebookCopyNotebookExecute(r)
}

/*
UsersUserOnenotePagesOnenotePageParentSectionParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenotePageId key: id of onenotePage
 @return ApiUsersUserOnenotePagesOnenotePageParentSectionParentNotebookCopyNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentSectionParentNotebookCopyNotebook(ctx _context.Context, userId string, onenotePageId string) ApiUsersUserOnenotePagesOnenotePageParentSectionParentNotebookCopyNotebookRequest {
	return ApiUsersUserOnenotePagesOnenotePageParentSectionParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentSectionParentNotebookCopyNotebookExecute(r ApiUsersUserOnenotePagesOnenotePageParentSectionParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenotePagesOnenotePageParentSectionParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/pages/{onenotePage-id}/parentSection/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1134 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1134 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1134
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenotePageId string
	sectionGroupId string
	inlineObject1135 *InlineObject1135
}

func (r ApiUsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) InlineObject1135(inlineObject1135 InlineObject1135) ApiUsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest {
	r.inlineObject1135 = &inlineObject1135
	return r
}

func (r ApiUsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookExecute(r)
}

/*
UsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenotePageId key: id of onenotePage
 @param sectionGroupId key: id of sectionGroup
 @return ApiUsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebook(ctx _context.Context, userId string, onenotePageId string, sectionGroupId string) ApiUsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest {
	return ApiUsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenotePageId: onenotePageId,
		sectionGroupId: sectionGroupId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookExecute(r ApiUsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/pages/{onenotePage-id}/parentSection/parentNotebook/sectionGroups/{sectionGroup-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1135 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1135 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1135
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenotePageId string
	sectionGroupId string
	onenoteSectionId string
	inlineObject1136 *InlineObject1136
}

func (r ApiUsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) InlineObject1136(inlineObject1136 InlineObject1136) ApiUsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject1136 = &inlineObject1136
	return r
}

func (r ApiUsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
UsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenotePageId key: id of onenotePage
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @return ApiUsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, userId string, onenotePageId string, sectionGroupId string, onenoteSectionId string) ApiUsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiUsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenotePageId: onenotePageId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r ApiUsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/pages/{onenotePage-id}/parentSection/parentNotebook/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1136 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1136 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1136
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenotePageId string
	sectionGroupId string
	onenoteSectionId string
	inlineObject1137 *InlineObject1137
}

func (r ApiUsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject1137(inlineObject1137 InlineObject1137) ApiUsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject1137 = &inlineObject1137
	return r
}

func (r ApiUsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
UsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenotePageId key: id of onenotePage
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @return ApiUsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, userId string, onenotePageId string, sectionGroupId string, onenoteSectionId string) ApiUsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiUsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenotePageId: onenotePageId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiUsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/pages/{onenotePage-id}/parentSection/parentNotebook/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1137 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1137 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1137
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenotePageId string
	onenoteSectionId string
	inlineObject1138 *InlineObject1138
}

func (r ApiUsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) InlineObject1138(inlineObject1138 InlineObject1138) ApiUsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject1138 = &inlineObject1138
	return r
}

func (r ApiUsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
UsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId key: id of onenoteSection
 @return ApiUsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, userId string, onenotePageId string, onenoteSectionId string) ApiUsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiUsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenotePageId: onenotePageId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r ApiUsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/pages/{onenotePage-id}/parentSection/parentNotebook/sections/{onenoteSection-id}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1138 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1138 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1138
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenotePageId string
	onenoteSectionId string
	inlineObject1139 *InlineObject1139
}

func (r ApiUsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject1139(inlineObject1139 InlineObject1139) ApiUsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject1139 = &inlineObject1139
	return r
}

func (r ApiUsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
UsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId key: id of onenoteSection
 @return ApiUsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, userId string, onenotePageId string, onenoteSectionId string) ApiUsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiUsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenotePageId: onenotePageId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiUsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/pages/{onenotePage-id}/parentSection/parentNotebook/sections/{onenoteSection-id}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1139 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1139 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1139
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenotePageId string
	inlineObject1140 *InlineObject1140
}

func (r ApiUsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookCopyNotebookRequest) InlineObject1140(inlineObject1140 InlineObject1140) ApiUsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookCopyNotebookRequest {
	r.inlineObject1140 = &inlineObject1140
	return r
}

func (r ApiUsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookCopyNotebookExecute(r)
}

/*
UsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenotePageId key: id of onenotePage
 @return ApiUsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookCopyNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookCopyNotebook(ctx _context.Context, userId string, onenotePageId string) ApiUsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookCopyNotebookRequest {
	return ApiUsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookCopyNotebookExecute(r ApiUsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/pages/{onenotePage-id}/parentSection/parentSectionGroup/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1140 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1140 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1140
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenotePageId string
	onenoteSectionId string
	inlineObject1141 *InlineObject1141
}

func (r ApiUsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) InlineObject1141(inlineObject1141 InlineObject1141) ApiUsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject1141 = &inlineObject1141
	return r
}

func (r ApiUsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
UsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId key: id of onenoteSection
 @return ApiUsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, userId string, onenotePageId string, onenoteSectionId string) ApiUsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiUsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenotePageId: onenotePageId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r ApiUsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/pages/{onenotePage-id}/parentSection/parentSectionGroup/parentNotebook/sections/{onenoteSection-id}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1141 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1141 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1141
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenotePageId string
	onenoteSectionId string
	inlineObject1142 *InlineObject1142
}

func (r ApiUsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject1142(inlineObject1142 InlineObject1142) ApiUsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject1142 = &inlineObject1142
	return r
}

func (r ApiUsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
UsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId key: id of onenoteSection
 @return ApiUsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, userId string, onenotePageId string, onenoteSectionId string) ApiUsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiUsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenotePageId: onenotePageId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiUsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/pages/{onenotePage-id}/parentSection/parentSectionGroup/parentNotebook/sections/{onenoteSection-id}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1142 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1142 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1142
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenotePageId string
	onenoteSectionId string
	inlineObject1143 *InlineObject1143
}

func (r ApiUsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) InlineObject1143(inlineObject1143 InlineObject1143) ApiUsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject1143 = &inlineObject1143
	return r
}

func (r ApiUsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
UsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId key: id of onenoteSection
 @return ApiUsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, userId string, onenotePageId string, onenoteSectionId string) ApiUsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiUsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenotePageId: onenotePageId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r ApiUsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/pages/{onenotePage-id}/parentSection/parentSectionGroup/sections/{onenoteSection-id}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1143 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1143 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1143
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenotePageId string
	onenoteSectionId string
	inlineObject1144 *InlineObject1144
}

func (r ApiUsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject1144(inlineObject1144 InlineObject1144) ApiUsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject1144 = &inlineObject1144
	return r
}

func (r ApiUsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
UsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId key: id of onenoteSection
 @return ApiUsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, userId string, onenotePageId string, onenoteSectionId string) ApiUsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiUsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenotePageId: onenotePageId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiUsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/pages/{onenotePage-id}/parentSection/parentSectionGroup/sections/{onenoteSection-id}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1144 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1144 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1144
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sectionGroupId string
	inlineObject1145 *InlineObject1145
}

func (r ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) InlineObject1145(inlineObject1145 InlineObject1145) ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookCopyNotebookRequest {
	r.inlineObject1145 = &inlineObject1145
	return r
}

func (r ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteSectionGroupsSectionGroupParentNotebookCopyNotebookExecute(r)
}

/*
UsersUserOnenoteSectionGroupsSectionGroupParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sectionGroupId key: id of sectionGroup
 @return ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookCopyNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteSectionGroupsSectionGroupParentNotebookCopyNotebook(ctx _context.Context, userId string, sectionGroupId string) ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookCopyNotebookRequest {
	return ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sectionGroupId: sectionGroupId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteSectionGroupsSectionGroupParentNotebookCopyNotebookExecute(r ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteSectionGroupsSectionGroupParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/sectionGroups/{sectionGroup-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1145 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1145 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1145
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sectionGroupId string
	onenoteSectionId string
	inlineObject1146 *InlineObject1146
}

func (r ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) InlineObject1146(inlineObject1146 InlineObject1146) ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject1146 = &inlineObject1146
	return r
}

func (r ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
UsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @return ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, userId string, sectionGroupId string, onenoteSectionId string) ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/sectionGroups/{sectionGroup-id}/parentNotebook/sections/{onenoteSection-id}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1146 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1146 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1146
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sectionGroupId string
	onenoteSectionId string
	inlineObject1147 *InlineObject1147
}

func (r ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject1147(inlineObject1147 InlineObject1147) ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject1147 = &inlineObject1147
	return r
}

func (r ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
UsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @return ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, userId string, sectionGroupId string, onenoteSectionId string) ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/sectionGroups/{sectionGroup-id}/parentNotebook/sections/{onenoteSection-id}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1147 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1147 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1147
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sectionGroupId string
	onenoteSectionId string
	onenotePageId string
	inlineObject1148 *InlineObject1148
}

func (r ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) InlineObject1148(inlineObject1148 InlineObject1148) ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest {
	r.inlineObject1148 = &inlineObject1148
	return r
}

func (r ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionExecute(r)
}

/*
UsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSection Invoke action copyToSection

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSection(ctx _context.Context, userId string, sectionGroupId string, onenoteSectionId string, onenotePageId string) ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest {
	return ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionExecute(r ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSection")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/sectionGroups/{sectionGroup-id}/parentNotebook/sections/{onenoteSection-id}/pages/{onenotePage-id}/microsoft.graph.copyToSection"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1148 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1148 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1148
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sectionGroupId string
	onenoteSectionId string
	onenotePageId string
	inlineObject1149 *InlineObject1149
}

func (r ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) InlineObject1149(inlineObject1149 InlineObject1149) ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest {
	r.inlineObject1149 = &inlineObject1149
	return r
}

func (r ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentExecute(r)
}

/*
UsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent Invoke action onenotePatchContent

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent(ctx _context.Context, userId string, sectionGroupId string, onenoteSectionId string, onenotePageId string) ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest {
	return ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentExecute(r ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/sectionGroups/{sectionGroup-id}/parentNotebook/sections/{onenoteSection-id}/pages/{onenotePage-id}/microsoft.graph.onenotePatchContent"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1149 == nil {
		return nil, reportError("inlineObject1149 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1149
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sectionGroupId string
	onenoteSectionId string
	onenotePageId string
	inlineObject1150 *InlineObject1150
}

func (r ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest) InlineObject1150(inlineObject1150 InlineObject1150) ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest {
	r.inlineObject1150 = &inlineObject1150
	return r
}

func (r ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookExecute(r)
}

/*
UsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebook(ctx _context.Context, userId string, sectionGroupId string, onenoteSectionId string, onenotePageId string) ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest {
	return ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookExecute(r ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/sectionGroups/{sectionGroup-id}/parentNotebook/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1150 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1150 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1150
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sectionGroupId string
	onenoteSectionId string
	onenotePageId string
	inlineObject1151 *InlineObject1151
}

func (r ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest) InlineObject1151(inlineObject1151 InlineObject1151) ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest {
	r.inlineObject1151 = &inlineObject1151
	return r
}

func (r ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookExecute(r)
}

/*
UsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebook(ctx _context.Context, userId string, sectionGroupId string, onenoteSectionId string, onenotePageId string) ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest {
	return ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookExecute(r ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/sectionGroups/{sectionGroup-id}/parentNotebook/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentSection/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1151 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1151 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1151
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sectionGroupId string
	onenoteSectionId string
	onenotePageId string
	inlineObject1152 *InlineObject1152
}

func (r ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest) InlineObject1152(inlineObject1152 InlineObject1152) ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest {
	r.inlineObject1152 = &inlineObject1152
	return r
}

func (r ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupExecute(r)
}

/*
UsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroup(ctx _context.Context, userId string, sectionGroupId string, onenoteSectionId string, onenotePageId string) ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest {
	return ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupExecute(r ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/sectionGroups/{sectionGroup-id}/parentNotebook/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentSection/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1152 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1152 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1152
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sectionGroupId string
	onenoteSectionId string
	inlineObject1153 *InlineObject1153
}

func (r ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest) InlineObject1153(inlineObject1153 InlineObject1153) ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest {
	r.inlineObject1153 = &inlineObject1153
	return r
}

func (r ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookExecute(r)
}

/*
UsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @return ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebook(ctx _context.Context, userId string, sectionGroupId string, onenoteSectionId string) ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest {
	return ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookExecute(r ApiUsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/sectionGroups/{sectionGroup-id}/parentNotebook/sections/{onenoteSection-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1153 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1153 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1153
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sectionGroupId string
	onenoteSectionId string
	inlineObject1154 *InlineObject1154
}

func (r ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) InlineObject1154(inlineObject1154 InlineObject1154) ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject1154 = &inlineObject1154
	return r
}

func (r ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @return ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, userId string, sectionGroupId string, onenoteSectionId string) ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1154 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1154 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1154
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sectionGroupId string
	onenoteSectionId string
	inlineObject1155 *InlineObject1155
}

func (r ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject1155(inlineObject1155 InlineObject1155) ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject1155 = &inlineObject1155
	return r
}

func (r ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @return ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, userId string, sectionGroupId string, onenoteSectionId string) ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1155 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1155 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1155
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sectionGroupId string
	onenoteSectionId string
	onenotePageId string
	inlineObject1156 *InlineObject1156
}

func (r ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) InlineObject1156(inlineObject1156 InlineObject1156) ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest {
	r.inlineObject1156 = &inlineObject1156
	return r
}

func (r ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionExecute(r)
}

/*
UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSection Invoke action copyToSection

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSection(ctx _context.Context, userId string, sectionGroupId string, onenoteSectionId string, onenotePageId string) ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest {
	return ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionExecute(r ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSection")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/pages/{onenotePage-id}/microsoft.graph.copyToSection"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1156 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1156 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1156
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sectionGroupId string
	onenoteSectionId string
	onenotePageId string
	inlineObject1157 *InlineObject1157
}

func (r ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) InlineObject1157(inlineObject1157 InlineObject1157) ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest {
	r.inlineObject1157 = &inlineObject1157
	return r
}

func (r ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentExecute(r)
}

/*
UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent Invoke action onenotePatchContent

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent(ctx _context.Context, userId string, sectionGroupId string, onenoteSectionId string, onenotePageId string) ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest {
	return ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentExecute(r ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/pages/{onenotePage-id}/microsoft.graph.onenotePatchContent"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1157 == nil {
		return nil, reportError("inlineObject1157 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1157
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sectionGroupId string
	onenoteSectionId string
	onenotePageId string
	inlineObject1158 *InlineObject1158
}

func (r ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest) InlineObject1158(inlineObject1158 InlineObject1158) ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest {
	r.inlineObject1158 = &inlineObject1158
	return r
}

func (r ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookExecute(r)
}

/*
UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebook(ctx _context.Context, userId string, sectionGroupId string, onenoteSectionId string, onenotePageId string) ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest {
	return ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookExecute(r ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1158 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1158 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1158
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sectionGroupId string
	onenoteSectionId string
	onenotePageId string
	onenoteSectionId1 string
	inlineObject1159 *InlineObject1159
}

func (r ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) InlineObject1159(inlineObject1159 InlineObject1159) ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject1159 = &inlineObject1159
	return r
}

func (r ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, userId string, sectionGroupId string, onenoteSectionId string, onenotePageId string, onenoteSectionId1 string) ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentNotebook/sections/{onenoteSection-id1}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1159 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1159 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1159
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sectionGroupId string
	onenoteSectionId string
	onenotePageId string
	onenoteSectionId1 string
	inlineObject1160 *InlineObject1160
}

func (r ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject1160(inlineObject1160 InlineObject1160) ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject1160 = &inlineObject1160
	return r
}

func (r ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, userId string, sectionGroupId string, onenoteSectionId string, onenotePageId string, onenoteSectionId1 string) ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentNotebook/sections/{onenoteSection-id1}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1160 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1160 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1160
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sectionGroupId string
	onenoteSectionId string
	onenotePageId string
	inlineObject1161 *InlineObject1161
}

func (r ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest) InlineObject1161(inlineObject1161 InlineObject1161) ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest {
	r.inlineObject1161 = &inlineObject1161
	return r
}

func (r ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookExecute(r)
}

/*
UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebook(ctx _context.Context, userId string, sectionGroupId string, onenoteSectionId string, onenotePageId string) ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest {
	return ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookExecute(r ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentSection/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1161 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1161 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1161
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sectionGroupId string
	onenoteSectionId string
	onenotePageId string
	inlineObject1162 *InlineObject1162
}

func (r ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest) InlineObject1162(inlineObject1162 InlineObject1162) ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest {
	r.inlineObject1162 = &inlineObject1162
	return r
}

func (r ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupExecute(r)
}

/*
UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroup(ctx _context.Context, userId string, sectionGroupId string, onenoteSectionId string, onenotePageId string) ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest {
	return ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupExecute(r ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentSection/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1162 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1162 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1162
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sectionGroupId string
	onenoteSectionId string
	inlineObject1163 *InlineObject1163
}

func (r ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest) InlineObject1163(inlineObject1163 InlineObject1163) ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest {
	r.inlineObject1163 = &inlineObject1163
	return r
}

func (r ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookExecute(r)
}

/*
UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @return ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebook(ctx _context.Context, userId string, sectionGroupId string, onenoteSectionId string) ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest {
	return ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookExecute(r ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1163 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1163 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1163
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sectionGroupId string
	onenoteSectionId string
	onenoteSectionId1 string
	inlineObject1164 *InlineObject1164
}

func (r ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) InlineObject1164(inlineObject1164 InlineObject1164) ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject1164 = &inlineObject1164
	return r
}

func (r ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, userId string, sectionGroupId string, onenoteSectionId string, onenoteSectionId1 string) ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/parentNotebook/sections/{onenoteSection-id1}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1164 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1164 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1164
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	sectionGroupId string
	onenoteSectionId string
	onenoteSectionId1 string
	inlineObject1165 *InlineObject1165
}

func (r ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject1165(inlineObject1165 InlineObject1165) ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject1165 = &inlineObject1165
	return r
}

func (r ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, userId string, sectionGroupId string, onenoteSectionId string, onenoteSectionId1 string) ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiUsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/parentNotebook/sections/{onenoteSection-id1}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1165 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1165 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1165
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenoteSectionId string
	inlineObject1166 *InlineObject1166
}

func (r ApiUsersUserOnenoteSectionsOnenoteSectionCopyToNotebookRequest) InlineObject1166(inlineObject1166 InlineObject1166) ApiUsersUserOnenoteSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject1166 = &inlineObject1166
	return r
}

func (r ApiUsersUserOnenoteSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
UsersUserOnenoteSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenoteSectionId key: id of onenoteSection
 @return ApiUsersUserOnenoteSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, userId string, onenoteSectionId string) ApiUsersUserOnenoteSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiUsersUserOnenoteSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteSectionsOnenoteSectionCopyToNotebookExecute(r ApiUsersUserOnenoteSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/sections/{onenoteSection-id}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1166 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1166 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1166
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenoteSectionId string
	inlineObject1167 *InlineObject1167
}

func (r ApiUsersUserOnenoteSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject1167(inlineObject1167 InlineObject1167) ApiUsersUserOnenoteSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject1167 = &inlineObject1167
	return r
}

func (r ApiUsersUserOnenoteSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
UsersUserOnenoteSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenoteSectionId key: id of onenoteSection
 @return ApiUsersUserOnenoteSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, userId string, onenoteSectionId string) ApiUsersUserOnenoteSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiUsersUserOnenoteSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiUsersUserOnenoteSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/sections/{onenoteSection-id}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1167 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1167 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1167
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenoteSectionId string
	onenotePageId string
	inlineObject1168 *InlineObject1168
}

func (r ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) InlineObject1168(inlineObject1168 InlineObject1168) ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest {
	r.inlineObject1168 = &inlineObject1168
	return r
}

func (r ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageCopyToSectionExecute(r)
}

/*
UsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageCopyToSection Invoke action copyToSection

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageCopyToSection(ctx _context.Context, userId string, onenoteSectionId string, onenotePageId string) ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest {
	return ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageCopyToSectionExecute(r ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageCopyToSection")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/sections/{onenoteSection-id}/pages/{onenotePage-id}/microsoft.graph.copyToSection"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1168 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1168 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1168
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenoteSectionId string
	onenotePageId string
	inlineObject1169 *InlineObject1169
}

func (r ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) InlineObject1169(inlineObject1169 InlineObject1169) ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest {
	r.inlineObject1169 = &inlineObject1169
	return r
}

func (r ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentExecute(r)
}

/*
UsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent Invoke action onenotePatchContent

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent(ctx _context.Context, userId string, onenoteSectionId string, onenotePageId string) ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest {
	return ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentExecute(r ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/sections/{onenoteSection-id}/pages/{onenotePage-id}/microsoft.graph.onenotePatchContent"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1169 == nil {
		return nil, reportError("inlineObject1169 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1169
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenoteSectionId string
	onenotePageId string
	inlineObject1170 *InlineObject1170
}

func (r ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest) InlineObject1170(inlineObject1170 InlineObject1170) ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest {
	r.inlineObject1170 = &inlineObject1170
	return r
}

func (r ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookExecute(r)
}

/*
UsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebook(ctx _context.Context, userId string, onenoteSectionId string, onenotePageId string) ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest {
	return ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookExecute(r ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1170 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1170 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1170
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenoteSectionId string
	onenotePageId string
	sectionGroupId string
	inlineObject1171 *InlineObject1171
}

func (r ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) InlineObject1171(inlineObject1171 InlineObject1171) ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest {
	r.inlineObject1171 = &inlineObject1171
	return r
}

func (r ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookExecute(r)
}

/*
UsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @param sectionGroupId key: id of sectionGroup
 @return ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebook(ctx _context.Context, userId string, onenoteSectionId string, onenotePageId string, sectionGroupId string) ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest {
	return ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
		sectionGroupId: sectionGroupId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookExecute(r ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentNotebook/sectionGroups/{sectionGroup-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1171 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1171 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1171
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenoteSectionId string
	onenotePageId string
	sectionGroupId string
	onenoteSectionId1 string
	inlineObject1172 *InlineObject1172
}

func (r ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) InlineObject1172(inlineObject1172 InlineObject1172) ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject1172 = &inlineObject1172
	return r
}

func (r ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
UsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, userId string, onenoteSectionId string, onenotePageId string, sectionGroupId string, onenoteSectionId1 string) ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentNotebook/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id1}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1172 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1172 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1172
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenoteSectionId string
	onenotePageId string
	sectionGroupId string
	onenoteSectionId1 string
	inlineObject1173 *InlineObject1173
}

func (r ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject1173(inlineObject1173 InlineObject1173) ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject1173 = &inlineObject1173
	return r
}

func (r ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
UsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, userId string, onenoteSectionId string, onenotePageId string, sectionGroupId string, onenoteSectionId1 string) ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentNotebook/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id1}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1173 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1173 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1173
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenoteSectionId string
	onenotePageId string
	onenoteSectionId1 string
	inlineObject1174 *InlineObject1174
}

func (r ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) InlineObject1174(inlineObject1174 InlineObject1174) ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject1174 = &inlineObject1174
	return r
}

func (r ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
UsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, userId string, onenoteSectionId string, onenotePageId string, onenoteSectionId1 string) ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentNotebook/sections/{onenoteSection-id1}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1174 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1174 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1174
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenoteSectionId string
	onenotePageId string
	onenoteSectionId1 string
	inlineObject1175 *InlineObject1175
}

func (r ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject1175(inlineObject1175 InlineObject1175) ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject1175 = &inlineObject1175
	return r
}

func (r ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
UsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, userId string, onenoteSectionId string, onenotePageId string, onenoteSectionId1 string) ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentNotebook/sections/{onenoteSection-id1}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1175 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1175 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1175
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenoteSectionId string
	onenotePageId string
	inlineObject1176 *InlineObject1176
}

func (r ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest) InlineObject1176(inlineObject1176 InlineObject1176) ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest {
	r.inlineObject1176 = &inlineObject1176
	return r
}

func (r ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookExecute(r)
}

/*
UsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebook(ctx _context.Context, userId string, onenoteSectionId string, onenotePageId string) ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest {
	return ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookExecute(r ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentSection/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1176 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1176 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1176
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenoteSectionId string
	onenotePageId string
	inlineObject1177 *InlineObject1177
}

func (r ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest) InlineObject1177(inlineObject1177 InlineObject1177) ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest {
	r.inlineObject1177 = &inlineObject1177
	return r
}

func (r ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupExecute(r)
}

/*
UsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroup(ctx _context.Context, userId string, onenoteSectionId string, onenotePageId string) ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest {
	return ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupExecute(r ApiUsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentSection/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1177 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1177 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1177
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteSectionsOnenoteSectionParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenoteSectionId string
	inlineObject1178 *InlineObject1178
}

func (r ApiUsersUserOnenoteSectionsOnenoteSectionParentNotebookCopyNotebookRequest) InlineObject1178(inlineObject1178 InlineObject1178) ApiUsersUserOnenoteSectionsOnenoteSectionParentNotebookCopyNotebookRequest {
	r.inlineObject1178 = &inlineObject1178
	return r
}

func (r ApiUsersUserOnenoteSectionsOnenoteSectionParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteSectionsOnenoteSectionParentNotebookCopyNotebookExecute(r)
}

/*
UsersUserOnenoteSectionsOnenoteSectionParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenoteSectionId key: id of onenoteSection
 @return ApiUsersUserOnenoteSectionsOnenoteSectionParentNotebookCopyNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteSectionsOnenoteSectionParentNotebookCopyNotebook(ctx _context.Context, userId string, onenoteSectionId string) ApiUsersUserOnenoteSectionsOnenoteSectionParentNotebookCopyNotebookRequest {
	return ApiUsersUserOnenoteSectionsOnenoteSectionParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteSectionsOnenoteSectionParentNotebookCopyNotebookExecute(r ApiUsersUserOnenoteSectionsOnenoteSectionParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteSectionsOnenoteSectionParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/sections/{onenoteSection-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1178 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1178 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1178
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenoteSectionId string
	sectionGroupId string
	inlineObject1179 *InlineObject1179
}

func (r ApiUsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) InlineObject1179(inlineObject1179 InlineObject1179) ApiUsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest {
	r.inlineObject1179 = &inlineObject1179
	return r
}

func (r ApiUsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookExecute(r)
}

/*
UsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenoteSectionId key: id of onenoteSection
 @param sectionGroupId key: id of sectionGroup
 @return ApiUsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebook(ctx _context.Context, userId string, onenoteSectionId string, sectionGroupId string) ApiUsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest {
	return ApiUsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenoteSectionId: onenoteSectionId,
		sectionGroupId: sectionGroupId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookExecute(r ApiUsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/sections/{onenoteSection-id}/parentNotebook/sectionGroups/{sectionGroup-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1179 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1179 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1179
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenoteSectionId string
	sectionGroupId string
	onenoteSectionId1 string
	inlineObject1180 *InlineObject1180
}

func (r ApiUsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) InlineObject1180(inlineObject1180 InlineObject1180) ApiUsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject1180 = &inlineObject1180
	return r
}

func (r ApiUsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
UsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenoteSectionId key: id of onenoteSection
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiUsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, userId string, onenoteSectionId string, sectionGroupId string, onenoteSectionId1 string) ApiUsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiUsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenoteSectionId: onenoteSectionId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r ApiUsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/sections/{onenoteSection-id}/parentNotebook/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id1}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1180 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1180 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1180
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenoteSectionId string
	sectionGroupId string
	onenoteSectionId1 string
	inlineObject1181 *InlineObject1181
}

func (r ApiUsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject1181(inlineObject1181 InlineObject1181) ApiUsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject1181 = &inlineObject1181
	return r
}

func (r ApiUsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
UsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenoteSectionId key: id of onenoteSection
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiUsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, userId string, onenoteSectionId string, sectionGroupId string, onenoteSectionId1 string) ApiUsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiUsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenoteSectionId: onenoteSectionId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiUsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/sections/{onenoteSection-id}/parentNotebook/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id1}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1181 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1181 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1181
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenoteSectionId string
	onenoteSectionId1 string
	inlineObject1182 *InlineObject1182
}

func (r ApiUsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) InlineObject1182(inlineObject1182 InlineObject1182) ApiUsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject1182 = &inlineObject1182
	return r
}

func (r ApiUsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
UsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenoteSectionId key: id of onenoteSection
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiUsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, userId string, onenoteSectionId string, onenoteSectionId1 string) ApiUsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiUsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenoteSectionId: onenoteSectionId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r ApiUsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/sections/{onenoteSection-id}/parentNotebook/sections/{onenoteSection-id1}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1182 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1182 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1182
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenoteSectionId string
	onenoteSectionId1 string
	inlineObject1183 *InlineObject1183
}

func (r ApiUsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject1183(inlineObject1183 InlineObject1183) ApiUsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject1183 = &inlineObject1183
	return r
}

func (r ApiUsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
UsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenoteSectionId key: id of onenoteSection
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiUsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, userId string, onenoteSectionId string, onenoteSectionId1 string) ApiUsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiUsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenoteSectionId: onenoteSectionId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiUsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/sections/{onenoteSection-id}/parentNotebook/sections/{onenoteSection-id1}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1183 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1183 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1183
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenoteSectionId string
	inlineObject1184 *InlineObject1184
}

func (r ApiUsersUserOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest) InlineObject1184(inlineObject1184 InlineObject1184) ApiUsersUserOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest {
	r.inlineObject1184 = &inlineObject1184
	return r
}

func (r ApiUsersUserOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookExecute(r)
}

/*
UsersUserOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenoteSectionId key: id of onenoteSection
 @return ApiUsersUserOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebook(ctx _context.Context, userId string, onenoteSectionId string) ApiUsersUserOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest {
	return ApiUsersUserOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookExecute(r ApiUsersUserOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/sections/{onenoteSection-id}/parentSectionGroup/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1184 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1184 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1184
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenoteSectionId string
	onenoteSectionId1 string
	inlineObject1185 *InlineObject1185
}

func (r ApiUsersUserOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) InlineObject1185(inlineObject1185 InlineObject1185) ApiUsersUserOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject1185 = &inlineObject1185
	return r
}

func (r ApiUsersUserOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
UsersUserOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenoteSectionId key: id of onenoteSection
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiUsersUserOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, userId string, onenoteSectionId string, onenoteSectionId1 string) ApiUsersUserOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiUsersUserOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenoteSectionId: onenoteSectionId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r ApiUsersUserOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/sections/{onenoteSection-id}/parentSectionGroup/parentNotebook/sections/{onenoteSection-id1}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1185 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1185 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1185
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenoteSectionId string
	onenoteSectionId1 string
	inlineObject1186 *InlineObject1186
}

func (r ApiUsersUserOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject1186(inlineObject1186 InlineObject1186) ApiUsersUserOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject1186 = &inlineObject1186
	return r
}

func (r ApiUsersUserOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
UsersUserOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenoteSectionId key: id of onenoteSection
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiUsersUserOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, userId string, onenoteSectionId string, onenoteSectionId1 string) ApiUsersUserOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiUsersUserOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenoteSectionId: onenoteSectionId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiUsersUserOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/sections/{onenoteSection-id}/parentSectionGroup/parentNotebook/sections/{onenoteSection-id1}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1186 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1186 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1186
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenoteSectionId string
	onenoteSectionId1 string
	inlineObject1187 *InlineObject1187
}

func (r ApiUsersUserOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) InlineObject1187(inlineObject1187 InlineObject1187) ApiUsersUserOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject1187 = &inlineObject1187
	return r
}

func (r ApiUsersUserOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
UsersUserOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenoteSectionId key: id of onenoteSection
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiUsersUserOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, userId string, onenoteSectionId string, onenoteSectionId1 string) ApiUsersUserOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiUsersUserOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenoteSectionId: onenoteSectionId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r ApiUsersUserOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/sections/{onenoteSection-id}/parentSectionGroup/sections/{onenoteSection-id1}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1187 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1187 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1187
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	onenoteSectionId string
	onenoteSectionId1 string
	inlineObject1188 *InlineObject1188
}

func (r ApiUsersUserOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject1188(inlineObject1188 InlineObject1188) ApiUsersUserOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject1188 = &inlineObject1188
	return r
}

func (r ApiUsersUserOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
UsersUserOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param onenoteSectionId key: id of onenoteSection
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiUsersUserOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *UsersActionsApiService) UsersUserOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, userId string, onenoteSectionId string, onenoteSectionId1 string) ApiUsersUserOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiUsersUserOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		onenoteSectionId: onenoteSectionId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *UsersActionsApiService) UsersUserOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiUsersUserOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onenote/sections/{onenoteSection-id}/parentSectionGroup/sections/{onenoteSection-id1}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1188 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1188 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1188
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserOnlineMeetingsCreateOrGetRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	inlineObject1189 *InlineObject1189
}

func (r ApiUsersUserOnlineMeetingsCreateOrGetRequest) InlineObject1189(inlineObject1189 InlineObject1189) ApiUsersUserOnlineMeetingsCreateOrGetRequest {
	r.inlineObject1189 = &inlineObject1189
	return r
}

func (r ApiUsersUserOnlineMeetingsCreateOrGetRequest) Execute() (AnyOfmicrosoftGraphOnlineMeeting, *_nethttp.Response, error) {
	return r.ApiService.UsersUserOnlineMeetingsCreateOrGetExecute(r)
}

/*
UsersUserOnlineMeetingsCreateOrGet Invoke action createOrGet

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @return ApiUsersUserOnlineMeetingsCreateOrGetRequest
*/
func (a *UsersActionsApiService) UsersUserOnlineMeetingsCreateOrGet(ctx _context.Context, userId string) ApiUsersUserOnlineMeetingsCreateOrGetRequest {
	return ApiUsersUserOnlineMeetingsCreateOrGetRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnlineMeeting
func (a *UsersActionsApiService) UsersUserOnlineMeetingsCreateOrGetExecute(r ApiUsersUserOnlineMeetingsCreateOrGetRequest) (AnyOfmicrosoftGraphOnlineMeeting, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnlineMeeting
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserOnlineMeetingsCreateOrGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/onlineMeetings/microsoft.graph.createOrGet"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1189 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1189 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1189
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserPresenceClearPresenceRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	inlineObject1190 *InlineObject1190
}

func (r ApiUsersUserPresenceClearPresenceRequest) InlineObject1190(inlineObject1190 InlineObject1190) ApiUsersUserPresenceClearPresenceRequest {
	r.inlineObject1190 = &inlineObject1190
	return r
}

func (r ApiUsersUserPresenceClearPresenceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserPresenceClearPresenceExecute(r)
}

/*
UsersUserPresenceClearPresence Invoke action clearPresence

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @return ApiUsersUserPresenceClearPresenceRequest
*/
func (a *UsersActionsApiService) UsersUserPresenceClearPresence(ctx _context.Context, userId string) ApiUsersUserPresenceClearPresenceRequest {
	return ApiUsersUserPresenceClearPresenceRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserPresenceClearPresenceExecute(r ApiUsersUserPresenceClearPresenceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserPresenceClearPresence")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/presence/microsoft.graph.clearPresence"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1190 == nil {
		return nil, reportError("inlineObject1190 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1190
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserPresenceSetPresenceRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	inlineObject1191 *InlineObject1191
}

func (r ApiUsersUserPresenceSetPresenceRequest) InlineObject1191(inlineObject1191 InlineObject1191) ApiUsersUserPresenceSetPresenceRequest {
	r.inlineObject1191 = &inlineObject1191
	return r
}

func (r ApiUsersUserPresenceSetPresenceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserPresenceSetPresenceExecute(r)
}

/*
UsersUserPresenceSetPresence Invoke action setPresence

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @return ApiUsersUserPresenceSetPresenceRequest
*/
func (a *UsersActionsApiService) UsersUserPresenceSetPresence(ctx _context.Context, userId string) ApiUsersUserPresenceSetPresenceRequest {
	return ApiUsersUserPresenceSetPresenceRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserPresenceSetPresenceExecute(r ApiUsersUserPresenceSetPresenceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserPresenceSetPresence")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/presence/microsoft.graph.setPresence"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1191 == nil {
		return nil, reportError("inlineObject1191 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1191
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserRemoveAllDevicesFromManagementRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
}


func (r ApiUsersUserRemoveAllDevicesFromManagementRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserRemoveAllDevicesFromManagementExecute(r)
}

/*
UsersUserRemoveAllDevicesFromManagement Invoke action removeAllDevicesFromManagement

Retire all devices from management for this user

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @return ApiUsersUserRemoveAllDevicesFromManagementRequest
*/
func (a *UsersActionsApiService) UsersUserRemoveAllDevicesFromManagement(ctx _context.Context, userId string) ApiUsersUserRemoveAllDevicesFromManagementRequest {
	return ApiUsersUserRemoveAllDevicesFromManagementRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserRemoveAllDevicesFromManagementExecute(r ApiUsersUserRemoveAllDevicesFromManagementRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserRemoveAllDevicesFromManagement")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/microsoft.graph.removeAllDevicesFromManagement"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserReprocessLicenseAssignmentRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
}


func (r ApiUsersUserReprocessLicenseAssignmentRequest) Execute() (AnyOfmicrosoftGraphUser, *_nethttp.Response, error) {
	return r.ApiService.UsersUserReprocessLicenseAssignmentExecute(r)
}

/*
UsersUserReprocessLicenseAssignment Invoke action reprocessLicenseAssignment

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @return ApiUsersUserReprocessLicenseAssignmentRequest
*/
func (a *UsersActionsApiService) UsersUserReprocessLicenseAssignment(ctx _context.Context, userId string) ApiUsersUserReprocessLicenseAssignmentRequest {
	return ApiUsersUserReprocessLicenseAssignmentRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphUser
func (a *UsersActionsApiService) UsersUserReprocessLicenseAssignmentExecute(r ApiUsersUserReprocessLicenseAssignmentRequest) (AnyOfmicrosoftGraphUser, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphUser
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserReprocessLicenseAssignment")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/microsoft.graph.reprocessLicenseAssignment"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserRestoreRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
}


func (r ApiUsersUserRestoreRequest) Execute() (AnyOfmicrosoftGraphDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.UsersUserRestoreExecute(r)
}

/*
UsersUserRestore Invoke action restore

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @return ApiUsersUserRestoreRequest
*/
func (a *UsersActionsApiService) UsersUserRestore(ctx _context.Context, userId string) ApiUsersUserRestoreRequest {
	return ApiUsersUserRestoreRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphDirectoryObject
func (a *UsersActionsApiService) UsersUserRestoreExecute(r ApiUsersUserRestoreRequest) (AnyOfmicrosoftGraphDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserRestore")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/microsoft.graph.restore"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserRevokeSignInSessionsRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
}


func (r ApiUsersUserRevokeSignInSessionsRequest) Execute() (bool, *_nethttp.Response, error) {
	return r.ApiService.UsersUserRevokeSignInSessionsExecute(r)
}

/*
UsersUserRevokeSignInSessions Invoke action revokeSignInSessions

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @return ApiUsersUserRevokeSignInSessionsRequest
*/
func (a *UsersActionsApiService) UsersUserRevokeSignInSessions(ctx _context.Context, userId string) ApiUsersUserRevokeSignInSessionsRequest {
	return ApiUsersUserRevokeSignInSessionsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return bool
func (a *UsersActionsApiService) UsersUserRevokeSignInSessionsExecute(r ApiUsersUserRevokeSignInSessionsRequest) (bool, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  bool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserRevokeSignInSessions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/microsoft.graph.revokeSignInSessions"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserSendMailRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	inlineObject1088 *InlineObject1088
}

func (r ApiUsersUserSendMailRequest) InlineObject1088(inlineObject1088 InlineObject1088) ApiUsersUserSendMailRequest {
	r.inlineObject1088 = &inlineObject1088
	return r
}

func (r ApiUsersUserSendMailRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserSendMailExecute(r)
}

/*
UsersUserSendMail Invoke action sendMail

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @return ApiUsersUserSendMailRequest
*/
func (a *UsersActionsApiService) UsersUserSendMail(ctx _context.Context, userId string) ApiUsersUserSendMailRequest {
	return ApiUsersUserSendMailRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserSendMailExecute(r ApiUsersUserSendMailRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserSendMail")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/microsoft.graph.sendMail"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1088 == nil {
		return nil, reportError("inlineObject1088 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1088
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserTeamworkSendActivityNotificationRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	inlineObject1192 *InlineObject1192
}

func (r ApiUsersUserTeamworkSendActivityNotificationRequest) InlineObject1192(inlineObject1192 InlineObject1192) ApiUsersUserTeamworkSendActivityNotificationRequest {
	r.inlineObject1192 = &inlineObject1192
	return r
}

func (r ApiUsersUserTeamworkSendActivityNotificationRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserTeamworkSendActivityNotificationExecute(r)
}

/*
UsersUserTeamworkSendActivityNotification Invoke action sendActivityNotification

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @return ApiUsersUserTeamworkSendActivityNotificationRequest
*/
func (a *UsersActionsApiService) UsersUserTeamworkSendActivityNotification(ctx _context.Context, userId string) ApiUsersUserTeamworkSendActivityNotificationRequest {
	return ApiUsersUserTeamworkSendActivityNotificationRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserTeamworkSendActivityNotificationExecute(r ApiUsersUserTeamworkSendActivityNotificationRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserTeamworkSendActivityNotification")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/teamwork/microsoft.graph.sendActivityNotification"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1192 == nil {
		return nil, reportError("inlineObject1192 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1192
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUserTranslateExchangeIdsRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	inlineObject1089 *InlineObject1089
}

func (r ApiUsersUserTranslateExchangeIdsRequest) InlineObject1089(inlineObject1089 InlineObject1089) ApiUsersUserTranslateExchangeIdsRequest {
	r.inlineObject1089 = &inlineObject1089
	return r
}

func (r ApiUsersUserTranslateExchangeIdsRequest) Execute() ([]MicrosoftGraphConvertIdResult, *_nethttp.Response, error) {
	return r.ApiService.UsersUserTranslateExchangeIdsExecute(r)
}

/*
UsersUserTranslateExchangeIds Invoke action translateExchangeIds

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @return ApiUsersUserTranslateExchangeIdsRequest
*/
func (a *UsersActionsApiService) UsersUserTranslateExchangeIds(ctx _context.Context, userId string) ApiUsersUserTranslateExchangeIdsRequest {
	return ApiUsersUserTranslateExchangeIdsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return []MicrosoftGraphConvertIdResult
func (a *UsersActionsApiService) UsersUserTranslateExchangeIdsExecute(r ApiUsersUserTranslateExchangeIdsRequest) ([]MicrosoftGraphConvertIdResult, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []MicrosoftGraphConvertIdResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserTranslateExchangeIds")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/microsoft.graph.translateExchangeIds"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1089 == nil {
		return localVarReturnValue, nil, reportError("inlineObject1089 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1089
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUserWipeManagedAppRegistrationsByDeviceTagRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	userId string
	inlineObject1090 *InlineObject1090
}

func (r ApiUsersUserWipeManagedAppRegistrationsByDeviceTagRequest) InlineObject1090(inlineObject1090 InlineObject1090) ApiUsersUserWipeManagedAppRegistrationsByDeviceTagRequest {
	r.inlineObject1090 = &inlineObject1090
	return r
}

func (r ApiUsersUserWipeManagedAppRegistrationsByDeviceTagRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUserWipeManagedAppRegistrationsByDeviceTagExecute(r)
}

/*
UsersUserWipeManagedAppRegistrationsByDeviceTag Invoke action wipeManagedAppRegistrationsByDeviceTag

Issues a wipe operation on an app registration with specified device tag.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @return ApiUsersUserWipeManagedAppRegistrationsByDeviceTagRequest
*/
func (a *UsersActionsApiService) UsersUserWipeManagedAppRegistrationsByDeviceTag(ctx _context.Context, userId string) ApiUsersUserWipeManagedAppRegistrationsByDeviceTagRequest {
	return ApiUsersUserWipeManagedAppRegistrationsByDeviceTagRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersUserWipeManagedAppRegistrationsByDeviceTagExecute(r ApiUsersUserWipeManagedAppRegistrationsByDeviceTagRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersUserWipeManagedAppRegistrationsByDeviceTag")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/microsoft.graph.wipeManagedAppRegistrationsByDeviceTag"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1090 == nil {
		return nil, reportError("inlineObject1090 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1090
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersValidatePropertiesRequest struct {
	ctx _context.Context
	ApiService *UsersActionsApiService
	inlineObject1195 *InlineObject1195
}

func (r ApiUsersValidatePropertiesRequest) InlineObject1195(inlineObject1195 InlineObject1195) ApiUsersValidatePropertiesRequest {
	r.inlineObject1195 = &inlineObject1195
	return r
}

func (r ApiUsersValidatePropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersValidatePropertiesExecute(r)
}

/*
UsersValidateProperties Invoke action validateProperties

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsersValidatePropertiesRequest
*/
func (a *UsersActionsApiService) UsersValidateProperties(ctx _context.Context) ApiUsersValidatePropertiesRequest {
	return ApiUsersValidatePropertiesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *UsersActionsApiService) UsersValidatePropertiesExecute(r ApiUsersValidatePropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersActionsApiService.UsersValidateProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/microsoft.graph.validateProperties"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject1195 == nil {
		return nil, reportError("inlineObject1195 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject1195
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
