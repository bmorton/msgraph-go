/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package msgraph

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// RoleManagementRbacApplicationApiService RoleManagementRbacApplicationApi service
type RoleManagementRbacApplicationApiService service

type ApiRoleManagementDeleteDirectoryRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	ifMatch *string
}

// ETag
func (r ApiRoleManagementDeleteDirectoryRequest) IfMatch(ifMatch string) ApiRoleManagementDeleteDirectoryRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiRoleManagementDeleteDirectoryRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RoleManagementDeleteDirectoryExecute(r)
}

/*
RoleManagementDeleteDirectory Delete navigation property directory for roleManagement

Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRoleManagementDeleteDirectoryRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementDeleteDirectory(ctx _context.Context) ApiRoleManagementDeleteDirectoryRequest {
	return ApiRoleManagementDeleteDirectoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RoleManagementRbacApplicationApiService) RoleManagementDeleteDirectoryExecute(r ApiRoleManagementDeleteDirectoryRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementDeleteDirectory")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/directory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRoleManagementDeleteEntitlementManagementRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	ifMatch *string
}

// ETag
func (r ApiRoleManagementDeleteEntitlementManagementRequest) IfMatch(ifMatch string) ApiRoleManagementDeleteEntitlementManagementRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiRoleManagementDeleteEntitlementManagementRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RoleManagementDeleteEntitlementManagementExecute(r)
}

/*
RoleManagementDeleteEntitlementManagement Delete navigation property entitlementManagement for roleManagement

Container for all entitlement management resources in Azure AD identity governance.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRoleManagementDeleteEntitlementManagementRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementDeleteEntitlementManagement(ctx _context.Context) ApiRoleManagementDeleteEntitlementManagementRequest {
	return ApiRoleManagementDeleteEntitlementManagementRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RoleManagementRbacApplicationApiService) RoleManagementDeleteEntitlementManagementExecute(r ApiRoleManagementDeleteEntitlementManagementRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementDeleteEntitlementManagement")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/entitlementManagement"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRoleManagementDirectoryCreateRoleAssignmentsRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	microsoftGraphUnifiedRoleAssignment *MicrosoftGraphUnifiedRoleAssignment
}

// New navigation property
func (r ApiRoleManagementDirectoryCreateRoleAssignmentsRequest) MicrosoftGraphUnifiedRoleAssignment(microsoftGraphUnifiedRoleAssignment MicrosoftGraphUnifiedRoleAssignment) ApiRoleManagementDirectoryCreateRoleAssignmentsRequest {
	r.microsoftGraphUnifiedRoleAssignment = &microsoftGraphUnifiedRoleAssignment
	return r
}

func (r ApiRoleManagementDirectoryCreateRoleAssignmentsRequest) Execute() (MicrosoftGraphUnifiedRoleAssignment, *_nethttp.Response, error) {
	return r.ApiService.RoleManagementDirectoryCreateRoleAssignmentsExecute(r)
}

/*
RoleManagementDirectoryCreateRoleAssignments Create new navigation property to roleAssignments for roleManagement

Resource to grant access to users or groups.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRoleManagementDirectoryCreateRoleAssignmentsRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryCreateRoleAssignments(ctx _context.Context) ApiRoleManagementDirectoryCreateRoleAssignmentsRequest {
	return ApiRoleManagementDirectoryCreateRoleAssignmentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphUnifiedRoleAssignment
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryCreateRoleAssignmentsExecute(r ApiRoleManagementDirectoryCreateRoleAssignmentsRequest) (MicrosoftGraphUnifiedRoleAssignment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphUnifiedRoleAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementDirectoryCreateRoleAssignments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/directory/roleAssignments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphUnifiedRoleAssignment == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphUnifiedRoleAssignment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphUnifiedRoleAssignment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRoleManagementDirectoryCreateRoleDefinitionsRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	microsoftGraphUnifiedRoleDefinition *MicrosoftGraphUnifiedRoleDefinition
}

// New navigation property
func (r ApiRoleManagementDirectoryCreateRoleDefinitionsRequest) MicrosoftGraphUnifiedRoleDefinition(microsoftGraphUnifiedRoleDefinition MicrosoftGraphUnifiedRoleDefinition) ApiRoleManagementDirectoryCreateRoleDefinitionsRequest {
	r.microsoftGraphUnifiedRoleDefinition = &microsoftGraphUnifiedRoleDefinition
	return r
}

func (r ApiRoleManagementDirectoryCreateRoleDefinitionsRequest) Execute() (MicrosoftGraphUnifiedRoleDefinition, *_nethttp.Response, error) {
	return r.ApiService.RoleManagementDirectoryCreateRoleDefinitionsExecute(r)
}

/*
RoleManagementDirectoryCreateRoleDefinitions Create new navigation property to roleDefinitions for roleManagement

Resource representing the roles allowed by RBAC providers and the permissions assigned to the roles.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRoleManagementDirectoryCreateRoleDefinitionsRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryCreateRoleDefinitions(ctx _context.Context) ApiRoleManagementDirectoryCreateRoleDefinitionsRequest {
	return ApiRoleManagementDirectoryCreateRoleDefinitionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphUnifiedRoleDefinition
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryCreateRoleDefinitionsExecute(r ApiRoleManagementDirectoryCreateRoleDefinitionsRequest) (MicrosoftGraphUnifiedRoleDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphUnifiedRoleDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementDirectoryCreateRoleDefinitions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/directory/roleDefinitions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphUnifiedRoleDefinition == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphUnifiedRoleDefinition is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphUnifiedRoleDefinition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRoleManagementDirectoryDeleteRoleAssignmentsRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleAssignmentId string
	ifMatch *string
}

// ETag
func (r ApiRoleManagementDirectoryDeleteRoleAssignmentsRequest) IfMatch(ifMatch string) ApiRoleManagementDirectoryDeleteRoleAssignmentsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiRoleManagementDirectoryDeleteRoleAssignmentsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RoleManagementDirectoryDeleteRoleAssignmentsExecute(r)
}

/*
RoleManagementDirectoryDeleteRoleAssignments Delete navigation property roleAssignments for roleManagement

Resource to grant access to users or groups.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleAssignmentId key: id of unifiedRoleAssignment
 @return ApiRoleManagementDirectoryDeleteRoleAssignmentsRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryDeleteRoleAssignments(ctx _context.Context, unifiedRoleAssignmentId string) ApiRoleManagementDirectoryDeleteRoleAssignmentsRequest {
	return ApiRoleManagementDirectoryDeleteRoleAssignmentsRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleAssignmentId: unifiedRoleAssignmentId,
	}
}

// Execute executes the request
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryDeleteRoleAssignmentsExecute(r ApiRoleManagementDirectoryDeleteRoleAssignmentsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementDirectoryDeleteRoleAssignments")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/directory/roleAssignments/{unifiedRoleAssignment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRoleManagementDirectoryDeleteRoleDefinitionsRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleDefinitionId string
	ifMatch *string
}

// ETag
func (r ApiRoleManagementDirectoryDeleteRoleDefinitionsRequest) IfMatch(ifMatch string) ApiRoleManagementDirectoryDeleteRoleDefinitionsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiRoleManagementDirectoryDeleteRoleDefinitionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RoleManagementDirectoryDeleteRoleDefinitionsExecute(r)
}

/*
RoleManagementDirectoryDeleteRoleDefinitions Delete navigation property roleDefinitions for roleManagement

Resource representing the roles allowed by RBAC providers and the permissions assigned to the roles.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleDefinitionId key: id of unifiedRoleDefinition
 @return ApiRoleManagementDirectoryDeleteRoleDefinitionsRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryDeleteRoleDefinitions(ctx _context.Context, unifiedRoleDefinitionId string) ApiRoleManagementDirectoryDeleteRoleDefinitionsRequest {
	return ApiRoleManagementDirectoryDeleteRoleDefinitionsRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleDefinitionId: unifiedRoleDefinitionId,
	}
}

// Execute executes the request
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryDeleteRoleDefinitionsExecute(r ApiRoleManagementDirectoryDeleteRoleDefinitionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementDirectoryDeleteRoleDefinitions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/directory/roleDefinitions/{unifiedRoleDefinition-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRoleManagementDirectoryGetRoleAssignmentsRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleAssignmentId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiRoleManagementDirectoryGetRoleAssignmentsRequest) Select_(select_ []string) ApiRoleManagementDirectoryGetRoleAssignmentsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiRoleManagementDirectoryGetRoleAssignmentsRequest) Expand(expand []string) ApiRoleManagementDirectoryGetRoleAssignmentsRequest {
	r.expand = &expand
	return r
}

func (r ApiRoleManagementDirectoryGetRoleAssignmentsRequest) Execute() (MicrosoftGraphUnifiedRoleAssignment, *_nethttp.Response, error) {
	return r.ApiService.RoleManagementDirectoryGetRoleAssignmentsExecute(r)
}

/*
RoleManagementDirectoryGetRoleAssignments Get roleAssignments from roleManagement

Resource to grant access to users or groups.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleAssignmentId key: id of unifiedRoleAssignment
 @return ApiRoleManagementDirectoryGetRoleAssignmentsRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryGetRoleAssignments(ctx _context.Context, unifiedRoleAssignmentId string) ApiRoleManagementDirectoryGetRoleAssignmentsRequest {
	return ApiRoleManagementDirectoryGetRoleAssignmentsRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleAssignmentId: unifiedRoleAssignmentId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphUnifiedRoleAssignment
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryGetRoleAssignmentsExecute(r ApiRoleManagementDirectoryGetRoleAssignmentsRequest) (MicrosoftGraphUnifiedRoleAssignment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphUnifiedRoleAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementDirectoryGetRoleAssignments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/directory/roleAssignments/{unifiedRoleAssignment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRoleManagementDirectoryGetRoleDefinitionsRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleDefinitionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiRoleManagementDirectoryGetRoleDefinitionsRequest) Select_(select_ []string) ApiRoleManagementDirectoryGetRoleDefinitionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiRoleManagementDirectoryGetRoleDefinitionsRequest) Expand(expand []string) ApiRoleManagementDirectoryGetRoleDefinitionsRequest {
	r.expand = &expand
	return r
}

func (r ApiRoleManagementDirectoryGetRoleDefinitionsRequest) Execute() (MicrosoftGraphUnifiedRoleDefinition, *_nethttp.Response, error) {
	return r.ApiService.RoleManagementDirectoryGetRoleDefinitionsExecute(r)
}

/*
RoleManagementDirectoryGetRoleDefinitions Get roleDefinitions from roleManagement

Resource representing the roles allowed by RBAC providers and the permissions assigned to the roles.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleDefinitionId key: id of unifiedRoleDefinition
 @return ApiRoleManagementDirectoryGetRoleDefinitionsRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryGetRoleDefinitions(ctx _context.Context, unifiedRoleDefinitionId string) ApiRoleManagementDirectoryGetRoleDefinitionsRequest {
	return ApiRoleManagementDirectoryGetRoleDefinitionsRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleDefinitionId: unifiedRoleDefinitionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphUnifiedRoleDefinition
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryGetRoleDefinitionsExecute(r ApiRoleManagementDirectoryGetRoleDefinitionsRequest) (MicrosoftGraphUnifiedRoleDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphUnifiedRoleDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementDirectoryGetRoleDefinitions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/directory/roleDefinitions/{unifiedRoleDefinition-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRoleManagementDirectoryListRoleAssignmentsRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiRoleManagementDirectoryListRoleAssignmentsRequest) Top(top int32) ApiRoleManagementDirectoryListRoleAssignmentsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiRoleManagementDirectoryListRoleAssignmentsRequest) Skip(skip int32) ApiRoleManagementDirectoryListRoleAssignmentsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiRoleManagementDirectoryListRoleAssignmentsRequest) Search(search string) ApiRoleManagementDirectoryListRoleAssignmentsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiRoleManagementDirectoryListRoleAssignmentsRequest) Filter(filter string) ApiRoleManagementDirectoryListRoleAssignmentsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiRoleManagementDirectoryListRoleAssignmentsRequest) Count(count bool) ApiRoleManagementDirectoryListRoleAssignmentsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiRoleManagementDirectoryListRoleAssignmentsRequest) Orderby(orderby []string) ApiRoleManagementDirectoryListRoleAssignmentsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiRoleManagementDirectoryListRoleAssignmentsRequest) Select_(select_ []string) ApiRoleManagementDirectoryListRoleAssignmentsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiRoleManagementDirectoryListRoleAssignmentsRequest) Expand(expand []string) ApiRoleManagementDirectoryListRoleAssignmentsRequest {
	r.expand = &expand
	return r
}

func (r ApiRoleManagementDirectoryListRoleAssignmentsRequest) Execute() (CollectionOfUnifiedRoleAssignment, *_nethttp.Response, error) {
	return r.ApiService.RoleManagementDirectoryListRoleAssignmentsExecute(r)
}

/*
RoleManagementDirectoryListRoleAssignments Get roleAssignments from roleManagement

Resource to grant access to users or groups.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRoleManagementDirectoryListRoleAssignmentsRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryListRoleAssignments(ctx _context.Context) ApiRoleManagementDirectoryListRoleAssignmentsRequest {
	return ApiRoleManagementDirectoryListRoleAssignmentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionOfUnifiedRoleAssignment
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryListRoleAssignmentsExecute(r ApiRoleManagementDirectoryListRoleAssignmentsRequest) (CollectionOfUnifiedRoleAssignment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfUnifiedRoleAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementDirectoryListRoleAssignments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/directory/roleAssignments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRoleManagementDirectoryListRoleDefinitionsRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiRoleManagementDirectoryListRoleDefinitionsRequest) Top(top int32) ApiRoleManagementDirectoryListRoleDefinitionsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiRoleManagementDirectoryListRoleDefinitionsRequest) Skip(skip int32) ApiRoleManagementDirectoryListRoleDefinitionsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiRoleManagementDirectoryListRoleDefinitionsRequest) Search(search string) ApiRoleManagementDirectoryListRoleDefinitionsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiRoleManagementDirectoryListRoleDefinitionsRequest) Filter(filter string) ApiRoleManagementDirectoryListRoleDefinitionsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiRoleManagementDirectoryListRoleDefinitionsRequest) Count(count bool) ApiRoleManagementDirectoryListRoleDefinitionsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiRoleManagementDirectoryListRoleDefinitionsRequest) Orderby(orderby []string) ApiRoleManagementDirectoryListRoleDefinitionsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiRoleManagementDirectoryListRoleDefinitionsRequest) Select_(select_ []string) ApiRoleManagementDirectoryListRoleDefinitionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiRoleManagementDirectoryListRoleDefinitionsRequest) Expand(expand []string) ApiRoleManagementDirectoryListRoleDefinitionsRequest {
	r.expand = &expand
	return r
}

func (r ApiRoleManagementDirectoryListRoleDefinitionsRequest) Execute() (CollectionOfUnifiedRoleDefinition, *_nethttp.Response, error) {
	return r.ApiService.RoleManagementDirectoryListRoleDefinitionsExecute(r)
}

/*
RoleManagementDirectoryListRoleDefinitions Get roleDefinitions from roleManagement

Resource representing the roles allowed by RBAC providers and the permissions assigned to the roles.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRoleManagementDirectoryListRoleDefinitionsRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryListRoleDefinitions(ctx _context.Context) ApiRoleManagementDirectoryListRoleDefinitionsRequest {
	return ApiRoleManagementDirectoryListRoleDefinitionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionOfUnifiedRoleDefinition
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryListRoleDefinitionsExecute(r ApiRoleManagementDirectoryListRoleDefinitionsRequest) (CollectionOfUnifiedRoleDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfUnifiedRoleDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementDirectoryListRoleDefinitions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/directory/roleDefinitions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRoleManagementDirectoryRoleAssignmentsDeleteAppScopeRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleAssignmentId string
	ifMatch *string
}

// ETag
func (r ApiRoleManagementDirectoryRoleAssignmentsDeleteAppScopeRequest) IfMatch(ifMatch string) ApiRoleManagementDirectoryRoleAssignmentsDeleteAppScopeRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiRoleManagementDirectoryRoleAssignmentsDeleteAppScopeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RoleManagementDirectoryRoleAssignmentsDeleteAppScopeExecute(r)
}

/*
RoleManagementDirectoryRoleAssignmentsDeleteAppScope Delete navigation property appScope for roleManagement

Read-only property with details of the app specific scope when the assignment scope is app specific. Containment entity. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleAssignmentId key: id of unifiedRoleAssignment
 @return ApiRoleManagementDirectoryRoleAssignmentsDeleteAppScopeRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryRoleAssignmentsDeleteAppScope(ctx _context.Context, unifiedRoleAssignmentId string) ApiRoleManagementDirectoryRoleAssignmentsDeleteAppScopeRequest {
	return ApiRoleManagementDirectoryRoleAssignmentsDeleteAppScopeRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleAssignmentId: unifiedRoleAssignmentId,
	}
}

// Execute executes the request
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryRoleAssignmentsDeleteAppScopeExecute(r ApiRoleManagementDirectoryRoleAssignmentsDeleteAppScopeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementDirectoryRoleAssignmentsDeleteAppScope")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/directory/roleAssignments/{unifiedRoleAssignment-id}/appScope"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRoleManagementDirectoryRoleAssignmentsDeleteRefDirectoryScopeRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleAssignmentId string
	ifMatch *string
}

// ETag
func (r ApiRoleManagementDirectoryRoleAssignmentsDeleteRefDirectoryScopeRequest) IfMatch(ifMatch string) ApiRoleManagementDirectoryRoleAssignmentsDeleteRefDirectoryScopeRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiRoleManagementDirectoryRoleAssignmentsDeleteRefDirectoryScopeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RoleManagementDirectoryRoleAssignmentsDeleteRefDirectoryScopeExecute(r)
}

/*
RoleManagementDirectoryRoleAssignmentsDeleteRefDirectoryScope Delete ref of navigation property directoryScope for roleManagement

The directory object that is the scope of the assignment. Read-only. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleAssignmentId key: id of unifiedRoleAssignment
 @return ApiRoleManagementDirectoryRoleAssignmentsDeleteRefDirectoryScopeRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryRoleAssignmentsDeleteRefDirectoryScope(ctx _context.Context, unifiedRoleAssignmentId string) ApiRoleManagementDirectoryRoleAssignmentsDeleteRefDirectoryScopeRequest {
	return ApiRoleManagementDirectoryRoleAssignmentsDeleteRefDirectoryScopeRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleAssignmentId: unifiedRoleAssignmentId,
	}
}

// Execute executes the request
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryRoleAssignmentsDeleteRefDirectoryScopeExecute(r ApiRoleManagementDirectoryRoleAssignmentsDeleteRefDirectoryScopeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementDirectoryRoleAssignmentsDeleteRefDirectoryScope")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/directory/roleAssignments/{unifiedRoleAssignment-id}/directoryScope/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRoleManagementDirectoryRoleAssignmentsDeleteRefPrincipalRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleAssignmentId string
	ifMatch *string
}

// ETag
func (r ApiRoleManagementDirectoryRoleAssignmentsDeleteRefPrincipalRequest) IfMatch(ifMatch string) ApiRoleManagementDirectoryRoleAssignmentsDeleteRefPrincipalRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiRoleManagementDirectoryRoleAssignmentsDeleteRefPrincipalRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RoleManagementDirectoryRoleAssignmentsDeleteRefPrincipalExecute(r)
}

/*
RoleManagementDirectoryRoleAssignmentsDeleteRefPrincipal Delete ref of navigation property principal for roleManagement

Referencing the assigned principal. Read-only. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleAssignmentId key: id of unifiedRoleAssignment
 @return ApiRoleManagementDirectoryRoleAssignmentsDeleteRefPrincipalRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryRoleAssignmentsDeleteRefPrincipal(ctx _context.Context, unifiedRoleAssignmentId string) ApiRoleManagementDirectoryRoleAssignmentsDeleteRefPrincipalRequest {
	return ApiRoleManagementDirectoryRoleAssignmentsDeleteRefPrincipalRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleAssignmentId: unifiedRoleAssignmentId,
	}
}

// Execute executes the request
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryRoleAssignmentsDeleteRefPrincipalExecute(r ApiRoleManagementDirectoryRoleAssignmentsDeleteRefPrincipalRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementDirectoryRoleAssignmentsDeleteRefPrincipal")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/directory/roleAssignments/{unifiedRoleAssignment-id}/principal/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRoleManagementDirectoryRoleAssignmentsDeleteRefRoleDefinitionRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleAssignmentId string
	ifMatch *string
}

// ETag
func (r ApiRoleManagementDirectoryRoleAssignmentsDeleteRefRoleDefinitionRequest) IfMatch(ifMatch string) ApiRoleManagementDirectoryRoleAssignmentsDeleteRefRoleDefinitionRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiRoleManagementDirectoryRoleAssignmentsDeleteRefRoleDefinitionRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RoleManagementDirectoryRoleAssignmentsDeleteRefRoleDefinitionExecute(r)
}

/*
RoleManagementDirectoryRoleAssignmentsDeleteRefRoleDefinition Delete ref of navigation property roleDefinition for roleManagement

The roleDefinition the assignment is for.  Supports $expand. roleDefinition.Id will be auto expanded.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleAssignmentId key: id of unifiedRoleAssignment
 @return ApiRoleManagementDirectoryRoleAssignmentsDeleteRefRoleDefinitionRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryRoleAssignmentsDeleteRefRoleDefinition(ctx _context.Context, unifiedRoleAssignmentId string) ApiRoleManagementDirectoryRoleAssignmentsDeleteRefRoleDefinitionRequest {
	return ApiRoleManagementDirectoryRoleAssignmentsDeleteRefRoleDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleAssignmentId: unifiedRoleAssignmentId,
	}
}

// Execute executes the request
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryRoleAssignmentsDeleteRefRoleDefinitionExecute(r ApiRoleManagementDirectoryRoleAssignmentsDeleteRefRoleDefinitionRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementDirectoryRoleAssignmentsDeleteRefRoleDefinition")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/directory/roleAssignments/{unifiedRoleAssignment-id}/roleDefinition/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRoleManagementDirectoryRoleAssignmentsGetAppScopeRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleAssignmentId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiRoleManagementDirectoryRoleAssignmentsGetAppScopeRequest) Select_(select_ []string) ApiRoleManagementDirectoryRoleAssignmentsGetAppScopeRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiRoleManagementDirectoryRoleAssignmentsGetAppScopeRequest) Expand(expand []string) ApiRoleManagementDirectoryRoleAssignmentsGetAppScopeRequest {
	r.expand = &expand
	return r
}

func (r ApiRoleManagementDirectoryRoleAssignmentsGetAppScopeRequest) Execute() (MicrosoftGraphAppScope, *_nethttp.Response, error) {
	return r.ApiService.RoleManagementDirectoryRoleAssignmentsGetAppScopeExecute(r)
}

/*
RoleManagementDirectoryRoleAssignmentsGetAppScope Get appScope from roleManagement

Read-only property with details of the app specific scope when the assignment scope is app specific. Containment entity. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleAssignmentId key: id of unifiedRoleAssignment
 @return ApiRoleManagementDirectoryRoleAssignmentsGetAppScopeRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryRoleAssignmentsGetAppScope(ctx _context.Context, unifiedRoleAssignmentId string) ApiRoleManagementDirectoryRoleAssignmentsGetAppScopeRequest {
	return ApiRoleManagementDirectoryRoleAssignmentsGetAppScopeRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleAssignmentId: unifiedRoleAssignmentId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphAppScope
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryRoleAssignmentsGetAppScopeExecute(r ApiRoleManagementDirectoryRoleAssignmentsGetAppScopeRequest) (MicrosoftGraphAppScope, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphAppScope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementDirectoryRoleAssignmentsGetAppScope")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/directory/roleAssignments/{unifiedRoleAssignment-id}/appScope"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRoleManagementDirectoryRoleAssignmentsGetDirectoryScopeRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleAssignmentId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiRoleManagementDirectoryRoleAssignmentsGetDirectoryScopeRequest) Select_(select_ []string) ApiRoleManagementDirectoryRoleAssignmentsGetDirectoryScopeRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiRoleManagementDirectoryRoleAssignmentsGetDirectoryScopeRequest) Expand(expand []string) ApiRoleManagementDirectoryRoleAssignmentsGetDirectoryScopeRequest {
	r.expand = &expand
	return r
}

func (r ApiRoleManagementDirectoryRoleAssignmentsGetDirectoryScopeRequest) Execute() (MicrosoftGraphDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.RoleManagementDirectoryRoleAssignmentsGetDirectoryScopeExecute(r)
}

/*
RoleManagementDirectoryRoleAssignmentsGetDirectoryScope Get directoryScope from roleManagement

The directory object that is the scope of the assignment. Read-only. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleAssignmentId key: id of unifiedRoleAssignment
 @return ApiRoleManagementDirectoryRoleAssignmentsGetDirectoryScopeRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryRoleAssignmentsGetDirectoryScope(ctx _context.Context, unifiedRoleAssignmentId string) ApiRoleManagementDirectoryRoleAssignmentsGetDirectoryScopeRequest {
	return ApiRoleManagementDirectoryRoleAssignmentsGetDirectoryScopeRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleAssignmentId: unifiedRoleAssignmentId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphDirectoryObject
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryRoleAssignmentsGetDirectoryScopeExecute(r ApiRoleManagementDirectoryRoleAssignmentsGetDirectoryScopeRequest) (MicrosoftGraphDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementDirectoryRoleAssignmentsGetDirectoryScope")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/directory/roleAssignments/{unifiedRoleAssignment-id}/directoryScope"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRoleManagementDirectoryRoleAssignmentsGetPrincipalRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleAssignmentId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiRoleManagementDirectoryRoleAssignmentsGetPrincipalRequest) Select_(select_ []string) ApiRoleManagementDirectoryRoleAssignmentsGetPrincipalRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiRoleManagementDirectoryRoleAssignmentsGetPrincipalRequest) Expand(expand []string) ApiRoleManagementDirectoryRoleAssignmentsGetPrincipalRequest {
	r.expand = &expand
	return r
}

func (r ApiRoleManagementDirectoryRoleAssignmentsGetPrincipalRequest) Execute() (MicrosoftGraphDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.RoleManagementDirectoryRoleAssignmentsGetPrincipalExecute(r)
}

/*
RoleManagementDirectoryRoleAssignmentsGetPrincipal Get principal from roleManagement

Referencing the assigned principal. Read-only. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleAssignmentId key: id of unifiedRoleAssignment
 @return ApiRoleManagementDirectoryRoleAssignmentsGetPrincipalRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryRoleAssignmentsGetPrincipal(ctx _context.Context, unifiedRoleAssignmentId string) ApiRoleManagementDirectoryRoleAssignmentsGetPrincipalRequest {
	return ApiRoleManagementDirectoryRoleAssignmentsGetPrincipalRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleAssignmentId: unifiedRoleAssignmentId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphDirectoryObject
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryRoleAssignmentsGetPrincipalExecute(r ApiRoleManagementDirectoryRoleAssignmentsGetPrincipalRequest) (MicrosoftGraphDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementDirectoryRoleAssignmentsGetPrincipal")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/directory/roleAssignments/{unifiedRoleAssignment-id}/principal"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRoleManagementDirectoryRoleAssignmentsGetRefDirectoryScopeRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleAssignmentId string
}


func (r ApiRoleManagementDirectoryRoleAssignmentsGetRefDirectoryScopeRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.RoleManagementDirectoryRoleAssignmentsGetRefDirectoryScopeExecute(r)
}

/*
RoleManagementDirectoryRoleAssignmentsGetRefDirectoryScope Get ref of directoryScope from roleManagement

The directory object that is the scope of the assignment. Read-only. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleAssignmentId key: id of unifiedRoleAssignment
 @return ApiRoleManagementDirectoryRoleAssignmentsGetRefDirectoryScopeRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryRoleAssignmentsGetRefDirectoryScope(ctx _context.Context, unifiedRoleAssignmentId string) ApiRoleManagementDirectoryRoleAssignmentsGetRefDirectoryScopeRequest {
	return ApiRoleManagementDirectoryRoleAssignmentsGetRefDirectoryScopeRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleAssignmentId: unifiedRoleAssignmentId,
	}
}

// Execute executes the request
//  @return string
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryRoleAssignmentsGetRefDirectoryScopeExecute(r ApiRoleManagementDirectoryRoleAssignmentsGetRefDirectoryScopeRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementDirectoryRoleAssignmentsGetRefDirectoryScope")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/directory/roleAssignments/{unifiedRoleAssignment-id}/directoryScope/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRoleManagementDirectoryRoleAssignmentsGetRefPrincipalRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleAssignmentId string
}


func (r ApiRoleManagementDirectoryRoleAssignmentsGetRefPrincipalRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.RoleManagementDirectoryRoleAssignmentsGetRefPrincipalExecute(r)
}

/*
RoleManagementDirectoryRoleAssignmentsGetRefPrincipal Get ref of principal from roleManagement

Referencing the assigned principal. Read-only. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleAssignmentId key: id of unifiedRoleAssignment
 @return ApiRoleManagementDirectoryRoleAssignmentsGetRefPrincipalRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryRoleAssignmentsGetRefPrincipal(ctx _context.Context, unifiedRoleAssignmentId string) ApiRoleManagementDirectoryRoleAssignmentsGetRefPrincipalRequest {
	return ApiRoleManagementDirectoryRoleAssignmentsGetRefPrincipalRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleAssignmentId: unifiedRoleAssignmentId,
	}
}

// Execute executes the request
//  @return string
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryRoleAssignmentsGetRefPrincipalExecute(r ApiRoleManagementDirectoryRoleAssignmentsGetRefPrincipalRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementDirectoryRoleAssignmentsGetRefPrincipal")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/directory/roleAssignments/{unifiedRoleAssignment-id}/principal/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRoleManagementDirectoryRoleAssignmentsGetRefRoleDefinitionRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleAssignmentId string
}


func (r ApiRoleManagementDirectoryRoleAssignmentsGetRefRoleDefinitionRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.RoleManagementDirectoryRoleAssignmentsGetRefRoleDefinitionExecute(r)
}

/*
RoleManagementDirectoryRoleAssignmentsGetRefRoleDefinition Get ref of roleDefinition from roleManagement

The roleDefinition the assignment is for.  Supports $expand. roleDefinition.Id will be auto expanded.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleAssignmentId key: id of unifiedRoleAssignment
 @return ApiRoleManagementDirectoryRoleAssignmentsGetRefRoleDefinitionRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryRoleAssignmentsGetRefRoleDefinition(ctx _context.Context, unifiedRoleAssignmentId string) ApiRoleManagementDirectoryRoleAssignmentsGetRefRoleDefinitionRequest {
	return ApiRoleManagementDirectoryRoleAssignmentsGetRefRoleDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleAssignmentId: unifiedRoleAssignmentId,
	}
}

// Execute executes the request
//  @return string
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryRoleAssignmentsGetRefRoleDefinitionExecute(r ApiRoleManagementDirectoryRoleAssignmentsGetRefRoleDefinitionRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementDirectoryRoleAssignmentsGetRefRoleDefinition")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/directory/roleAssignments/{unifiedRoleAssignment-id}/roleDefinition/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRoleManagementDirectoryRoleAssignmentsGetRoleDefinitionRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleAssignmentId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiRoleManagementDirectoryRoleAssignmentsGetRoleDefinitionRequest) Select_(select_ []string) ApiRoleManagementDirectoryRoleAssignmentsGetRoleDefinitionRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiRoleManagementDirectoryRoleAssignmentsGetRoleDefinitionRequest) Expand(expand []string) ApiRoleManagementDirectoryRoleAssignmentsGetRoleDefinitionRequest {
	r.expand = &expand
	return r
}

func (r ApiRoleManagementDirectoryRoleAssignmentsGetRoleDefinitionRequest) Execute() (MicrosoftGraphUnifiedRoleDefinition, *_nethttp.Response, error) {
	return r.ApiService.RoleManagementDirectoryRoleAssignmentsGetRoleDefinitionExecute(r)
}

/*
RoleManagementDirectoryRoleAssignmentsGetRoleDefinition Get roleDefinition from roleManagement

The roleDefinition the assignment is for.  Supports $expand. roleDefinition.Id will be auto expanded.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleAssignmentId key: id of unifiedRoleAssignment
 @return ApiRoleManagementDirectoryRoleAssignmentsGetRoleDefinitionRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryRoleAssignmentsGetRoleDefinition(ctx _context.Context, unifiedRoleAssignmentId string) ApiRoleManagementDirectoryRoleAssignmentsGetRoleDefinitionRequest {
	return ApiRoleManagementDirectoryRoleAssignmentsGetRoleDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleAssignmentId: unifiedRoleAssignmentId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphUnifiedRoleDefinition
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryRoleAssignmentsGetRoleDefinitionExecute(r ApiRoleManagementDirectoryRoleAssignmentsGetRoleDefinitionRequest) (MicrosoftGraphUnifiedRoleDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphUnifiedRoleDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementDirectoryRoleAssignmentsGetRoleDefinition")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/directory/roleAssignments/{unifiedRoleAssignment-id}/roleDefinition"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRoleManagementDirectoryRoleAssignmentsUpdateAppScopeRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleAssignmentId string
	microsoftGraphAppScope *MicrosoftGraphAppScope
}

// New navigation property values
func (r ApiRoleManagementDirectoryRoleAssignmentsUpdateAppScopeRequest) MicrosoftGraphAppScope(microsoftGraphAppScope MicrosoftGraphAppScope) ApiRoleManagementDirectoryRoleAssignmentsUpdateAppScopeRequest {
	r.microsoftGraphAppScope = &microsoftGraphAppScope
	return r
}

func (r ApiRoleManagementDirectoryRoleAssignmentsUpdateAppScopeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RoleManagementDirectoryRoleAssignmentsUpdateAppScopeExecute(r)
}

/*
RoleManagementDirectoryRoleAssignmentsUpdateAppScope Update the navigation property appScope in roleManagement

Read-only property with details of the app specific scope when the assignment scope is app specific. Containment entity. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleAssignmentId key: id of unifiedRoleAssignment
 @return ApiRoleManagementDirectoryRoleAssignmentsUpdateAppScopeRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryRoleAssignmentsUpdateAppScope(ctx _context.Context, unifiedRoleAssignmentId string) ApiRoleManagementDirectoryRoleAssignmentsUpdateAppScopeRequest {
	return ApiRoleManagementDirectoryRoleAssignmentsUpdateAppScopeRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleAssignmentId: unifiedRoleAssignmentId,
	}
}

// Execute executes the request
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryRoleAssignmentsUpdateAppScopeExecute(r ApiRoleManagementDirectoryRoleAssignmentsUpdateAppScopeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementDirectoryRoleAssignmentsUpdateAppScope")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/directory/roleAssignments/{unifiedRoleAssignment-id}/appScope"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphAppScope == nil {
		return nil, reportError("microsoftGraphAppScope is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphAppScope
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRoleManagementDirectoryRoleAssignmentsUpdateRefDirectoryScopeRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleAssignmentId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiRoleManagementDirectoryRoleAssignmentsUpdateRefDirectoryScopeRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiRoleManagementDirectoryRoleAssignmentsUpdateRefDirectoryScopeRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiRoleManagementDirectoryRoleAssignmentsUpdateRefDirectoryScopeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RoleManagementDirectoryRoleAssignmentsUpdateRefDirectoryScopeExecute(r)
}

/*
RoleManagementDirectoryRoleAssignmentsUpdateRefDirectoryScope Update the ref of navigation property directoryScope in roleManagement

The directory object that is the scope of the assignment. Read-only. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleAssignmentId key: id of unifiedRoleAssignment
 @return ApiRoleManagementDirectoryRoleAssignmentsUpdateRefDirectoryScopeRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryRoleAssignmentsUpdateRefDirectoryScope(ctx _context.Context, unifiedRoleAssignmentId string) ApiRoleManagementDirectoryRoleAssignmentsUpdateRefDirectoryScopeRequest {
	return ApiRoleManagementDirectoryRoleAssignmentsUpdateRefDirectoryScopeRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleAssignmentId: unifiedRoleAssignmentId,
	}
}

// Execute executes the request
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryRoleAssignmentsUpdateRefDirectoryScopeExecute(r ApiRoleManagementDirectoryRoleAssignmentsUpdateRefDirectoryScopeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementDirectoryRoleAssignmentsUpdateRefDirectoryScope")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/directory/roleAssignments/{unifiedRoleAssignment-id}/directoryScope/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRoleManagementDirectoryRoleAssignmentsUpdateRefPrincipalRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleAssignmentId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiRoleManagementDirectoryRoleAssignmentsUpdateRefPrincipalRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiRoleManagementDirectoryRoleAssignmentsUpdateRefPrincipalRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiRoleManagementDirectoryRoleAssignmentsUpdateRefPrincipalRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RoleManagementDirectoryRoleAssignmentsUpdateRefPrincipalExecute(r)
}

/*
RoleManagementDirectoryRoleAssignmentsUpdateRefPrincipal Update the ref of navigation property principal in roleManagement

Referencing the assigned principal. Read-only. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleAssignmentId key: id of unifiedRoleAssignment
 @return ApiRoleManagementDirectoryRoleAssignmentsUpdateRefPrincipalRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryRoleAssignmentsUpdateRefPrincipal(ctx _context.Context, unifiedRoleAssignmentId string) ApiRoleManagementDirectoryRoleAssignmentsUpdateRefPrincipalRequest {
	return ApiRoleManagementDirectoryRoleAssignmentsUpdateRefPrincipalRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleAssignmentId: unifiedRoleAssignmentId,
	}
}

// Execute executes the request
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryRoleAssignmentsUpdateRefPrincipalExecute(r ApiRoleManagementDirectoryRoleAssignmentsUpdateRefPrincipalRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementDirectoryRoleAssignmentsUpdateRefPrincipal")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/directory/roleAssignments/{unifiedRoleAssignment-id}/principal/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRoleManagementDirectoryRoleAssignmentsUpdateRefRoleDefinitionRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleAssignmentId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiRoleManagementDirectoryRoleAssignmentsUpdateRefRoleDefinitionRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiRoleManagementDirectoryRoleAssignmentsUpdateRefRoleDefinitionRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiRoleManagementDirectoryRoleAssignmentsUpdateRefRoleDefinitionRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RoleManagementDirectoryRoleAssignmentsUpdateRefRoleDefinitionExecute(r)
}

/*
RoleManagementDirectoryRoleAssignmentsUpdateRefRoleDefinition Update the ref of navigation property roleDefinition in roleManagement

The roleDefinition the assignment is for.  Supports $expand. roleDefinition.Id will be auto expanded.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleAssignmentId key: id of unifiedRoleAssignment
 @return ApiRoleManagementDirectoryRoleAssignmentsUpdateRefRoleDefinitionRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryRoleAssignmentsUpdateRefRoleDefinition(ctx _context.Context, unifiedRoleAssignmentId string) ApiRoleManagementDirectoryRoleAssignmentsUpdateRefRoleDefinitionRequest {
	return ApiRoleManagementDirectoryRoleAssignmentsUpdateRefRoleDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleAssignmentId: unifiedRoleAssignmentId,
	}
}

// Execute executes the request
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryRoleAssignmentsUpdateRefRoleDefinitionExecute(r ApiRoleManagementDirectoryRoleAssignmentsUpdateRefRoleDefinitionRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementDirectoryRoleAssignmentsUpdateRefRoleDefinition")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/directory/roleAssignments/{unifiedRoleAssignment-id}/roleDefinition/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRoleManagementDirectoryRoleDefinitionsCreateInheritsPermissionsFromRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleDefinitionId string
	microsoftGraphUnifiedRoleDefinition *MicrosoftGraphUnifiedRoleDefinition
}

// New navigation property
func (r ApiRoleManagementDirectoryRoleDefinitionsCreateInheritsPermissionsFromRequest) MicrosoftGraphUnifiedRoleDefinition(microsoftGraphUnifiedRoleDefinition MicrosoftGraphUnifiedRoleDefinition) ApiRoleManagementDirectoryRoleDefinitionsCreateInheritsPermissionsFromRequest {
	r.microsoftGraphUnifiedRoleDefinition = &microsoftGraphUnifiedRoleDefinition
	return r
}

func (r ApiRoleManagementDirectoryRoleDefinitionsCreateInheritsPermissionsFromRequest) Execute() (MicrosoftGraphUnifiedRoleDefinition, *_nethttp.Response, error) {
	return r.ApiService.RoleManagementDirectoryRoleDefinitionsCreateInheritsPermissionsFromExecute(r)
}

/*
RoleManagementDirectoryRoleDefinitionsCreateInheritsPermissionsFrom Create new navigation property to inheritsPermissionsFrom for roleManagement

Read-only collection of role definitions that the given role definition inherits from. Only Azure AD built-in roles (isBuiltIn is true) support this attribute. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleDefinitionId key: id of unifiedRoleDefinition
 @return ApiRoleManagementDirectoryRoleDefinitionsCreateInheritsPermissionsFromRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryRoleDefinitionsCreateInheritsPermissionsFrom(ctx _context.Context, unifiedRoleDefinitionId string) ApiRoleManagementDirectoryRoleDefinitionsCreateInheritsPermissionsFromRequest {
	return ApiRoleManagementDirectoryRoleDefinitionsCreateInheritsPermissionsFromRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleDefinitionId: unifiedRoleDefinitionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphUnifiedRoleDefinition
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryRoleDefinitionsCreateInheritsPermissionsFromExecute(r ApiRoleManagementDirectoryRoleDefinitionsCreateInheritsPermissionsFromRequest) (MicrosoftGraphUnifiedRoleDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphUnifiedRoleDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementDirectoryRoleDefinitionsCreateInheritsPermissionsFrom")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/directory/roleDefinitions/{unifiedRoleDefinition-id}/inheritsPermissionsFrom"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphUnifiedRoleDefinition == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphUnifiedRoleDefinition is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphUnifiedRoleDefinition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRoleManagementDirectoryRoleDefinitionsDeleteInheritsPermissionsFromRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleDefinitionId string
	unifiedRoleDefinitionId1 string
	ifMatch *string
}

// ETag
func (r ApiRoleManagementDirectoryRoleDefinitionsDeleteInheritsPermissionsFromRequest) IfMatch(ifMatch string) ApiRoleManagementDirectoryRoleDefinitionsDeleteInheritsPermissionsFromRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiRoleManagementDirectoryRoleDefinitionsDeleteInheritsPermissionsFromRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RoleManagementDirectoryRoleDefinitionsDeleteInheritsPermissionsFromExecute(r)
}

/*
RoleManagementDirectoryRoleDefinitionsDeleteInheritsPermissionsFrom Delete navigation property inheritsPermissionsFrom for roleManagement

Read-only collection of role definitions that the given role definition inherits from. Only Azure AD built-in roles (isBuiltIn is true) support this attribute. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleDefinitionId key: id of unifiedRoleDefinition
 @param unifiedRoleDefinitionId1 key: id of unifiedRoleDefinition
 @return ApiRoleManagementDirectoryRoleDefinitionsDeleteInheritsPermissionsFromRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryRoleDefinitionsDeleteInheritsPermissionsFrom(ctx _context.Context, unifiedRoleDefinitionId string, unifiedRoleDefinitionId1 string) ApiRoleManagementDirectoryRoleDefinitionsDeleteInheritsPermissionsFromRequest {
	return ApiRoleManagementDirectoryRoleDefinitionsDeleteInheritsPermissionsFromRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleDefinitionId: unifiedRoleDefinitionId,
		unifiedRoleDefinitionId1: unifiedRoleDefinitionId1,
	}
}

// Execute executes the request
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryRoleDefinitionsDeleteInheritsPermissionsFromExecute(r ApiRoleManagementDirectoryRoleDefinitionsDeleteInheritsPermissionsFromRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementDirectoryRoleDefinitionsDeleteInheritsPermissionsFrom")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/directory/roleDefinitions/{unifiedRoleDefinition-id}/inheritsPermissionsFrom/{unifiedRoleDefinition-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleDefinitionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleDefinition-id1"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleDefinitionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRoleManagementDirectoryRoleDefinitionsGetInheritsPermissionsFromRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleDefinitionId string
	unifiedRoleDefinitionId1 string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiRoleManagementDirectoryRoleDefinitionsGetInheritsPermissionsFromRequest) Select_(select_ []string) ApiRoleManagementDirectoryRoleDefinitionsGetInheritsPermissionsFromRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiRoleManagementDirectoryRoleDefinitionsGetInheritsPermissionsFromRequest) Expand(expand []string) ApiRoleManagementDirectoryRoleDefinitionsGetInheritsPermissionsFromRequest {
	r.expand = &expand
	return r
}

func (r ApiRoleManagementDirectoryRoleDefinitionsGetInheritsPermissionsFromRequest) Execute() (MicrosoftGraphUnifiedRoleDefinition, *_nethttp.Response, error) {
	return r.ApiService.RoleManagementDirectoryRoleDefinitionsGetInheritsPermissionsFromExecute(r)
}

/*
RoleManagementDirectoryRoleDefinitionsGetInheritsPermissionsFrom Get inheritsPermissionsFrom from roleManagement

Read-only collection of role definitions that the given role definition inherits from. Only Azure AD built-in roles (isBuiltIn is true) support this attribute. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleDefinitionId key: id of unifiedRoleDefinition
 @param unifiedRoleDefinitionId1 key: id of unifiedRoleDefinition
 @return ApiRoleManagementDirectoryRoleDefinitionsGetInheritsPermissionsFromRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryRoleDefinitionsGetInheritsPermissionsFrom(ctx _context.Context, unifiedRoleDefinitionId string, unifiedRoleDefinitionId1 string) ApiRoleManagementDirectoryRoleDefinitionsGetInheritsPermissionsFromRequest {
	return ApiRoleManagementDirectoryRoleDefinitionsGetInheritsPermissionsFromRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleDefinitionId: unifiedRoleDefinitionId,
		unifiedRoleDefinitionId1: unifiedRoleDefinitionId1,
	}
}

// Execute executes the request
//  @return MicrosoftGraphUnifiedRoleDefinition
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryRoleDefinitionsGetInheritsPermissionsFromExecute(r ApiRoleManagementDirectoryRoleDefinitionsGetInheritsPermissionsFromRequest) (MicrosoftGraphUnifiedRoleDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphUnifiedRoleDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementDirectoryRoleDefinitionsGetInheritsPermissionsFrom")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/directory/roleDefinitions/{unifiedRoleDefinition-id}/inheritsPermissionsFrom/{unifiedRoleDefinition-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleDefinitionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleDefinition-id1"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleDefinitionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRoleManagementDirectoryRoleDefinitionsListInheritsPermissionsFromRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleDefinitionId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiRoleManagementDirectoryRoleDefinitionsListInheritsPermissionsFromRequest) Top(top int32) ApiRoleManagementDirectoryRoleDefinitionsListInheritsPermissionsFromRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiRoleManagementDirectoryRoleDefinitionsListInheritsPermissionsFromRequest) Skip(skip int32) ApiRoleManagementDirectoryRoleDefinitionsListInheritsPermissionsFromRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiRoleManagementDirectoryRoleDefinitionsListInheritsPermissionsFromRequest) Search(search string) ApiRoleManagementDirectoryRoleDefinitionsListInheritsPermissionsFromRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiRoleManagementDirectoryRoleDefinitionsListInheritsPermissionsFromRequest) Filter(filter string) ApiRoleManagementDirectoryRoleDefinitionsListInheritsPermissionsFromRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiRoleManagementDirectoryRoleDefinitionsListInheritsPermissionsFromRequest) Count(count bool) ApiRoleManagementDirectoryRoleDefinitionsListInheritsPermissionsFromRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiRoleManagementDirectoryRoleDefinitionsListInheritsPermissionsFromRequest) Orderby(orderby []string) ApiRoleManagementDirectoryRoleDefinitionsListInheritsPermissionsFromRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiRoleManagementDirectoryRoleDefinitionsListInheritsPermissionsFromRequest) Select_(select_ []string) ApiRoleManagementDirectoryRoleDefinitionsListInheritsPermissionsFromRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiRoleManagementDirectoryRoleDefinitionsListInheritsPermissionsFromRequest) Expand(expand []string) ApiRoleManagementDirectoryRoleDefinitionsListInheritsPermissionsFromRequest {
	r.expand = &expand
	return r
}

func (r ApiRoleManagementDirectoryRoleDefinitionsListInheritsPermissionsFromRequest) Execute() (CollectionOfUnifiedRoleDefinition, *_nethttp.Response, error) {
	return r.ApiService.RoleManagementDirectoryRoleDefinitionsListInheritsPermissionsFromExecute(r)
}

/*
RoleManagementDirectoryRoleDefinitionsListInheritsPermissionsFrom Get inheritsPermissionsFrom from roleManagement

Read-only collection of role definitions that the given role definition inherits from. Only Azure AD built-in roles (isBuiltIn is true) support this attribute. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleDefinitionId key: id of unifiedRoleDefinition
 @return ApiRoleManagementDirectoryRoleDefinitionsListInheritsPermissionsFromRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryRoleDefinitionsListInheritsPermissionsFrom(ctx _context.Context, unifiedRoleDefinitionId string) ApiRoleManagementDirectoryRoleDefinitionsListInheritsPermissionsFromRequest {
	return ApiRoleManagementDirectoryRoleDefinitionsListInheritsPermissionsFromRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleDefinitionId: unifiedRoleDefinitionId,
	}
}

// Execute executes the request
//  @return CollectionOfUnifiedRoleDefinition
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryRoleDefinitionsListInheritsPermissionsFromExecute(r ApiRoleManagementDirectoryRoleDefinitionsListInheritsPermissionsFromRequest) (CollectionOfUnifiedRoleDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfUnifiedRoleDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementDirectoryRoleDefinitionsListInheritsPermissionsFrom")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/directory/roleDefinitions/{unifiedRoleDefinition-id}/inheritsPermissionsFrom"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRoleManagementDirectoryRoleDefinitionsUpdateInheritsPermissionsFromRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleDefinitionId string
	unifiedRoleDefinitionId1 string
	microsoftGraphUnifiedRoleDefinition *MicrosoftGraphUnifiedRoleDefinition
}

// New navigation property values
func (r ApiRoleManagementDirectoryRoleDefinitionsUpdateInheritsPermissionsFromRequest) MicrosoftGraphUnifiedRoleDefinition(microsoftGraphUnifiedRoleDefinition MicrosoftGraphUnifiedRoleDefinition) ApiRoleManagementDirectoryRoleDefinitionsUpdateInheritsPermissionsFromRequest {
	r.microsoftGraphUnifiedRoleDefinition = &microsoftGraphUnifiedRoleDefinition
	return r
}

func (r ApiRoleManagementDirectoryRoleDefinitionsUpdateInheritsPermissionsFromRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RoleManagementDirectoryRoleDefinitionsUpdateInheritsPermissionsFromExecute(r)
}

/*
RoleManagementDirectoryRoleDefinitionsUpdateInheritsPermissionsFrom Update the navigation property inheritsPermissionsFrom in roleManagement

Read-only collection of role definitions that the given role definition inherits from. Only Azure AD built-in roles (isBuiltIn is true) support this attribute. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleDefinitionId key: id of unifiedRoleDefinition
 @param unifiedRoleDefinitionId1 key: id of unifiedRoleDefinition
 @return ApiRoleManagementDirectoryRoleDefinitionsUpdateInheritsPermissionsFromRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryRoleDefinitionsUpdateInheritsPermissionsFrom(ctx _context.Context, unifiedRoleDefinitionId string, unifiedRoleDefinitionId1 string) ApiRoleManagementDirectoryRoleDefinitionsUpdateInheritsPermissionsFromRequest {
	return ApiRoleManagementDirectoryRoleDefinitionsUpdateInheritsPermissionsFromRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleDefinitionId: unifiedRoleDefinitionId,
		unifiedRoleDefinitionId1: unifiedRoleDefinitionId1,
	}
}

// Execute executes the request
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryRoleDefinitionsUpdateInheritsPermissionsFromExecute(r ApiRoleManagementDirectoryRoleDefinitionsUpdateInheritsPermissionsFromRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementDirectoryRoleDefinitionsUpdateInheritsPermissionsFrom")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/directory/roleDefinitions/{unifiedRoleDefinition-id}/inheritsPermissionsFrom/{unifiedRoleDefinition-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleDefinitionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleDefinition-id1"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleDefinitionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphUnifiedRoleDefinition == nil {
		return nil, reportError("microsoftGraphUnifiedRoleDefinition is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphUnifiedRoleDefinition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRoleManagementDirectoryUpdateRoleAssignmentsRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleAssignmentId string
	microsoftGraphUnifiedRoleAssignment *MicrosoftGraphUnifiedRoleAssignment
}

// New navigation property values
func (r ApiRoleManagementDirectoryUpdateRoleAssignmentsRequest) MicrosoftGraphUnifiedRoleAssignment(microsoftGraphUnifiedRoleAssignment MicrosoftGraphUnifiedRoleAssignment) ApiRoleManagementDirectoryUpdateRoleAssignmentsRequest {
	r.microsoftGraphUnifiedRoleAssignment = &microsoftGraphUnifiedRoleAssignment
	return r
}

func (r ApiRoleManagementDirectoryUpdateRoleAssignmentsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RoleManagementDirectoryUpdateRoleAssignmentsExecute(r)
}

/*
RoleManagementDirectoryUpdateRoleAssignments Update the navigation property roleAssignments in roleManagement

Resource to grant access to users or groups.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleAssignmentId key: id of unifiedRoleAssignment
 @return ApiRoleManagementDirectoryUpdateRoleAssignmentsRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryUpdateRoleAssignments(ctx _context.Context, unifiedRoleAssignmentId string) ApiRoleManagementDirectoryUpdateRoleAssignmentsRequest {
	return ApiRoleManagementDirectoryUpdateRoleAssignmentsRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleAssignmentId: unifiedRoleAssignmentId,
	}
}

// Execute executes the request
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryUpdateRoleAssignmentsExecute(r ApiRoleManagementDirectoryUpdateRoleAssignmentsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementDirectoryUpdateRoleAssignments")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/directory/roleAssignments/{unifiedRoleAssignment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphUnifiedRoleAssignment == nil {
		return nil, reportError("microsoftGraphUnifiedRoleAssignment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphUnifiedRoleAssignment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRoleManagementDirectoryUpdateRoleDefinitionsRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleDefinitionId string
	microsoftGraphUnifiedRoleDefinition *MicrosoftGraphUnifiedRoleDefinition
}

// New navigation property values
func (r ApiRoleManagementDirectoryUpdateRoleDefinitionsRequest) MicrosoftGraphUnifiedRoleDefinition(microsoftGraphUnifiedRoleDefinition MicrosoftGraphUnifiedRoleDefinition) ApiRoleManagementDirectoryUpdateRoleDefinitionsRequest {
	r.microsoftGraphUnifiedRoleDefinition = &microsoftGraphUnifiedRoleDefinition
	return r
}

func (r ApiRoleManagementDirectoryUpdateRoleDefinitionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RoleManagementDirectoryUpdateRoleDefinitionsExecute(r)
}

/*
RoleManagementDirectoryUpdateRoleDefinitions Update the navigation property roleDefinitions in roleManagement

Resource representing the roles allowed by RBAC providers and the permissions assigned to the roles.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleDefinitionId key: id of unifiedRoleDefinition
 @return ApiRoleManagementDirectoryUpdateRoleDefinitionsRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryUpdateRoleDefinitions(ctx _context.Context, unifiedRoleDefinitionId string) ApiRoleManagementDirectoryUpdateRoleDefinitionsRequest {
	return ApiRoleManagementDirectoryUpdateRoleDefinitionsRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleDefinitionId: unifiedRoleDefinitionId,
	}
}

// Execute executes the request
func (a *RoleManagementRbacApplicationApiService) RoleManagementDirectoryUpdateRoleDefinitionsExecute(r ApiRoleManagementDirectoryUpdateRoleDefinitionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementDirectoryUpdateRoleDefinitions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/directory/roleDefinitions/{unifiedRoleDefinition-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphUnifiedRoleDefinition == nil {
		return nil, reportError("microsoftGraphUnifiedRoleDefinition is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphUnifiedRoleDefinition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRoleManagementEntitlementManagementCreateRoleAssignmentsRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	microsoftGraphUnifiedRoleAssignment *MicrosoftGraphUnifiedRoleAssignment
}

// New navigation property
func (r ApiRoleManagementEntitlementManagementCreateRoleAssignmentsRequest) MicrosoftGraphUnifiedRoleAssignment(microsoftGraphUnifiedRoleAssignment MicrosoftGraphUnifiedRoleAssignment) ApiRoleManagementEntitlementManagementCreateRoleAssignmentsRequest {
	r.microsoftGraphUnifiedRoleAssignment = &microsoftGraphUnifiedRoleAssignment
	return r
}

func (r ApiRoleManagementEntitlementManagementCreateRoleAssignmentsRequest) Execute() (MicrosoftGraphUnifiedRoleAssignment, *_nethttp.Response, error) {
	return r.ApiService.RoleManagementEntitlementManagementCreateRoleAssignmentsExecute(r)
}

/*
RoleManagementEntitlementManagementCreateRoleAssignments Create new navigation property to roleAssignments for roleManagement

Resource to grant access to users or groups.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRoleManagementEntitlementManagementCreateRoleAssignmentsRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementCreateRoleAssignments(ctx _context.Context) ApiRoleManagementEntitlementManagementCreateRoleAssignmentsRequest {
	return ApiRoleManagementEntitlementManagementCreateRoleAssignmentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphUnifiedRoleAssignment
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementCreateRoleAssignmentsExecute(r ApiRoleManagementEntitlementManagementCreateRoleAssignmentsRequest) (MicrosoftGraphUnifiedRoleAssignment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphUnifiedRoleAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementEntitlementManagementCreateRoleAssignments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/entitlementManagement/roleAssignments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphUnifiedRoleAssignment == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphUnifiedRoleAssignment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphUnifiedRoleAssignment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRoleManagementEntitlementManagementCreateRoleDefinitionsRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	microsoftGraphUnifiedRoleDefinition *MicrosoftGraphUnifiedRoleDefinition
}

// New navigation property
func (r ApiRoleManagementEntitlementManagementCreateRoleDefinitionsRequest) MicrosoftGraphUnifiedRoleDefinition(microsoftGraphUnifiedRoleDefinition MicrosoftGraphUnifiedRoleDefinition) ApiRoleManagementEntitlementManagementCreateRoleDefinitionsRequest {
	r.microsoftGraphUnifiedRoleDefinition = &microsoftGraphUnifiedRoleDefinition
	return r
}

func (r ApiRoleManagementEntitlementManagementCreateRoleDefinitionsRequest) Execute() (MicrosoftGraphUnifiedRoleDefinition, *_nethttp.Response, error) {
	return r.ApiService.RoleManagementEntitlementManagementCreateRoleDefinitionsExecute(r)
}

/*
RoleManagementEntitlementManagementCreateRoleDefinitions Create new navigation property to roleDefinitions for roleManagement

Resource representing the roles allowed by RBAC providers and the permissions assigned to the roles.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRoleManagementEntitlementManagementCreateRoleDefinitionsRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementCreateRoleDefinitions(ctx _context.Context) ApiRoleManagementEntitlementManagementCreateRoleDefinitionsRequest {
	return ApiRoleManagementEntitlementManagementCreateRoleDefinitionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphUnifiedRoleDefinition
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementCreateRoleDefinitionsExecute(r ApiRoleManagementEntitlementManagementCreateRoleDefinitionsRequest) (MicrosoftGraphUnifiedRoleDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphUnifiedRoleDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementEntitlementManagementCreateRoleDefinitions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/entitlementManagement/roleDefinitions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphUnifiedRoleDefinition == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphUnifiedRoleDefinition is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphUnifiedRoleDefinition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRoleManagementEntitlementManagementDeleteRoleAssignmentsRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleAssignmentId string
	ifMatch *string
}

// ETag
func (r ApiRoleManagementEntitlementManagementDeleteRoleAssignmentsRequest) IfMatch(ifMatch string) ApiRoleManagementEntitlementManagementDeleteRoleAssignmentsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiRoleManagementEntitlementManagementDeleteRoleAssignmentsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RoleManagementEntitlementManagementDeleteRoleAssignmentsExecute(r)
}

/*
RoleManagementEntitlementManagementDeleteRoleAssignments Delete navigation property roleAssignments for roleManagement

Resource to grant access to users or groups.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleAssignmentId key: id of unifiedRoleAssignment
 @return ApiRoleManagementEntitlementManagementDeleteRoleAssignmentsRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementDeleteRoleAssignments(ctx _context.Context, unifiedRoleAssignmentId string) ApiRoleManagementEntitlementManagementDeleteRoleAssignmentsRequest {
	return ApiRoleManagementEntitlementManagementDeleteRoleAssignmentsRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleAssignmentId: unifiedRoleAssignmentId,
	}
}

// Execute executes the request
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementDeleteRoleAssignmentsExecute(r ApiRoleManagementEntitlementManagementDeleteRoleAssignmentsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementEntitlementManagementDeleteRoleAssignments")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/entitlementManagement/roleAssignments/{unifiedRoleAssignment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRoleManagementEntitlementManagementDeleteRoleDefinitionsRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleDefinitionId string
	ifMatch *string
}

// ETag
func (r ApiRoleManagementEntitlementManagementDeleteRoleDefinitionsRequest) IfMatch(ifMatch string) ApiRoleManagementEntitlementManagementDeleteRoleDefinitionsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiRoleManagementEntitlementManagementDeleteRoleDefinitionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RoleManagementEntitlementManagementDeleteRoleDefinitionsExecute(r)
}

/*
RoleManagementEntitlementManagementDeleteRoleDefinitions Delete navigation property roleDefinitions for roleManagement

Resource representing the roles allowed by RBAC providers and the permissions assigned to the roles.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleDefinitionId key: id of unifiedRoleDefinition
 @return ApiRoleManagementEntitlementManagementDeleteRoleDefinitionsRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementDeleteRoleDefinitions(ctx _context.Context, unifiedRoleDefinitionId string) ApiRoleManagementEntitlementManagementDeleteRoleDefinitionsRequest {
	return ApiRoleManagementEntitlementManagementDeleteRoleDefinitionsRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleDefinitionId: unifiedRoleDefinitionId,
	}
}

// Execute executes the request
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementDeleteRoleDefinitionsExecute(r ApiRoleManagementEntitlementManagementDeleteRoleDefinitionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementEntitlementManagementDeleteRoleDefinitions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/entitlementManagement/roleDefinitions/{unifiedRoleDefinition-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRoleManagementEntitlementManagementGetRoleAssignmentsRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleAssignmentId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiRoleManagementEntitlementManagementGetRoleAssignmentsRequest) Select_(select_ []string) ApiRoleManagementEntitlementManagementGetRoleAssignmentsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiRoleManagementEntitlementManagementGetRoleAssignmentsRequest) Expand(expand []string) ApiRoleManagementEntitlementManagementGetRoleAssignmentsRequest {
	r.expand = &expand
	return r
}

func (r ApiRoleManagementEntitlementManagementGetRoleAssignmentsRequest) Execute() (MicrosoftGraphUnifiedRoleAssignment, *_nethttp.Response, error) {
	return r.ApiService.RoleManagementEntitlementManagementGetRoleAssignmentsExecute(r)
}

/*
RoleManagementEntitlementManagementGetRoleAssignments Get roleAssignments from roleManagement

Resource to grant access to users or groups.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleAssignmentId key: id of unifiedRoleAssignment
 @return ApiRoleManagementEntitlementManagementGetRoleAssignmentsRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementGetRoleAssignments(ctx _context.Context, unifiedRoleAssignmentId string) ApiRoleManagementEntitlementManagementGetRoleAssignmentsRequest {
	return ApiRoleManagementEntitlementManagementGetRoleAssignmentsRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleAssignmentId: unifiedRoleAssignmentId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphUnifiedRoleAssignment
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementGetRoleAssignmentsExecute(r ApiRoleManagementEntitlementManagementGetRoleAssignmentsRequest) (MicrosoftGraphUnifiedRoleAssignment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphUnifiedRoleAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementEntitlementManagementGetRoleAssignments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/entitlementManagement/roleAssignments/{unifiedRoleAssignment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRoleManagementEntitlementManagementGetRoleDefinitionsRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleDefinitionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiRoleManagementEntitlementManagementGetRoleDefinitionsRequest) Select_(select_ []string) ApiRoleManagementEntitlementManagementGetRoleDefinitionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiRoleManagementEntitlementManagementGetRoleDefinitionsRequest) Expand(expand []string) ApiRoleManagementEntitlementManagementGetRoleDefinitionsRequest {
	r.expand = &expand
	return r
}

func (r ApiRoleManagementEntitlementManagementGetRoleDefinitionsRequest) Execute() (MicrosoftGraphUnifiedRoleDefinition, *_nethttp.Response, error) {
	return r.ApiService.RoleManagementEntitlementManagementGetRoleDefinitionsExecute(r)
}

/*
RoleManagementEntitlementManagementGetRoleDefinitions Get roleDefinitions from roleManagement

Resource representing the roles allowed by RBAC providers and the permissions assigned to the roles.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleDefinitionId key: id of unifiedRoleDefinition
 @return ApiRoleManagementEntitlementManagementGetRoleDefinitionsRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementGetRoleDefinitions(ctx _context.Context, unifiedRoleDefinitionId string) ApiRoleManagementEntitlementManagementGetRoleDefinitionsRequest {
	return ApiRoleManagementEntitlementManagementGetRoleDefinitionsRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleDefinitionId: unifiedRoleDefinitionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphUnifiedRoleDefinition
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementGetRoleDefinitionsExecute(r ApiRoleManagementEntitlementManagementGetRoleDefinitionsRequest) (MicrosoftGraphUnifiedRoleDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphUnifiedRoleDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementEntitlementManagementGetRoleDefinitions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/entitlementManagement/roleDefinitions/{unifiedRoleDefinition-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRoleManagementEntitlementManagementListRoleAssignmentsRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiRoleManagementEntitlementManagementListRoleAssignmentsRequest) Top(top int32) ApiRoleManagementEntitlementManagementListRoleAssignmentsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiRoleManagementEntitlementManagementListRoleAssignmentsRequest) Skip(skip int32) ApiRoleManagementEntitlementManagementListRoleAssignmentsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiRoleManagementEntitlementManagementListRoleAssignmentsRequest) Search(search string) ApiRoleManagementEntitlementManagementListRoleAssignmentsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiRoleManagementEntitlementManagementListRoleAssignmentsRequest) Filter(filter string) ApiRoleManagementEntitlementManagementListRoleAssignmentsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiRoleManagementEntitlementManagementListRoleAssignmentsRequest) Count(count bool) ApiRoleManagementEntitlementManagementListRoleAssignmentsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiRoleManagementEntitlementManagementListRoleAssignmentsRequest) Orderby(orderby []string) ApiRoleManagementEntitlementManagementListRoleAssignmentsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiRoleManagementEntitlementManagementListRoleAssignmentsRequest) Select_(select_ []string) ApiRoleManagementEntitlementManagementListRoleAssignmentsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiRoleManagementEntitlementManagementListRoleAssignmentsRequest) Expand(expand []string) ApiRoleManagementEntitlementManagementListRoleAssignmentsRequest {
	r.expand = &expand
	return r
}

func (r ApiRoleManagementEntitlementManagementListRoleAssignmentsRequest) Execute() (CollectionOfUnifiedRoleAssignment, *_nethttp.Response, error) {
	return r.ApiService.RoleManagementEntitlementManagementListRoleAssignmentsExecute(r)
}

/*
RoleManagementEntitlementManagementListRoleAssignments Get roleAssignments from roleManagement

Resource to grant access to users or groups.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRoleManagementEntitlementManagementListRoleAssignmentsRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementListRoleAssignments(ctx _context.Context) ApiRoleManagementEntitlementManagementListRoleAssignmentsRequest {
	return ApiRoleManagementEntitlementManagementListRoleAssignmentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionOfUnifiedRoleAssignment
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementListRoleAssignmentsExecute(r ApiRoleManagementEntitlementManagementListRoleAssignmentsRequest) (CollectionOfUnifiedRoleAssignment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfUnifiedRoleAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementEntitlementManagementListRoleAssignments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/entitlementManagement/roleAssignments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRoleManagementEntitlementManagementListRoleDefinitionsRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiRoleManagementEntitlementManagementListRoleDefinitionsRequest) Top(top int32) ApiRoleManagementEntitlementManagementListRoleDefinitionsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiRoleManagementEntitlementManagementListRoleDefinitionsRequest) Skip(skip int32) ApiRoleManagementEntitlementManagementListRoleDefinitionsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiRoleManagementEntitlementManagementListRoleDefinitionsRequest) Search(search string) ApiRoleManagementEntitlementManagementListRoleDefinitionsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiRoleManagementEntitlementManagementListRoleDefinitionsRequest) Filter(filter string) ApiRoleManagementEntitlementManagementListRoleDefinitionsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiRoleManagementEntitlementManagementListRoleDefinitionsRequest) Count(count bool) ApiRoleManagementEntitlementManagementListRoleDefinitionsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiRoleManagementEntitlementManagementListRoleDefinitionsRequest) Orderby(orderby []string) ApiRoleManagementEntitlementManagementListRoleDefinitionsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiRoleManagementEntitlementManagementListRoleDefinitionsRequest) Select_(select_ []string) ApiRoleManagementEntitlementManagementListRoleDefinitionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiRoleManagementEntitlementManagementListRoleDefinitionsRequest) Expand(expand []string) ApiRoleManagementEntitlementManagementListRoleDefinitionsRequest {
	r.expand = &expand
	return r
}

func (r ApiRoleManagementEntitlementManagementListRoleDefinitionsRequest) Execute() (CollectionOfUnifiedRoleDefinition, *_nethttp.Response, error) {
	return r.ApiService.RoleManagementEntitlementManagementListRoleDefinitionsExecute(r)
}

/*
RoleManagementEntitlementManagementListRoleDefinitions Get roleDefinitions from roleManagement

Resource representing the roles allowed by RBAC providers and the permissions assigned to the roles.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRoleManagementEntitlementManagementListRoleDefinitionsRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementListRoleDefinitions(ctx _context.Context) ApiRoleManagementEntitlementManagementListRoleDefinitionsRequest {
	return ApiRoleManagementEntitlementManagementListRoleDefinitionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionOfUnifiedRoleDefinition
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementListRoleDefinitionsExecute(r ApiRoleManagementEntitlementManagementListRoleDefinitionsRequest) (CollectionOfUnifiedRoleDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfUnifiedRoleDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementEntitlementManagementListRoleDefinitions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/entitlementManagement/roleDefinitions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRoleManagementEntitlementManagementRoleAssignmentsDeleteAppScopeRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleAssignmentId string
	ifMatch *string
}

// ETag
func (r ApiRoleManagementEntitlementManagementRoleAssignmentsDeleteAppScopeRequest) IfMatch(ifMatch string) ApiRoleManagementEntitlementManagementRoleAssignmentsDeleteAppScopeRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiRoleManagementEntitlementManagementRoleAssignmentsDeleteAppScopeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RoleManagementEntitlementManagementRoleAssignmentsDeleteAppScopeExecute(r)
}

/*
RoleManagementEntitlementManagementRoleAssignmentsDeleteAppScope Delete navigation property appScope for roleManagement

Read-only property with details of the app specific scope when the assignment scope is app specific. Containment entity. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleAssignmentId key: id of unifiedRoleAssignment
 @return ApiRoleManagementEntitlementManagementRoleAssignmentsDeleteAppScopeRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementRoleAssignmentsDeleteAppScope(ctx _context.Context, unifiedRoleAssignmentId string) ApiRoleManagementEntitlementManagementRoleAssignmentsDeleteAppScopeRequest {
	return ApiRoleManagementEntitlementManagementRoleAssignmentsDeleteAppScopeRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleAssignmentId: unifiedRoleAssignmentId,
	}
}

// Execute executes the request
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementRoleAssignmentsDeleteAppScopeExecute(r ApiRoleManagementEntitlementManagementRoleAssignmentsDeleteAppScopeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementEntitlementManagementRoleAssignmentsDeleteAppScope")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/entitlementManagement/roleAssignments/{unifiedRoleAssignment-id}/appScope"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRoleManagementEntitlementManagementRoleAssignmentsDeleteRefDirectoryScopeRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleAssignmentId string
	ifMatch *string
}

// ETag
func (r ApiRoleManagementEntitlementManagementRoleAssignmentsDeleteRefDirectoryScopeRequest) IfMatch(ifMatch string) ApiRoleManagementEntitlementManagementRoleAssignmentsDeleteRefDirectoryScopeRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiRoleManagementEntitlementManagementRoleAssignmentsDeleteRefDirectoryScopeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RoleManagementEntitlementManagementRoleAssignmentsDeleteRefDirectoryScopeExecute(r)
}

/*
RoleManagementEntitlementManagementRoleAssignmentsDeleteRefDirectoryScope Delete ref of navigation property directoryScope for roleManagement

The directory object that is the scope of the assignment. Read-only. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleAssignmentId key: id of unifiedRoleAssignment
 @return ApiRoleManagementEntitlementManagementRoleAssignmentsDeleteRefDirectoryScopeRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementRoleAssignmentsDeleteRefDirectoryScope(ctx _context.Context, unifiedRoleAssignmentId string) ApiRoleManagementEntitlementManagementRoleAssignmentsDeleteRefDirectoryScopeRequest {
	return ApiRoleManagementEntitlementManagementRoleAssignmentsDeleteRefDirectoryScopeRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleAssignmentId: unifiedRoleAssignmentId,
	}
}

// Execute executes the request
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementRoleAssignmentsDeleteRefDirectoryScopeExecute(r ApiRoleManagementEntitlementManagementRoleAssignmentsDeleteRefDirectoryScopeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementEntitlementManagementRoleAssignmentsDeleteRefDirectoryScope")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/entitlementManagement/roleAssignments/{unifiedRoleAssignment-id}/directoryScope/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRoleManagementEntitlementManagementRoleAssignmentsDeleteRefPrincipalRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleAssignmentId string
	ifMatch *string
}

// ETag
func (r ApiRoleManagementEntitlementManagementRoleAssignmentsDeleteRefPrincipalRequest) IfMatch(ifMatch string) ApiRoleManagementEntitlementManagementRoleAssignmentsDeleteRefPrincipalRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiRoleManagementEntitlementManagementRoleAssignmentsDeleteRefPrincipalRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RoleManagementEntitlementManagementRoleAssignmentsDeleteRefPrincipalExecute(r)
}

/*
RoleManagementEntitlementManagementRoleAssignmentsDeleteRefPrincipal Delete ref of navigation property principal for roleManagement

Referencing the assigned principal. Read-only. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleAssignmentId key: id of unifiedRoleAssignment
 @return ApiRoleManagementEntitlementManagementRoleAssignmentsDeleteRefPrincipalRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementRoleAssignmentsDeleteRefPrincipal(ctx _context.Context, unifiedRoleAssignmentId string) ApiRoleManagementEntitlementManagementRoleAssignmentsDeleteRefPrincipalRequest {
	return ApiRoleManagementEntitlementManagementRoleAssignmentsDeleteRefPrincipalRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleAssignmentId: unifiedRoleAssignmentId,
	}
}

// Execute executes the request
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementRoleAssignmentsDeleteRefPrincipalExecute(r ApiRoleManagementEntitlementManagementRoleAssignmentsDeleteRefPrincipalRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementEntitlementManagementRoleAssignmentsDeleteRefPrincipal")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/entitlementManagement/roleAssignments/{unifiedRoleAssignment-id}/principal/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRoleManagementEntitlementManagementRoleAssignmentsDeleteRefRoleDefinitionRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleAssignmentId string
	ifMatch *string
}

// ETag
func (r ApiRoleManagementEntitlementManagementRoleAssignmentsDeleteRefRoleDefinitionRequest) IfMatch(ifMatch string) ApiRoleManagementEntitlementManagementRoleAssignmentsDeleteRefRoleDefinitionRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiRoleManagementEntitlementManagementRoleAssignmentsDeleteRefRoleDefinitionRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RoleManagementEntitlementManagementRoleAssignmentsDeleteRefRoleDefinitionExecute(r)
}

/*
RoleManagementEntitlementManagementRoleAssignmentsDeleteRefRoleDefinition Delete ref of navigation property roleDefinition for roleManagement

The roleDefinition the assignment is for.  Supports $expand. roleDefinition.Id will be auto expanded.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleAssignmentId key: id of unifiedRoleAssignment
 @return ApiRoleManagementEntitlementManagementRoleAssignmentsDeleteRefRoleDefinitionRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementRoleAssignmentsDeleteRefRoleDefinition(ctx _context.Context, unifiedRoleAssignmentId string) ApiRoleManagementEntitlementManagementRoleAssignmentsDeleteRefRoleDefinitionRequest {
	return ApiRoleManagementEntitlementManagementRoleAssignmentsDeleteRefRoleDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleAssignmentId: unifiedRoleAssignmentId,
	}
}

// Execute executes the request
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementRoleAssignmentsDeleteRefRoleDefinitionExecute(r ApiRoleManagementEntitlementManagementRoleAssignmentsDeleteRefRoleDefinitionRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementEntitlementManagementRoleAssignmentsDeleteRefRoleDefinition")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/entitlementManagement/roleAssignments/{unifiedRoleAssignment-id}/roleDefinition/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRoleManagementEntitlementManagementRoleAssignmentsGetAppScopeRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleAssignmentId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiRoleManagementEntitlementManagementRoleAssignmentsGetAppScopeRequest) Select_(select_ []string) ApiRoleManagementEntitlementManagementRoleAssignmentsGetAppScopeRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiRoleManagementEntitlementManagementRoleAssignmentsGetAppScopeRequest) Expand(expand []string) ApiRoleManagementEntitlementManagementRoleAssignmentsGetAppScopeRequest {
	r.expand = &expand
	return r
}

func (r ApiRoleManagementEntitlementManagementRoleAssignmentsGetAppScopeRequest) Execute() (MicrosoftGraphAppScope, *_nethttp.Response, error) {
	return r.ApiService.RoleManagementEntitlementManagementRoleAssignmentsGetAppScopeExecute(r)
}

/*
RoleManagementEntitlementManagementRoleAssignmentsGetAppScope Get appScope from roleManagement

Read-only property with details of the app specific scope when the assignment scope is app specific. Containment entity. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleAssignmentId key: id of unifiedRoleAssignment
 @return ApiRoleManagementEntitlementManagementRoleAssignmentsGetAppScopeRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementRoleAssignmentsGetAppScope(ctx _context.Context, unifiedRoleAssignmentId string) ApiRoleManagementEntitlementManagementRoleAssignmentsGetAppScopeRequest {
	return ApiRoleManagementEntitlementManagementRoleAssignmentsGetAppScopeRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleAssignmentId: unifiedRoleAssignmentId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphAppScope
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementRoleAssignmentsGetAppScopeExecute(r ApiRoleManagementEntitlementManagementRoleAssignmentsGetAppScopeRequest) (MicrosoftGraphAppScope, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphAppScope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementEntitlementManagementRoleAssignmentsGetAppScope")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/entitlementManagement/roleAssignments/{unifiedRoleAssignment-id}/appScope"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRoleManagementEntitlementManagementRoleAssignmentsGetDirectoryScopeRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleAssignmentId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiRoleManagementEntitlementManagementRoleAssignmentsGetDirectoryScopeRequest) Select_(select_ []string) ApiRoleManagementEntitlementManagementRoleAssignmentsGetDirectoryScopeRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiRoleManagementEntitlementManagementRoleAssignmentsGetDirectoryScopeRequest) Expand(expand []string) ApiRoleManagementEntitlementManagementRoleAssignmentsGetDirectoryScopeRequest {
	r.expand = &expand
	return r
}

func (r ApiRoleManagementEntitlementManagementRoleAssignmentsGetDirectoryScopeRequest) Execute() (MicrosoftGraphDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.RoleManagementEntitlementManagementRoleAssignmentsGetDirectoryScopeExecute(r)
}

/*
RoleManagementEntitlementManagementRoleAssignmentsGetDirectoryScope Get directoryScope from roleManagement

The directory object that is the scope of the assignment. Read-only. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleAssignmentId key: id of unifiedRoleAssignment
 @return ApiRoleManagementEntitlementManagementRoleAssignmentsGetDirectoryScopeRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementRoleAssignmentsGetDirectoryScope(ctx _context.Context, unifiedRoleAssignmentId string) ApiRoleManagementEntitlementManagementRoleAssignmentsGetDirectoryScopeRequest {
	return ApiRoleManagementEntitlementManagementRoleAssignmentsGetDirectoryScopeRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleAssignmentId: unifiedRoleAssignmentId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphDirectoryObject
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementRoleAssignmentsGetDirectoryScopeExecute(r ApiRoleManagementEntitlementManagementRoleAssignmentsGetDirectoryScopeRequest) (MicrosoftGraphDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementEntitlementManagementRoleAssignmentsGetDirectoryScope")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/entitlementManagement/roleAssignments/{unifiedRoleAssignment-id}/directoryScope"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRoleManagementEntitlementManagementRoleAssignmentsGetPrincipalRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleAssignmentId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiRoleManagementEntitlementManagementRoleAssignmentsGetPrincipalRequest) Select_(select_ []string) ApiRoleManagementEntitlementManagementRoleAssignmentsGetPrincipalRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiRoleManagementEntitlementManagementRoleAssignmentsGetPrincipalRequest) Expand(expand []string) ApiRoleManagementEntitlementManagementRoleAssignmentsGetPrincipalRequest {
	r.expand = &expand
	return r
}

func (r ApiRoleManagementEntitlementManagementRoleAssignmentsGetPrincipalRequest) Execute() (MicrosoftGraphDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.RoleManagementEntitlementManagementRoleAssignmentsGetPrincipalExecute(r)
}

/*
RoleManagementEntitlementManagementRoleAssignmentsGetPrincipal Get principal from roleManagement

Referencing the assigned principal. Read-only. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleAssignmentId key: id of unifiedRoleAssignment
 @return ApiRoleManagementEntitlementManagementRoleAssignmentsGetPrincipalRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementRoleAssignmentsGetPrincipal(ctx _context.Context, unifiedRoleAssignmentId string) ApiRoleManagementEntitlementManagementRoleAssignmentsGetPrincipalRequest {
	return ApiRoleManagementEntitlementManagementRoleAssignmentsGetPrincipalRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleAssignmentId: unifiedRoleAssignmentId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphDirectoryObject
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementRoleAssignmentsGetPrincipalExecute(r ApiRoleManagementEntitlementManagementRoleAssignmentsGetPrincipalRequest) (MicrosoftGraphDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementEntitlementManagementRoleAssignmentsGetPrincipal")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/entitlementManagement/roleAssignments/{unifiedRoleAssignment-id}/principal"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRoleManagementEntitlementManagementRoleAssignmentsGetRefDirectoryScopeRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleAssignmentId string
}


func (r ApiRoleManagementEntitlementManagementRoleAssignmentsGetRefDirectoryScopeRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.RoleManagementEntitlementManagementRoleAssignmentsGetRefDirectoryScopeExecute(r)
}

/*
RoleManagementEntitlementManagementRoleAssignmentsGetRefDirectoryScope Get ref of directoryScope from roleManagement

The directory object that is the scope of the assignment. Read-only. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleAssignmentId key: id of unifiedRoleAssignment
 @return ApiRoleManagementEntitlementManagementRoleAssignmentsGetRefDirectoryScopeRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementRoleAssignmentsGetRefDirectoryScope(ctx _context.Context, unifiedRoleAssignmentId string) ApiRoleManagementEntitlementManagementRoleAssignmentsGetRefDirectoryScopeRequest {
	return ApiRoleManagementEntitlementManagementRoleAssignmentsGetRefDirectoryScopeRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleAssignmentId: unifiedRoleAssignmentId,
	}
}

// Execute executes the request
//  @return string
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementRoleAssignmentsGetRefDirectoryScopeExecute(r ApiRoleManagementEntitlementManagementRoleAssignmentsGetRefDirectoryScopeRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementEntitlementManagementRoleAssignmentsGetRefDirectoryScope")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/entitlementManagement/roleAssignments/{unifiedRoleAssignment-id}/directoryScope/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRoleManagementEntitlementManagementRoleAssignmentsGetRefPrincipalRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleAssignmentId string
}


func (r ApiRoleManagementEntitlementManagementRoleAssignmentsGetRefPrincipalRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.RoleManagementEntitlementManagementRoleAssignmentsGetRefPrincipalExecute(r)
}

/*
RoleManagementEntitlementManagementRoleAssignmentsGetRefPrincipal Get ref of principal from roleManagement

Referencing the assigned principal. Read-only. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleAssignmentId key: id of unifiedRoleAssignment
 @return ApiRoleManagementEntitlementManagementRoleAssignmentsGetRefPrincipalRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementRoleAssignmentsGetRefPrincipal(ctx _context.Context, unifiedRoleAssignmentId string) ApiRoleManagementEntitlementManagementRoleAssignmentsGetRefPrincipalRequest {
	return ApiRoleManagementEntitlementManagementRoleAssignmentsGetRefPrincipalRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleAssignmentId: unifiedRoleAssignmentId,
	}
}

// Execute executes the request
//  @return string
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementRoleAssignmentsGetRefPrincipalExecute(r ApiRoleManagementEntitlementManagementRoleAssignmentsGetRefPrincipalRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementEntitlementManagementRoleAssignmentsGetRefPrincipal")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/entitlementManagement/roleAssignments/{unifiedRoleAssignment-id}/principal/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRoleManagementEntitlementManagementRoleAssignmentsGetRefRoleDefinitionRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleAssignmentId string
}


func (r ApiRoleManagementEntitlementManagementRoleAssignmentsGetRefRoleDefinitionRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.RoleManagementEntitlementManagementRoleAssignmentsGetRefRoleDefinitionExecute(r)
}

/*
RoleManagementEntitlementManagementRoleAssignmentsGetRefRoleDefinition Get ref of roleDefinition from roleManagement

The roleDefinition the assignment is for.  Supports $expand. roleDefinition.Id will be auto expanded.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleAssignmentId key: id of unifiedRoleAssignment
 @return ApiRoleManagementEntitlementManagementRoleAssignmentsGetRefRoleDefinitionRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementRoleAssignmentsGetRefRoleDefinition(ctx _context.Context, unifiedRoleAssignmentId string) ApiRoleManagementEntitlementManagementRoleAssignmentsGetRefRoleDefinitionRequest {
	return ApiRoleManagementEntitlementManagementRoleAssignmentsGetRefRoleDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleAssignmentId: unifiedRoleAssignmentId,
	}
}

// Execute executes the request
//  @return string
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementRoleAssignmentsGetRefRoleDefinitionExecute(r ApiRoleManagementEntitlementManagementRoleAssignmentsGetRefRoleDefinitionRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementEntitlementManagementRoleAssignmentsGetRefRoleDefinition")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/entitlementManagement/roleAssignments/{unifiedRoleAssignment-id}/roleDefinition/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRoleManagementEntitlementManagementRoleAssignmentsGetRoleDefinitionRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleAssignmentId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiRoleManagementEntitlementManagementRoleAssignmentsGetRoleDefinitionRequest) Select_(select_ []string) ApiRoleManagementEntitlementManagementRoleAssignmentsGetRoleDefinitionRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiRoleManagementEntitlementManagementRoleAssignmentsGetRoleDefinitionRequest) Expand(expand []string) ApiRoleManagementEntitlementManagementRoleAssignmentsGetRoleDefinitionRequest {
	r.expand = &expand
	return r
}

func (r ApiRoleManagementEntitlementManagementRoleAssignmentsGetRoleDefinitionRequest) Execute() (MicrosoftGraphUnifiedRoleDefinition, *_nethttp.Response, error) {
	return r.ApiService.RoleManagementEntitlementManagementRoleAssignmentsGetRoleDefinitionExecute(r)
}

/*
RoleManagementEntitlementManagementRoleAssignmentsGetRoleDefinition Get roleDefinition from roleManagement

The roleDefinition the assignment is for.  Supports $expand. roleDefinition.Id will be auto expanded.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleAssignmentId key: id of unifiedRoleAssignment
 @return ApiRoleManagementEntitlementManagementRoleAssignmentsGetRoleDefinitionRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementRoleAssignmentsGetRoleDefinition(ctx _context.Context, unifiedRoleAssignmentId string) ApiRoleManagementEntitlementManagementRoleAssignmentsGetRoleDefinitionRequest {
	return ApiRoleManagementEntitlementManagementRoleAssignmentsGetRoleDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleAssignmentId: unifiedRoleAssignmentId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphUnifiedRoleDefinition
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementRoleAssignmentsGetRoleDefinitionExecute(r ApiRoleManagementEntitlementManagementRoleAssignmentsGetRoleDefinitionRequest) (MicrosoftGraphUnifiedRoleDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphUnifiedRoleDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementEntitlementManagementRoleAssignmentsGetRoleDefinition")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/entitlementManagement/roleAssignments/{unifiedRoleAssignment-id}/roleDefinition"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRoleManagementEntitlementManagementRoleAssignmentsUpdateAppScopeRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleAssignmentId string
	microsoftGraphAppScope *MicrosoftGraphAppScope
}

// New navigation property values
func (r ApiRoleManagementEntitlementManagementRoleAssignmentsUpdateAppScopeRequest) MicrosoftGraphAppScope(microsoftGraphAppScope MicrosoftGraphAppScope) ApiRoleManagementEntitlementManagementRoleAssignmentsUpdateAppScopeRequest {
	r.microsoftGraphAppScope = &microsoftGraphAppScope
	return r
}

func (r ApiRoleManagementEntitlementManagementRoleAssignmentsUpdateAppScopeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RoleManagementEntitlementManagementRoleAssignmentsUpdateAppScopeExecute(r)
}

/*
RoleManagementEntitlementManagementRoleAssignmentsUpdateAppScope Update the navigation property appScope in roleManagement

Read-only property with details of the app specific scope when the assignment scope is app specific. Containment entity. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleAssignmentId key: id of unifiedRoleAssignment
 @return ApiRoleManagementEntitlementManagementRoleAssignmentsUpdateAppScopeRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementRoleAssignmentsUpdateAppScope(ctx _context.Context, unifiedRoleAssignmentId string) ApiRoleManagementEntitlementManagementRoleAssignmentsUpdateAppScopeRequest {
	return ApiRoleManagementEntitlementManagementRoleAssignmentsUpdateAppScopeRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleAssignmentId: unifiedRoleAssignmentId,
	}
}

// Execute executes the request
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementRoleAssignmentsUpdateAppScopeExecute(r ApiRoleManagementEntitlementManagementRoleAssignmentsUpdateAppScopeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementEntitlementManagementRoleAssignmentsUpdateAppScope")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/entitlementManagement/roleAssignments/{unifiedRoleAssignment-id}/appScope"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphAppScope == nil {
		return nil, reportError("microsoftGraphAppScope is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphAppScope
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRoleManagementEntitlementManagementRoleAssignmentsUpdateRefDirectoryScopeRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleAssignmentId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiRoleManagementEntitlementManagementRoleAssignmentsUpdateRefDirectoryScopeRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiRoleManagementEntitlementManagementRoleAssignmentsUpdateRefDirectoryScopeRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiRoleManagementEntitlementManagementRoleAssignmentsUpdateRefDirectoryScopeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RoleManagementEntitlementManagementRoleAssignmentsUpdateRefDirectoryScopeExecute(r)
}

/*
RoleManagementEntitlementManagementRoleAssignmentsUpdateRefDirectoryScope Update the ref of navigation property directoryScope in roleManagement

The directory object that is the scope of the assignment. Read-only. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleAssignmentId key: id of unifiedRoleAssignment
 @return ApiRoleManagementEntitlementManagementRoleAssignmentsUpdateRefDirectoryScopeRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementRoleAssignmentsUpdateRefDirectoryScope(ctx _context.Context, unifiedRoleAssignmentId string) ApiRoleManagementEntitlementManagementRoleAssignmentsUpdateRefDirectoryScopeRequest {
	return ApiRoleManagementEntitlementManagementRoleAssignmentsUpdateRefDirectoryScopeRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleAssignmentId: unifiedRoleAssignmentId,
	}
}

// Execute executes the request
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementRoleAssignmentsUpdateRefDirectoryScopeExecute(r ApiRoleManagementEntitlementManagementRoleAssignmentsUpdateRefDirectoryScopeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementEntitlementManagementRoleAssignmentsUpdateRefDirectoryScope")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/entitlementManagement/roleAssignments/{unifiedRoleAssignment-id}/directoryScope/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRoleManagementEntitlementManagementRoleAssignmentsUpdateRefPrincipalRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleAssignmentId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiRoleManagementEntitlementManagementRoleAssignmentsUpdateRefPrincipalRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiRoleManagementEntitlementManagementRoleAssignmentsUpdateRefPrincipalRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiRoleManagementEntitlementManagementRoleAssignmentsUpdateRefPrincipalRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RoleManagementEntitlementManagementRoleAssignmentsUpdateRefPrincipalExecute(r)
}

/*
RoleManagementEntitlementManagementRoleAssignmentsUpdateRefPrincipal Update the ref of navigation property principal in roleManagement

Referencing the assigned principal. Read-only. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleAssignmentId key: id of unifiedRoleAssignment
 @return ApiRoleManagementEntitlementManagementRoleAssignmentsUpdateRefPrincipalRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementRoleAssignmentsUpdateRefPrincipal(ctx _context.Context, unifiedRoleAssignmentId string) ApiRoleManagementEntitlementManagementRoleAssignmentsUpdateRefPrincipalRequest {
	return ApiRoleManagementEntitlementManagementRoleAssignmentsUpdateRefPrincipalRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleAssignmentId: unifiedRoleAssignmentId,
	}
}

// Execute executes the request
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementRoleAssignmentsUpdateRefPrincipalExecute(r ApiRoleManagementEntitlementManagementRoleAssignmentsUpdateRefPrincipalRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementEntitlementManagementRoleAssignmentsUpdateRefPrincipal")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/entitlementManagement/roleAssignments/{unifiedRoleAssignment-id}/principal/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRoleManagementEntitlementManagementRoleAssignmentsUpdateRefRoleDefinitionRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleAssignmentId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiRoleManagementEntitlementManagementRoleAssignmentsUpdateRefRoleDefinitionRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiRoleManagementEntitlementManagementRoleAssignmentsUpdateRefRoleDefinitionRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiRoleManagementEntitlementManagementRoleAssignmentsUpdateRefRoleDefinitionRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RoleManagementEntitlementManagementRoleAssignmentsUpdateRefRoleDefinitionExecute(r)
}

/*
RoleManagementEntitlementManagementRoleAssignmentsUpdateRefRoleDefinition Update the ref of navigation property roleDefinition in roleManagement

The roleDefinition the assignment is for.  Supports $expand. roleDefinition.Id will be auto expanded.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleAssignmentId key: id of unifiedRoleAssignment
 @return ApiRoleManagementEntitlementManagementRoleAssignmentsUpdateRefRoleDefinitionRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementRoleAssignmentsUpdateRefRoleDefinition(ctx _context.Context, unifiedRoleAssignmentId string) ApiRoleManagementEntitlementManagementRoleAssignmentsUpdateRefRoleDefinitionRequest {
	return ApiRoleManagementEntitlementManagementRoleAssignmentsUpdateRefRoleDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleAssignmentId: unifiedRoleAssignmentId,
	}
}

// Execute executes the request
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementRoleAssignmentsUpdateRefRoleDefinitionExecute(r ApiRoleManagementEntitlementManagementRoleAssignmentsUpdateRefRoleDefinitionRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementEntitlementManagementRoleAssignmentsUpdateRefRoleDefinition")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/entitlementManagement/roleAssignments/{unifiedRoleAssignment-id}/roleDefinition/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRoleManagementEntitlementManagementRoleDefinitionsCreateInheritsPermissionsFromRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleDefinitionId string
	microsoftGraphUnifiedRoleDefinition *MicrosoftGraphUnifiedRoleDefinition
}

// New navigation property
func (r ApiRoleManagementEntitlementManagementRoleDefinitionsCreateInheritsPermissionsFromRequest) MicrosoftGraphUnifiedRoleDefinition(microsoftGraphUnifiedRoleDefinition MicrosoftGraphUnifiedRoleDefinition) ApiRoleManagementEntitlementManagementRoleDefinitionsCreateInheritsPermissionsFromRequest {
	r.microsoftGraphUnifiedRoleDefinition = &microsoftGraphUnifiedRoleDefinition
	return r
}

func (r ApiRoleManagementEntitlementManagementRoleDefinitionsCreateInheritsPermissionsFromRequest) Execute() (MicrosoftGraphUnifiedRoleDefinition, *_nethttp.Response, error) {
	return r.ApiService.RoleManagementEntitlementManagementRoleDefinitionsCreateInheritsPermissionsFromExecute(r)
}

/*
RoleManagementEntitlementManagementRoleDefinitionsCreateInheritsPermissionsFrom Create new navigation property to inheritsPermissionsFrom for roleManagement

Read-only collection of role definitions that the given role definition inherits from. Only Azure AD built-in roles (isBuiltIn is true) support this attribute. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleDefinitionId key: id of unifiedRoleDefinition
 @return ApiRoleManagementEntitlementManagementRoleDefinitionsCreateInheritsPermissionsFromRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementRoleDefinitionsCreateInheritsPermissionsFrom(ctx _context.Context, unifiedRoleDefinitionId string) ApiRoleManagementEntitlementManagementRoleDefinitionsCreateInheritsPermissionsFromRequest {
	return ApiRoleManagementEntitlementManagementRoleDefinitionsCreateInheritsPermissionsFromRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleDefinitionId: unifiedRoleDefinitionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphUnifiedRoleDefinition
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementRoleDefinitionsCreateInheritsPermissionsFromExecute(r ApiRoleManagementEntitlementManagementRoleDefinitionsCreateInheritsPermissionsFromRequest) (MicrosoftGraphUnifiedRoleDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphUnifiedRoleDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementEntitlementManagementRoleDefinitionsCreateInheritsPermissionsFrom")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/entitlementManagement/roleDefinitions/{unifiedRoleDefinition-id}/inheritsPermissionsFrom"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphUnifiedRoleDefinition == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphUnifiedRoleDefinition is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphUnifiedRoleDefinition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRoleManagementEntitlementManagementRoleDefinitionsDeleteInheritsPermissionsFromRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleDefinitionId string
	unifiedRoleDefinitionId1 string
	ifMatch *string
}

// ETag
func (r ApiRoleManagementEntitlementManagementRoleDefinitionsDeleteInheritsPermissionsFromRequest) IfMatch(ifMatch string) ApiRoleManagementEntitlementManagementRoleDefinitionsDeleteInheritsPermissionsFromRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiRoleManagementEntitlementManagementRoleDefinitionsDeleteInheritsPermissionsFromRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RoleManagementEntitlementManagementRoleDefinitionsDeleteInheritsPermissionsFromExecute(r)
}

/*
RoleManagementEntitlementManagementRoleDefinitionsDeleteInheritsPermissionsFrom Delete navigation property inheritsPermissionsFrom for roleManagement

Read-only collection of role definitions that the given role definition inherits from. Only Azure AD built-in roles (isBuiltIn is true) support this attribute. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleDefinitionId key: id of unifiedRoleDefinition
 @param unifiedRoleDefinitionId1 key: id of unifiedRoleDefinition
 @return ApiRoleManagementEntitlementManagementRoleDefinitionsDeleteInheritsPermissionsFromRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementRoleDefinitionsDeleteInheritsPermissionsFrom(ctx _context.Context, unifiedRoleDefinitionId string, unifiedRoleDefinitionId1 string) ApiRoleManagementEntitlementManagementRoleDefinitionsDeleteInheritsPermissionsFromRequest {
	return ApiRoleManagementEntitlementManagementRoleDefinitionsDeleteInheritsPermissionsFromRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleDefinitionId: unifiedRoleDefinitionId,
		unifiedRoleDefinitionId1: unifiedRoleDefinitionId1,
	}
}

// Execute executes the request
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementRoleDefinitionsDeleteInheritsPermissionsFromExecute(r ApiRoleManagementEntitlementManagementRoleDefinitionsDeleteInheritsPermissionsFromRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementEntitlementManagementRoleDefinitionsDeleteInheritsPermissionsFrom")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/entitlementManagement/roleDefinitions/{unifiedRoleDefinition-id}/inheritsPermissionsFrom/{unifiedRoleDefinition-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleDefinitionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleDefinition-id1"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleDefinitionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRoleManagementEntitlementManagementRoleDefinitionsGetInheritsPermissionsFromRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleDefinitionId string
	unifiedRoleDefinitionId1 string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiRoleManagementEntitlementManagementRoleDefinitionsGetInheritsPermissionsFromRequest) Select_(select_ []string) ApiRoleManagementEntitlementManagementRoleDefinitionsGetInheritsPermissionsFromRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiRoleManagementEntitlementManagementRoleDefinitionsGetInheritsPermissionsFromRequest) Expand(expand []string) ApiRoleManagementEntitlementManagementRoleDefinitionsGetInheritsPermissionsFromRequest {
	r.expand = &expand
	return r
}

func (r ApiRoleManagementEntitlementManagementRoleDefinitionsGetInheritsPermissionsFromRequest) Execute() (MicrosoftGraphUnifiedRoleDefinition, *_nethttp.Response, error) {
	return r.ApiService.RoleManagementEntitlementManagementRoleDefinitionsGetInheritsPermissionsFromExecute(r)
}

/*
RoleManagementEntitlementManagementRoleDefinitionsGetInheritsPermissionsFrom Get inheritsPermissionsFrom from roleManagement

Read-only collection of role definitions that the given role definition inherits from. Only Azure AD built-in roles (isBuiltIn is true) support this attribute. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleDefinitionId key: id of unifiedRoleDefinition
 @param unifiedRoleDefinitionId1 key: id of unifiedRoleDefinition
 @return ApiRoleManagementEntitlementManagementRoleDefinitionsGetInheritsPermissionsFromRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementRoleDefinitionsGetInheritsPermissionsFrom(ctx _context.Context, unifiedRoleDefinitionId string, unifiedRoleDefinitionId1 string) ApiRoleManagementEntitlementManagementRoleDefinitionsGetInheritsPermissionsFromRequest {
	return ApiRoleManagementEntitlementManagementRoleDefinitionsGetInheritsPermissionsFromRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleDefinitionId: unifiedRoleDefinitionId,
		unifiedRoleDefinitionId1: unifiedRoleDefinitionId1,
	}
}

// Execute executes the request
//  @return MicrosoftGraphUnifiedRoleDefinition
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementRoleDefinitionsGetInheritsPermissionsFromExecute(r ApiRoleManagementEntitlementManagementRoleDefinitionsGetInheritsPermissionsFromRequest) (MicrosoftGraphUnifiedRoleDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphUnifiedRoleDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementEntitlementManagementRoleDefinitionsGetInheritsPermissionsFrom")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/entitlementManagement/roleDefinitions/{unifiedRoleDefinition-id}/inheritsPermissionsFrom/{unifiedRoleDefinition-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleDefinitionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleDefinition-id1"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleDefinitionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRoleManagementEntitlementManagementRoleDefinitionsListInheritsPermissionsFromRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleDefinitionId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiRoleManagementEntitlementManagementRoleDefinitionsListInheritsPermissionsFromRequest) Top(top int32) ApiRoleManagementEntitlementManagementRoleDefinitionsListInheritsPermissionsFromRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiRoleManagementEntitlementManagementRoleDefinitionsListInheritsPermissionsFromRequest) Skip(skip int32) ApiRoleManagementEntitlementManagementRoleDefinitionsListInheritsPermissionsFromRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiRoleManagementEntitlementManagementRoleDefinitionsListInheritsPermissionsFromRequest) Search(search string) ApiRoleManagementEntitlementManagementRoleDefinitionsListInheritsPermissionsFromRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiRoleManagementEntitlementManagementRoleDefinitionsListInheritsPermissionsFromRequest) Filter(filter string) ApiRoleManagementEntitlementManagementRoleDefinitionsListInheritsPermissionsFromRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiRoleManagementEntitlementManagementRoleDefinitionsListInheritsPermissionsFromRequest) Count(count bool) ApiRoleManagementEntitlementManagementRoleDefinitionsListInheritsPermissionsFromRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiRoleManagementEntitlementManagementRoleDefinitionsListInheritsPermissionsFromRequest) Orderby(orderby []string) ApiRoleManagementEntitlementManagementRoleDefinitionsListInheritsPermissionsFromRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiRoleManagementEntitlementManagementRoleDefinitionsListInheritsPermissionsFromRequest) Select_(select_ []string) ApiRoleManagementEntitlementManagementRoleDefinitionsListInheritsPermissionsFromRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiRoleManagementEntitlementManagementRoleDefinitionsListInheritsPermissionsFromRequest) Expand(expand []string) ApiRoleManagementEntitlementManagementRoleDefinitionsListInheritsPermissionsFromRequest {
	r.expand = &expand
	return r
}

func (r ApiRoleManagementEntitlementManagementRoleDefinitionsListInheritsPermissionsFromRequest) Execute() (CollectionOfUnifiedRoleDefinition, *_nethttp.Response, error) {
	return r.ApiService.RoleManagementEntitlementManagementRoleDefinitionsListInheritsPermissionsFromExecute(r)
}

/*
RoleManagementEntitlementManagementRoleDefinitionsListInheritsPermissionsFrom Get inheritsPermissionsFrom from roleManagement

Read-only collection of role definitions that the given role definition inherits from. Only Azure AD built-in roles (isBuiltIn is true) support this attribute. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleDefinitionId key: id of unifiedRoleDefinition
 @return ApiRoleManagementEntitlementManagementRoleDefinitionsListInheritsPermissionsFromRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementRoleDefinitionsListInheritsPermissionsFrom(ctx _context.Context, unifiedRoleDefinitionId string) ApiRoleManagementEntitlementManagementRoleDefinitionsListInheritsPermissionsFromRequest {
	return ApiRoleManagementEntitlementManagementRoleDefinitionsListInheritsPermissionsFromRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleDefinitionId: unifiedRoleDefinitionId,
	}
}

// Execute executes the request
//  @return CollectionOfUnifiedRoleDefinition
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementRoleDefinitionsListInheritsPermissionsFromExecute(r ApiRoleManagementEntitlementManagementRoleDefinitionsListInheritsPermissionsFromRequest) (CollectionOfUnifiedRoleDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfUnifiedRoleDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementEntitlementManagementRoleDefinitionsListInheritsPermissionsFrom")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/entitlementManagement/roleDefinitions/{unifiedRoleDefinition-id}/inheritsPermissionsFrom"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRoleManagementEntitlementManagementRoleDefinitionsUpdateInheritsPermissionsFromRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleDefinitionId string
	unifiedRoleDefinitionId1 string
	microsoftGraphUnifiedRoleDefinition *MicrosoftGraphUnifiedRoleDefinition
}

// New navigation property values
func (r ApiRoleManagementEntitlementManagementRoleDefinitionsUpdateInheritsPermissionsFromRequest) MicrosoftGraphUnifiedRoleDefinition(microsoftGraphUnifiedRoleDefinition MicrosoftGraphUnifiedRoleDefinition) ApiRoleManagementEntitlementManagementRoleDefinitionsUpdateInheritsPermissionsFromRequest {
	r.microsoftGraphUnifiedRoleDefinition = &microsoftGraphUnifiedRoleDefinition
	return r
}

func (r ApiRoleManagementEntitlementManagementRoleDefinitionsUpdateInheritsPermissionsFromRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RoleManagementEntitlementManagementRoleDefinitionsUpdateInheritsPermissionsFromExecute(r)
}

/*
RoleManagementEntitlementManagementRoleDefinitionsUpdateInheritsPermissionsFrom Update the navigation property inheritsPermissionsFrom in roleManagement

Read-only collection of role definitions that the given role definition inherits from. Only Azure AD built-in roles (isBuiltIn is true) support this attribute. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleDefinitionId key: id of unifiedRoleDefinition
 @param unifiedRoleDefinitionId1 key: id of unifiedRoleDefinition
 @return ApiRoleManagementEntitlementManagementRoleDefinitionsUpdateInheritsPermissionsFromRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementRoleDefinitionsUpdateInheritsPermissionsFrom(ctx _context.Context, unifiedRoleDefinitionId string, unifiedRoleDefinitionId1 string) ApiRoleManagementEntitlementManagementRoleDefinitionsUpdateInheritsPermissionsFromRequest {
	return ApiRoleManagementEntitlementManagementRoleDefinitionsUpdateInheritsPermissionsFromRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleDefinitionId: unifiedRoleDefinitionId,
		unifiedRoleDefinitionId1: unifiedRoleDefinitionId1,
	}
}

// Execute executes the request
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementRoleDefinitionsUpdateInheritsPermissionsFromExecute(r ApiRoleManagementEntitlementManagementRoleDefinitionsUpdateInheritsPermissionsFromRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementEntitlementManagementRoleDefinitionsUpdateInheritsPermissionsFrom")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/entitlementManagement/roleDefinitions/{unifiedRoleDefinition-id}/inheritsPermissionsFrom/{unifiedRoleDefinition-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleDefinitionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleDefinition-id1"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleDefinitionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphUnifiedRoleDefinition == nil {
		return nil, reportError("microsoftGraphUnifiedRoleDefinition is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphUnifiedRoleDefinition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRoleManagementEntitlementManagementUpdateRoleAssignmentsRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleAssignmentId string
	microsoftGraphUnifiedRoleAssignment *MicrosoftGraphUnifiedRoleAssignment
}

// New navigation property values
func (r ApiRoleManagementEntitlementManagementUpdateRoleAssignmentsRequest) MicrosoftGraphUnifiedRoleAssignment(microsoftGraphUnifiedRoleAssignment MicrosoftGraphUnifiedRoleAssignment) ApiRoleManagementEntitlementManagementUpdateRoleAssignmentsRequest {
	r.microsoftGraphUnifiedRoleAssignment = &microsoftGraphUnifiedRoleAssignment
	return r
}

func (r ApiRoleManagementEntitlementManagementUpdateRoleAssignmentsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RoleManagementEntitlementManagementUpdateRoleAssignmentsExecute(r)
}

/*
RoleManagementEntitlementManagementUpdateRoleAssignments Update the navigation property roleAssignments in roleManagement

Resource to grant access to users or groups.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleAssignmentId key: id of unifiedRoleAssignment
 @return ApiRoleManagementEntitlementManagementUpdateRoleAssignmentsRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementUpdateRoleAssignments(ctx _context.Context, unifiedRoleAssignmentId string) ApiRoleManagementEntitlementManagementUpdateRoleAssignmentsRequest {
	return ApiRoleManagementEntitlementManagementUpdateRoleAssignmentsRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleAssignmentId: unifiedRoleAssignmentId,
	}
}

// Execute executes the request
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementUpdateRoleAssignmentsExecute(r ApiRoleManagementEntitlementManagementUpdateRoleAssignmentsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementEntitlementManagementUpdateRoleAssignments")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/entitlementManagement/roleAssignments/{unifiedRoleAssignment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphUnifiedRoleAssignment == nil {
		return nil, reportError("microsoftGraphUnifiedRoleAssignment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphUnifiedRoleAssignment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRoleManagementEntitlementManagementUpdateRoleDefinitionsRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	unifiedRoleDefinitionId string
	microsoftGraphUnifiedRoleDefinition *MicrosoftGraphUnifiedRoleDefinition
}

// New navigation property values
func (r ApiRoleManagementEntitlementManagementUpdateRoleDefinitionsRequest) MicrosoftGraphUnifiedRoleDefinition(microsoftGraphUnifiedRoleDefinition MicrosoftGraphUnifiedRoleDefinition) ApiRoleManagementEntitlementManagementUpdateRoleDefinitionsRequest {
	r.microsoftGraphUnifiedRoleDefinition = &microsoftGraphUnifiedRoleDefinition
	return r
}

func (r ApiRoleManagementEntitlementManagementUpdateRoleDefinitionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RoleManagementEntitlementManagementUpdateRoleDefinitionsExecute(r)
}

/*
RoleManagementEntitlementManagementUpdateRoleDefinitions Update the navigation property roleDefinitions in roleManagement

Resource representing the roles allowed by RBAC providers and the permissions assigned to the roles.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unifiedRoleDefinitionId key: id of unifiedRoleDefinition
 @return ApiRoleManagementEntitlementManagementUpdateRoleDefinitionsRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementUpdateRoleDefinitions(ctx _context.Context, unifiedRoleDefinitionId string) ApiRoleManagementEntitlementManagementUpdateRoleDefinitionsRequest {
	return ApiRoleManagementEntitlementManagementUpdateRoleDefinitionsRequest{
		ApiService: a,
		ctx: ctx,
		unifiedRoleDefinitionId: unifiedRoleDefinitionId,
	}
}

// Execute executes the request
func (a *RoleManagementRbacApplicationApiService) RoleManagementEntitlementManagementUpdateRoleDefinitionsExecute(r ApiRoleManagementEntitlementManagementUpdateRoleDefinitionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementEntitlementManagementUpdateRoleDefinitions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/entitlementManagement/roleDefinitions/{unifiedRoleDefinition-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"unifiedRoleDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.unifiedRoleDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphUnifiedRoleDefinition == nil {
		return nil, reportError("microsoftGraphUnifiedRoleDefinition is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphUnifiedRoleDefinition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRoleManagementGetDirectoryRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiRoleManagementGetDirectoryRequest) Select_(select_ []string) ApiRoleManagementGetDirectoryRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiRoleManagementGetDirectoryRequest) Expand(expand []string) ApiRoleManagementGetDirectoryRequest {
	r.expand = &expand
	return r
}

func (r ApiRoleManagementGetDirectoryRequest) Execute() (MicrosoftGraphRbacApplication, *_nethttp.Response, error) {
	return r.ApiService.RoleManagementGetDirectoryExecute(r)
}

/*
RoleManagementGetDirectory Get directory from roleManagement

Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRoleManagementGetDirectoryRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementGetDirectory(ctx _context.Context) ApiRoleManagementGetDirectoryRequest {
	return ApiRoleManagementGetDirectoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphRbacApplication
func (a *RoleManagementRbacApplicationApiService) RoleManagementGetDirectoryExecute(r ApiRoleManagementGetDirectoryRequest) (MicrosoftGraphRbacApplication, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphRbacApplication
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementGetDirectory")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/directory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRoleManagementGetEntitlementManagementRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiRoleManagementGetEntitlementManagementRequest) Select_(select_ []string) ApiRoleManagementGetEntitlementManagementRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiRoleManagementGetEntitlementManagementRequest) Expand(expand []string) ApiRoleManagementGetEntitlementManagementRequest {
	r.expand = &expand
	return r
}

func (r ApiRoleManagementGetEntitlementManagementRequest) Execute() (MicrosoftGraphRbacApplication, *_nethttp.Response, error) {
	return r.ApiService.RoleManagementGetEntitlementManagementExecute(r)
}

/*
RoleManagementGetEntitlementManagement Get entitlementManagement from roleManagement

Container for all entitlement management resources in Azure AD identity governance.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRoleManagementGetEntitlementManagementRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementGetEntitlementManagement(ctx _context.Context) ApiRoleManagementGetEntitlementManagementRequest {
	return ApiRoleManagementGetEntitlementManagementRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphRbacApplication
func (a *RoleManagementRbacApplicationApiService) RoleManagementGetEntitlementManagementExecute(r ApiRoleManagementGetEntitlementManagementRequest) (MicrosoftGraphRbacApplication, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphRbacApplication
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementGetEntitlementManagement")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/entitlementManagement"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRoleManagementUpdateDirectoryRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	microsoftGraphRbacApplication *MicrosoftGraphRbacApplication
}

// New navigation property values
func (r ApiRoleManagementUpdateDirectoryRequest) MicrosoftGraphRbacApplication(microsoftGraphRbacApplication MicrosoftGraphRbacApplication) ApiRoleManagementUpdateDirectoryRequest {
	r.microsoftGraphRbacApplication = &microsoftGraphRbacApplication
	return r
}

func (r ApiRoleManagementUpdateDirectoryRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RoleManagementUpdateDirectoryExecute(r)
}

/*
RoleManagementUpdateDirectory Update the navigation property directory in roleManagement

Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRoleManagementUpdateDirectoryRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementUpdateDirectory(ctx _context.Context) ApiRoleManagementUpdateDirectoryRequest {
	return ApiRoleManagementUpdateDirectoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RoleManagementRbacApplicationApiService) RoleManagementUpdateDirectoryExecute(r ApiRoleManagementUpdateDirectoryRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementUpdateDirectory")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/directory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphRbacApplication == nil {
		return nil, reportError("microsoftGraphRbacApplication is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphRbacApplication
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRoleManagementUpdateEntitlementManagementRequest struct {
	ctx _context.Context
	ApiService *RoleManagementRbacApplicationApiService
	microsoftGraphRbacApplication *MicrosoftGraphRbacApplication
}

// New navigation property values
func (r ApiRoleManagementUpdateEntitlementManagementRequest) MicrosoftGraphRbacApplication(microsoftGraphRbacApplication MicrosoftGraphRbacApplication) ApiRoleManagementUpdateEntitlementManagementRequest {
	r.microsoftGraphRbacApplication = &microsoftGraphRbacApplication
	return r
}

func (r ApiRoleManagementUpdateEntitlementManagementRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RoleManagementUpdateEntitlementManagementExecute(r)
}

/*
RoleManagementUpdateEntitlementManagement Update the navigation property entitlementManagement in roleManagement

Container for all entitlement management resources in Azure AD identity governance.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRoleManagementUpdateEntitlementManagementRequest
*/
func (a *RoleManagementRbacApplicationApiService) RoleManagementUpdateEntitlementManagement(ctx _context.Context) ApiRoleManagementUpdateEntitlementManagementRequest {
	return ApiRoleManagementUpdateEntitlementManagementRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RoleManagementRbacApplicationApiService) RoleManagementUpdateEntitlementManagementExecute(r ApiRoleManagementUpdateEntitlementManagementRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoleManagementRbacApplicationApiService.RoleManagementUpdateEntitlementManagement")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roleManagement/entitlementManagement"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphRbacApplication == nil {
		return nil, reportError("microsoftGraphRbacApplication is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphRbacApplication
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
