/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// IdentityConditionalAccessRootApiService IdentityConditionalAccessRootApi service
type IdentityConditionalAccessRootApiService service

type ApiIdentityConditionalAccessCreateNamedLocationsRequest struct {
	ctx _context.Context
	ApiService *IdentityConditionalAccessRootApiService
	microsoftGraphNamedLocation *MicrosoftGraphNamedLocation
}

// New navigation property
func (r ApiIdentityConditionalAccessCreateNamedLocationsRequest) MicrosoftGraphNamedLocation(microsoftGraphNamedLocation MicrosoftGraphNamedLocation) ApiIdentityConditionalAccessCreateNamedLocationsRequest {
	r.microsoftGraphNamedLocation = &microsoftGraphNamedLocation
	return r
}

func (r ApiIdentityConditionalAccessCreateNamedLocationsRequest) Execute() (MicrosoftGraphNamedLocation, *_nethttp.Response, error) {
	return r.ApiService.IdentityConditionalAccessCreateNamedLocationsExecute(r)
}

/*
IdentityConditionalAccessCreateNamedLocations Create new navigation property to namedLocations for identity

Read-only. Nullable. Returns a collection of the specified named locations.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIdentityConditionalAccessCreateNamedLocationsRequest
*/
func (a *IdentityConditionalAccessRootApiService) IdentityConditionalAccessCreateNamedLocations(ctx _context.Context) ApiIdentityConditionalAccessCreateNamedLocationsRequest {
	return ApiIdentityConditionalAccessCreateNamedLocationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphNamedLocation
func (a *IdentityConditionalAccessRootApiService) IdentityConditionalAccessCreateNamedLocationsExecute(r ApiIdentityConditionalAccessCreateNamedLocationsRequest) (MicrosoftGraphNamedLocation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphNamedLocation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityConditionalAccessRootApiService.IdentityConditionalAccessCreateNamedLocations")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/conditionalAccess/namedLocations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphNamedLocation == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphNamedLocation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphNamedLocation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityConditionalAccessCreatePoliciesRequest struct {
	ctx _context.Context
	ApiService *IdentityConditionalAccessRootApiService
	microsoftGraphConditionalAccessPolicy *MicrosoftGraphConditionalAccessPolicy
}

// New navigation property
func (r ApiIdentityConditionalAccessCreatePoliciesRequest) MicrosoftGraphConditionalAccessPolicy(microsoftGraphConditionalAccessPolicy MicrosoftGraphConditionalAccessPolicy) ApiIdentityConditionalAccessCreatePoliciesRequest {
	r.microsoftGraphConditionalAccessPolicy = &microsoftGraphConditionalAccessPolicy
	return r
}

func (r ApiIdentityConditionalAccessCreatePoliciesRequest) Execute() (MicrosoftGraphConditionalAccessPolicy, *_nethttp.Response, error) {
	return r.ApiService.IdentityConditionalAccessCreatePoliciesExecute(r)
}

/*
IdentityConditionalAccessCreatePolicies Create new navigation property to policies for identity

Read-only. Nullable. Returns a collection of the specified Conditional Access (CA) policies.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIdentityConditionalAccessCreatePoliciesRequest
*/
func (a *IdentityConditionalAccessRootApiService) IdentityConditionalAccessCreatePolicies(ctx _context.Context) ApiIdentityConditionalAccessCreatePoliciesRequest {
	return ApiIdentityConditionalAccessCreatePoliciesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphConditionalAccessPolicy
func (a *IdentityConditionalAccessRootApiService) IdentityConditionalAccessCreatePoliciesExecute(r ApiIdentityConditionalAccessCreatePoliciesRequest) (MicrosoftGraphConditionalAccessPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphConditionalAccessPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityConditionalAccessRootApiService.IdentityConditionalAccessCreatePolicies")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/conditionalAccess/policies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphConditionalAccessPolicy == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphConditionalAccessPolicy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphConditionalAccessPolicy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityConditionalAccessDeleteNamedLocationsRequest struct {
	ctx _context.Context
	ApiService *IdentityConditionalAccessRootApiService
	namedLocationId string
	ifMatch *string
}

// ETag
func (r ApiIdentityConditionalAccessDeleteNamedLocationsRequest) IfMatch(ifMatch string) ApiIdentityConditionalAccessDeleteNamedLocationsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiIdentityConditionalAccessDeleteNamedLocationsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityConditionalAccessDeleteNamedLocationsExecute(r)
}

/*
IdentityConditionalAccessDeleteNamedLocations Delete navigation property namedLocations for identity

Read-only. Nullable. Returns a collection of the specified named locations.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namedLocationId key: id of namedLocation
 @return ApiIdentityConditionalAccessDeleteNamedLocationsRequest
*/
func (a *IdentityConditionalAccessRootApiService) IdentityConditionalAccessDeleteNamedLocations(ctx _context.Context, namedLocationId string) ApiIdentityConditionalAccessDeleteNamedLocationsRequest {
	return ApiIdentityConditionalAccessDeleteNamedLocationsRequest{
		ApiService: a,
		ctx: ctx,
		namedLocationId: namedLocationId,
	}
}

// Execute executes the request
func (a *IdentityConditionalAccessRootApiService) IdentityConditionalAccessDeleteNamedLocationsExecute(r ApiIdentityConditionalAccessDeleteNamedLocationsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityConditionalAccessRootApiService.IdentityConditionalAccessDeleteNamedLocations")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/conditionalAccess/namedLocations/{namedLocation-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"namedLocation-id"+"}", _neturl.PathEscape(parameterToString(r.namedLocationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityConditionalAccessDeletePoliciesRequest struct {
	ctx _context.Context
	ApiService *IdentityConditionalAccessRootApiService
	conditionalAccessPolicyId string
	ifMatch *string
}

// ETag
func (r ApiIdentityConditionalAccessDeletePoliciesRequest) IfMatch(ifMatch string) ApiIdentityConditionalAccessDeletePoliciesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiIdentityConditionalAccessDeletePoliciesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityConditionalAccessDeletePoliciesExecute(r)
}

/*
IdentityConditionalAccessDeletePolicies Delete navigation property policies for identity

Read-only. Nullable. Returns a collection of the specified Conditional Access (CA) policies.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param conditionalAccessPolicyId key: id of conditionalAccessPolicy
 @return ApiIdentityConditionalAccessDeletePoliciesRequest
*/
func (a *IdentityConditionalAccessRootApiService) IdentityConditionalAccessDeletePolicies(ctx _context.Context, conditionalAccessPolicyId string) ApiIdentityConditionalAccessDeletePoliciesRequest {
	return ApiIdentityConditionalAccessDeletePoliciesRequest{
		ApiService: a,
		ctx: ctx,
		conditionalAccessPolicyId: conditionalAccessPolicyId,
	}
}

// Execute executes the request
func (a *IdentityConditionalAccessRootApiService) IdentityConditionalAccessDeletePoliciesExecute(r ApiIdentityConditionalAccessDeletePoliciesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityConditionalAccessRootApiService.IdentityConditionalAccessDeletePolicies")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/conditionalAccess/policies/{conditionalAccessPolicy-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"conditionalAccessPolicy-id"+"}", _neturl.PathEscape(parameterToString(r.conditionalAccessPolicyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityConditionalAccessGetNamedLocationsRequest struct {
	ctx _context.Context
	ApiService *IdentityConditionalAccessRootApiService
	namedLocationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiIdentityConditionalAccessGetNamedLocationsRequest) Select_(select_ []string) ApiIdentityConditionalAccessGetNamedLocationsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityConditionalAccessGetNamedLocationsRequest) Expand(expand []string) ApiIdentityConditionalAccessGetNamedLocationsRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityConditionalAccessGetNamedLocationsRequest) Execute() (MicrosoftGraphNamedLocation, *_nethttp.Response, error) {
	return r.ApiService.IdentityConditionalAccessGetNamedLocationsExecute(r)
}

/*
IdentityConditionalAccessGetNamedLocations Get namedLocations from identity

Read-only. Nullable. Returns a collection of the specified named locations.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namedLocationId key: id of namedLocation
 @return ApiIdentityConditionalAccessGetNamedLocationsRequest
*/
func (a *IdentityConditionalAccessRootApiService) IdentityConditionalAccessGetNamedLocations(ctx _context.Context, namedLocationId string) ApiIdentityConditionalAccessGetNamedLocationsRequest {
	return ApiIdentityConditionalAccessGetNamedLocationsRequest{
		ApiService: a,
		ctx: ctx,
		namedLocationId: namedLocationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphNamedLocation
func (a *IdentityConditionalAccessRootApiService) IdentityConditionalAccessGetNamedLocationsExecute(r ApiIdentityConditionalAccessGetNamedLocationsRequest) (MicrosoftGraphNamedLocation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphNamedLocation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityConditionalAccessRootApiService.IdentityConditionalAccessGetNamedLocations")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/conditionalAccess/namedLocations/{namedLocation-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"namedLocation-id"+"}", _neturl.PathEscape(parameterToString(r.namedLocationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityConditionalAccessGetPoliciesRequest struct {
	ctx _context.Context
	ApiService *IdentityConditionalAccessRootApiService
	conditionalAccessPolicyId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiIdentityConditionalAccessGetPoliciesRequest) Select_(select_ []string) ApiIdentityConditionalAccessGetPoliciesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityConditionalAccessGetPoliciesRequest) Expand(expand []string) ApiIdentityConditionalAccessGetPoliciesRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityConditionalAccessGetPoliciesRequest) Execute() (MicrosoftGraphConditionalAccessPolicy, *_nethttp.Response, error) {
	return r.ApiService.IdentityConditionalAccessGetPoliciesExecute(r)
}

/*
IdentityConditionalAccessGetPolicies Get policies from identity

Read-only. Nullable. Returns a collection of the specified Conditional Access (CA) policies.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param conditionalAccessPolicyId key: id of conditionalAccessPolicy
 @return ApiIdentityConditionalAccessGetPoliciesRequest
*/
func (a *IdentityConditionalAccessRootApiService) IdentityConditionalAccessGetPolicies(ctx _context.Context, conditionalAccessPolicyId string) ApiIdentityConditionalAccessGetPoliciesRequest {
	return ApiIdentityConditionalAccessGetPoliciesRequest{
		ApiService: a,
		ctx: ctx,
		conditionalAccessPolicyId: conditionalAccessPolicyId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphConditionalAccessPolicy
func (a *IdentityConditionalAccessRootApiService) IdentityConditionalAccessGetPoliciesExecute(r ApiIdentityConditionalAccessGetPoliciesRequest) (MicrosoftGraphConditionalAccessPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphConditionalAccessPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityConditionalAccessRootApiService.IdentityConditionalAccessGetPolicies")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/conditionalAccess/policies/{conditionalAccessPolicy-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"conditionalAccessPolicy-id"+"}", _neturl.PathEscape(parameterToString(r.conditionalAccessPolicyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityConditionalAccessListNamedLocationsRequest struct {
	ctx _context.Context
	ApiService *IdentityConditionalAccessRootApiService
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiIdentityConditionalAccessListNamedLocationsRequest) Top(top int32) ApiIdentityConditionalAccessListNamedLocationsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiIdentityConditionalAccessListNamedLocationsRequest) Skip(skip int32) ApiIdentityConditionalAccessListNamedLocationsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiIdentityConditionalAccessListNamedLocationsRequest) Search(search string) ApiIdentityConditionalAccessListNamedLocationsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiIdentityConditionalAccessListNamedLocationsRequest) Filter(filter string) ApiIdentityConditionalAccessListNamedLocationsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiIdentityConditionalAccessListNamedLocationsRequest) Count(count bool) ApiIdentityConditionalAccessListNamedLocationsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiIdentityConditionalAccessListNamedLocationsRequest) Orderby(orderby []string) ApiIdentityConditionalAccessListNamedLocationsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiIdentityConditionalAccessListNamedLocationsRequest) Select_(select_ []string) ApiIdentityConditionalAccessListNamedLocationsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityConditionalAccessListNamedLocationsRequest) Expand(expand []string) ApiIdentityConditionalAccessListNamedLocationsRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityConditionalAccessListNamedLocationsRequest) Execute() (CollectionOfNamedLocation, *_nethttp.Response, error) {
	return r.ApiService.IdentityConditionalAccessListNamedLocationsExecute(r)
}

/*
IdentityConditionalAccessListNamedLocations Get namedLocations from identity

Read-only. Nullable. Returns a collection of the specified named locations.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIdentityConditionalAccessListNamedLocationsRequest
*/
func (a *IdentityConditionalAccessRootApiService) IdentityConditionalAccessListNamedLocations(ctx _context.Context) ApiIdentityConditionalAccessListNamedLocationsRequest {
	return ApiIdentityConditionalAccessListNamedLocationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionOfNamedLocation
func (a *IdentityConditionalAccessRootApiService) IdentityConditionalAccessListNamedLocationsExecute(r ApiIdentityConditionalAccessListNamedLocationsRequest) (CollectionOfNamedLocation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfNamedLocation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityConditionalAccessRootApiService.IdentityConditionalAccessListNamedLocations")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/conditionalAccess/namedLocations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityConditionalAccessListPoliciesRequest struct {
	ctx _context.Context
	ApiService *IdentityConditionalAccessRootApiService
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiIdentityConditionalAccessListPoliciesRequest) Top(top int32) ApiIdentityConditionalAccessListPoliciesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiIdentityConditionalAccessListPoliciesRequest) Skip(skip int32) ApiIdentityConditionalAccessListPoliciesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiIdentityConditionalAccessListPoliciesRequest) Search(search string) ApiIdentityConditionalAccessListPoliciesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiIdentityConditionalAccessListPoliciesRequest) Filter(filter string) ApiIdentityConditionalAccessListPoliciesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiIdentityConditionalAccessListPoliciesRequest) Count(count bool) ApiIdentityConditionalAccessListPoliciesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiIdentityConditionalAccessListPoliciesRequest) Orderby(orderby []string) ApiIdentityConditionalAccessListPoliciesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiIdentityConditionalAccessListPoliciesRequest) Select_(select_ []string) ApiIdentityConditionalAccessListPoliciesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityConditionalAccessListPoliciesRequest) Expand(expand []string) ApiIdentityConditionalAccessListPoliciesRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityConditionalAccessListPoliciesRequest) Execute() (CollectionOfConditionalAccessPolicy, *_nethttp.Response, error) {
	return r.ApiService.IdentityConditionalAccessListPoliciesExecute(r)
}

/*
IdentityConditionalAccessListPolicies Get policies from identity

Read-only. Nullable. Returns a collection of the specified Conditional Access (CA) policies.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIdentityConditionalAccessListPoliciesRequest
*/
func (a *IdentityConditionalAccessRootApiService) IdentityConditionalAccessListPolicies(ctx _context.Context) ApiIdentityConditionalAccessListPoliciesRequest {
	return ApiIdentityConditionalAccessListPoliciesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionOfConditionalAccessPolicy
func (a *IdentityConditionalAccessRootApiService) IdentityConditionalAccessListPoliciesExecute(r ApiIdentityConditionalAccessListPoliciesRequest) (CollectionOfConditionalAccessPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfConditionalAccessPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityConditionalAccessRootApiService.IdentityConditionalAccessListPolicies")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/conditionalAccess/policies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityConditionalAccessUpdateNamedLocationsRequest struct {
	ctx _context.Context
	ApiService *IdentityConditionalAccessRootApiService
	namedLocationId string
	microsoftGraphNamedLocation *MicrosoftGraphNamedLocation
}

// New navigation property values
func (r ApiIdentityConditionalAccessUpdateNamedLocationsRequest) MicrosoftGraphNamedLocation(microsoftGraphNamedLocation MicrosoftGraphNamedLocation) ApiIdentityConditionalAccessUpdateNamedLocationsRequest {
	r.microsoftGraphNamedLocation = &microsoftGraphNamedLocation
	return r
}

func (r ApiIdentityConditionalAccessUpdateNamedLocationsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityConditionalAccessUpdateNamedLocationsExecute(r)
}

/*
IdentityConditionalAccessUpdateNamedLocations Update the navigation property namedLocations in identity

Read-only. Nullable. Returns a collection of the specified named locations.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namedLocationId key: id of namedLocation
 @return ApiIdentityConditionalAccessUpdateNamedLocationsRequest
*/
func (a *IdentityConditionalAccessRootApiService) IdentityConditionalAccessUpdateNamedLocations(ctx _context.Context, namedLocationId string) ApiIdentityConditionalAccessUpdateNamedLocationsRequest {
	return ApiIdentityConditionalAccessUpdateNamedLocationsRequest{
		ApiService: a,
		ctx: ctx,
		namedLocationId: namedLocationId,
	}
}

// Execute executes the request
func (a *IdentityConditionalAccessRootApiService) IdentityConditionalAccessUpdateNamedLocationsExecute(r ApiIdentityConditionalAccessUpdateNamedLocationsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityConditionalAccessRootApiService.IdentityConditionalAccessUpdateNamedLocations")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/conditionalAccess/namedLocations/{namedLocation-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"namedLocation-id"+"}", _neturl.PathEscape(parameterToString(r.namedLocationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphNamedLocation == nil {
		return nil, reportError("microsoftGraphNamedLocation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphNamedLocation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityConditionalAccessUpdatePoliciesRequest struct {
	ctx _context.Context
	ApiService *IdentityConditionalAccessRootApiService
	conditionalAccessPolicyId string
	microsoftGraphConditionalAccessPolicy *MicrosoftGraphConditionalAccessPolicy
}

// New navigation property values
func (r ApiIdentityConditionalAccessUpdatePoliciesRequest) MicrosoftGraphConditionalAccessPolicy(microsoftGraphConditionalAccessPolicy MicrosoftGraphConditionalAccessPolicy) ApiIdentityConditionalAccessUpdatePoliciesRequest {
	r.microsoftGraphConditionalAccessPolicy = &microsoftGraphConditionalAccessPolicy
	return r
}

func (r ApiIdentityConditionalAccessUpdatePoliciesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityConditionalAccessUpdatePoliciesExecute(r)
}

/*
IdentityConditionalAccessUpdatePolicies Update the navigation property policies in identity

Read-only. Nullable. Returns a collection of the specified Conditional Access (CA) policies.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param conditionalAccessPolicyId key: id of conditionalAccessPolicy
 @return ApiIdentityConditionalAccessUpdatePoliciesRequest
*/
func (a *IdentityConditionalAccessRootApiService) IdentityConditionalAccessUpdatePolicies(ctx _context.Context, conditionalAccessPolicyId string) ApiIdentityConditionalAccessUpdatePoliciesRequest {
	return ApiIdentityConditionalAccessUpdatePoliciesRequest{
		ApiService: a,
		ctx: ctx,
		conditionalAccessPolicyId: conditionalAccessPolicyId,
	}
}

// Execute executes the request
func (a *IdentityConditionalAccessRootApiService) IdentityConditionalAccessUpdatePoliciesExecute(r ApiIdentityConditionalAccessUpdatePoliciesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityConditionalAccessRootApiService.IdentityConditionalAccessUpdatePolicies")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/conditionalAccess/policies/{conditionalAccessPolicy-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"conditionalAccessPolicy-id"+"}", _neturl.PathEscape(parameterToString(r.conditionalAccessPolicyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphConditionalAccessPolicy == nil {
		return nil, reportError("microsoftGraphConditionalAccessPolicy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphConditionalAccessPolicy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityDeleteConditionalAccessRequest struct {
	ctx _context.Context
	ApiService *IdentityConditionalAccessRootApiService
	ifMatch *string
}

// ETag
func (r ApiIdentityDeleteConditionalAccessRequest) IfMatch(ifMatch string) ApiIdentityDeleteConditionalAccessRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiIdentityDeleteConditionalAccessRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityDeleteConditionalAccessExecute(r)
}

/*
IdentityDeleteConditionalAccess Delete navigation property conditionalAccess for identity

the entry point for the Conditional Access (CA) object model.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIdentityDeleteConditionalAccessRequest
*/
func (a *IdentityConditionalAccessRootApiService) IdentityDeleteConditionalAccess(ctx _context.Context) ApiIdentityDeleteConditionalAccessRequest {
	return ApiIdentityDeleteConditionalAccessRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IdentityConditionalAccessRootApiService) IdentityDeleteConditionalAccessExecute(r ApiIdentityDeleteConditionalAccessRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityConditionalAccessRootApiService.IdentityDeleteConditionalAccess")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/conditionalAccess"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGetConditionalAccessRequest struct {
	ctx _context.Context
	ApiService *IdentityConditionalAccessRootApiService
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiIdentityGetConditionalAccessRequest) Select_(select_ []string) ApiIdentityGetConditionalAccessRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityGetConditionalAccessRequest) Expand(expand []string) ApiIdentityGetConditionalAccessRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityGetConditionalAccessRequest) Execute() (MicrosoftGraphConditionalAccessRoot, *_nethttp.Response, error) {
	return r.ApiService.IdentityGetConditionalAccessExecute(r)
}

/*
IdentityGetConditionalAccess Get conditionalAccess from identity

the entry point for the Conditional Access (CA) object model.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIdentityGetConditionalAccessRequest
*/
func (a *IdentityConditionalAccessRootApiService) IdentityGetConditionalAccess(ctx _context.Context) ApiIdentityGetConditionalAccessRequest {
	return ApiIdentityGetConditionalAccessRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphConditionalAccessRoot
func (a *IdentityConditionalAccessRootApiService) IdentityGetConditionalAccessExecute(r ApiIdentityGetConditionalAccessRequest) (MicrosoftGraphConditionalAccessRoot, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphConditionalAccessRoot
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityConditionalAccessRootApiService.IdentityGetConditionalAccess")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/conditionalAccess"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityUpdateConditionalAccessRequest struct {
	ctx _context.Context
	ApiService *IdentityConditionalAccessRootApiService
	microsoftGraphConditionalAccessRoot *MicrosoftGraphConditionalAccessRoot
}

// New navigation property values
func (r ApiIdentityUpdateConditionalAccessRequest) MicrosoftGraphConditionalAccessRoot(microsoftGraphConditionalAccessRoot MicrosoftGraphConditionalAccessRoot) ApiIdentityUpdateConditionalAccessRequest {
	r.microsoftGraphConditionalAccessRoot = &microsoftGraphConditionalAccessRoot
	return r
}

func (r ApiIdentityUpdateConditionalAccessRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityUpdateConditionalAccessExecute(r)
}

/*
IdentityUpdateConditionalAccess Update the navigation property conditionalAccess in identity

the entry point for the Conditional Access (CA) object model.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIdentityUpdateConditionalAccessRequest
*/
func (a *IdentityConditionalAccessRootApiService) IdentityUpdateConditionalAccess(ctx _context.Context) ApiIdentityUpdateConditionalAccessRequest {
	return ApiIdentityUpdateConditionalAccessRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IdentityConditionalAccessRootApiService) IdentityUpdateConditionalAccessExecute(r ApiIdentityUpdateConditionalAccessRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityConditionalAccessRootApiService.IdentityUpdateConditionalAccess")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/conditionalAccess"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphConditionalAccessRoot == nil {
		return nil, reportError("microsoftGraphConditionalAccessRoot is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphConditionalAccessRoot
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
