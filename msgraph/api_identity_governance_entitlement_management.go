/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package msgraph

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// IdentityGovernanceEntitlementManagementApiService IdentityGovernanceEntitlementManagementApi service
type IdentityGovernanceEntitlementManagementApiService service

type ApiIdentityGovernanceDeleteEntitlementManagementRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	ifMatch *string
}

// ETag
func (r ApiIdentityGovernanceDeleteEntitlementManagementRequest) IfMatch(ifMatch string) ApiIdentityGovernanceDeleteEntitlementManagementRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiIdentityGovernanceDeleteEntitlementManagementRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceDeleteEntitlementManagementExecute(r)
}

/*
IdentityGovernanceDeleteEntitlementManagement Delete navigation property entitlementManagement for identityGovernance

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIdentityGovernanceDeleteEntitlementManagementRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceDeleteEntitlementManagement(ctx _context.Context) ApiIdentityGovernanceDeleteEntitlementManagementRequest {
	return ApiIdentityGovernanceDeleteEntitlementManagementRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceDeleteEntitlementManagementExecute(r ApiIdentityGovernanceDeleteEntitlementManagementRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceDeleteEntitlementManagement")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsCreateStagesRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	approvalId string
	microsoftGraphApprovalStage *MicrosoftGraphApprovalStage
}

// New navigation property
func (r ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsCreateStagesRequest) MicrosoftGraphApprovalStage(microsoftGraphApprovalStage MicrosoftGraphApprovalStage) ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsCreateStagesRequest {
	r.microsoftGraphApprovalStage = &microsoftGraphApprovalStage
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsCreateStagesRequest) Execute() (MicrosoftGraphApprovalStage, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsCreateStagesExecute(r)
}

/*
IdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsCreateStages Create new navigation property to stages for identityGovernance

A collection of stages in the approval decision.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param approvalId key: id of approval
 @return ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsCreateStagesRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsCreateStages(ctx _context.Context, approvalId string) ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsCreateStagesRequest {
	return ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsCreateStagesRequest{
		ApiService: a,
		ctx: ctx,
		approvalId: approvalId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphApprovalStage
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsCreateStagesExecute(r ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsCreateStagesRequest) (MicrosoftGraphApprovalStage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphApprovalStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsCreateStages")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/accessPackageAssignmentApprovals/{approval-id}/stages"
	localVarPath = strings.Replace(localVarPath, "{"+"approval-id"+"}", _neturl.PathEscape(parameterToString(r.approvalId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphApprovalStage == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphApprovalStage is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphApprovalStage
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsDeleteStagesRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	approvalId string
	approvalStageId string
	ifMatch *string
}

// ETag
func (r ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsDeleteStagesRequest) IfMatch(ifMatch string) ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsDeleteStagesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsDeleteStagesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsDeleteStagesExecute(r)
}

/*
IdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsDeleteStages Delete navigation property stages for identityGovernance

A collection of stages in the approval decision.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param approvalId key: id of approval
 @param approvalStageId key: id of approvalStage
 @return ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsDeleteStagesRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsDeleteStages(ctx _context.Context, approvalId string, approvalStageId string) ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsDeleteStagesRequest {
	return ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsDeleteStagesRequest{
		ApiService: a,
		ctx: ctx,
		approvalId: approvalId,
		approvalStageId: approvalStageId,
	}
}

// Execute executes the request
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsDeleteStagesExecute(r ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsDeleteStagesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsDeleteStages")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/accessPackageAssignmentApprovals/{approval-id}/stages/{approvalStage-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"approval-id"+"}", _neturl.PathEscape(parameterToString(r.approvalId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"approvalStage-id"+"}", _neturl.PathEscape(parameterToString(r.approvalStageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsGetStagesRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	approvalId string
	approvalStageId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsGetStagesRequest) Select_(select_ []string) ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsGetStagesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsGetStagesRequest) Expand(expand []string) ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsGetStagesRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsGetStagesRequest) Execute() (MicrosoftGraphApprovalStage, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsGetStagesExecute(r)
}

/*
IdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsGetStages Get stages from identityGovernance

A collection of stages in the approval decision.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param approvalId key: id of approval
 @param approvalStageId key: id of approvalStage
 @return ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsGetStagesRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsGetStages(ctx _context.Context, approvalId string, approvalStageId string) ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsGetStagesRequest {
	return ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsGetStagesRequest{
		ApiService: a,
		ctx: ctx,
		approvalId: approvalId,
		approvalStageId: approvalStageId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphApprovalStage
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsGetStagesExecute(r ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsGetStagesRequest) (MicrosoftGraphApprovalStage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphApprovalStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsGetStages")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/accessPackageAssignmentApprovals/{approval-id}/stages/{approvalStage-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"approval-id"+"}", _neturl.PathEscape(parameterToString(r.approvalId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"approvalStage-id"+"}", _neturl.PathEscape(parameterToString(r.approvalStageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsListStagesRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	approvalId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsListStagesRequest) Top(top int32) ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsListStagesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsListStagesRequest) Skip(skip int32) ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsListStagesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsListStagesRequest) Search(search string) ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsListStagesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsListStagesRequest) Filter(filter string) ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsListStagesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsListStagesRequest) Count(count bool) ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsListStagesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsListStagesRequest) Orderby(orderby []string) ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsListStagesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsListStagesRequest) Select_(select_ []string) ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsListStagesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsListStagesRequest) Expand(expand []string) ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsListStagesRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsListStagesRequest) Execute() (CollectionOfApprovalStage, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsListStagesExecute(r)
}

/*
IdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsListStages Get stages from identityGovernance

A collection of stages in the approval decision.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param approvalId key: id of approval
 @return ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsListStagesRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsListStages(ctx _context.Context, approvalId string) ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsListStagesRequest {
	return ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsListStagesRequest{
		ApiService: a,
		ctx: ctx,
		approvalId: approvalId,
	}
}

// Execute executes the request
//  @return CollectionOfApprovalStage
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsListStagesExecute(r ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsListStagesRequest) (CollectionOfApprovalStage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfApprovalStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsListStages")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/accessPackageAssignmentApprovals/{approval-id}/stages"
	localVarPath = strings.Replace(localVarPath, "{"+"approval-id"+"}", _neturl.PathEscape(parameterToString(r.approvalId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsUpdateStagesRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	approvalId string
	approvalStageId string
	microsoftGraphApprovalStage *MicrosoftGraphApprovalStage
}

// New navigation property values
func (r ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsUpdateStagesRequest) MicrosoftGraphApprovalStage(microsoftGraphApprovalStage MicrosoftGraphApprovalStage) ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsUpdateStagesRequest {
	r.microsoftGraphApprovalStage = &microsoftGraphApprovalStage
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsUpdateStagesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsUpdateStagesExecute(r)
}

/*
IdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsUpdateStages Update the navigation property stages in identityGovernance

A collection of stages in the approval decision.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param approvalId key: id of approval
 @param approvalStageId key: id of approvalStage
 @return ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsUpdateStagesRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsUpdateStages(ctx _context.Context, approvalId string, approvalStageId string) ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsUpdateStagesRequest {
	return ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsUpdateStagesRequest{
		ApiService: a,
		ctx: ctx,
		approvalId: approvalId,
		approvalStageId: approvalStageId,
	}
}

// Execute executes the request
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsUpdateStagesExecute(r ApiIdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsUpdateStagesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementAccessPackageAssignmentApprovalsUpdateStages")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/accessPackageAssignmentApprovals/{approval-id}/stages/{approvalStage-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"approval-id"+"}", _neturl.PathEscape(parameterToString(r.approvalId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"approvalStage-id"+"}", _neturl.PathEscape(parameterToString(r.approvalStageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphApprovalStage == nil {
		return nil, reportError("microsoftGraphApprovalStage is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphApprovalStage
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementAccessPackagesDeleteRefCatalogRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	accessPackageId string
	ifMatch *string
}

// ETag
func (r ApiIdentityGovernanceEntitlementManagementAccessPackagesDeleteRefCatalogRequest) IfMatch(ifMatch string) ApiIdentityGovernanceEntitlementManagementAccessPackagesDeleteRefCatalogRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementAccessPackagesDeleteRefCatalogRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementAccessPackagesDeleteRefCatalogExecute(r)
}

/*
IdentityGovernanceEntitlementManagementAccessPackagesDeleteRefCatalog Delete ref of navigation property catalog for identityGovernance

Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessPackageId key: id of accessPackage
 @return ApiIdentityGovernanceEntitlementManagementAccessPackagesDeleteRefCatalogRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAccessPackagesDeleteRefCatalog(ctx _context.Context, accessPackageId string) ApiIdentityGovernanceEntitlementManagementAccessPackagesDeleteRefCatalogRequest {
	return ApiIdentityGovernanceEntitlementManagementAccessPackagesDeleteRefCatalogRequest{
		ApiService: a,
		ctx: ctx,
		accessPackageId: accessPackageId,
	}
}

// Execute executes the request
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAccessPackagesDeleteRefCatalogExecute(r ApiIdentityGovernanceEntitlementManagementAccessPackagesDeleteRefCatalogRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementAccessPackagesDeleteRefCatalog")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/accessPackages/{accessPackage-id}/catalog/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackage-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementAccessPackagesGetCatalogRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	accessPackageId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiIdentityGovernanceEntitlementManagementAccessPackagesGetCatalogRequest) Select_(select_ []string) ApiIdentityGovernanceEntitlementManagementAccessPackagesGetCatalogRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityGovernanceEntitlementManagementAccessPackagesGetCatalogRequest) Expand(expand []string) ApiIdentityGovernanceEntitlementManagementAccessPackagesGetCatalogRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementAccessPackagesGetCatalogRequest) Execute() (MicrosoftGraphAccessPackageCatalog, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementAccessPackagesGetCatalogExecute(r)
}

/*
IdentityGovernanceEntitlementManagementAccessPackagesGetCatalog Get catalog from identityGovernance

Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessPackageId key: id of accessPackage
 @return ApiIdentityGovernanceEntitlementManagementAccessPackagesGetCatalogRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAccessPackagesGetCatalog(ctx _context.Context, accessPackageId string) ApiIdentityGovernanceEntitlementManagementAccessPackagesGetCatalogRequest {
	return ApiIdentityGovernanceEntitlementManagementAccessPackagesGetCatalogRequest{
		ApiService: a,
		ctx: ctx,
		accessPackageId: accessPackageId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphAccessPackageCatalog
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAccessPackagesGetCatalogExecute(r ApiIdentityGovernanceEntitlementManagementAccessPackagesGetCatalogRequest) (MicrosoftGraphAccessPackageCatalog, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphAccessPackageCatalog
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementAccessPackagesGetCatalog")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/accessPackages/{accessPackage-id}/catalog"
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackage-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementAccessPackagesGetRefCatalogRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	accessPackageId string
}


func (r ApiIdentityGovernanceEntitlementManagementAccessPackagesGetRefCatalogRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementAccessPackagesGetRefCatalogExecute(r)
}

/*
IdentityGovernanceEntitlementManagementAccessPackagesGetRefCatalog Get ref of catalog from identityGovernance

Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessPackageId key: id of accessPackage
 @return ApiIdentityGovernanceEntitlementManagementAccessPackagesGetRefCatalogRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAccessPackagesGetRefCatalog(ctx _context.Context, accessPackageId string) ApiIdentityGovernanceEntitlementManagementAccessPackagesGetRefCatalogRequest {
	return ApiIdentityGovernanceEntitlementManagementAccessPackagesGetRefCatalogRequest{
		ApiService: a,
		ctx: ctx,
		accessPackageId: accessPackageId,
	}
}

// Execute executes the request
//  @return string
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAccessPackagesGetRefCatalogExecute(r ApiIdentityGovernanceEntitlementManagementAccessPackagesGetRefCatalogRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementAccessPackagesGetRefCatalog")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/accessPackages/{accessPackage-id}/catalog/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackage-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementAccessPackagesUpdateRefCatalogRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	accessPackageId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiIdentityGovernanceEntitlementManagementAccessPackagesUpdateRefCatalogRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiIdentityGovernanceEntitlementManagementAccessPackagesUpdateRefCatalogRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementAccessPackagesUpdateRefCatalogRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementAccessPackagesUpdateRefCatalogExecute(r)
}

/*
IdentityGovernanceEntitlementManagementAccessPackagesUpdateRefCatalog Update the ref of navigation property catalog in identityGovernance

Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessPackageId key: id of accessPackage
 @return ApiIdentityGovernanceEntitlementManagementAccessPackagesUpdateRefCatalogRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAccessPackagesUpdateRefCatalog(ctx _context.Context, accessPackageId string) ApiIdentityGovernanceEntitlementManagementAccessPackagesUpdateRefCatalogRequest {
	return ApiIdentityGovernanceEntitlementManagementAccessPackagesUpdateRefCatalogRequest{
		ApiService: a,
		ctx: ctx,
		accessPackageId: accessPackageId,
	}
}

// Execute executes the request
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAccessPackagesUpdateRefCatalogExecute(r ApiIdentityGovernanceEntitlementManagementAccessPackagesUpdateRefCatalogRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementAccessPackagesUpdateRefCatalog")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/accessPackages/{accessPackage-id}/catalog/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackage-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementAssignmentRequestsDeleteRefAccessPackageRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	accessPackageAssignmentRequestId string
	ifMatch *string
}

// ETag
func (r ApiIdentityGovernanceEntitlementManagementAssignmentRequestsDeleteRefAccessPackageRequest) IfMatch(ifMatch string) ApiIdentityGovernanceEntitlementManagementAssignmentRequestsDeleteRefAccessPackageRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementAssignmentRequestsDeleteRefAccessPackageRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementAssignmentRequestsDeleteRefAccessPackageExecute(r)
}

/*
IdentityGovernanceEntitlementManagementAssignmentRequestsDeleteRefAccessPackage Delete ref of navigation property accessPackage for identityGovernance

The access package associated with the accessPackageAssignmentRequest. An access package defines the collections of resource roles and the policies for how one or more users can get access to those resources. Read-only. Nullable.  Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessPackageAssignmentRequestId key: id of accessPackageAssignmentRequest
 @return ApiIdentityGovernanceEntitlementManagementAssignmentRequestsDeleteRefAccessPackageRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAssignmentRequestsDeleteRefAccessPackage(ctx _context.Context, accessPackageAssignmentRequestId string) ApiIdentityGovernanceEntitlementManagementAssignmentRequestsDeleteRefAccessPackageRequest {
	return ApiIdentityGovernanceEntitlementManagementAssignmentRequestsDeleteRefAccessPackageRequest{
		ApiService: a,
		ctx: ctx,
		accessPackageAssignmentRequestId: accessPackageAssignmentRequestId,
	}
}

// Execute executes the request
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAssignmentRequestsDeleteRefAccessPackageExecute(r ApiIdentityGovernanceEntitlementManagementAssignmentRequestsDeleteRefAccessPackageRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementAssignmentRequestsDeleteRefAccessPackage")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/assignmentRequests/{accessPackageAssignmentRequest-id}/accessPackage/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackageAssignmentRequest-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageAssignmentRequestId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementAssignmentRequestsDeleteRefAssignmentRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	accessPackageAssignmentRequestId string
	ifMatch *string
}

// ETag
func (r ApiIdentityGovernanceEntitlementManagementAssignmentRequestsDeleteRefAssignmentRequest) IfMatch(ifMatch string) ApiIdentityGovernanceEntitlementManagementAssignmentRequestsDeleteRefAssignmentRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementAssignmentRequestsDeleteRefAssignmentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementAssignmentRequestsDeleteRefAssignmentExecute(r)
}

/*
IdentityGovernanceEntitlementManagementAssignmentRequestsDeleteRefAssignment Delete ref of navigation property assignment for identityGovernance

For a requestType of UserAdd or AdminAdd, this is an access package assignment requested to be created.  For a requestType of UserRemove, AdminRemove or SystemRemove, this has the id property of an existing assignment to be removed.   Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessPackageAssignmentRequestId key: id of accessPackageAssignmentRequest
 @return ApiIdentityGovernanceEntitlementManagementAssignmentRequestsDeleteRefAssignmentRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAssignmentRequestsDeleteRefAssignment(ctx _context.Context, accessPackageAssignmentRequestId string) ApiIdentityGovernanceEntitlementManagementAssignmentRequestsDeleteRefAssignmentRequest {
	return ApiIdentityGovernanceEntitlementManagementAssignmentRequestsDeleteRefAssignmentRequest{
		ApiService: a,
		ctx: ctx,
		accessPackageAssignmentRequestId: accessPackageAssignmentRequestId,
	}
}

// Execute executes the request
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAssignmentRequestsDeleteRefAssignmentExecute(r ApiIdentityGovernanceEntitlementManagementAssignmentRequestsDeleteRefAssignmentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementAssignmentRequestsDeleteRefAssignment")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/assignmentRequests/{accessPackageAssignmentRequest-id}/assignment/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackageAssignmentRequest-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageAssignmentRequestId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementAssignmentRequestsDeleteRefRequestorRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	accessPackageAssignmentRequestId string
	ifMatch *string
}

// ETag
func (r ApiIdentityGovernanceEntitlementManagementAssignmentRequestsDeleteRefRequestorRequest) IfMatch(ifMatch string) ApiIdentityGovernanceEntitlementManagementAssignmentRequestsDeleteRefRequestorRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementAssignmentRequestsDeleteRefRequestorRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementAssignmentRequestsDeleteRefRequestorExecute(r)
}

/*
IdentityGovernanceEntitlementManagementAssignmentRequestsDeleteRefRequestor Delete ref of navigation property requestor for identityGovernance

The subject who requested or, if a direct assignment, was assigned. Read-only. Nullable. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessPackageAssignmentRequestId key: id of accessPackageAssignmentRequest
 @return ApiIdentityGovernanceEntitlementManagementAssignmentRequestsDeleteRefRequestorRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAssignmentRequestsDeleteRefRequestor(ctx _context.Context, accessPackageAssignmentRequestId string) ApiIdentityGovernanceEntitlementManagementAssignmentRequestsDeleteRefRequestorRequest {
	return ApiIdentityGovernanceEntitlementManagementAssignmentRequestsDeleteRefRequestorRequest{
		ApiService: a,
		ctx: ctx,
		accessPackageAssignmentRequestId: accessPackageAssignmentRequestId,
	}
}

// Execute executes the request
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAssignmentRequestsDeleteRefRequestorExecute(r ApiIdentityGovernanceEntitlementManagementAssignmentRequestsDeleteRefRequestorRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementAssignmentRequestsDeleteRefRequestor")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/assignmentRequests/{accessPackageAssignmentRequest-id}/requestor/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackageAssignmentRequest-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageAssignmentRequestId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementAssignmentRequestsGetAccessPackageRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	accessPackageAssignmentRequestId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiIdentityGovernanceEntitlementManagementAssignmentRequestsGetAccessPackageRequest) Select_(select_ []string) ApiIdentityGovernanceEntitlementManagementAssignmentRequestsGetAccessPackageRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityGovernanceEntitlementManagementAssignmentRequestsGetAccessPackageRequest) Expand(expand []string) ApiIdentityGovernanceEntitlementManagementAssignmentRequestsGetAccessPackageRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementAssignmentRequestsGetAccessPackageRequest) Execute() (MicrosoftGraphAccessPackage, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementAssignmentRequestsGetAccessPackageExecute(r)
}

/*
IdentityGovernanceEntitlementManagementAssignmentRequestsGetAccessPackage Get accessPackage from identityGovernance

The access package associated with the accessPackageAssignmentRequest. An access package defines the collections of resource roles and the policies for how one or more users can get access to those resources. Read-only. Nullable.  Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessPackageAssignmentRequestId key: id of accessPackageAssignmentRequest
 @return ApiIdentityGovernanceEntitlementManagementAssignmentRequestsGetAccessPackageRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAssignmentRequestsGetAccessPackage(ctx _context.Context, accessPackageAssignmentRequestId string) ApiIdentityGovernanceEntitlementManagementAssignmentRequestsGetAccessPackageRequest {
	return ApiIdentityGovernanceEntitlementManagementAssignmentRequestsGetAccessPackageRequest{
		ApiService: a,
		ctx: ctx,
		accessPackageAssignmentRequestId: accessPackageAssignmentRequestId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphAccessPackage
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAssignmentRequestsGetAccessPackageExecute(r ApiIdentityGovernanceEntitlementManagementAssignmentRequestsGetAccessPackageRequest) (MicrosoftGraphAccessPackage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphAccessPackage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementAssignmentRequestsGetAccessPackage")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/assignmentRequests/{accessPackageAssignmentRequest-id}/accessPackage"
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackageAssignmentRequest-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageAssignmentRequestId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementAssignmentRequestsGetAssignmentRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	accessPackageAssignmentRequestId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiIdentityGovernanceEntitlementManagementAssignmentRequestsGetAssignmentRequest) Select_(select_ []string) ApiIdentityGovernanceEntitlementManagementAssignmentRequestsGetAssignmentRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityGovernanceEntitlementManagementAssignmentRequestsGetAssignmentRequest) Expand(expand []string) ApiIdentityGovernanceEntitlementManagementAssignmentRequestsGetAssignmentRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementAssignmentRequestsGetAssignmentRequest) Execute() (MicrosoftGraphAccessPackageAssignment, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementAssignmentRequestsGetAssignmentExecute(r)
}

/*
IdentityGovernanceEntitlementManagementAssignmentRequestsGetAssignment Get assignment from identityGovernance

For a requestType of UserAdd or AdminAdd, this is an access package assignment requested to be created.  For a requestType of UserRemove, AdminRemove or SystemRemove, this has the id property of an existing assignment to be removed.   Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessPackageAssignmentRequestId key: id of accessPackageAssignmentRequest
 @return ApiIdentityGovernanceEntitlementManagementAssignmentRequestsGetAssignmentRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAssignmentRequestsGetAssignment(ctx _context.Context, accessPackageAssignmentRequestId string) ApiIdentityGovernanceEntitlementManagementAssignmentRequestsGetAssignmentRequest {
	return ApiIdentityGovernanceEntitlementManagementAssignmentRequestsGetAssignmentRequest{
		ApiService: a,
		ctx: ctx,
		accessPackageAssignmentRequestId: accessPackageAssignmentRequestId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphAccessPackageAssignment
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAssignmentRequestsGetAssignmentExecute(r ApiIdentityGovernanceEntitlementManagementAssignmentRequestsGetAssignmentRequest) (MicrosoftGraphAccessPackageAssignment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphAccessPackageAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementAssignmentRequestsGetAssignment")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/assignmentRequests/{accessPackageAssignmentRequest-id}/assignment"
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackageAssignmentRequest-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageAssignmentRequestId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementAssignmentRequestsGetRefAccessPackageRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	accessPackageAssignmentRequestId string
}


func (r ApiIdentityGovernanceEntitlementManagementAssignmentRequestsGetRefAccessPackageRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementAssignmentRequestsGetRefAccessPackageExecute(r)
}

/*
IdentityGovernanceEntitlementManagementAssignmentRequestsGetRefAccessPackage Get ref of accessPackage from identityGovernance

The access package associated with the accessPackageAssignmentRequest. An access package defines the collections of resource roles and the policies for how one or more users can get access to those resources. Read-only. Nullable.  Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessPackageAssignmentRequestId key: id of accessPackageAssignmentRequest
 @return ApiIdentityGovernanceEntitlementManagementAssignmentRequestsGetRefAccessPackageRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAssignmentRequestsGetRefAccessPackage(ctx _context.Context, accessPackageAssignmentRequestId string) ApiIdentityGovernanceEntitlementManagementAssignmentRequestsGetRefAccessPackageRequest {
	return ApiIdentityGovernanceEntitlementManagementAssignmentRequestsGetRefAccessPackageRequest{
		ApiService: a,
		ctx: ctx,
		accessPackageAssignmentRequestId: accessPackageAssignmentRequestId,
	}
}

// Execute executes the request
//  @return string
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAssignmentRequestsGetRefAccessPackageExecute(r ApiIdentityGovernanceEntitlementManagementAssignmentRequestsGetRefAccessPackageRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementAssignmentRequestsGetRefAccessPackage")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/assignmentRequests/{accessPackageAssignmentRequest-id}/accessPackage/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackageAssignmentRequest-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageAssignmentRequestId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementAssignmentRequestsGetRefAssignmentRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	accessPackageAssignmentRequestId string
}


func (r ApiIdentityGovernanceEntitlementManagementAssignmentRequestsGetRefAssignmentRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementAssignmentRequestsGetRefAssignmentExecute(r)
}

/*
IdentityGovernanceEntitlementManagementAssignmentRequestsGetRefAssignment Get ref of assignment from identityGovernance

For a requestType of UserAdd or AdminAdd, this is an access package assignment requested to be created.  For a requestType of UserRemove, AdminRemove or SystemRemove, this has the id property of an existing assignment to be removed.   Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessPackageAssignmentRequestId key: id of accessPackageAssignmentRequest
 @return ApiIdentityGovernanceEntitlementManagementAssignmentRequestsGetRefAssignmentRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAssignmentRequestsGetRefAssignment(ctx _context.Context, accessPackageAssignmentRequestId string) ApiIdentityGovernanceEntitlementManagementAssignmentRequestsGetRefAssignmentRequest {
	return ApiIdentityGovernanceEntitlementManagementAssignmentRequestsGetRefAssignmentRequest{
		ApiService: a,
		ctx: ctx,
		accessPackageAssignmentRequestId: accessPackageAssignmentRequestId,
	}
}

// Execute executes the request
//  @return string
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAssignmentRequestsGetRefAssignmentExecute(r ApiIdentityGovernanceEntitlementManagementAssignmentRequestsGetRefAssignmentRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementAssignmentRequestsGetRefAssignment")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/assignmentRequests/{accessPackageAssignmentRequest-id}/assignment/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackageAssignmentRequest-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageAssignmentRequestId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementAssignmentRequestsGetRefRequestorRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	accessPackageAssignmentRequestId string
}


func (r ApiIdentityGovernanceEntitlementManagementAssignmentRequestsGetRefRequestorRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementAssignmentRequestsGetRefRequestorExecute(r)
}

/*
IdentityGovernanceEntitlementManagementAssignmentRequestsGetRefRequestor Get ref of requestor from identityGovernance

The subject who requested or, if a direct assignment, was assigned. Read-only. Nullable. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessPackageAssignmentRequestId key: id of accessPackageAssignmentRequest
 @return ApiIdentityGovernanceEntitlementManagementAssignmentRequestsGetRefRequestorRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAssignmentRequestsGetRefRequestor(ctx _context.Context, accessPackageAssignmentRequestId string) ApiIdentityGovernanceEntitlementManagementAssignmentRequestsGetRefRequestorRequest {
	return ApiIdentityGovernanceEntitlementManagementAssignmentRequestsGetRefRequestorRequest{
		ApiService: a,
		ctx: ctx,
		accessPackageAssignmentRequestId: accessPackageAssignmentRequestId,
	}
}

// Execute executes the request
//  @return string
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAssignmentRequestsGetRefRequestorExecute(r ApiIdentityGovernanceEntitlementManagementAssignmentRequestsGetRefRequestorRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementAssignmentRequestsGetRefRequestor")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/assignmentRequests/{accessPackageAssignmentRequest-id}/requestor/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackageAssignmentRequest-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageAssignmentRequestId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementAssignmentRequestsGetRequestorRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	accessPackageAssignmentRequestId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiIdentityGovernanceEntitlementManagementAssignmentRequestsGetRequestorRequest) Select_(select_ []string) ApiIdentityGovernanceEntitlementManagementAssignmentRequestsGetRequestorRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityGovernanceEntitlementManagementAssignmentRequestsGetRequestorRequest) Expand(expand []string) ApiIdentityGovernanceEntitlementManagementAssignmentRequestsGetRequestorRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementAssignmentRequestsGetRequestorRequest) Execute() (MicrosoftGraphAccessPackageSubject, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementAssignmentRequestsGetRequestorExecute(r)
}

/*
IdentityGovernanceEntitlementManagementAssignmentRequestsGetRequestor Get requestor from identityGovernance

The subject who requested or, if a direct assignment, was assigned. Read-only. Nullable. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessPackageAssignmentRequestId key: id of accessPackageAssignmentRequest
 @return ApiIdentityGovernanceEntitlementManagementAssignmentRequestsGetRequestorRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAssignmentRequestsGetRequestor(ctx _context.Context, accessPackageAssignmentRequestId string) ApiIdentityGovernanceEntitlementManagementAssignmentRequestsGetRequestorRequest {
	return ApiIdentityGovernanceEntitlementManagementAssignmentRequestsGetRequestorRequest{
		ApiService: a,
		ctx: ctx,
		accessPackageAssignmentRequestId: accessPackageAssignmentRequestId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphAccessPackageSubject
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAssignmentRequestsGetRequestorExecute(r ApiIdentityGovernanceEntitlementManagementAssignmentRequestsGetRequestorRequest) (MicrosoftGraphAccessPackageSubject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphAccessPackageSubject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementAssignmentRequestsGetRequestor")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/assignmentRequests/{accessPackageAssignmentRequest-id}/requestor"
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackageAssignmentRequest-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageAssignmentRequestId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementAssignmentRequestsUpdateRefAccessPackageRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	accessPackageAssignmentRequestId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiIdentityGovernanceEntitlementManagementAssignmentRequestsUpdateRefAccessPackageRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiIdentityGovernanceEntitlementManagementAssignmentRequestsUpdateRefAccessPackageRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementAssignmentRequestsUpdateRefAccessPackageRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementAssignmentRequestsUpdateRefAccessPackageExecute(r)
}

/*
IdentityGovernanceEntitlementManagementAssignmentRequestsUpdateRefAccessPackage Update the ref of navigation property accessPackage in identityGovernance

The access package associated with the accessPackageAssignmentRequest. An access package defines the collections of resource roles and the policies for how one or more users can get access to those resources. Read-only. Nullable.  Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessPackageAssignmentRequestId key: id of accessPackageAssignmentRequest
 @return ApiIdentityGovernanceEntitlementManagementAssignmentRequestsUpdateRefAccessPackageRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAssignmentRequestsUpdateRefAccessPackage(ctx _context.Context, accessPackageAssignmentRequestId string) ApiIdentityGovernanceEntitlementManagementAssignmentRequestsUpdateRefAccessPackageRequest {
	return ApiIdentityGovernanceEntitlementManagementAssignmentRequestsUpdateRefAccessPackageRequest{
		ApiService: a,
		ctx: ctx,
		accessPackageAssignmentRequestId: accessPackageAssignmentRequestId,
	}
}

// Execute executes the request
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAssignmentRequestsUpdateRefAccessPackageExecute(r ApiIdentityGovernanceEntitlementManagementAssignmentRequestsUpdateRefAccessPackageRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementAssignmentRequestsUpdateRefAccessPackage")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/assignmentRequests/{accessPackageAssignmentRequest-id}/accessPackage/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackageAssignmentRequest-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageAssignmentRequestId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementAssignmentRequestsUpdateRefAssignmentRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	accessPackageAssignmentRequestId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiIdentityGovernanceEntitlementManagementAssignmentRequestsUpdateRefAssignmentRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiIdentityGovernanceEntitlementManagementAssignmentRequestsUpdateRefAssignmentRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementAssignmentRequestsUpdateRefAssignmentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementAssignmentRequestsUpdateRefAssignmentExecute(r)
}

/*
IdentityGovernanceEntitlementManagementAssignmentRequestsUpdateRefAssignment Update the ref of navigation property assignment in identityGovernance

For a requestType of UserAdd or AdminAdd, this is an access package assignment requested to be created.  For a requestType of UserRemove, AdminRemove or SystemRemove, this has the id property of an existing assignment to be removed.   Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessPackageAssignmentRequestId key: id of accessPackageAssignmentRequest
 @return ApiIdentityGovernanceEntitlementManagementAssignmentRequestsUpdateRefAssignmentRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAssignmentRequestsUpdateRefAssignment(ctx _context.Context, accessPackageAssignmentRequestId string) ApiIdentityGovernanceEntitlementManagementAssignmentRequestsUpdateRefAssignmentRequest {
	return ApiIdentityGovernanceEntitlementManagementAssignmentRequestsUpdateRefAssignmentRequest{
		ApiService: a,
		ctx: ctx,
		accessPackageAssignmentRequestId: accessPackageAssignmentRequestId,
	}
}

// Execute executes the request
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAssignmentRequestsUpdateRefAssignmentExecute(r ApiIdentityGovernanceEntitlementManagementAssignmentRequestsUpdateRefAssignmentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementAssignmentRequestsUpdateRefAssignment")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/assignmentRequests/{accessPackageAssignmentRequest-id}/assignment/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackageAssignmentRequest-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageAssignmentRequestId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementAssignmentRequestsUpdateRefRequestorRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	accessPackageAssignmentRequestId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiIdentityGovernanceEntitlementManagementAssignmentRequestsUpdateRefRequestorRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiIdentityGovernanceEntitlementManagementAssignmentRequestsUpdateRefRequestorRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementAssignmentRequestsUpdateRefRequestorRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementAssignmentRequestsUpdateRefRequestorExecute(r)
}

/*
IdentityGovernanceEntitlementManagementAssignmentRequestsUpdateRefRequestor Update the ref of navigation property requestor in identityGovernance

The subject who requested or, if a direct assignment, was assigned. Read-only. Nullable. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessPackageAssignmentRequestId key: id of accessPackageAssignmentRequest
 @return ApiIdentityGovernanceEntitlementManagementAssignmentRequestsUpdateRefRequestorRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAssignmentRequestsUpdateRefRequestor(ctx _context.Context, accessPackageAssignmentRequestId string) ApiIdentityGovernanceEntitlementManagementAssignmentRequestsUpdateRefRequestorRequest {
	return ApiIdentityGovernanceEntitlementManagementAssignmentRequestsUpdateRefRequestorRequest{
		ApiService: a,
		ctx: ctx,
		accessPackageAssignmentRequestId: accessPackageAssignmentRequestId,
	}
}

// Execute executes the request
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAssignmentRequestsUpdateRefRequestorExecute(r ApiIdentityGovernanceEntitlementManagementAssignmentRequestsUpdateRefRequestorRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementAssignmentRequestsUpdateRefRequestor")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/assignmentRequests/{accessPackageAssignmentRequest-id}/requestor/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackageAssignmentRequest-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageAssignmentRequestId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementAssignmentsDeleteRefAccessPackageRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	accessPackageAssignmentId string
	ifMatch *string
}

// ETag
func (r ApiIdentityGovernanceEntitlementManagementAssignmentsDeleteRefAccessPackageRequest) IfMatch(ifMatch string) ApiIdentityGovernanceEntitlementManagementAssignmentsDeleteRefAccessPackageRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementAssignmentsDeleteRefAccessPackageRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementAssignmentsDeleteRefAccessPackageExecute(r)
}

/*
IdentityGovernanceEntitlementManagementAssignmentsDeleteRefAccessPackage Delete ref of navigation property accessPackage for identityGovernance

Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessPackageAssignmentId key: id of accessPackageAssignment
 @return ApiIdentityGovernanceEntitlementManagementAssignmentsDeleteRefAccessPackageRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAssignmentsDeleteRefAccessPackage(ctx _context.Context, accessPackageAssignmentId string) ApiIdentityGovernanceEntitlementManagementAssignmentsDeleteRefAccessPackageRequest {
	return ApiIdentityGovernanceEntitlementManagementAssignmentsDeleteRefAccessPackageRequest{
		ApiService: a,
		ctx: ctx,
		accessPackageAssignmentId: accessPackageAssignmentId,
	}
}

// Execute executes the request
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAssignmentsDeleteRefAccessPackageExecute(r ApiIdentityGovernanceEntitlementManagementAssignmentsDeleteRefAccessPackageRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementAssignmentsDeleteRefAccessPackage")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/assignments/{accessPackageAssignment-id}/accessPackage/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackageAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementAssignmentsDeleteRefTargetRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	accessPackageAssignmentId string
	ifMatch *string
}

// ETag
func (r ApiIdentityGovernanceEntitlementManagementAssignmentsDeleteRefTargetRequest) IfMatch(ifMatch string) ApiIdentityGovernanceEntitlementManagementAssignmentsDeleteRefTargetRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementAssignmentsDeleteRefTargetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementAssignmentsDeleteRefTargetExecute(r)
}

/*
IdentityGovernanceEntitlementManagementAssignmentsDeleteRefTarget Delete ref of navigation property target for identityGovernance

The subject of the access package assignment. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessPackageAssignmentId key: id of accessPackageAssignment
 @return ApiIdentityGovernanceEntitlementManagementAssignmentsDeleteRefTargetRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAssignmentsDeleteRefTarget(ctx _context.Context, accessPackageAssignmentId string) ApiIdentityGovernanceEntitlementManagementAssignmentsDeleteRefTargetRequest {
	return ApiIdentityGovernanceEntitlementManagementAssignmentsDeleteRefTargetRequest{
		ApiService: a,
		ctx: ctx,
		accessPackageAssignmentId: accessPackageAssignmentId,
	}
}

// Execute executes the request
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAssignmentsDeleteRefTargetExecute(r ApiIdentityGovernanceEntitlementManagementAssignmentsDeleteRefTargetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementAssignmentsDeleteRefTarget")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/assignments/{accessPackageAssignment-id}/target/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackageAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementAssignmentsGetAccessPackageRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	accessPackageAssignmentId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiIdentityGovernanceEntitlementManagementAssignmentsGetAccessPackageRequest) Select_(select_ []string) ApiIdentityGovernanceEntitlementManagementAssignmentsGetAccessPackageRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityGovernanceEntitlementManagementAssignmentsGetAccessPackageRequest) Expand(expand []string) ApiIdentityGovernanceEntitlementManagementAssignmentsGetAccessPackageRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementAssignmentsGetAccessPackageRequest) Execute() (MicrosoftGraphAccessPackage, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementAssignmentsGetAccessPackageExecute(r)
}

/*
IdentityGovernanceEntitlementManagementAssignmentsGetAccessPackage Get accessPackage from identityGovernance

Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessPackageAssignmentId key: id of accessPackageAssignment
 @return ApiIdentityGovernanceEntitlementManagementAssignmentsGetAccessPackageRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAssignmentsGetAccessPackage(ctx _context.Context, accessPackageAssignmentId string) ApiIdentityGovernanceEntitlementManagementAssignmentsGetAccessPackageRequest {
	return ApiIdentityGovernanceEntitlementManagementAssignmentsGetAccessPackageRequest{
		ApiService: a,
		ctx: ctx,
		accessPackageAssignmentId: accessPackageAssignmentId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphAccessPackage
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAssignmentsGetAccessPackageExecute(r ApiIdentityGovernanceEntitlementManagementAssignmentsGetAccessPackageRequest) (MicrosoftGraphAccessPackage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphAccessPackage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementAssignmentsGetAccessPackage")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/assignments/{accessPackageAssignment-id}/accessPackage"
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackageAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementAssignmentsGetRefAccessPackageRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	accessPackageAssignmentId string
}


func (r ApiIdentityGovernanceEntitlementManagementAssignmentsGetRefAccessPackageRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementAssignmentsGetRefAccessPackageExecute(r)
}

/*
IdentityGovernanceEntitlementManagementAssignmentsGetRefAccessPackage Get ref of accessPackage from identityGovernance

Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessPackageAssignmentId key: id of accessPackageAssignment
 @return ApiIdentityGovernanceEntitlementManagementAssignmentsGetRefAccessPackageRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAssignmentsGetRefAccessPackage(ctx _context.Context, accessPackageAssignmentId string) ApiIdentityGovernanceEntitlementManagementAssignmentsGetRefAccessPackageRequest {
	return ApiIdentityGovernanceEntitlementManagementAssignmentsGetRefAccessPackageRequest{
		ApiService: a,
		ctx: ctx,
		accessPackageAssignmentId: accessPackageAssignmentId,
	}
}

// Execute executes the request
//  @return string
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAssignmentsGetRefAccessPackageExecute(r ApiIdentityGovernanceEntitlementManagementAssignmentsGetRefAccessPackageRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementAssignmentsGetRefAccessPackage")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/assignments/{accessPackageAssignment-id}/accessPackage/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackageAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementAssignmentsGetRefTargetRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	accessPackageAssignmentId string
}


func (r ApiIdentityGovernanceEntitlementManagementAssignmentsGetRefTargetRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementAssignmentsGetRefTargetExecute(r)
}

/*
IdentityGovernanceEntitlementManagementAssignmentsGetRefTarget Get ref of target from identityGovernance

The subject of the access package assignment. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessPackageAssignmentId key: id of accessPackageAssignment
 @return ApiIdentityGovernanceEntitlementManagementAssignmentsGetRefTargetRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAssignmentsGetRefTarget(ctx _context.Context, accessPackageAssignmentId string) ApiIdentityGovernanceEntitlementManagementAssignmentsGetRefTargetRequest {
	return ApiIdentityGovernanceEntitlementManagementAssignmentsGetRefTargetRequest{
		ApiService: a,
		ctx: ctx,
		accessPackageAssignmentId: accessPackageAssignmentId,
	}
}

// Execute executes the request
//  @return string
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAssignmentsGetRefTargetExecute(r ApiIdentityGovernanceEntitlementManagementAssignmentsGetRefTargetRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementAssignmentsGetRefTarget")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/assignments/{accessPackageAssignment-id}/target/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackageAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementAssignmentsGetTargetRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	accessPackageAssignmentId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiIdentityGovernanceEntitlementManagementAssignmentsGetTargetRequest) Select_(select_ []string) ApiIdentityGovernanceEntitlementManagementAssignmentsGetTargetRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityGovernanceEntitlementManagementAssignmentsGetTargetRequest) Expand(expand []string) ApiIdentityGovernanceEntitlementManagementAssignmentsGetTargetRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementAssignmentsGetTargetRequest) Execute() (MicrosoftGraphAccessPackageSubject, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementAssignmentsGetTargetExecute(r)
}

/*
IdentityGovernanceEntitlementManagementAssignmentsGetTarget Get target from identityGovernance

The subject of the access package assignment. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessPackageAssignmentId key: id of accessPackageAssignment
 @return ApiIdentityGovernanceEntitlementManagementAssignmentsGetTargetRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAssignmentsGetTarget(ctx _context.Context, accessPackageAssignmentId string) ApiIdentityGovernanceEntitlementManagementAssignmentsGetTargetRequest {
	return ApiIdentityGovernanceEntitlementManagementAssignmentsGetTargetRequest{
		ApiService: a,
		ctx: ctx,
		accessPackageAssignmentId: accessPackageAssignmentId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphAccessPackageSubject
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAssignmentsGetTargetExecute(r ApiIdentityGovernanceEntitlementManagementAssignmentsGetTargetRequest) (MicrosoftGraphAccessPackageSubject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphAccessPackageSubject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementAssignmentsGetTarget")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/assignments/{accessPackageAssignment-id}/target"
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackageAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementAssignmentsUpdateRefAccessPackageRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	accessPackageAssignmentId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiIdentityGovernanceEntitlementManagementAssignmentsUpdateRefAccessPackageRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiIdentityGovernanceEntitlementManagementAssignmentsUpdateRefAccessPackageRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementAssignmentsUpdateRefAccessPackageRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementAssignmentsUpdateRefAccessPackageExecute(r)
}

/*
IdentityGovernanceEntitlementManagementAssignmentsUpdateRefAccessPackage Update the ref of navigation property accessPackage in identityGovernance

Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessPackageAssignmentId key: id of accessPackageAssignment
 @return ApiIdentityGovernanceEntitlementManagementAssignmentsUpdateRefAccessPackageRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAssignmentsUpdateRefAccessPackage(ctx _context.Context, accessPackageAssignmentId string) ApiIdentityGovernanceEntitlementManagementAssignmentsUpdateRefAccessPackageRequest {
	return ApiIdentityGovernanceEntitlementManagementAssignmentsUpdateRefAccessPackageRequest{
		ApiService: a,
		ctx: ctx,
		accessPackageAssignmentId: accessPackageAssignmentId,
	}
}

// Execute executes the request
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAssignmentsUpdateRefAccessPackageExecute(r ApiIdentityGovernanceEntitlementManagementAssignmentsUpdateRefAccessPackageRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementAssignmentsUpdateRefAccessPackage")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/assignments/{accessPackageAssignment-id}/accessPackage/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackageAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementAssignmentsUpdateRefTargetRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	accessPackageAssignmentId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiIdentityGovernanceEntitlementManagementAssignmentsUpdateRefTargetRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiIdentityGovernanceEntitlementManagementAssignmentsUpdateRefTargetRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementAssignmentsUpdateRefTargetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementAssignmentsUpdateRefTargetExecute(r)
}

/*
IdentityGovernanceEntitlementManagementAssignmentsUpdateRefTarget Update the ref of navigation property target in identityGovernance

The subject of the access package assignment. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessPackageAssignmentId key: id of accessPackageAssignment
 @return ApiIdentityGovernanceEntitlementManagementAssignmentsUpdateRefTargetRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAssignmentsUpdateRefTarget(ctx _context.Context, accessPackageAssignmentId string) ApiIdentityGovernanceEntitlementManagementAssignmentsUpdateRefTargetRequest {
	return ApiIdentityGovernanceEntitlementManagementAssignmentsUpdateRefTargetRequest{
		ApiService: a,
		ctx: ctx,
		accessPackageAssignmentId: accessPackageAssignmentId,
	}
}

// Execute executes the request
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementAssignmentsUpdateRefTargetExecute(r ApiIdentityGovernanceEntitlementManagementAssignmentsUpdateRefTargetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementAssignmentsUpdateRefTarget")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/assignments/{accessPackageAssignment-id}/target/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackageAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementCatalogsAccessPackagesDeleteRefCatalogRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	accessPackageCatalogId string
	accessPackageId string
	ifMatch *string
}

// ETag
func (r ApiIdentityGovernanceEntitlementManagementCatalogsAccessPackagesDeleteRefCatalogRequest) IfMatch(ifMatch string) ApiIdentityGovernanceEntitlementManagementCatalogsAccessPackagesDeleteRefCatalogRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementCatalogsAccessPackagesDeleteRefCatalogRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementCatalogsAccessPackagesDeleteRefCatalogExecute(r)
}

/*
IdentityGovernanceEntitlementManagementCatalogsAccessPackagesDeleteRefCatalog Delete ref of navigation property catalog for identityGovernance

Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessPackageCatalogId key: id of accessPackageCatalog
 @param accessPackageId key: id of accessPackage
 @return ApiIdentityGovernanceEntitlementManagementCatalogsAccessPackagesDeleteRefCatalogRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementCatalogsAccessPackagesDeleteRefCatalog(ctx _context.Context, accessPackageCatalogId string, accessPackageId string) ApiIdentityGovernanceEntitlementManagementCatalogsAccessPackagesDeleteRefCatalogRequest {
	return ApiIdentityGovernanceEntitlementManagementCatalogsAccessPackagesDeleteRefCatalogRequest{
		ApiService: a,
		ctx: ctx,
		accessPackageCatalogId: accessPackageCatalogId,
		accessPackageId: accessPackageId,
	}
}

// Execute executes the request
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementCatalogsAccessPackagesDeleteRefCatalogExecute(r ApiIdentityGovernanceEntitlementManagementCatalogsAccessPackagesDeleteRefCatalogRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementCatalogsAccessPackagesDeleteRefCatalog")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/catalogs/{accessPackageCatalog-id}/accessPackages/{accessPackage-id}/catalog/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackageCatalog-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageCatalogId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackage-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementCatalogsAccessPackagesGetCatalogRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	accessPackageCatalogId string
	accessPackageId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiIdentityGovernanceEntitlementManagementCatalogsAccessPackagesGetCatalogRequest) Select_(select_ []string) ApiIdentityGovernanceEntitlementManagementCatalogsAccessPackagesGetCatalogRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityGovernanceEntitlementManagementCatalogsAccessPackagesGetCatalogRequest) Expand(expand []string) ApiIdentityGovernanceEntitlementManagementCatalogsAccessPackagesGetCatalogRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementCatalogsAccessPackagesGetCatalogRequest) Execute() (MicrosoftGraphAccessPackageCatalog, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementCatalogsAccessPackagesGetCatalogExecute(r)
}

/*
IdentityGovernanceEntitlementManagementCatalogsAccessPackagesGetCatalog Get catalog from identityGovernance

Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessPackageCatalogId key: id of accessPackageCatalog
 @param accessPackageId key: id of accessPackage
 @return ApiIdentityGovernanceEntitlementManagementCatalogsAccessPackagesGetCatalogRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementCatalogsAccessPackagesGetCatalog(ctx _context.Context, accessPackageCatalogId string, accessPackageId string) ApiIdentityGovernanceEntitlementManagementCatalogsAccessPackagesGetCatalogRequest {
	return ApiIdentityGovernanceEntitlementManagementCatalogsAccessPackagesGetCatalogRequest{
		ApiService: a,
		ctx: ctx,
		accessPackageCatalogId: accessPackageCatalogId,
		accessPackageId: accessPackageId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphAccessPackageCatalog
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementCatalogsAccessPackagesGetCatalogExecute(r ApiIdentityGovernanceEntitlementManagementCatalogsAccessPackagesGetCatalogRequest) (MicrosoftGraphAccessPackageCatalog, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphAccessPackageCatalog
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementCatalogsAccessPackagesGetCatalog")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/catalogs/{accessPackageCatalog-id}/accessPackages/{accessPackage-id}/catalog"
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackageCatalog-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageCatalogId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackage-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementCatalogsAccessPackagesGetRefCatalogRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	accessPackageCatalogId string
	accessPackageId string
}


func (r ApiIdentityGovernanceEntitlementManagementCatalogsAccessPackagesGetRefCatalogRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementCatalogsAccessPackagesGetRefCatalogExecute(r)
}

/*
IdentityGovernanceEntitlementManagementCatalogsAccessPackagesGetRefCatalog Get ref of catalog from identityGovernance

Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessPackageCatalogId key: id of accessPackageCatalog
 @param accessPackageId key: id of accessPackage
 @return ApiIdentityGovernanceEntitlementManagementCatalogsAccessPackagesGetRefCatalogRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementCatalogsAccessPackagesGetRefCatalog(ctx _context.Context, accessPackageCatalogId string, accessPackageId string) ApiIdentityGovernanceEntitlementManagementCatalogsAccessPackagesGetRefCatalogRequest {
	return ApiIdentityGovernanceEntitlementManagementCatalogsAccessPackagesGetRefCatalogRequest{
		ApiService: a,
		ctx: ctx,
		accessPackageCatalogId: accessPackageCatalogId,
		accessPackageId: accessPackageId,
	}
}

// Execute executes the request
//  @return string
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementCatalogsAccessPackagesGetRefCatalogExecute(r ApiIdentityGovernanceEntitlementManagementCatalogsAccessPackagesGetRefCatalogRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementCatalogsAccessPackagesGetRefCatalog")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/catalogs/{accessPackageCatalog-id}/accessPackages/{accessPackage-id}/catalog/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackageCatalog-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageCatalogId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackage-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementCatalogsAccessPackagesUpdateRefCatalogRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	accessPackageCatalogId string
	accessPackageId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiIdentityGovernanceEntitlementManagementCatalogsAccessPackagesUpdateRefCatalogRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiIdentityGovernanceEntitlementManagementCatalogsAccessPackagesUpdateRefCatalogRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementCatalogsAccessPackagesUpdateRefCatalogRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementCatalogsAccessPackagesUpdateRefCatalogExecute(r)
}

/*
IdentityGovernanceEntitlementManagementCatalogsAccessPackagesUpdateRefCatalog Update the ref of navigation property catalog in identityGovernance

Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessPackageCatalogId key: id of accessPackageCatalog
 @param accessPackageId key: id of accessPackage
 @return ApiIdentityGovernanceEntitlementManagementCatalogsAccessPackagesUpdateRefCatalogRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementCatalogsAccessPackagesUpdateRefCatalog(ctx _context.Context, accessPackageCatalogId string, accessPackageId string) ApiIdentityGovernanceEntitlementManagementCatalogsAccessPackagesUpdateRefCatalogRequest {
	return ApiIdentityGovernanceEntitlementManagementCatalogsAccessPackagesUpdateRefCatalogRequest{
		ApiService: a,
		ctx: ctx,
		accessPackageCatalogId: accessPackageCatalogId,
		accessPackageId: accessPackageId,
	}
}

// Execute executes the request
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementCatalogsAccessPackagesUpdateRefCatalogExecute(r ApiIdentityGovernanceEntitlementManagementCatalogsAccessPackagesUpdateRefCatalogRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementCatalogsAccessPackagesUpdateRefCatalog")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/catalogs/{accessPackageCatalog-id}/accessPackages/{accessPackage-id}/catalog/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackageCatalog-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageCatalogId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackage-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementCatalogsCreateAccessPackagesRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	accessPackageCatalogId string
	microsoftGraphAccessPackage *MicrosoftGraphAccessPackage
}

// New navigation property
func (r ApiIdentityGovernanceEntitlementManagementCatalogsCreateAccessPackagesRequest) MicrosoftGraphAccessPackage(microsoftGraphAccessPackage MicrosoftGraphAccessPackage) ApiIdentityGovernanceEntitlementManagementCatalogsCreateAccessPackagesRequest {
	r.microsoftGraphAccessPackage = &microsoftGraphAccessPackage
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementCatalogsCreateAccessPackagesRequest) Execute() (MicrosoftGraphAccessPackage, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementCatalogsCreateAccessPackagesExecute(r)
}

/*
IdentityGovernanceEntitlementManagementCatalogsCreateAccessPackages Create new navigation property to accessPackages for identityGovernance

The access packages in this catalog. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessPackageCatalogId key: id of accessPackageCatalog
 @return ApiIdentityGovernanceEntitlementManagementCatalogsCreateAccessPackagesRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementCatalogsCreateAccessPackages(ctx _context.Context, accessPackageCatalogId string) ApiIdentityGovernanceEntitlementManagementCatalogsCreateAccessPackagesRequest {
	return ApiIdentityGovernanceEntitlementManagementCatalogsCreateAccessPackagesRequest{
		ApiService: a,
		ctx: ctx,
		accessPackageCatalogId: accessPackageCatalogId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphAccessPackage
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementCatalogsCreateAccessPackagesExecute(r ApiIdentityGovernanceEntitlementManagementCatalogsCreateAccessPackagesRequest) (MicrosoftGraphAccessPackage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphAccessPackage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementCatalogsCreateAccessPackages")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/catalogs/{accessPackageCatalog-id}/accessPackages"
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackageCatalog-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageCatalogId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphAccessPackage == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphAccessPackage is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphAccessPackage
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementCatalogsDeleteAccessPackagesRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	accessPackageCatalogId string
	accessPackageId string
	ifMatch *string
}

// ETag
func (r ApiIdentityGovernanceEntitlementManagementCatalogsDeleteAccessPackagesRequest) IfMatch(ifMatch string) ApiIdentityGovernanceEntitlementManagementCatalogsDeleteAccessPackagesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementCatalogsDeleteAccessPackagesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementCatalogsDeleteAccessPackagesExecute(r)
}

/*
IdentityGovernanceEntitlementManagementCatalogsDeleteAccessPackages Delete navigation property accessPackages for identityGovernance

The access packages in this catalog. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessPackageCatalogId key: id of accessPackageCatalog
 @param accessPackageId key: id of accessPackage
 @return ApiIdentityGovernanceEntitlementManagementCatalogsDeleteAccessPackagesRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementCatalogsDeleteAccessPackages(ctx _context.Context, accessPackageCatalogId string, accessPackageId string) ApiIdentityGovernanceEntitlementManagementCatalogsDeleteAccessPackagesRequest {
	return ApiIdentityGovernanceEntitlementManagementCatalogsDeleteAccessPackagesRequest{
		ApiService: a,
		ctx: ctx,
		accessPackageCatalogId: accessPackageCatalogId,
		accessPackageId: accessPackageId,
	}
}

// Execute executes the request
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementCatalogsDeleteAccessPackagesExecute(r ApiIdentityGovernanceEntitlementManagementCatalogsDeleteAccessPackagesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementCatalogsDeleteAccessPackages")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/catalogs/{accessPackageCatalog-id}/accessPackages/{accessPackage-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackageCatalog-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageCatalogId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackage-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementCatalogsGetAccessPackagesRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	accessPackageCatalogId string
	accessPackageId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiIdentityGovernanceEntitlementManagementCatalogsGetAccessPackagesRequest) Select_(select_ []string) ApiIdentityGovernanceEntitlementManagementCatalogsGetAccessPackagesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityGovernanceEntitlementManagementCatalogsGetAccessPackagesRequest) Expand(expand []string) ApiIdentityGovernanceEntitlementManagementCatalogsGetAccessPackagesRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementCatalogsGetAccessPackagesRequest) Execute() (MicrosoftGraphAccessPackage, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementCatalogsGetAccessPackagesExecute(r)
}

/*
IdentityGovernanceEntitlementManagementCatalogsGetAccessPackages Get accessPackages from identityGovernance

The access packages in this catalog. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessPackageCatalogId key: id of accessPackageCatalog
 @param accessPackageId key: id of accessPackage
 @return ApiIdentityGovernanceEntitlementManagementCatalogsGetAccessPackagesRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementCatalogsGetAccessPackages(ctx _context.Context, accessPackageCatalogId string, accessPackageId string) ApiIdentityGovernanceEntitlementManagementCatalogsGetAccessPackagesRequest {
	return ApiIdentityGovernanceEntitlementManagementCatalogsGetAccessPackagesRequest{
		ApiService: a,
		ctx: ctx,
		accessPackageCatalogId: accessPackageCatalogId,
		accessPackageId: accessPackageId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphAccessPackage
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementCatalogsGetAccessPackagesExecute(r ApiIdentityGovernanceEntitlementManagementCatalogsGetAccessPackagesRequest) (MicrosoftGraphAccessPackage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphAccessPackage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementCatalogsGetAccessPackages")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/catalogs/{accessPackageCatalog-id}/accessPackages/{accessPackage-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackageCatalog-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageCatalogId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackage-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementCatalogsListAccessPackagesRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	accessPackageCatalogId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiIdentityGovernanceEntitlementManagementCatalogsListAccessPackagesRequest) Top(top int32) ApiIdentityGovernanceEntitlementManagementCatalogsListAccessPackagesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiIdentityGovernanceEntitlementManagementCatalogsListAccessPackagesRequest) Skip(skip int32) ApiIdentityGovernanceEntitlementManagementCatalogsListAccessPackagesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiIdentityGovernanceEntitlementManagementCatalogsListAccessPackagesRequest) Search(search string) ApiIdentityGovernanceEntitlementManagementCatalogsListAccessPackagesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiIdentityGovernanceEntitlementManagementCatalogsListAccessPackagesRequest) Filter(filter string) ApiIdentityGovernanceEntitlementManagementCatalogsListAccessPackagesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiIdentityGovernanceEntitlementManagementCatalogsListAccessPackagesRequest) Count(count bool) ApiIdentityGovernanceEntitlementManagementCatalogsListAccessPackagesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiIdentityGovernanceEntitlementManagementCatalogsListAccessPackagesRequest) Orderby(orderby []string) ApiIdentityGovernanceEntitlementManagementCatalogsListAccessPackagesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiIdentityGovernanceEntitlementManagementCatalogsListAccessPackagesRequest) Select_(select_ []string) ApiIdentityGovernanceEntitlementManagementCatalogsListAccessPackagesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityGovernanceEntitlementManagementCatalogsListAccessPackagesRequest) Expand(expand []string) ApiIdentityGovernanceEntitlementManagementCatalogsListAccessPackagesRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementCatalogsListAccessPackagesRequest) Execute() (CollectionOfAccessPackage, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementCatalogsListAccessPackagesExecute(r)
}

/*
IdentityGovernanceEntitlementManagementCatalogsListAccessPackages Get accessPackages from identityGovernance

The access packages in this catalog. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessPackageCatalogId key: id of accessPackageCatalog
 @return ApiIdentityGovernanceEntitlementManagementCatalogsListAccessPackagesRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementCatalogsListAccessPackages(ctx _context.Context, accessPackageCatalogId string) ApiIdentityGovernanceEntitlementManagementCatalogsListAccessPackagesRequest {
	return ApiIdentityGovernanceEntitlementManagementCatalogsListAccessPackagesRequest{
		ApiService: a,
		ctx: ctx,
		accessPackageCatalogId: accessPackageCatalogId,
	}
}

// Execute executes the request
//  @return CollectionOfAccessPackage
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementCatalogsListAccessPackagesExecute(r ApiIdentityGovernanceEntitlementManagementCatalogsListAccessPackagesRequest) (CollectionOfAccessPackage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfAccessPackage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementCatalogsListAccessPackages")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/catalogs/{accessPackageCatalog-id}/accessPackages"
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackageCatalog-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageCatalogId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementCatalogsUpdateAccessPackagesRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	accessPackageCatalogId string
	accessPackageId string
	microsoftGraphAccessPackage *MicrosoftGraphAccessPackage
}

// New navigation property values
func (r ApiIdentityGovernanceEntitlementManagementCatalogsUpdateAccessPackagesRequest) MicrosoftGraphAccessPackage(microsoftGraphAccessPackage MicrosoftGraphAccessPackage) ApiIdentityGovernanceEntitlementManagementCatalogsUpdateAccessPackagesRequest {
	r.microsoftGraphAccessPackage = &microsoftGraphAccessPackage
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementCatalogsUpdateAccessPackagesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementCatalogsUpdateAccessPackagesExecute(r)
}

/*
IdentityGovernanceEntitlementManagementCatalogsUpdateAccessPackages Update the navigation property accessPackages in identityGovernance

The access packages in this catalog. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessPackageCatalogId key: id of accessPackageCatalog
 @param accessPackageId key: id of accessPackage
 @return ApiIdentityGovernanceEntitlementManagementCatalogsUpdateAccessPackagesRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementCatalogsUpdateAccessPackages(ctx _context.Context, accessPackageCatalogId string, accessPackageId string) ApiIdentityGovernanceEntitlementManagementCatalogsUpdateAccessPackagesRequest {
	return ApiIdentityGovernanceEntitlementManagementCatalogsUpdateAccessPackagesRequest{
		ApiService: a,
		ctx: ctx,
		accessPackageCatalogId: accessPackageCatalogId,
		accessPackageId: accessPackageId,
	}
}

// Execute executes the request
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementCatalogsUpdateAccessPackagesExecute(r ApiIdentityGovernanceEntitlementManagementCatalogsUpdateAccessPackagesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementCatalogsUpdateAccessPackages")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/catalogs/{accessPackageCatalog-id}/accessPackages/{accessPackage-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackageCatalog-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageCatalogId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackage-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphAccessPackage == nil {
		return nil, reportError("microsoftGraphAccessPackage is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphAccessPackage
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsCreateExternalSponsorsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	connectedOrganizationId string
	microsoftGraphDirectoryObject *MicrosoftGraphDirectoryObject
}

// New navigation property
func (r ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsCreateExternalSponsorsRequest) MicrosoftGraphDirectoryObject(microsoftGraphDirectoryObject MicrosoftGraphDirectoryObject) ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsCreateExternalSponsorsRequest {
	r.microsoftGraphDirectoryObject = &microsoftGraphDirectoryObject
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsCreateExternalSponsorsRequest) Execute() (MicrosoftGraphDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementConnectedOrganizationsCreateExternalSponsorsExecute(r)
}

/*
IdentityGovernanceEntitlementManagementConnectedOrganizationsCreateExternalSponsors Create new navigation property to externalSponsors for identityGovernance

Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectedOrganizationId key: id of connectedOrganization
 @return ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsCreateExternalSponsorsRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementConnectedOrganizationsCreateExternalSponsors(ctx _context.Context, connectedOrganizationId string) ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsCreateExternalSponsorsRequest {
	return ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsCreateExternalSponsorsRequest{
		ApiService: a,
		ctx: ctx,
		connectedOrganizationId: connectedOrganizationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphDirectoryObject
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementConnectedOrganizationsCreateExternalSponsorsExecute(r ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsCreateExternalSponsorsRequest) (MicrosoftGraphDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementConnectedOrganizationsCreateExternalSponsors")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/connectedOrganizations/{connectedOrganization-id}/externalSponsors"
	localVarPath = strings.Replace(localVarPath, "{"+"connectedOrganization-id"+"}", _neturl.PathEscape(parameterToString(r.connectedOrganizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphDirectoryObject == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphDirectoryObject is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphDirectoryObject
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsCreateInternalSponsorsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	connectedOrganizationId string
	microsoftGraphDirectoryObject *MicrosoftGraphDirectoryObject
}

// New navigation property
func (r ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsCreateInternalSponsorsRequest) MicrosoftGraphDirectoryObject(microsoftGraphDirectoryObject MicrosoftGraphDirectoryObject) ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsCreateInternalSponsorsRequest {
	r.microsoftGraphDirectoryObject = &microsoftGraphDirectoryObject
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsCreateInternalSponsorsRequest) Execute() (MicrosoftGraphDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementConnectedOrganizationsCreateInternalSponsorsExecute(r)
}

/*
IdentityGovernanceEntitlementManagementConnectedOrganizationsCreateInternalSponsors Create new navigation property to internalSponsors for identityGovernance

Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectedOrganizationId key: id of connectedOrganization
 @return ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsCreateInternalSponsorsRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementConnectedOrganizationsCreateInternalSponsors(ctx _context.Context, connectedOrganizationId string) ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsCreateInternalSponsorsRequest {
	return ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsCreateInternalSponsorsRequest{
		ApiService: a,
		ctx: ctx,
		connectedOrganizationId: connectedOrganizationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphDirectoryObject
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementConnectedOrganizationsCreateInternalSponsorsExecute(r ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsCreateInternalSponsorsRequest) (MicrosoftGraphDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementConnectedOrganizationsCreateInternalSponsors")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/connectedOrganizations/{connectedOrganization-id}/internalSponsors"
	localVarPath = strings.Replace(localVarPath, "{"+"connectedOrganization-id"+"}", _neturl.PathEscape(parameterToString(r.connectedOrganizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphDirectoryObject == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphDirectoryObject is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphDirectoryObject
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsDeleteExternalSponsorsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	connectedOrganizationId string
	directoryObjectId string
	ifMatch *string
}

// ETag
func (r ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsDeleteExternalSponsorsRequest) IfMatch(ifMatch string) ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsDeleteExternalSponsorsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsDeleteExternalSponsorsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementConnectedOrganizationsDeleteExternalSponsorsExecute(r)
}

/*
IdentityGovernanceEntitlementManagementConnectedOrganizationsDeleteExternalSponsors Delete navigation property externalSponsors for identityGovernance

Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectedOrganizationId key: id of connectedOrganization
 @param directoryObjectId key: id of directoryObject
 @return ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsDeleteExternalSponsorsRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementConnectedOrganizationsDeleteExternalSponsors(ctx _context.Context, connectedOrganizationId string, directoryObjectId string) ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsDeleteExternalSponsorsRequest {
	return ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsDeleteExternalSponsorsRequest{
		ApiService: a,
		ctx: ctx,
		connectedOrganizationId: connectedOrganizationId,
		directoryObjectId: directoryObjectId,
	}
}

// Execute executes the request
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementConnectedOrganizationsDeleteExternalSponsorsExecute(r ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsDeleteExternalSponsorsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementConnectedOrganizationsDeleteExternalSponsors")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/connectedOrganizations/{connectedOrganization-id}/externalSponsors/{directoryObject-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"connectedOrganization-id"+"}", _neturl.PathEscape(parameterToString(r.connectedOrganizationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"directoryObject-id"+"}", _neturl.PathEscape(parameterToString(r.directoryObjectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsDeleteInternalSponsorsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	connectedOrganizationId string
	directoryObjectId string
	ifMatch *string
}

// ETag
func (r ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsDeleteInternalSponsorsRequest) IfMatch(ifMatch string) ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsDeleteInternalSponsorsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsDeleteInternalSponsorsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementConnectedOrganizationsDeleteInternalSponsorsExecute(r)
}

/*
IdentityGovernanceEntitlementManagementConnectedOrganizationsDeleteInternalSponsors Delete navigation property internalSponsors for identityGovernance

Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectedOrganizationId key: id of connectedOrganization
 @param directoryObjectId key: id of directoryObject
 @return ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsDeleteInternalSponsorsRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementConnectedOrganizationsDeleteInternalSponsors(ctx _context.Context, connectedOrganizationId string, directoryObjectId string) ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsDeleteInternalSponsorsRequest {
	return ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsDeleteInternalSponsorsRequest{
		ApiService: a,
		ctx: ctx,
		connectedOrganizationId: connectedOrganizationId,
		directoryObjectId: directoryObjectId,
	}
}

// Execute executes the request
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementConnectedOrganizationsDeleteInternalSponsorsExecute(r ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsDeleteInternalSponsorsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementConnectedOrganizationsDeleteInternalSponsors")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/connectedOrganizations/{connectedOrganization-id}/internalSponsors/{directoryObject-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"connectedOrganization-id"+"}", _neturl.PathEscape(parameterToString(r.connectedOrganizationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"directoryObject-id"+"}", _neturl.PathEscape(parameterToString(r.directoryObjectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsGetExternalSponsorsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	connectedOrganizationId string
	directoryObjectId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsGetExternalSponsorsRequest) Select_(select_ []string) ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsGetExternalSponsorsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsGetExternalSponsorsRequest) Expand(expand []string) ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsGetExternalSponsorsRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsGetExternalSponsorsRequest) Execute() (MicrosoftGraphDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementConnectedOrganizationsGetExternalSponsorsExecute(r)
}

/*
IdentityGovernanceEntitlementManagementConnectedOrganizationsGetExternalSponsors Get externalSponsors from identityGovernance

Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectedOrganizationId key: id of connectedOrganization
 @param directoryObjectId key: id of directoryObject
 @return ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsGetExternalSponsorsRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementConnectedOrganizationsGetExternalSponsors(ctx _context.Context, connectedOrganizationId string, directoryObjectId string) ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsGetExternalSponsorsRequest {
	return ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsGetExternalSponsorsRequest{
		ApiService: a,
		ctx: ctx,
		connectedOrganizationId: connectedOrganizationId,
		directoryObjectId: directoryObjectId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphDirectoryObject
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementConnectedOrganizationsGetExternalSponsorsExecute(r ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsGetExternalSponsorsRequest) (MicrosoftGraphDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementConnectedOrganizationsGetExternalSponsors")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/connectedOrganizations/{connectedOrganization-id}/externalSponsors/{directoryObject-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"connectedOrganization-id"+"}", _neturl.PathEscape(parameterToString(r.connectedOrganizationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"directoryObject-id"+"}", _neturl.PathEscape(parameterToString(r.directoryObjectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsGetInternalSponsorsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	connectedOrganizationId string
	directoryObjectId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsGetInternalSponsorsRequest) Select_(select_ []string) ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsGetInternalSponsorsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsGetInternalSponsorsRequest) Expand(expand []string) ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsGetInternalSponsorsRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsGetInternalSponsorsRequest) Execute() (MicrosoftGraphDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementConnectedOrganizationsGetInternalSponsorsExecute(r)
}

/*
IdentityGovernanceEntitlementManagementConnectedOrganizationsGetInternalSponsors Get internalSponsors from identityGovernance

Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectedOrganizationId key: id of connectedOrganization
 @param directoryObjectId key: id of directoryObject
 @return ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsGetInternalSponsorsRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementConnectedOrganizationsGetInternalSponsors(ctx _context.Context, connectedOrganizationId string, directoryObjectId string) ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsGetInternalSponsorsRequest {
	return ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsGetInternalSponsorsRequest{
		ApiService: a,
		ctx: ctx,
		connectedOrganizationId: connectedOrganizationId,
		directoryObjectId: directoryObjectId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphDirectoryObject
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementConnectedOrganizationsGetInternalSponsorsExecute(r ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsGetInternalSponsorsRequest) (MicrosoftGraphDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementConnectedOrganizationsGetInternalSponsors")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/connectedOrganizations/{connectedOrganization-id}/internalSponsors/{directoryObject-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"connectedOrganization-id"+"}", _neturl.PathEscape(parameterToString(r.connectedOrganizationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"directoryObject-id"+"}", _neturl.PathEscape(parameterToString(r.directoryObjectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsListExternalSponsorsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	connectedOrganizationId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsListExternalSponsorsRequest) Top(top int32) ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsListExternalSponsorsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsListExternalSponsorsRequest) Skip(skip int32) ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsListExternalSponsorsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsListExternalSponsorsRequest) Search(search string) ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsListExternalSponsorsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsListExternalSponsorsRequest) Filter(filter string) ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsListExternalSponsorsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsListExternalSponsorsRequest) Count(count bool) ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsListExternalSponsorsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsListExternalSponsorsRequest) Orderby(orderby []string) ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsListExternalSponsorsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsListExternalSponsorsRequest) Select_(select_ []string) ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsListExternalSponsorsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsListExternalSponsorsRequest) Expand(expand []string) ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsListExternalSponsorsRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsListExternalSponsorsRequest) Execute() (CollectionOfDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementConnectedOrganizationsListExternalSponsorsExecute(r)
}

/*
IdentityGovernanceEntitlementManagementConnectedOrganizationsListExternalSponsors Get externalSponsors from identityGovernance

Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectedOrganizationId key: id of connectedOrganization
 @return ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsListExternalSponsorsRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementConnectedOrganizationsListExternalSponsors(ctx _context.Context, connectedOrganizationId string) ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsListExternalSponsorsRequest {
	return ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsListExternalSponsorsRequest{
		ApiService: a,
		ctx: ctx,
		connectedOrganizationId: connectedOrganizationId,
	}
}

// Execute executes the request
//  @return CollectionOfDirectoryObject
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementConnectedOrganizationsListExternalSponsorsExecute(r ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsListExternalSponsorsRequest) (CollectionOfDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementConnectedOrganizationsListExternalSponsors")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/connectedOrganizations/{connectedOrganization-id}/externalSponsors"
	localVarPath = strings.Replace(localVarPath, "{"+"connectedOrganization-id"+"}", _neturl.PathEscape(parameterToString(r.connectedOrganizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsListInternalSponsorsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	connectedOrganizationId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsListInternalSponsorsRequest) Top(top int32) ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsListInternalSponsorsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsListInternalSponsorsRequest) Skip(skip int32) ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsListInternalSponsorsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsListInternalSponsorsRequest) Search(search string) ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsListInternalSponsorsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsListInternalSponsorsRequest) Filter(filter string) ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsListInternalSponsorsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsListInternalSponsorsRequest) Count(count bool) ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsListInternalSponsorsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsListInternalSponsorsRequest) Orderby(orderby []string) ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsListInternalSponsorsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsListInternalSponsorsRequest) Select_(select_ []string) ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsListInternalSponsorsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsListInternalSponsorsRequest) Expand(expand []string) ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsListInternalSponsorsRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsListInternalSponsorsRequest) Execute() (CollectionOfDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementConnectedOrganizationsListInternalSponsorsExecute(r)
}

/*
IdentityGovernanceEntitlementManagementConnectedOrganizationsListInternalSponsors Get internalSponsors from identityGovernance

Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectedOrganizationId key: id of connectedOrganization
 @return ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsListInternalSponsorsRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementConnectedOrganizationsListInternalSponsors(ctx _context.Context, connectedOrganizationId string) ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsListInternalSponsorsRequest {
	return ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsListInternalSponsorsRequest{
		ApiService: a,
		ctx: ctx,
		connectedOrganizationId: connectedOrganizationId,
	}
}

// Execute executes the request
//  @return CollectionOfDirectoryObject
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementConnectedOrganizationsListInternalSponsorsExecute(r ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsListInternalSponsorsRequest) (CollectionOfDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementConnectedOrganizationsListInternalSponsors")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/connectedOrganizations/{connectedOrganization-id}/internalSponsors"
	localVarPath = strings.Replace(localVarPath, "{"+"connectedOrganization-id"+"}", _neturl.PathEscape(parameterToString(r.connectedOrganizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsUpdateExternalSponsorsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	connectedOrganizationId string
	directoryObjectId string
	microsoftGraphDirectoryObject *MicrosoftGraphDirectoryObject
}

// New navigation property values
func (r ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsUpdateExternalSponsorsRequest) MicrosoftGraphDirectoryObject(microsoftGraphDirectoryObject MicrosoftGraphDirectoryObject) ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsUpdateExternalSponsorsRequest {
	r.microsoftGraphDirectoryObject = &microsoftGraphDirectoryObject
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsUpdateExternalSponsorsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementConnectedOrganizationsUpdateExternalSponsorsExecute(r)
}

/*
IdentityGovernanceEntitlementManagementConnectedOrganizationsUpdateExternalSponsors Update the navigation property externalSponsors in identityGovernance

Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectedOrganizationId key: id of connectedOrganization
 @param directoryObjectId key: id of directoryObject
 @return ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsUpdateExternalSponsorsRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementConnectedOrganizationsUpdateExternalSponsors(ctx _context.Context, connectedOrganizationId string, directoryObjectId string) ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsUpdateExternalSponsorsRequest {
	return ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsUpdateExternalSponsorsRequest{
		ApiService: a,
		ctx: ctx,
		connectedOrganizationId: connectedOrganizationId,
		directoryObjectId: directoryObjectId,
	}
}

// Execute executes the request
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementConnectedOrganizationsUpdateExternalSponsorsExecute(r ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsUpdateExternalSponsorsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementConnectedOrganizationsUpdateExternalSponsors")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/connectedOrganizations/{connectedOrganization-id}/externalSponsors/{directoryObject-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"connectedOrganization-id"+"}", _neturl.PathEscape(parameterToString(r.connectedOrganizationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"directoryObject-id"+"}", _neturl.PathEscape(parameterToString(r.directoryObjectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphDirectoryObject == nil {
		return nil, reportError("microsoftGraphDirectoryObject is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphDirectoryObject
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsUpdateInternalSponsorsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	connectedOrganizationId string
	directoryObjectId string
	microsoftGraphDirectoryObject *MicrosoftGraphDirectoryObject
}

// New navigation property values
func (r ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsUpdateInternalSponsorsRequest) MicrosoftGraphDirectoryObject(microsoftGraphDirectoryObject MicrosoftGraphDirectoryObject) ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsUpdateInternalSponsorsRequest {
	r.microsoftGraphDirectoryObject = &microsoftGraphDirectoryObject
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsUpdateInternalSponsorsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementConnectedOrganizationsUpdateInternalSponsorsExecute(r)
}

/*
IdentityGovernanceEntitlementManagementConnectedOrganizationsUpdateInternalSponsors Update the navigation property internalSponsors in identityGovernance

Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectedOrganizationId key: id of connectedOrganization
 @param directoryObjectId key: id of directoryObject
 @return ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsUpdateInternalSponsorsRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementConnectedOrganizationsUpdateInternalSponsors(ctx _context.Context, connectedOrganizationId string, directoryObjectId string) ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsUpdateInternalSponsorsRequest {
	return ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsUpdateInternalSponsorsRequest{
		ApiService: a,
		ctx: ctx,
		connectedOrganizationId: connectedOrganizationId,
		directoryObjectId: directoryObjectId,
	}
}

// Execute executes the request
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementConnectedOrganizationsUpdateInternalSponsorsExecute(r ApiIdentityGovernanceEntitlementManagementConnectedOrganizationsUpdateInternalSponsorsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementConnectedOrganizationsUpdateInternalSponsors")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/connectedOrganizations/{connectedOrganization-id}/internalSponsors/{directoryObject-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"connectedOrganization-id"+"}", _neturl.PathEscape(parameterToString(r.connectedOrganizationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"directoryObject-id"+"}", _neturl.PathEscape(parameterToString(r.directoryObjectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphDirectoryObject == nil {
		return nil, reportError("microsoftGraphDirectoryObject is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphDirectoryObject
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementCreateAccessPackageAssignmentApprovalsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	microsoftGraphApproval *MicrosoftGraphApproval
}

// New navigation property
func (r ApiIdentityGovernanceEntitlementManagementCreateAccessPackageAssignmentApprovalsRequest) MicrosoftGraphApproval(microsoftGraphApproval MicrosoftGraphApproval) ApiIdentityGovernanceEntitlementManagementCreateAccessPackageAssignmentApprovalsRequest {
	r.microsoftGraphApproval = &microsoftGraphApproval
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementCreateAccessPackageAssignmentApprovalsRequest) Execute() (MicrosoftGraphApproval, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementCreateAccessPackageAssignmentApprovalsExecute(r)
}

/*
IdentityGovernanceEntitlementManagementCreateAccessPackageAssignmentApprovals Create new navigation property to accessPackageAssignmentApprovals for identityGovernance

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIdentityGovernanceEntitlementManagementCreateAccessPackageAssignmentApprovalsRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementCreateAccessPackageAssignmentApprovals(ctx _context.Context) ApiIdentityGovernanceEntitlementManagementCreateAccessPackageAssignmentApprovalsRequest {
	return ApiIdentityGovernanceEntitlementManagementCreateAccessPackageAssignmentApprovalsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphApproval
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementCreateAccessPackageAssignmentApprovalsExecute(r ApiIdentityGovernanceEntitlementManagementCreateAccessPackageAssignmentApprovalsRequest) (MicrosoftGraphApproval, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphApproval
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementCreateAccessPackageAssignmentApprovals")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/accessPackageAssignmentApprovals"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphApproval == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphApproval is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphApproval
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementCreateAccessPackagesRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	microsoftGraphAccessPackage *MicrosoftGraphAccessPackage
}

// New navigation property
func (r ApiIdentityGovernanceEntitlementManagementCreateAccessPackagesRequest) MicrosoftGraphAccessPackage(microsoftGraphAccessPackage MicrosoftGraphAccessPackage) ApiIdentityGovernanceEntitlementManagementCreateAccessPackagesRequest {
	r.microsoftGraphAccessPackage = &microsoftGraphAccessPackage
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementCreateAccessPackagesRequest) Execute() (MicrosoftGraphAccessPackage, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementCreateAccessPackagesExecute(r)
}

/*
IdentityGovernanceEntitlementManagementCreateAccessPackages Create new navigation property to accessPackages for identityGovernance

Access packages.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIdentityGovernanceEntitlementManagementCreateAccessPackagesRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementCreateAccessPackages(ctx _context.Context) ApiIdentityGovernanceEntitlementManagementCreateAccessPackagesRequest {
	return ApiIdentityGovernanceEntitlementManagementCreateAccessPackagesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphAccessPackage
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementCreateAccessPackagesExecute(r ApiIdentityGovernanceEntitlementManagementCreateAccessPackagesRequest) (MicrosoftGraphAccessPackage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphAccessPackage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementCreateAccessPackages")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/accessPackages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphAccessPackage == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphAccessPackage is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphAccessPackage
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementCreateAssignmentRequestsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	microsoftGraphAccessPackageAssignmentRequest *MicrosoftGraphAccessPackageAssignmentRequest
}

// New navigation property
func (r ApiIdentityGovernanceEntitlementManagementCreateAssignmentRequestsRequest) MicrosoftGraphAccessPackageAssignmentRequest(microsoftGraphAccessPackageAssignmentRequest MicrosoftGraphAccessPackageAssignmentRequest) ApiIdentityGovernanceEntitlementManagementCreateAssignmentRequestsRequest {
	r.microsoftGraphAccessPackageAssignmentRequest = &microsoftGraphAccessPackageAssignmentRequest
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementCreateAssignmentRequestsRequest) Execute() (MicrosoftGraphAccessPackageAssignmentRequest, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementCreateAssignmentRequestsExecute(r)
}

/*
IdentityGovernanceEntitlementManagementCreateAssignmentRequests Create new navigation property to assignmentRequests for identityGovernance

Access package assignment requests.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIdentityGovernanceEntitlementManagementCreateAssignmentRequestsRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementCreateAssignmentRequests(ctx _context.Context) ApiIdentityGovernanceEntitlementManagementCreateAssignmentRequestsRequest {
	return ApiIdentityGovernanceEntitlementManagementCreateAssignmentRequestsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphAccessPackageAssignmentRequest
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementCreateAssignmentRequestsExecute(r ApiIdentityGovernanceEntitlementManagementCreateAssignmentRequestsRequest) (MicrosoftGraphAccessPackageAssignmentRequest, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphAccessPackageAssignmentRequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementCreateAssignmentRequests")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/assignmentRequests"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphAccessPackageAssignmentRequest == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphAccessPackageAssignmentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphAccessPackageAssignmentRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementCreateAssignmentsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	microsoftGraphAccessPackageAssignment *MicrosoftGraphAccessPackageAssignment
}

// New navigation property
func (r ApiIdentityGovernanceEntitlementManagementCreateAssignmentsRequest) MicrosoftGraphAccessPackageAssignment(microsoftGraphAccessPackageAssignment MicrosoftGraphAccessPackageAssignment) ApiIdentityGovernanceEntitlementManagementCreateAssignmentsRequest {
	r.microsoftGraphAccessPackageAssignment = &microsoftGraphAccessPackageAssignment
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementCreateAssignmentsRequest) Execute() (MicrosoftGraphAccessPackageAssignment, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementCreateAssignmentsExecute(r)
}

/*
IdentityGovernanceEntitlementManagementCreateAssignments Create new navigation property to assignments for identityGovernance

Access package assignments.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIdentityGovernanceEntitlementManagementCreateAssignmentsRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementCreateAssignments(ctx _context.Context) ApiIdentityGovernanceEntitlementManagementCreateAssignmentsRequest {
	return ApiIdentityGovernanceEntitlementManagementCreateAssignmentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphAccessPackageAssignment
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementCreateAssignmentsExecute(r ApiIdentityGovernanceEntitlementManagementCreateAssignmentsRequest) (MicrosoftGraphAccessPackageAssignment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphAccessPackageAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementCreateAssignments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/assignments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphAccessPackageAssignment == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphAccessPackageAssignment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphAccessPackageAssignment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementCreateCatalogsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	microsoftGraphAccessPackageCatalog *MicrosoftGraphAccessPackageCatalog
}

// New navigation property
func (r ApiIdentityGovernanceEntitlementManagementCreateCatalogsRequest) MicrosoftGraphAccessPackageCatalog(microsoftGraphAccessPackageCatalog MicrosoftGraphAccessPackageCatalog) ApiIdentityGovernanceEntitlementManagementCreateCatalogsRequest {
	r.microsoftGraphAccessPackageCatalog = &microsoftGraphAccessPackageCatalog
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementCreateCatalogsRequest) Execute() (MicrosoftGraphAccessPackageCatalog, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementCreateCatalogsExecute(r)
}

/*
IdentityGovernanceEntitlementManagementCreateCatalogs Create new navigation property to catalogs for identityGovernance

Access package catalogs.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIdentityGovernanceEntitlementManagementCreateCatalogsRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementCreateCatalogs(ctx _context.Context) ApiIdentityGovernanceEntitlementManagementCreateCatalogsRequest {
	return ApiIdentityGovernanceEntitlementManagementCreateCatalogsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphAccessPackageCatalog
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementCreateCatalogsExecute(r ApiIdentityGovernanceEntitlementManagementCreateCatalogsRequest) (MicrosoftGraphAccessPackageCatalog, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphAccessPackageCatalog
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementCreateCatalogs")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/catalogs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphAccessPackageCatalog == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphAccessPackageCatalog is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphAccessPackageCatalog
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementCreateConnectedOrganizationsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	microsoftGraphConnectedOrganization *MicrosoftGraphConnectedOrganization
}

// New navigation property
func (r ApiIdentityGovernanceEntitlementManagementCreateConnectedOrganizationsRequest) MicrosoftGraphConnectedOrganization(microsoftGraphConnectedOrganization MicrosoftGraphConnectedOrganization) ApiIdentityGovernanceEntitlementManagementCreateConnectedOrganizationsRequest {
	r.microsoftGraphConnectedOrganization = &microsoftGraphConnectedOrganization
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementCreateConnectedOrganizationsRequest) Execute() (MicrosoftGraphConnectedOrganization, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementCreateConnectedOrganizationsExecute(r)
}

/*
IdentityGovernanceEntitlementManagementCreateConnectedOrganizations Create new navigation property to connectedOrganizations for identityGovernance

Connected organizations.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIdentityGovernanceEntitlementManagementCreateConnectedOrganizationsRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementCreateConnectedOrganizations(ctx _context.Context) ApiIdentityGovernanceEntitlementManagementCreateConnectedOrganizationsRequest {
	return ApiIdentityGovernanceEntitlementManagementCreateConnectedOrganizationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphConnectedOrganization
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementCreateConnectedOrganizationsExecute(r ApiIdentityGovernanceEntitlementManagementCreateConnectedOrganizationsRequest) (MicrosoftGraphConnectedOrganization, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphConnectedOrganization
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementCreateConnectedOrganizations")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/connectedOrganizations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphConnectedOrganization == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphConnectedOrganization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphConnectedOrganization
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementDeleteAccessPackageAssignmentApprovalsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	approvalId string
	ifMatch *string
}

// ETag
func (r ApiIdentityGovernanceEntitlementManagementDeleteAccessPackageAssignmentApprovalsRequest) IfMatch(ifMatch string) ApiIdentityGovernanceEntitlementManagementDeleteAccessPackageAssignmentApprovalsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementDeleteAccessPackageAssignmentApprovalsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementDeleteAccessPackageAssignmentApprovalsExecute(r)
}

/*
IdentityGovernanceEntitlementManagementDeleteAccessPackageAssignmentApprovals Delete navigation property accessPackageAssignmentApprovals for identityGovernance

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param approvalId key: id of approval
 @return ApiIdentityGovernanceEntitlementManagementDeleteAccessPackageAssignmentApprovalsRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementDeleteAccessPackageAssignmentApprovals(ctx _context.Context, approvalId string) ApiIdentityGovernanceEntitlementManagementDeleteAccessPackageAssignmentApprovalsRequest {
	return ApiIdentityGovernanceEntitlementManagementDeleteAccessPackageAssignmentApprovalsRequest{
		ApiService: a,
		ctx: ctx,
		approvalId: approvalId,
	}
}

// Execute executes the request
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementDeleteAccessPackageAssignmentApprovalsExecute(r ApiIdentityGovernanceEntitlementManagementDeleteAccessPackageAssignmentApprovalsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementDeleteAccessPackageAssignmentApprovals")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/accessPackageAssignmentApprovals/{approval-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"approval-id"+"}", _neturl.PathEscape(parameterToString(r.approvalId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementDeleteAccessPackagesRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	accessPackageId string
	ifMatch *string
}

// ETag
func (r ApiIdentityGovernanceEntitlementManagementDeleteAccessPackagesRequest) IfMatch(ifMatch string) ApiIdentityGovernanceEntitlementManagementDeleteAccessPackagesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementDeleteAccessPackagesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementDeleteAccessPackagesExecute(r)
}

/*
IdentityGovernanceEntitlementManagementDeleteAccessPackages Delete navigation property accessPackages for identityGovernance

Access packages.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessPackageId key: id of accessPackage
 @return ApiIdentityGovernanceEntitlementManagementDeleteAccessPackagesRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementDeleteAccessPackages(ctx _context.Context, accessPackageId string) ApiIdentityGovernanceEntitlementManagementDeleteAccessPackagesRequest {
	return ApiIdentityGovernanceEntitlementManagementDeleteAccessPackagesRequest{
		ApiService: a,
		ctx: ctx,
		accessPackageId: accessPackageId,
	}
}

// Execute executes the request
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementDeleteAccessPackagesExecute(r ApiIdentityGovernanceEntitlementManagementDeleteAccessPackagesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementDeleteAccessPackages")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/accessPackages/{accessPackage-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackage-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementDeleteAssignmentRequestsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	accessPackageAssignmentRequestId string
	ifMatch *string
}

// ETag
func (r ApiIdentityGovernanceEntitlementManagementDeleteAssignmentRequestsRequest) IfMatch(ifMatch string) ApiIdentityGovernanceEntitlementManagementDeleteAssignmentRequestsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementDeleteAssignmentRequestsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementDeleteAssignmentRequestsExecute(r)
}

/*
IdentityGovernanceEntitlementManagementDeleteAssignmentRequests Delete navigation property assignmentRequests for identityGovernance

Access package assignment requests.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessPackageAssignmentRequestId key: id of accessPackageAssignmentRequest
 @return ApiIdentityGovernanceEntitlementManagementDeleteAssignmentRequestsRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementDeleteAssignmentRequests(ctx _context.Context, accessPackageAssignmentRequestId string) ApiIdentityGovernanceEntitlementManagementDeleteAssignmentRequestsRequest {
	return ApiIdentityGovernanceEntitlementManagementDeleteAssignmentRequestsRequest{
		ApiService: a,
		ctx: ctx,
		accessPackageAssignmentRequestId: accessPackageAssignmentRequestId,
	}
}

// Execute executes the request
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementDeleteAssignmentRequestsExecute(r ApiIdentityGovernanceEntitlementManagementDeleteAssignmentRequestsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementDeleteAssignmentRequests")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/assignmentRequests/{accessPackageAssignmentRequest-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackageAssignmentRequest-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageAssignmentRequestId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementDeleteAssignmentsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	accessPackageAssignmentId string
	ifMatch *string
}

// ETag
func (r ApiIdentityGovernanceEntitlementManagementDeleteAssignmentsRequest) IfMatch(ifMatch string) ApiIdentityGovernanceEntitlementManagementDeleteAssignmentsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementDeleteAssignmentsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementDeleteAssignmentsExecute(r)
}

/*
IdentityGovernanceEntitlementManagementDeleteAssignments Delete navigation property assignments for identityGovernance

Access package assignments.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessPackageAssignmentId key: id of accessPackageAssignment
 @return ApiIdentityGovernanceEntitlementManagementDeleteAssignmentsRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementDeleteAssignments(ctx _context.Context, accessPackageAssignmentId string) ApiIdentityGovernanceEntitlementManagementDeleteAssignmentsRequest {
	return ApiIdentityGovernanceEntitlementManagementDeleteAssignmentsRequest{
		ApiService: a,
		ctx: ctx,
		accessPackageAssignmentId: accessPackageAssignmentId,
	}
}

// Execute executes the request
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementDeleteAssignmentsExecute(r ApiIdentityGovernanceEntitlementManagementDeleteAssignmentsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementDeleteAssignments")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/assignments/{accessPackageAssignment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackageAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementDeleteCatalogsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	accessPackageCatalogId string
	ifMatch *string
}

// ETag
func (r ApiIdentityGovernanceEntitlementManagementDeleteCatalogsRequest) IfMatch(ifMatch string) ApiIdentityGovernanceEntitlementManagementDeleteCatalogsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementDeleteCatalogsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementDeleteCatalogsExecute(r)
}

/*
IdentityGovernanceEntitlementManagementDeleteCatalogs Delete navigation property catalogs for identityGovernance

Access package catalogs.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessPackageCatalogId key: id of accessPackageCatalog
 @return ApiIdentityGovernanceEntitlementManagementDeleteCatalogsRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementDeleteCatalogs(ctx _context.Context, accessPackageCatalogId string) ApiIdentityGovernanceEntitlementManagementDeleteCatalogsRequest {
	return ApiIdentityGovernanceEntitlementManagementDeleteCatalogsRequest{
		ApiService: a,
		ctx: ctx,
		accessPackageCatalogId: accessPackageCatalogId,
	}
}

// Execute executes the request
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementDeleteCatalogsExecute(r ApiIdentityGovernanceEntitlementManagementDeleteCatalogsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementDeleteCatalogs")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/catalogs/{accessPackageCatalog-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackageCatalog-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageCatalogId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementDeleteConnectedOrganizationsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	connectedOrganizationId string
	ifMatch *string
}

// ETag
func (r ApiIdentityGovernanceEntitlementManagementDeleteConnectedOrganizationsRequest) IfMatch(ifMatch string) ApiIdentityGovernanceEntitlementManagementDeleteConnectedOrganizationsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementDeleteConnectedOrganizationsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementDeleteConnectedOrganizationsExecute(r)
}

/*
IdentityGovernanceEntitlementManagementDeleteConnectedOrganizations Delete navigation property connectedOrganizations for identityGovernance

Connected organizations.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectedOrganizationId key: id of connectedOrganization
 @return ApiIdentityGovernanceEntitlementManagementDeleteConnectedOrganizationsRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementDeleteConnectedOrganizations(ctx _context.Context, connectedOrganizationId string) ApiIdentityGovernanceEntitlementManagementDeleteConnectedOrganizationsRequest {
	return ApiIdentityGovernanceEntitlementManagementDeleteConnectedOrganizationsRequest{
		ApiService: a,
		ctx: ctx,
		connectedOrganizationId: connectedOrganizationId,
	}
}

// Execute executes the request
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementDeleteConnectedOrganizationsExecute(r ApiIdentityGovernanceEntitlementManagementDeleteConnectedOrganizationsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementDeleteConnectedOrganizations")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/connectedOrganizations/{connectedOrganization-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"connectedOrganization-id"+"}", _neturl.PathEscape(parameterToString(r.connectedOrganizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementDeleteSettingsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	ifMatch *string
}

// ETag
func (r ApiIdentityGovernanceEntitlementManagementDeleteSettingsRequest) IfMatch(ifMatch string) ApiIdentityGovernanceEntitlementManagementDeleteSettingsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementDeleteSettingsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementDeleteSettingsExecute(r)
}

/*
IdentityGovernanceEntitlementManagementDeleteSettings Delete navigation property settings for identityGovernance

Entitlement management settings.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIdentityGovernanceEntitlementManagementDeleteSettingsRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementDeleteSettings(ctx _context.Context) ApiIdentityGovernanceEntitlementManagementDeleteSettingsRequest {
	return ApiIdentityGovernanceEntitlementManagementDeleteSettingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementDeleteSettingsExecute(r ApiIdentityGovernanceEntitlementManagementDeleteSettingsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementDeleteSettings")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/settings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementGetAccessPackageAssignmentApprovalsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	approvalId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiIdentityGovernanceEntitlementManagementGetAccessPackageAssignmentApprovalsRequest) Select_(select_ []string) ApiIdentityGovernanceEntitlementManagementGetAccessPackageAssignmentApprovalsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityGovernanceEntitlementManagementGetAccessPackageAssignmentApprovalsRequest) Expand(expand []string) ApiIdentityGovernanceEntitlementManagementGetAccessPackageAssignmentApprovalsRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementGetAccessPackageAssignmentApprovalsRequest) Execute() (MicrosoftGraphApproval, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementGetAccessPackageAssignmentApprovalsExecute(r)
}

/*
IdentityGovernanceEntitlementManagementGetAccessPackageAssignmentApprovals Get accessPackageAssignmentApprovals from identityGovernance

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param approvalId key: id of approval
 @return ApiIdentityGovernanceEntitlementManagementGetAccessPackageAssignmentApprovalsRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementGetAccessPackageAssignmentApprovals(ctx _context.Context, approvalId string) ApiIdentityGovernanceEntitlementManagementGetAccessPackageAssignmentApprovalsRequest {
	return ApiIdentityGovernanceEntitlementManagementGetAccessPackageAssignmentApprovalsRequest{
		ApiService: a,
		ctx: ctx,
		approvalId: approvalId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphApproval
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementGetAccessPackageAssignmentApprovalsExecute(r ApiIdentityGovernanceEntitlementManagementGetAccessPackageAssignmentApprovalsRequest) (MicrosoftGraphApproval, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphApproval
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementGetAccessPackageAssignmentApprovals")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/accessPackageAssignmentApprovals/{approval-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"approval-id"+"}", _neturl.PathEscape(parameterToString(r.approvalId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementGetAccessPackagesRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	accessPackageId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiIdentityGovernanceEntitlementManagementGetAccessPackagesRequest) Select_(select_ []string) ApiIdentityGovernanceEntitlementManagementGetAccessPackagesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityGovernanceEntitlementManagementGetAccessPackagesRequest) Expand(expand []string) ApiIdentityGovernanceEntitlementManagementGetAccessPackagesRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementGetAccessPackagesRequest) Execute() (MicrosoftGraphAccessPackage, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementGetAccessPackagesExecute(r)
}

/*
IdentityGovernanceEntitlementManagementGetAccessPackages Get accessPackages from identityGovernance

Access packages.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessPackageId key: id of accessPackage
 @return ApiIdentityGovernanceEntitlementManagementGetAccessPackagesRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementGetAccessPackages(ctx _context.Context, accessPackageId string) ApiIdentityGovernanceEntitlementManagementGetAccessPackagesRequest {
	return ApiIdentityGovernanceEntitlementManagementGetAccessPackagesRequest{
		ApiService: a,
		ctx: ctx,
		accessPackageId: accessPackageId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphAccessPackage
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementGetAccessPackagesExecute(r ApiIdentityGovernanceEntitlementManagementGetAccessPackagesRequest) (MicrosoftGraphAccessPackage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphAccessPackage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementGetAccessPackages")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/accessPackages/{accessPackage-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackage-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementGetAssignmentRequestsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	accessPackageAssignmentRequestId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiIdentityGovernanceEntitlementManagementGetAssignmentRequestsRequest) Select_(select_ []string) ApiIdentityGovernanceEntitlementManagementGetAssignmentRequestsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityGovernanceEntitlementManagementGetAssignmentRequestsRequest) Expand(expand []string) ApiIdentityGovernanceEntitlementManagementGetAssignmentRequestsRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementGetAssignmentRequestsRequest) Execute() (MicrosoftGraphAccessPackageAssignmentRequest, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementGetAssignmentRequestsExecute(r)
}

/*
IdentityGovernanceEntitlementManagementGetAssignmentRequests Get assignmentRequests from identityGovernance

Access package assignment requests.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessPackageAssignmentRequestId key: id of accessPackageAssignmentRequest
 @return ApiIdentityGovernanceEntitlementManagementGetAssignmentRequestsRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementGetAssignmentRequests(ctx _context.Context, accessPackageAssignmentRequestId string) ApiIdentityGovernanceEntitlementManagementGetAssignmentRequestsRequest {
	return ApiIdentityGovernanceEntitlementManagementGetAssignmentRequestsRequest{
		ApiService: a,
		ctx: ctx,
		accessPackageAssignmentRequestId: accessPackageAssignmentRequestId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphAccessPackageAssignmentRequest
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementGetAssignmentRequestsExecute(r ApiIdentityGovernanceEntitlementManagementGetAssignmentRequestsRequest) (MicrosoftGraphAccessPackageAssignmentRequest, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphAccessPackageAssignmentRequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementGetAssignmentRequests")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/assignmentRequests/{accessPackageAssignmentRequest-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackageAssignmentRequest-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageAssignmentRequestId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementGetAssignmentsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	accessPackageAssignmentId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiIdentityGovernanceEntitlementManagementGetAssignmentsRequest) Select_(select_ []string) ApiIdentityGovernanceEntitlementManagementGetAssignmentsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityGovernanceEntitlementManagementGetAssignmentsRequest) Expand(expand []string) ApiIdentityGovernanceEntitlementManagementGetAssignmentsRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementGetAssignmentsRequest) Execute() (MicrosoftGraphAccessPackageAssignment, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementGetAssignmentsExecute(r)
}

/*
IdentityGovernanceEntitlementManagementGetAssignments Get assignments from identityGovernance

Access package assignments.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessPackageAssignmentId key: id of accessPackageAssignment
 @return ApiIdentityGovernanceEntitlementManagementGetAssignmentsRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementGetAssignments(ctx _context.Context, accessPackageAssignmentId string) ApiIdentityGovernanceEntitlementManagementGetAssignmentsRequest {
	return ApiIdentityGovernanceEntitlementManagementGetAssignmentsRequest{
		ApiService: a,
		ctx: ctx,
		accessPackageAssignmentId: accessPackageAssignmentId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphAccessPackageAssignment
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementGetAssignmentsExecute(r ApiIdentityGovernanceEntitlementManagementGetAssignmentsRequest) (MicrosoftGraphAccessPackageAssignment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphAccessPackageAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementGetAssignments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/assignments/{accessPackageAssignment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackageAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementGetCatalogsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	accessPackageCatalogId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiIdentityGovernanceEntitlementManagementGetCatalogsRequest) Select_(select_ []string) ApiIdentityGovernanceEntitlementManagementGetCatalogsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityGovernanceEntitlementManagementGetCatalogsRequest) Expand(expand []string) ApiIdentityGovernanceEntitlementManagementGetCatalogsRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementGetCatalogsRequest) Execute() (MicrosoftGraphAccessPackageCatalog, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementGetCatalogsExecute(r)
}

/*
IdentityGovernanceEntitlementManagementGetCatalogs Get catalogs from identityGovernance

Access package catalogs.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessPackageCatalogId key: id of accessPackageCatalog
 @return ApiIdentityGovernanceEntitlementManagementGetCatalogsRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementGetCatalogs(ctx _context.Context, accessPackageCatalogId string) ApiIdentityGovernanceEntitlementManagementGetCatalogsRequest {
	return ApiIdentityGovernanceEntitlementManagementGetCatalogsRequest{
		ApiService: a,
		ctx: ctx,
		accessPackageCatalogId: accessPackageCatalogId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphAccessPackageCatalog
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementGetCatalogsExecute(r ApiIdentityGovernanceEntitlementManagementGetCatalogsRequest) (MicrosoftGraphAccessPackageCatalog, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphAccessPackageCatalog
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementGetCatalogs")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/catalogs/{accessPackageCatalog-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackageCatalog-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageCatalogId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementGetConnectedOrganizationsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	connectedOrganizationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiIdentityGovernanceEntitlementManagementGetConnectedOrganizationsRequest) Select_(select_ []string) ApiIdentityGovernanceEntitlementManagementGetConnectedOrganizationsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityGovernanceEntitlementManagementGetConnectedOrganizationsRequest) Expand(expand []string) ApiIdentityGovernanceEntitlementManagementGetConnectedOrganizationsRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementGetConnectedOrganizationsRequest) Execute() (MicrosoftGraphConnectedOrganization, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementGetConnectedOrganizationsExecute(r)
}

/*
IdentityGovernanceEntitlementManagementGetConnectedOrganizations Get connectedOrganizations from identityGovernance

Connected organizations.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectedOrganizationId key: id of connectedOrganization
 @return ApiIdentityGovernanceEntitlementManagementGetConnectedOrganizationsRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementGetConnectedOrganizations(ctx _context.Context, connectedOrganizationId string) ApiIdentityGovernanceEntitlementManagementGetConnectedOrganizationsRequest {
	return ApiIdentityGovernanceEntitlementManagementGetConnectedOrganizationsRequest{
		ApiService: a,
		ctx: ctx,
		connectedOrganizationId: connectedOrganizationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphConnectedOrganization
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementGetConnectedOrganizationsExecute(r ApiIdentityGovernanceEntitlementManagementGetConnectedOrganizationsRequest) (MicrosoftGraphConnectedOrganization, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphConnectedOrganization
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementGetConnectedOrganizations")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/connectedOrganizations/{connectedOrganization-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"connectedOrganization-id"+"}", _neturl.PathEscape(parameterToString(r.connectedOrganizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementGetSettingsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiIdentityGovernanceEntitlementManagementGetSettingsRequest) Select_(select_ []string) ApiIdentityGovernanceEntitlementManagementGetSettingsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityGovernanceEntitlementManagementGetSettingsRequest) Expand(expand []string) ApiIdentityGovernanceEntitlementManagementGetSettingsRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementGetSettingsRequest) Execute() (MicrosoftGraphEntitlementManagementSettings, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementGetSettingsExecute(r)
}

/*
IdentityGovernanceEntitlementManagementGetSettings Get settings from identityGovernance

Entitlement management settings.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIdentityGovernanceEntitlementManagementGetSettingsRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementGetSettings(ctx _context.Context) ApiIdentityGovernanceEntitlementManagementGetSettingsRequest {
	return ApiIdentityGovernanceEntitlementManagementGetSettingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEntitlementManagementSettings
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementGetSettingsExecute(r ApiIdentityGovernanceEntitlementManagementGetSettingsRequest) (MicrosoftGraphEntitlementManagementSettings, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEntitlementManagementSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementGetSettings")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/settings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementListAccessPackageAssignmentApprovalsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiIdentityGovernanceEntitlementManagementListAccessPackageAssignmentApprovalsRequest) Top(top int32) ApiIdentityGovernanceEntitlementManagementListAccessPackageAssignmentApprovalsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiIdentityGovernanceEntitlementManagementListAccessPackageAssignmentApprovalsRequest) Skip(skip int32) ApiIdentityGovernanceEntitlementManagementListAccessPackageAssignmentApprovalsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiIdentityGovernanceEntitlementManagementListAccessPackageAssignmentApprovalsRequest) Search(search string) ApiIdentityGovernanceEntitlementManagementListAccessPackageAssignmentApprovalsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiIdentityGovernanceEntitlementManagementListAccessPackageAssignmentApprovalsRequest) Filter(filter string) ApiIdentityGovernanceEntitlementManagementListAccessPackageAssignmentApprovalsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiIdentityGovernanceEntitlementManagementListAccessPackageAssignmentApprovalsRequest) Count(count bool) ApiIdentityGovernanceEntitlementManagementListAccessPackageAssignmentApprovalsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiIdentityGovernanceEntitlementManagementListAccessPackageAssignmentApprovalsRequest) Orderby(orderby []string) ApiIdentityGovernanceEntitlementManagementListAccessPackageAssignmentApprovalsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiIdentityGovernanceEntitlementManagementListAccessPackageAssignmentApprovalsRequest) Select_(select_ []string) ApiIdentityGovernanceEntitlementManagementListAccessPackageAssignmentApprovalsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityGovernanceEntitlementManagementListAccessPackageAssignmentApprovalsRequest) Expand(expand []string) ApiIdentityGovernanceEntitlementManagementListAccessPackageAssignmentApprovalsRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementListAccessPackageAssignmentApprovalsRequest) Execute() (CollectionOfApproval, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementListAccessPackageAssignmentApprovalsExecute(r)
}

/*
IdentityGovernanceEntitlementManagementListAccessPackageAssignmentApprovals Get accessPackageAssignmentApprovals from identityGovernance

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIdentityGovernanceEntitlementManagementListAccessPackageAssignmentApprovalsRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementListAccessPackageAssignmentApprovals(ctx _context.Context) ApiIdentityGovernanceEntitlementManagementListAccessPackageAssignmentApprovalsRequest {
	return ApiIdentityGovernanceEntitlementManagementListAccessPackageAssignmentApprovalsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionOfApproval
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementListAccessPackageAssignmentApprovalsExecute(r ApiIdentityGovernanceEntitlementManagementListAccessPackageAssignmentApprovalsRequest) (CollectionOfApproval, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfApproval
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementListAccessPackageAssignmentApprovals")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/accessPackageAssignmentApprovals"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementListAccessPackagesRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiIdentityGovernanceEntitlementManagementListAccessPackagesRequest) Top(top int32) ApiIdentityGovernanceEntitlementManagementListAccessPackagesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiIdentityGovernanceEntitlementManagementListAccessPackagesRequest) Skip(skip int32) ApiIdentityGovernanceEntitlementManagementListAccessPackagesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiIdentityGovernanceEntitlementManagementListAccessPackagesRequest) Search(search string) ApiIdentityGovernanceEntitlementManagementListAccessPackagesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiIdentityGovernanceEntitlementManagementListAccessPackagesRequest) Filter(filter string) ApiIdentityGovernanceEntitlementManagementListAccessPackagesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiIdentityGovernanceEntitlementManagementListAccessPackagesRequest) Count(count bool) ApiIdentityGovernanceEntitlementManagementListAccessPackagesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiIdentityGovernanceEntitlementManagementListAccessPackagesRequest) Orderby(orderby []string) ApiIdentityGovernanceEntitlementManagementListAccessPackagesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiIdentityGovernanceEntitlementManagementListAccessPackagesRequest) Select_(select_ []string) ApiIdentityGovernanceEntitlementManagementListAccessPackagesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityGovernanceEntitlementManagementListAccessPackagesRequest) Expand(expand []string) ApiIdentityGovernanceEntitlementManagementListAccessPackagesRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementListAccessPackagesRequest) Execute() (CollectionOfAccessPackage, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementListAccessPackagesExecute(r)
}

/*
IdentityGovernanceEntitlementManagementListAccessPackages Get accessPackages from identityGovernance

Access packages.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIdentityGovernanceEntitlementManagementListAccessPackagesRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementListAccessPackages(ctx _context.Context) ApiIdentityGovernanceEntitlementManagementListAccessPackagesRequest {
	return ApiIdentityGovernanceEntitlementManagementListAccessPackagesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionOfAccessPackage
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementListAccessPackagesExecute(r ApiIdentityGovernanceEntitlementManagementListAccessPackagesRequest) (CollectionOfAccessPackage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfAccessPackage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementListAccessPackages")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/accessPackages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementListAssignmentRequestsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiIdentityGovernanceEntitlementManagementListAssignmentRequestsRequest) Top(top int32) ApiIdentityGovernanceEntitlementManagementListAssignmentRequestsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiIdentityGovernanceEntitlementManagementListAssignmentRequestsRequest) Skip(skip int32) ApiIdentityGovernanceEntitlementManagementListAssignmentRequestsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiIdentityGovernanceEntitlementManagementListAssignmentRequestsRequest) Search(search string) ApiIdentityGovernanceEntitlementManagementListAssignmentRequestsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiIdentityGovernanceEntitlementManagementListAssignmentRequestsRequest) Filter(filter string) ApiIdentityGovernanceEntitlementManagementListAssignmentRequestsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiIdentityGovernanceEntitlementManagementListAssignmentRequestsRequest) Count(count bool) ApiIdentityGovernanceEntitlementManagementListAssignmentRequestsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiIdentityGovernanceEntitlementManagementListAssignmentRequestsRequest) Orderby(orderby []string) ApiIdentityGovernanceEntitlementManagementListAssignmentRequestsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiIdentityGovernanceEntitlementManagementListAssignmentRequestsRequest) Select_(select_ []string) ApiIdentityGovernanceEntitlementManagementListAssignmentRequestsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityGovernanceEntitlementManagementListAssignmentRequestsRequest) Expand(expand []string) ApiIdentityGovernanceEntitlementManagementListAssignmentRequestsRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementListAssignmentRequestsRequest) Execute() (CollectionOfAccessPackageAssignmentRequest, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementListAssignmentRequestsExecute(r)
}

/*
IdentityGovernanceEntitlementManagementListAssignmentRequests Get assignmentRequests from identityGovernance

Access package assignment requests.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIdentityGovernanceEntitlementManagementListAssignmentRequestsRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementListAssignmentRequests(ctx _context.Context) ApiIdentityGovernanceEntitlementManagementListAssignmentRequestsRequest {
	return ApiIdentityGovernanceEntitlementManagementListAssignmentRequestsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionOfAccessPackageAssignmentRequest
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementListAssignmentRequestsExecute(r ApiIdentityGovernanceEntitlementManagementListAssignmentRequestsRequest) (CollectionOfAccessPackageAssignmentRequest, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfAccessPackageAssignmentRequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementListAssignmentRequests")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/assignmentRequests"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementListAssignmentsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiIdentityGovernanceEntitlementManagementListAssignmentsRequest) Top(top int32) ApiIdentityGovernanceEntitlementManagementListAssignmentsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiIdentityGovernanceEntitlementManagementListAssignmentsRequest) Skip(skip int32) ApiIdentityGovernanceEntitlementManagementListAssignmentsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiIdentityGovernanceEntitlementManagementListAssignmentsRequest) Search(search string) ApiIdentityGovernanceEntitlementManagementListAssignmentsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiIdentityGovernanceEntitlementManagementListAssignmentsRequest) Filter(filter string) ApiIdentityGovernanceEntitlementManagementListAssignmentsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiIdentityGovernanceEntitlementManagementListAssignmentsRequest) Count(count bool) ApiIdentityGovernanceEntitlementManagementListAssignmentsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiIdentityGovernanceEntitlementManagementListAssignmentsRequest) Orderby(orderby []string) ApiIdentityGovernanceEntitlementManagementListAssignmentsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiIdentityGovernanceEntitlementManagementListAssignmentsRequest) Select_(select_ []string) ApiIdentityGovernanceEntitlementManagementListAssignmentsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityGovernanceEntitlementManagementListAssignmentsRequest) Expand(expand []string) ApiIdentityGovernanceEntitlementManagementListAssignmentsRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementListAssignmentsRequest) Execute() (CollectionOfAccessPackageAssignment, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementListAssignmentsExecute(r)
}

/*
IdentityGovernanceEntitlementManagementListAssignments Get assignments from identityGovernance

Access package assignments.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIdentityGovernanceEntitlementManagementListAssignmentsRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementListAssignments(ctx _context.Context) ApiIdentityGovernanceEntitlementManagementListAssignmentsRequest {
	return ApiIdentityGovernanceEntitlementManagementListAssignmentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionOfAccessPackageAssignment
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementListAssignmentsExecute(r ApiIdentityGovernanceEntitlementManagementListAssignmentsRequest) (CollectionOfAccessPackageAssignment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfAccessPackageAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementListAssignments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/assignments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementListCatalogsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiIdentityGovernanceEntitlementManagementListCatalogsRequest) Top(top int32) ApiIdentityGovernanceEntitlementManagementListCatalogsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiIdentityGovernanceEntitlementManagementListCatalogsRequest) Skip(skip int32) ApiIdentityGovernanceEntitlementManagementListCatalogsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiIdentityGovernanceEntitlementManagementListCatalogsRequest) Search(search string) ApiIdentityGovernanceEntitlementManagementListCatalogsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiIdentityGovernanceEntitlementManagementListCatalogsRequest) Filter(filter string) ApiIdentityGovernanceEntitlementManagementListCatalogsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiIdentityGovernanceEntitlementManagementListCatalogsRequest) Count(count bool) ApiIdentityGovernanceEntitlementManagementListCatalogsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiIdentityGovernanceEntitlementManagementListCatalogsRequest) Orderby(orderby []string) ApiIdentityGovernanceEntitlementManagementListCatalogsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiIdentityGovernanceEntitlementManagementListCatalogsRequest) Select_(select_ []string) ApiIdentityGovernanceEntitlementManagementListCatalogsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityGovernanceEntitlementManagementListCatalogsRequest) Expand(expand []string) ApiIdentityGovernanceEntitlementManagementListCatalogsRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementListCatalogsRequest) Execute() (CollectionOfAccessPackageCatalog, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementListCatalogsExecute(r)
}

/*
IdentityGovernanceEntitlementManagementListCatalogs Get catalogs from identityGovernance

Access package catalogs.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIdentityGovernanceEntitlementManagementListCatalogsRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementListCatalogs(ctx _context.Context) ApiIdentityGovernanceEntitlementManagementListCatalogsRequest {
	return ApiIdentityGovernanceEntitlementManagementListCatalogsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionOfAccessPackageCatalog
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementListCatalogsExecute(r ApiIdentityGovernanceEntitlementManagementListCatalogsRequest) (CollectionOfAccessPackageCatalog, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfAccessPackageCatalog
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementListCatalogs")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/catalogs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementListConnectedOrganizationsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiIdentityGovernanceEntitlementManagementListConnectedOrganizationsRequest) Top(top int32) ApiIdentityGovernanceEntitlementManagementListConnectedOrganizationsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiIdentityGovernanceEntitlementManagementListConnectedOrganizationsRequest) Skip(skip int32) ApiIdentityGovernanceEntitlementManagementListConnectedOrganizationsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiIdentityGovernanceEntitlementManagementListConnectedOrganizationsRequest) Search(search string) ApiIdentityGovernanceEntitlementManagementListConnectedOrganizationsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiIdentityGovernanceEntitlementManagementListConnectedOrganizationsRequest) Filter(filter string) ApiIdentityGovernanceEntitlementManagementListConnectedOrganizationsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiIdentityGovernanceEntitlementManagementListConnectedOrganizationsRequest) Count(count bool) ApiIdentityGovernanceEntitlementManagementListConnectedOrganizationsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiIdentityGovernanceEntitlementManagementListConnectedOrganizationsRequest) Orderby(orderby []string) ApiIdentityGovernanceEntitlementManagementListConnectedOrganizationsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiIdentityGovernanceEntitlementManagementListConnectedOrganizationsRequest) Select_(select_ []string) ApiIdentityGovernanceEntitlementManagementListConnectedOrganizationsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityGovernanceEntitlementManagementListConnectedOrganizationsRequest) Expand(expand []string) ApiIdentityGovernanceEntitlementManagementListConnectedOrganizationsRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementListConnectedOrganizationsRequest) Execute() (CollectionOfConnectedOrganization, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementListConnectedOrganizationsExecute(r)
}

/*
IdentityGovernanceEntitlementManagementListConnectedOrganizations Get connectedOrganizations from identityGovernance

Connected organizations.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIdentityGovernanceEntitlementManagementListConnectedOrganizationsRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementListConnectedOrganizations(ctx _context.Context) ApiIdentityGovernanceEntitlementManagementListConnectedOrganizationsRequest {
	return ApiIdentityGovernanceEntitlementManagementListConnectedOrganizationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionOfConnectedOrganization
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementListConnectedOrganizationsExecute(r ApiIdentityGovernanceEntitlementManagementListConnectedOrganizationsRequest) (CollectionOfConnectedOrganization, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfConnectedOrganization
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementListConnectedOrganizations")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/connectedOrganizations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementUpdateAccessPackageAssignmentApprovalsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	approvalId string
	microsoftGraphApproval *MicrosoftGraphApproval
}

// New navigation property values
func (r ApiIdentityGovernanceEntitlementManagementUpdateAccessPackageAssignmentApprovalsRequest) MicrosoftGraphApproval(microsoftGraphApproval MicrosoftGraphApproval) ApiIdentityGovernanceEntitlementManagementUpdateAccessPackageAssignmentApprovalsRequest {
	r.microsoftGraphApproval = &microsoftGraphApproval
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementUpdateAccessPackageAssignmentApprovalsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementUpdateAccessPackageAssignmentApprovalsExecute(r)
}

/*
IdentityGovernanceEntitlementManagementUpdateAccessPackageAssignmentApprovals Update the navigation property accessPackageAssignmentApprovals in identityGovernance

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param approvalId key: id of approval
 @return ApiIdentityGovernanceEntitlementManagementUpdateAccessPackageAssignmentApprovalsRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementUpdateAccessPackageAssignmentApprovals(ctx _context.Context, approvalId string) ApiIdentityGovernanceEntitlementManagementUpdateAccessPackageAssignmentApprovalsRequest {
	return ApiIdentityGovernanceEntitlementManagementUpdateAccessPackageAssignmentApprovalsRequest{
		ApiService: a,
		ctx: ctx,
		approvalId: approvalId,
	}
}

// Execute executes the request
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementUpdateAccessPackageAssignmentApprovalsExecute(r ApiIdentityGovernanceEntitlementManagementUpdateAccessPackageAssignmentApprovalsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementUpdateAccessPackageAssignmentApprovals")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/accessPackageAssignmentApprovals/{approval-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"approval-id"+"}", _neturl.PathEscape(parameterToString(r.approvalId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphApproval == nil {
		return nil, reportError("microsoftGraphApproval is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphApproval
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementUpdateAccessPackagesRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	accessPackageId string
	microsoftGraphAccessPackage *MicrosoftGraphAccessPackage
}

// New navigation property values
func (r ApiIdentityGovernanceEntitlementManagementUpdateAccessPackagesRequest) MicrosoftGraphAccessPackage(microsoftGraphAccessPackage MicrosoftGraphAccessPackage) ApiIdentityGovernanceEntitlementManagementUpdateAccessPackagesRequest {
	r.microsoftGraphAccessPackage = &microsoftGraphAccessPackage
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementUpdateAccessPackagesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementUpdateAccessPackagesExecute(r)
}

/*
IdentityGovernanceEntitlementManagementUpdateAccessPackages Update the navigation property accessPackages in identityGovernance

Access packages.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessPackageId key: id of accessPackage
 @return ApiIdentityGovernanceEntitlementManagementUpdateAccessPackagesRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementUpdateAccessPackages(ctx _context.Context, accessPackageId string) ApiIdentityGovernanceEntitlementManagementUpdateAccessPackagesRequest {
	return ApiIdentityGovernanceEntitlementManagementUpdateAccessPackagesRequest{
		ApiService: a,
		ctx: ctx,
		accessPackageId: accessPackageId,
	}
}

// Execute executes the request
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementUpdateAccessPackagesExecute(r ApiIdentityGovernanceEntitlementManagementUpdateAccessPackagesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementUpdateAccessPackages")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/accessPackages/{accessPackage-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackage-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphAccessPackage == nil {
		return nil, reportError("microsoftGraphAccessPackage is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphAccessPackage
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementUpdateAssignmentRequestsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	accessPackageAssignmentRequestId string
	microsoftGraphAccessPackageAssignmentRequest *MicrosoftGraphAccessPackageAssignmentRequest
}

// New navigation property values
func (r ApiIdentityGovernanceEntitlementManagementUpdateAssignmentRequestsRequest) MicrosoftGraphAccessPackageAssignmentRequest(microsoftGraphAccessPackageAssignmentRequest MicrosoftGraphAccessPackageAssignmentRequest) ApiIdentityGovernanceEntitlementManagementUpdateAssignmentRequestsRequest {
	r.microsoftGraphAccessPackageAssignmentRequest = &microsoftGraphAccessPackageAssignmentRequest
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementUpdateAssignmentRequestsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementUpdateAssignmentRequestsExecute(r)
}

/*
IdentityGovernanceEntitlementManagementUpdateAssignmentRequests Update the navigation property assignmentRequests in identityGovernance

Access package assignment requests.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessPackageAssignmentRequestId key: id of accessPackageAssignmentRequest
 @return ApiIdentityGovernanceEntitlementManagementUpdateAssignmentRequestsRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementUpdateAssignmentRequests(ctx _context.Context, accessPackageAssignmentRequestId string) ApiIdentityGovernanceEntitlementManagementUpdateAssignmentRequestsRequest {
	return ApiIdentityGovernanceEntitlementManagementUpdateAssignmentRequestsRequest{
		ApiService: a,
		ctx: ctx,
		accessPackageAssignmentRequestId: accessPackageAssignmentRequestId,
	}
}

// Execute executes the request
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementUpdateAssignmentRequestsExecute(r ApiIdentityGovernanceEntitlementManagementUpdateAssignmentRequestsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementUpdateAssignmentRequests")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/assignmentRequests/{accessPackageAssignmentRequest-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackageAssignmentRequest-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageAssignmentRequestId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphAccessPackageAssignmentRequest == nil {
		return nil, reportError("microsoftGraphAccessPackageAssignmentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphAccessPackageAssignmentRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementUpdateAssignmentsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	accessPackageAssignmentId string
	microsoftGraphAccessPackageAssignment *MicrosoftGraphAccessPackageAssignment
}

// New navigation property values
func (r ApiIdentityGovernanceEntitlementManagementUpdateAssignmentsRequest) MicrosoftGraphAccessPackageAssignment(microsoftGraphAccessPackageAssignment MicrosoftGraphAccessPackageAssignment) ApiIdentityGovernanceEntitlementManagementUpdateAssignmentsRequest {
	r.microsoftGraphAccessPackageAssignment = &microsoftGraphAccessPackageAssignment
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementUpdateAssignmentsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementUpdateAssignmentsExecute(r)
}

/*
IdentityGovernanceEntitlementManagementUpdateAssignments Update the navigation property assignments in identityGovernance

Access package assignments.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessPackageAssignmentId key: id of accessPackageAssignment
 @return ApiIdentityGovernanceEntitlementManagementUpdateAssignmentsRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementUpdateAssignments(ctx _context.Context, accessPackageAssignmentId string) ApiIdentityGovernanceEntitlementManagementUpdateAssignmentsRequest {
	return ApiIdentityGovernanceEntitlementManagementUpdateAssignmentsRequest{
		ApiService: a,
		ctx: ctx,
		accessPackageAssignmentId: accessPackageAssignmentId,
	}
}

// Execute executes the request
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementUpdateAssignmentsExecute(r ApiIdentityGovernanceEntitlementManagementUpdateAssignmentsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementUpdateAssignments")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/assignments/{accessPackageAssignment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackageAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphAccessPackageAssignment == nil {
		return nil, reportError("microsoftGraphAccessPackageAssignment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphAccessPackageAssignment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementUpdateCatalogsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	accessPackageCatalogId string
	microsoftGraphAccessPackageCatalog *MicrosoftGraphAccessPackageCatalog
}

// New navigation property values
func (r ApiIdentityGovernanceEntitlementManagementUpdateCatalogsRequest) MicrosoftGraphAccessPackageCatalog(microsoftGraphAccessPackageCatalog MicrosoftGraphAccessPackageCatalog) ApiIdentityGovernanceEntitlementManagementUpdateCatalogsRequest {
	r.microsoftGraphAccessPackageCatalog = &microsoftGraphAccessPackageCatalog
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementUpdateCatalogsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementUpdateCatalogsExecute(r)
}

/*
IdentityGovernanceEntitlementManagementUpdateCatalogs Update the navigation property catalogs in identityGovernance

Access package catalogs.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessPackageCatalogId key: id of accessPackageCatalog
 @return ApiIdentityGovernanceEntitlementManagementUpdateCatalogsRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementUpdateCatalogs(ctx _context.Context, accessPackageCatalogId string) ApiIdentityGovernanceEntitlementManagementUpdateCatalogsRequest {
	return ApiIdentityGovernanceEntitlementManagementUpdateCatalogsRequest{
		ApiService: a,
		ctx: ctx,
		accessPackageCatalogId: accessPackageCatalogId,
	}
}

// Execute executes the request
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementUpdateCatalogsExecute(r ApiIdentityGovernanceEntitlementManagementUpdateCatalogsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementUpdateCatalogs")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/catalogs/{accessPackageCatalog-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"accessPackageCatalog-id"+"}", _neturl.PathEscape(parameterToString(r.accessPackageCatalogId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphAccessPackageCatalog == nil {
		return nil, reportError("microsoftGraphAccessPackageCatalog is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphAccessPackageCatalog
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementUpdateConnectedOrganizationsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	connectedOrganizationId string
	microsoftGraphConnectedOrganization *MicrosoftGraphConnectedOrganization
}

// New navigation property values
func (r ApiIdentityGovernanceEntitlementManagementUpdateConnectedOrganizationsRequest) MicrosoftGraphConnectedOrganization(microsoftGraphConnectedOrganization MicrosoftGraphConnectedOrganization) ApiIdentityGovernanceEntitlementManagementUpdateConnectedOrganizationsRequest {
	r.microsoftGraphConnectedOrganization = &microsoftGraphConnectedOrganization
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementUpdateConnectedOrganizationsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementUpdateConnectedOrganizationsExecute(r)
}

/*
IdentityGovernanceEntitlementManagementUpdateConnectedOrganizations Update the navigation property connectedOrganizations in identityGovernance

Connected organizations.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectedOrganizationId key: id of connectedOrganization
 @return ApiIdentityGovernanceEntitlementManagementUpdateConnectedOrganizationsRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementUpdateConnectedOrganizations(ctx _context.Context, connectedOrganizationId string) ApiIdentityGovernanceEntitlementManagementUpdateConnectedOrganizationsRequest {
	return ApiIdentityGovernanceEntitlementManagementUpdateConnectedOrganizationsRequest{
		ApiService: a,
		ctx: ctx,
		connectedOrganizationId: connectedOrganizationId,
	}
}

// Execute executes the request
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementUpdateConnectedOrganizationsExecute(r ApiIdentityGovernanceEntitlementManagementUpdateConnectedOrganizationsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementUpdateConnectedOrganizations")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/connectedOrganizations/{connectedOrganization-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"connectedOrganization-id"+"}", _neturl.PathEscape(parameterToString(r.connectedOrganizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphConnectedOrganization == nil {
		return nil, reportError("microsoftGraphConnectedOrganization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphConnectedOrganization
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceEntitlementManagementUpdateSettingsRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	microsoftGraphEntitlementManagementSettings *MicrosoftGraphEntitlementManagementSettings
}

// New navigation property values
func (r ApiIdentityGovernanceEntitlementManagementUpdateSettingsRequest) MicrosoftGraphEntitlementManagementSettings(microsoftGraphEntitlementManagementSettings MicrosoftGraphEntitlementManagementSettings) ApiIdentityGovernanceEntitlementManagementUpdateSettingsRequest {
	r.microsoftGraphEntitlementManagementSettings = &microsoftGraphEntitlementManagementSettings
	return r
}

func (r ApiIdentityGovernanceEntitlementManagementUpdateSettingsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceEntitlementManagementUpdateSettingsExecute(r)
}

/*
IdentityGovernanceEntitlementManagementUpdateSettings Update the navigation property settings in identityGovernance

Entitlement management settings.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIdentityGovernanceEntitlementManagementUpdateSettingsRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementUpdateSettings(ctx _context.Context) ApiIdentityGovernanceEntitlementManagementUpdateSettingsRequest {
	return ApiIdentityGovernanceEntitlementManagementUpdateSettingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceEntitlementManagementUpdateSettingsExecute(r ApiIdentityGovernanceEntitlementManagementUpdateSettingsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceEntitlementManagementUpdateSettings")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement/settings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphEntitlementManagementSettings == nil {
		return nil, reportError("microsoftGraphEntitlementManagementSettings is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphEntitlementManagementSettings
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIdentityGovernanceGetEntitlementManagementRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiIdentityGovernanceGetEntitlementManagementRequest) Select_(select_ []string) ApiIdentityGovernanceGetEntitlementManagementRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiIdentityGovernanceGetEntitlementManagementRequest) Expand(expand []string) ApiIdentityGovernanceGetEntitlementManagementRequest {
	r.expand = &expand
	return r
}

func (r ApiIdentityGovernanceGetEntitlementManagementRequest) Execute() (MicrosoftGraphEntitlementManagement, *_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceGetEntitlementManagementExecute(r)
}

/*
IdentityGovernanceGetEntitlementManagement Get entitlementManagement from identityGovernance

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIdentityGovernanceGetEntitlementManagementRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceGetEntitlementManagement(ctx _context.Context) ApiIdentityGovernanceGetEntitlementManagementRequest {
	return ApiIdentityGovernanceGetEntitlementManagementRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEntitlementManagement
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceGetEntitlementManagementExecute(r ApiIdentityGovernanceGetEntitlementManagementRequest) (MicrosoftGraphEntitlementManagement, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEntitlementManagement
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceGetEntitlementManagement")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentityGovernanceUpdateEntitlementManagementRequest struct {
	ctx _context.Context
	ApiService *IdentityGovernanceEntitlementManagementApiService
	microsoftGraphEntitlementManagement *MicrosoftGraphEntitlementManagement
}

// New navigation property values
func (r ApiIdentityGovernanceUpdateEntitlementManagementRequest) MicrosoftGraphEntitlementManagement(microsoftGraphEntitlementManagement MicrosoftGraphEntitlementManagement) ApiIdentityGovernanceUpdateEntitlementManagementRequest {
	r.microsoftGraphEntitlementManagement = &microsoftGraphEntitlementManagement
	return r
}

func (r ApiIdentityGovernanceUpdateEntitlementManagementRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IdentityGovernanceUpdateEntitlementManagementExecute(r)
}

/*
IdentityGovernanceUpdateEntitlementManagement Update the navigation property entitlementManagement in identityGovernance

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIdentityGovernanceUpdateEntitlementManagementRequest
*/
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceUpdateEntitlementManagement(ctx _context.Context) ApiIdentityGovernanceUpdateEntitlementManagementRequest {
	return ApiIdentityGovernanceUpdateEntitlementManagementRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IdentityGovernanceEntitlementManagementApiService) IdentityGovernanceUpdateEntitlementManagementExecute(r ApiIdentityGovernanceUpdateEntitlementManagementRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityGovernanceEntitlementManagementApiService.IdentityGovernanceUpdateEntitlementManagement")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identityGovernance/entitlementManagement"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphEntitlementManagement == nil {
		return nil, reportError("microsoftGraphEntitlementManagement is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphEntitlementManagement
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
