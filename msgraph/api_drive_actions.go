/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// DriveActionsApiService DriveActionsApi service
type DriveActionsApiService service

type ApiDriveListContentTypesAddCopyRequest struct {
	ctx _context.Context
	ApiService *DriveActionsApiService
	inlineObject140 *InlineObject140
}

func (r ApiDriveListContentTypesAddCopyRequest) InlineObject140(inlineObject140 InlineObject140) ApiDriveListContentTypesAddCopyRequest {
	r.inlineObject140 = &inlineObject140
	return r
}

func (r ApiDriveListContentTypesAddCopyRequest) Execute() (AnyOfmicrosoftGraphContentType, *_nethttp.Response, error) {
	return r.ApiService.DriveListContentTypesAddCopyExecute(r)
}

/*
DriveListContentTypesAddCopy Invoke action addCopy

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDriveListContentTypesAddCopyRequest
*/
func (a *DriveActionsApiService) DriveListContentTypesAddCopy(ctx _context.Context) ApiDriveListContentTypesAddCopyRequest {
	return ApiDriveListContentTypesAddCopyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphContentType
func (a *DriveActionsApiService) DriveListContentTypesAddCopyExecute(r ApiDriveListContentTypesAddCopyRequest) (AnyOfmicrosoftGraphContentType, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphContentType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveActionsApiService.DriveListContentTypesAddCopy")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/contentTypes/microsoft.graph.addCopy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject140 == nil {
		return localVarReturnValue, nil, reportError("inlineObject140 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject140
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDriveListContentTypesContentTypeAssociateWithHubSitesRequest struct {
	ctx _context.Context
	ApiService *DriveActionsApiService
	contentTypeId string
	inlineObject138 *InlineObject138
}

func (r ApiDriveListContentTypesContentTypeAssociateWithHubSitesRequest) InlineObject138(inlineObject138 InlineObject138) ApiDriveListContentTypesContentTypeAssociateWithHubSitesRequest {
	r.inlineObject138 = &inlineObject138
	return r
}

func (r ApiDriveListContentTypesContentTypeAssociateWithHubSitesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DriveListContentTypesContentTypeAssociateWithHubSitesExecute(r)
}

/*
DriveListContentTypesContentTypeAssociateWithHubSites Invoke action associateWithHubSites

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentTypeId key: id of contentType
 @return ApiDriveListContentTypesContentTypeAssociateWithHubSitesRequest
*/
func (a *DriveActionsApiService) DriveListContentTypesContentTypeAssociateWithHubSites(ctx _context.Context, contentTypeId string) ApiDriveListContentTypesContentTypeAssociateWithHubSitesRequest {
	return ApiDriveListContentTypesContentTypeAssociateWithHubSitesRequest{
		ApiService: a,
		ctx: ctx,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
func (a *DriveActionsApiService) DriveListContentTypesContentTypeAssociateWithHubSitesExecute(r ApiDriveListContentTypesContentTypeAssociateWithHubSitesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveActionsApiService.DriveListContentTypesContentTypeAssociateWithHubSites")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/contentTypes/{contentType-id}/microsoft.graph.associateWithHubSites"
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject138 == nil {
		return nil, reportError("inlineObject138 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject138
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDriveListContentTypesContentTypeBaseAssociateWithHubSitesRequest struct {
	ctx _context.Context
	ApiService *DriveActionsApiService
	contentTypeId string
	inlineObject135 *InlineObject135
}

func (r ApiDriveListContentTypesContentTypeBaseAssociateWithHubSitesRequest) InlineObject135(inlineObject135 InlineObject135) ApiDriveListContentTypesContentTypeBaseAssociateWithHubSitesRequest {
	r.inlineObject135 = &inlineObject135
	return r
}

func (r ApiDriveListContentTypesContentTypeBaseAssociateWithHubSitesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DriveListContentTypesContentTypeBaseAssociateWithHubSitesExecute(r)
}

/*
DriveListContentTypesContentTypeBaseAssociateWithHubSites Invoke action associateWithHubSites

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentTypeId key: id of contentType
 @return ApiDriveListContentTypesContentTypeBaseAssociateWithHubSitesRequest
*/
func (a *DriveActionsApiService) DriveListContentTypesContentTypeBaseAssociateWithHubSites(ctx _context.Context, contentTypeId string) ApiDriveListContentTypesContentTypeBaseAssociateWithHubSitesRequest {
	return ApiDriveListContentTypesContentTypeBaseAssociateWithHubSitesRequest{
		ApiService: a,
		ctx: ctx,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
func (a *DriveActionsApiService) DriveListContentTypesContentTypeBaseAssociateWithHubSitesExecute(r ApiDriveListContentTypesContentTypeBaseAssociateWithHubSitesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveActionsApiService.DriveListContentTypesContentTypeBaseAssociateWithHubSites")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/contentTypes/{contentType-id}/base/microsoft.graph.associateWithHubSites"
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject135 == nil {
		return nil, reportError("inlineObject135 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject135
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDriveListContentTypesContentTypeBaseCopyToDefaultContentLocationRequest struct {
	ctx _context.Context
	ApiService *DriveActionsApiService
	contentTypeId string
	inlineObject136 *InlineObject136
}

func (r ApiDriveListContentTypesContentTypeBaseCopyToDefaultContentLocationRequest) InlineObject136(inlineObject136 InlineObject136) ApiDriveListContentTypesContentTypeBaseCopyToDefaultContentLocationRequest {
	r.inlineObject136 = &inlineObject136
	return r
}

func (r ApiDriveListContentTypesContentTypeBaseCopyToDefaultContentLocationRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DriveListContentTypesContentTypeBaseCopyToDefaultContentLocationExecute(r)
}

/*
DriveListContentTypesContentTypeBaseCopyToDefaultContentLocation Invoke action copyToDefaultContentLocation

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentTypeId key: id of contentType
 @return ApiDriveListContentTypesContentTypeBaseCopyToDefaultContentLocationRequest
*/
func (a *DriveActionsApiService) DriveListContentTypesContentTypeBaseCopyToDefaultContentLocation(ctx _context.Context, contentTypeId string) ApiDriveListContentTypesContentTypeBaseCopyToDefaultContentLocationRequest {
	return ApiDriveListContentTypesContentTypeBaseCopyToDefaultContentLocationRequest{
		ApiService: a,
		ctx: ctx,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
func (a *DriveActionsApiService) DriveListContentTypesContentTypeBaseCopyToDefaultContentLocationExecute(r ApiDriveListContentTypesContentTypeBaseCopyToDefaultContentLocationRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveActionsApiService.DriveListContentTypesContentTypeBaseCopyToDefaultContentLocation")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/contentTypes/{contentType-id}/base/microsoft.graph.copyToDefaultContentLocation"
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject136 == nil {
		return nil, reportError("inlineObject136 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject136
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDriveListContentTypesContentTypeBasePublishRequest struct {
	ctx _context.Context
	ApiService *DriveActionsApiService
	contentTypeId string
}


func (r ApiDriveListContentTypesContentTypeBasePublishRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DriveListContentTypesContentTypeBasePublishExecute(r)
}

/*
DriveListContentTypesContentTypeBasePublish Invoke action publish

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentTypeId key: id of contentType
 @return ApiDriveListContentTypesContentTypeBasePublishRequest
*/
func (a *DriveActionsApiService) DriveListContentTypesContentTypeBasePublish(ctx _context.Context, contentTypeId string) ApiDriveListContentTypesContentTypeBasePublishRequest {
	return ApiDriveListContentTypesContentTypeBasePublishRequest{
		ApiService: a,
		ctx: ctx,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
func (a *DriveActionsApiService) DriveListContentTypesContentTypeBasePublishExecute(r ApiDriveListContentTypesContentTypeBasePublishRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveActionsApiService.DriveListContentTypesContentTypeBasePublish")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/contentTypes/{contentType-id}/base/microsoft.graph.publish"
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDriveListContentTypesContentTypeBaseTypesAddCopyRequest struct {
	ctx _context.Context
	ApiService *DriveActionsApiService
	contentTypeId string
	inlineObject137 *InlineObject137
}

func (r ApiDriveListContentTypesContentTypeBaseTypesAddCopyRequest) InlineObject137(inlineObject137 InlineObject137) ApiDriveListContentTypesContentTypeBaseTypesAddCopyRequest {
	r.inlineObject137 = &inlineObject137
	return r
}

func (r ApiDriveListContentTypesContentTypeBaseTypesAddCopyRequest) Execute() (AnyOfmicrosoftGraphContentType, *_nethttp.Response, error) {
	return r.ApiService.DriveListContentTypesContentTypeBaseTypesAddCopyExecute(r)
}

/*
DriveListContentTypesContentTypeBaseTypesAddCopy Invoke action addCopy

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentTypeId key: id of contentType
 @return ApiDriveListContentTypesContentTypeBaseTypesAddCopyRequest
*/
func (a *DriveActionsApiService) DriveListContentTypesContentTypeBaseTypesAddCopy(ctx _context.Context, contentTypeId string) ApiDriveListContentTypesContentTypeBaseTypesAddCopyRequest {
	return ApiDriveListContentTypesContentTypeBaseTypesAddCopyRequest{
		ApiService: a,
		ctx: ctx,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphContentType
func (a *DriveActionsApiService) DriveListContentTypesContentTypeBaseTypesAddCopyExecute(r ApiDriveListContentTypesContentTypeBaseTypesAddCopyRequest) (AnyOfmicrosoftGraphContentType, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphContentType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveActionsApiService.DriveListContentTypesContentTypeBaseTypesAddCopy")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/contentTypes/{contentType-id}/baseTypes/microsoft.graph.addCopy"
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject137 == nil {
		return localVarReturnValue, nil, reportError("inlineObject137 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject137
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDriveListContentTypesContentTypeBaseUnpublishRequest struct {
	ctx _context.Context
	ApiService *DriveActionsApiService
	contentTypeId string
}


func (r ApiDriveListContentTypesContentTypeBaseUnpublishRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DriveListContentTypesContentTypeBaseUnpublishExecute(r)
}

/*
DriveListContentTypesContentTypeBaseUnpublish Invoke action unpublish

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentTypeId key: id of contentType
 @return ApiDriveListContentTypesContentTypeBaseUnpublishRequest
*/
func (a *DriveActionsApiService) DriveListContentTypesContentTypeBaseUnpublish(ctx _context.Context, contentTypeId string) ApiDriveListContentTypesContentTypeBaseUnpublishRequest {
	return ApiDriveListContentTypesContentTypeBaseUnpublishRequest{
		ApiService: a,
		ctx: ctx,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
func (a *DriveActionsApiService) DriveListContentTypesContentTypeBaseUnpublishExecute(r ApiDriveListContentTypesContentTypeBaseUnpublishRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveActionsApiService.DriveListContentTypesContentTypeBaseUnpublish")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/contentTypes/{contentType-id}/base/microsoft.graph.unpublish"
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDriveListContentTypesContentTypeCopyToDefaultContentLocationRequest struct {
	ctx _context.Context
	ApiService *DriveActionsApiService
	contentTypeId string
	inlineObject139 *InlineObject139
}

func (r ApiDriveListContentTypesContentTypeCopyToDefaultContentLocationRequest) InlineObject139(inlineObject139 InlineObject139) ApiDriveListContentTypesContentTypeCopyToDefaultContentLocationRequest {
	r.inlineObject139 = &inlineObject139
	return r
}

func (r ApiDriveListContentTypesContentTypeCopyToDefaultContentLocationRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DriveListContentTypesContentTypeCopyToDefaultContentLocationExecute(r)
}

/*
DriveListContentTypesContentTypeCopyToDefaultContentLocation Invoke action copyToDefaultContentLocation

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentTypeId key: id of contentType
 @return ApiDriveListContentTypesContentTypeCopyToDefaultContentLocationRequest
*/
func (a *DriveActionsApiService) DriveListContentTypesContentTypeCopyToDefaultContentLocation(ctx _context.Context, contentTypeId string) ApiDriveListContentTypesContentTypeCopyToDefaultContentLocationRequest {
	return ApiDriveListContentTypesContentTypeCopyToDefaultContentLocationRequest{
		ApiService: a,
		ctx: ctx,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
func (a *DriveActionsApiService) DriveListContentTypesContentTypeCopyToDefaultContentLocationExecute(r ApiDriveListContentTypesContentTypeCopyToDefaultContentLocationRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveActionsApiService.DriveListContentTypesContentTypeCopyToDefaultContentLocation")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/contentTypes/{contentType-id}/microsoft.graph.copyToDefaultContentLocation"
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject139 == nil {
		return nil, reportError("inlineObject139 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject139
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDriveListContentTypesContentTypePublishRequest struct {
	ctx _context.Context
	ApiService *DriveActionsApiService
	contentTypeId string
}


func (r ApiDriveListContentTypesContentTypePublishRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DriveListContentTypesContentTypePublishExecute(r)
}

/*
DriveListContentTypesContentTypePublish Invoke action publish

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentTypeId key: id of contentType
 @return ApiDriveListContentTypesContentTypePublishRequest
*/
func (a *DriveActionsApiService) DriveListContentTypesContentTypePublish(ctx _context.Context, contentTypeId string) ApiDriveListContentTypesContentTypePublishRequest {
	return ApiDriveListContentTypesContentTypePublishRequest{
		ApiService: a,
		ctx: ctx,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
func (a *DriveActionsApiService) DriveListContentTypesContentTypePublishExecute(r ApiDriveListContentTypesContentTypePublishRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveActionsApiService.DriveListContentTypesContentTypePublish")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/contentTypes/{contentType-id}/microsoft.graph.publish"
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDriveListContentTypesContentTypeUnpublishRequest struct {
	ctx _context.Context
	ApiService *DriveActionsApiService
	contentTypeId string
}


func (r ApiDriveListContentTypesContentTypeUnpublishRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DriveListContentTypesContentTypeUnpublishExecute(r)
}

/*
DriveListContentTypesContentTypeUnpublish Invoke action unpublish

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentTypeId key: id of contentType
 @return ApiDriveListContentTypesContentTypeUnpublishRequest
*/
func (a *DriveActionsApiService) DriveListContentTypesContentTypeUnpublish(ctx _context.Context, contentTypeId string) ApiDriveListContentTypesContentTypeUnpublishRequest {
	return ApiDriveListContentTypesContentTypeUnpublishRequest{
		ApiService: a,
		ctx: ctx,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
func (a *DriveActionsApiService) DriveListContentTypesContentTypeUnpublishExecute(r ApiDriveListContentTypesContentTypeUnpublishRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveActionsApiService.DriveListContentTypesContentTypeUnpublish")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/contentTypes/{contentType-id}/microsoft.graph.unpublish"
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDriveListItemsListItemVersionsListItemVersionRestoreVersionRequest struct {
	ctx _context.Context
	ApiService *DriveActionsApiService
	listItemId string
	listItemVersionId string
}


func (r ApiDriveListItemsListItemVersionsListItemVersionRestoreVersionRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DriveListItemsListItemVersionsListItemVersionRestoreVersionExecute(r)
}

/*
DriveListItemsListItemVersionsListItemVersionRestoreVersion Invoke action restoreVersion

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listItemId key: id of listItem
 @param listItemVersionId key: id of listItemVersion
 @return ApiDriveListItemsListItemVersionsListItemVersionRestoreVersionRequest
*/
func (a *DriveActionsApiService) DriveListItemsListItemVersionsListItemVersionRestoreVersion(ctx _context.Context, listItemId string, listItemVersionId string) ApiDriveListItemsListItemVersionsListItemVersionRestoreVersionRequest {
	return ApiDriveListItemsListItemVersionsListItemVersionRestoreVersionRequest{
		ApiService: a,
		ctx: ctx,
		listItemId: listItemId,
		listItemVersionId: listItemVersionId,
	}
}

// Execute executes the request
func (a *DriveActionsApiService) DriveListItemsListItemVersionsListItemVersionRestoreVersionExecute(r ApiDriveListItemsListItemVersionsListItemVersionRestoreVersionRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveActionsApiService.DriveListItemsListItemVersionsListItemVersionRestoreVersion")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/items/{listItem-id}/versions/{listItemVersion-id}/microsoft.graph.restoreVersion"
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItemVersion-id"+"}", _neturl.PathEscape(parameterToString(r.listItemVersionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
