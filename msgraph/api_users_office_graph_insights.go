/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// UsersOfficeGraphInsightsApiService UsersOfficeGraphInsightsApi service
type UsersOfficeGraphInsightsApiService service

type ApiUsersDeleteInsightsRequest struct {
	ctx _context.Context
	ApiService *UsersOfficeGraphInsightsApiService
	userId string
	ifMatch *string
}

// ETag
func (r ApiUsersDeleteInsightsRequest) IfMatch(ifMatch string) ApiUsersDeleteInsightsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersDeleteInsightsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersDeleteInsightsExecute(r)
}

/*
UsersDeleteInsights Delete navigation property insights for users

Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @return ApiUsersDeleteInsightsRequest
*/
func (a *UsersOfficeGraphInsightsApiService) UsersDeleteInsights(ctx _context.Context, userId string) ApiUsersDeleteInsightsRequest {
	return ApiUsersDeleteInsightsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
func (a *UsersOfficeGraphInsightsApiService) UsersDeleteInsightsExecute(r ApiUsersDeleteInsightsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersOfficeGraphInsightsApiService.UsersDeleteInsights")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersGetInsightsRequest struct {
	ctx _context.Context
	ApiService *UsersOfficeGraphInsightsApiService
	userId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiUsersGetInsightsRequest) Select_(select_ []string) ApiUsersGetInsightsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersGetInsightsRequest) Expand(expand []string) ApiUsersGetInsightsRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersGetInsightsRequest) Execute() (MicrosoftGraphOfficeGraphInsights, *_nethttp.Response, error) {
	return r.ApiService.UsersGetInsightsExecute(r)
}

/*
UsersGetInsights Get insights from users

Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @return ApiUsersGetInsightsRequest
*/
func (a *UsersOfficeGraphInsightsApiService) UsersGetInsights(ctx _context.Context, userId string) ApiUsersGetInsightsRequest {
	return ApiUsersGetInsightsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphOfficeGraphInsights
func (a *UsersOfficeGraphInsightsApiService) UsersGetInsightsExecute(r ApiUsersGetInsightsRequest) (MicrosoftGraphOfficeGraphInsights, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphOfficeGraphInsights
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersOfficeGraphInsightsApiService.UsersGetInsights")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersInsightsCreateSharedRequest struct {
	ctx _context.Context
	ApiService *UsersOfficeGraphInsightsApiService
	userId string
	microsoftGraphSharedInsight *MicrosoftGraphSharedInsight
}

// New navigation property
func (r ApiUsersInsightsCreateSharedRequest) MicrosoftGraphSharedInsight(microsoftGraphSharedInsight MicrosoftGraphSharedInsight) ApiUsersInsightsCreateSharedRequest {
	r.microsoftGraphSharedInsight = &microsoftGraphSharedInsight
	return r
}

func (r ApiUsersInsightsCreateSharedRequest) Execute() (MicrosoftGraphSharedInsight, *_nethttp.Response, error) {
	return r.ApiService.UsersInsightsCreateSharedExecute(r)
}

/*
UsersInsightsCreateShared Create new navigation property to shared for users

Calculated relationship identifying documents shared with or by the user. This includes URLs, file attachments, and reference attachments to OneDrive for Business and SharePoint files found in Outlook messages and meetings. This also includes URLs and reference attachments to Teams conversations. Ordered by recency of share.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @return ApiUsersInsightsCreateSharedRequest
*/
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsCreateShared(ctx _context.Context, userId string) ApiUsersInsightsCreateSharedRequest {
	return ApiUsersInsightsCreateSharedRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphSharedInsight
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsCreateSharedExecute(r ApiUsersInsightsCreateSharedRequest) (MicrosoftGraphSharedInsight, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphSharedInsight
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersOfficeGraphInsightsApiService.UsersInsightsCreateShared")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphSharedInsight == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphSharedInsight is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphSharedInsight
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersInsightsCreateTrendingRequest struct {
	ctx _context.Context
	ApiService *UsersOfficeGraphInsightsApiService
	userId string
	microsoftGraphTrending *MicrosoftGraphTrending
}

// New navigation property
func (r ApiUsersInsightsCreateTrendingRequest) MicrosoftGraphTrending(microsoftGraphTrending MicrosoftGraphTrending) ApiUsersInsightsCreateTrendingRequest {
	r.microsoftGraphTrending = &microsoftGraphTrending
	return r
}

func (r ApiUsersInsightsCreateTrendingRequest) Execute() (MicrosoftGraphTrending, *_nethttp.Response, error) {
	return r.ApiService.UsersInsightsCreateTrendingExecute(r)
}

/*
UsersInsightsCreateTrending Create new navigation property to trending for users

Calculated relationship identifying documents trending around a user. Trending documents are calculated based on activity of the user's closest network of people and include files stored in OneDrive for Business and SharePoint. Trending insights help the user to discover potentially useful content that the user has access to, but has never viewed before.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @return ApiUsersInsightsCreateTrendingRequest
*/
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsCreateTrending(ctx _context.Context, userId string) ApiUsersInsightsCreateTrendingRequest {
	return ApiUsersInsightsCreateTrendingRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTrending
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsCreateTrendingExecute(r ApiUsersInsightsCreateTrendingRequest) (MicrosoftGraphTrending, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTrending
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersOfficeGraphInsightsApiService.UsersInsightsCreateTrending")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/trending"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTrending == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphTrending is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTrending
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersInsightsCreateUsedRequest struct {
	ctx _context.Context
	ApiService *UsersOfficeGraphInsightsApiService
	userId string
	microsoftGraphUsedInsight *MicrosoftGraphUsedInsight
}

// New navigation property
func (r ApiUsersInsightsCreateUsedRequest) MicrosoftGraphUsedInsight(microsoftGraphUsedInsight MicrosoftGraphUsedInsight) ApiUsersInsightsCreateUsedRequest {
	r.microsoftGraphUsedInsight = &microsoftGraphUsedInsight
	return r
}

func (r ApiUsersInsightsCreateUsedRequest) Execute() (MicrosoftGraphUsedInsight, *_nethttp.Response, error) {
	return r.ApiService.UsersInsightsCreateUsedExecute(r)
}

/*
UsersInsightsCreateUsed Create new navigation property to used for users

Calculated relationship identifying the latest documents viewed or modified by a user, including OneDrive for Business and SharePoint documents, ranked by recency of use.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @return ApiUsersInsightsCreateUsedRequest
*/
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsCreateUsed(ctx _context.Context, userId string) ApiUsersInsightsCreateUsedRequest {
	return ApiUsersInsightsCreateUsedRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphUsedInsight
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsCreateUsedExecute(r ApiUsersInsightsCreateUsedRequest) (MicrosoftGraphUsedInsight, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphUsedInsight
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersOfficeGraphInsightsApiService.UsersInsightsCreateUsed")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/used"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphUsedInsight == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphUsedInsight is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphUsedInsight
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersInsightsDeleteSharedRequest struct {
	ctx _context.Context
	ApiService *UsersOfficeGraphInsightsApiService
	userId string
	sharedInsightId string
	ifMatch *string
}

// ETag
func (r ApiUsersInsightsDeleteSharedRequest) IfMatch(ifMatch string) ApiUsersInsightsDeleteSharedRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersInsightsDeleteSharedRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersInsightsDeleteSharedExecute(r)
}

/*
UsersInsightsDeleteShared Delete navigation property shared for users

Calculated relationship identifying documents shared with or by the user. This includes URLs, file attachments, and reference attachments to OneDrive for Business and SharePoint files found in Outlook messages and meetings. This also includes URLs and reference attachments to Teams conversations. Ordered by recency of share.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersInsightsDeleteSharedRequest
*/
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsDeleteShared(ctx _context.Context, userId string, sharedInsightId string) ApiUsersInsightsDeleteSharedRequest {
	return ApiUsersInsightsDeleteSharedRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsDeleteSharedExecute(r ApiUsersInsightsDeleteSharedRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersOfficeGraphInsightsApiService.UsersInsightsDeleteShared")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersInsightsDeleteTrendingRequest struct {
	ctx _context.Context
	ApiService *UsersOfficeGraphInsightsApiService
	userId string
	trendingId string
	ifMatch *string
}

// ETag
func (r ApiUsersInsightsDeleteTrendingRequest) IfMatch(ifMatch string) ApiUsersInsightsDeleteTrendingRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersInsightsDeleteTrendingRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersInsightsDeleteTrendingExecute(r)
}

/*
UsersInsightsDeleteTrending Delete navigation property trending for users

Calculated relationship identifying documents trending around a user. Trending documents are calculated based on activity of the user's closest network of people and include files stored in OneDrive for Business and SharePoint. Trending insights help the user to discover potentially useful content that the user has access to, but has never viewed before.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param trendingId key: id of trending
 @return ApiUsersInsightsDeleteTrendingRequest
*/
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsDeleteTrending(ctx _context.Context, userId string, trendingId string) ApiUsersInsightsDeleteTrendingRequest {
	return ApiUsersInsightsDeleteTrendingRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		trendingId: trendingId,
	}
}

// Execute executes the request
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsDeleteTrendingExecute(r ApiUsersInsightsDeleteTrendingRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersOfficeGraphInsightsApiService.UsersInsightsDeleteTrending")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/trending/{trending-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersInsightsDeleteUsedRequest struct {
	ctx _context.Context
	ApiService *UsersOfficeGraphInsightsApiService
	userId string
	usedInsightId string
	ifMatch *string
}

// ETag
func (r ApiUsersInsightsDeleteUsedRequest) IfMatch(ifMatch string) ApiUsersInsightsDeleteUsedRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersInsightsDeleteUsedRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersInsightsDeleteUsedExecute(r)
}

/*
UsersInsightsDeleteUsed Delete navigation property used for users

Calculated relationship identifying the latest documents viewed or modified by a user, including OneDrive for Business and SharePoint documents, ranked by recency of use.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param usedInsightId key: id of usedInsight
 @return ApiUsersInsightsDeleteUsedRequest
*/
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsDeleteUsed(ctx _context.Context, userId string, usedInsightId string) ApiUsersInsightsDeleteUsedRequest {
	return ApiUsersInsightsDeleteUsedRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsDeleteUsedExecute(r ApiUsersInsightsDeleteUsedRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersOfficeGraphInsightsApiService.UsersInsightsDeleteUsed")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/used/{usedInsight-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersInsightsGetSharedRequest struct {
	ctx _context.Context
	ApiService *UsersOfficeGraphInsightsApiService
	userId string
	sharedInsightId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiUsersInsightsGetSharedRequest) Select_(select_ []string) ApiUsersInsightsGetSharedRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersInsightsGetSharedRequest) Expand(expand []string) ApiUsersInsightsGetSharedRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersInsightsGetSharedRequest) Execute() (MicrosoftGraphSharedInsight, *_nethttp.Response, error) {
	return r.ApiService.UsersInsightsGetSharedExecute(r)
}

/*
UsersInsightsGetShared Get shared from users

Calculated relationship identifying documents shared with or by the user. This includes URLs, file attachments, and reference attachments to OneDrive for Business and SharePoint files found in Outlook messages and meetings. This also includes URLs and reference attachments to Teams conversations. Ordered by recency of share.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersInsightsGetSharedRequest
*/
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsGetShared(ctx _context.Context, userId string, sharedInsightId string) ApiUsersInsightsGetSharedRequest {
	return ApiUsersInsightsGetSharedRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphSharedInsight
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsGetSharedExecute(r ApiUsersInsightsGetSharedRequest) (MicrosoftGraphSharedInsight, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphSharedInsight
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersOfficeGraphInsightsApiService.UsersInsightsGetShared")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersInsightsGetTrendingRequest struct {
	ctx _context.Context
	ApiService *UsersOfficeGraphInsightsApiService
	userId string
	trendingId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiUsersInsightsGetTrendingRequest) Select_(select_ []string) ApiUsersInsightsGetTrendingRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersInsightsGetTrendingRequest) Expand(expand []string) ApiUsersInsightsGetTrendingRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersInsightsGetTrendingRequest) Execute() (MicrosoftGraphTrending, *_nethttp.Response, error) {
	return r.ApiService.UsersInsightsGetTrendingExecute(r)
}

/*
UsersInsightsGetTrending Get trending from users

Calculated relationship identifying documents trending around a user. Trending documents are calculated based on activity of the user's closest network of people and include files stored in OneDrive for Business and SharePoint. Trending insights help the user to discover potentially useful content that the user has access to, but has never viewed before.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param trendingId key: id of trending
 @return ApiUsersInsightsGetTrendingRequest
*/
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsGetTrending(ctx _context.Context, userId string, trendingId string) ApiUsersInsightsGetTrendingRequest {
	return ApiUsersInsightsGetTrendingRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		trendingId: trendingId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTrending
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsGetTrendingExecute(r ApiUsersInsightsGetTrendingRequest) (MicrosoftGraphTrending, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTrending
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersOfficeGraphInsightsApiService.UsersInsightsGetTrending")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/trending/{trending-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersInsightsGetUsedRequest struct {
	ctx _context.Context
	ApiService *UsersOfficeGraphInsightsApiService
	userId string
	usedInsightId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiUsersInsightsGetUsedRequest) Select_(select_ []string) ApiUsersInsightsGetUsedRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersInsightsGetUsedRequest) Expand(expand []string) ApiUsersInsightsGetUsedRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersInsightsGetUsedRequest) Execute() (MicrosoftGraphUsedInsight, *_nethttp.Response, error) {
	return r.ApiService.UsersInsightsGetUsedExecute(r)
}

/*
UsersInsightsGetUsed Get used from users

Calculated relationship identifying the latest documents viewed or modified by a user, including OneDrive for Business and SharePoint documents, ranked by recency of use.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param usedInsightId key: id of usedInsight
 @return ApiUsersInsightsGetUsedRequest
*/
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsGetUsed(ctx _context.Context, userId string, usedInsightId string) ApiUsersInsightsGetUsedRequest {
	return ApiUsersInsightsGetUsedRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphUsedInsight
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsGetUsedExecute(r ApiUsersInsightsGetUsedRequest) (MicrosoftGraphUsedInsight, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphUsedInsight
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersOfficeGraphInsightsApiService.UsersInsightsGetUsed")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/used/{usedInsight-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersInsightsListSharedRequest struct {
	ctx _context.Context
	ApiService *UsersOfficeGraphInsightsApiService
	userId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiUsersInsightsListSharedRequest) Top(top int32) ApiUsersInsightsListSharedRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiUsersInsightsListSharedRequest) Skip(skip int32) ApiUsersInsightsListSharedRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiUsersInsightsListSharedRequest) Search(search string) ApiUsersInsightsListSharedRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiUsersInsightsListSharedRequest) Filter(filter string) ApiUsersInsightsListSharedRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiUsersInsightsListSharedRequest) Count(count bool) ApiUsersInsightsListSharedRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiUsersInsightsListSharedRequest) Orderby(orderby []string) ApiUsersInsightsListSharedRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiUsersInsightsListSharedRequest) Select_(select_ []string) ApiUsersInsightsListSharedRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersInsightsListSharedRequest) Expand(expand []string) ApiUsersInsightsListSharedRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersInsightsListSharedRequest) Execute() (CollectionOfSharedInsight, *_nethttp.Response, error) {
	return r.ApiService.UsersInsightsListSharedExecute(r)
}

/*
UsersInsightsListShared Get shared from users

Calculated relationship identifying documents shared with or by the user. This includes URLs, file attachments, and reference attachments to OneDrive for Business and SharePoint files found in Outlook messages and meetings. This also includes URLs and reference attachments to Teams conversations. Ordered by recency of share.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @return ApiUsersInsightsListSharedRequest
*/
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsListShared(ctx _context.Context, userId string) ApiUsersInsightsListSharedRequest {
	return ApiUsersInsightsListSharedRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return CollectionOfSharedInsight
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsListSharedExecute(r ApiUsersInsightsListSharedRequest) (CollectionOfSharedInsight, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfSharedInsight
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersOfficeGraphInsightsApiService.UsersInsightsListShared")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersInsightsListTrendingRequest struct {
	ctx _context.Context
	ApiService *UsersOfficeGraphInsightsApiService
	userId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiUsersInsightsListTrendingRequest) Top(top int32) ApiUsersInsightsListTrendingRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiUsersInsightsListTrendingRequest) Skip(skip int32) ApiUsersInsightsListTrendingRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiUsersInsightsListTrendingRequest) Search(search string) ApiUsersInsightsListTrendingRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiUsersInsightsListTrendingRequest) Filter(filter string) ApiUsersInsightsListTrendingRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiUsersInsightsListTrendingRequest) Count(count bool) ApiUsersInsightsListTrendingRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiUsersInsightsListTrendingRequest) Orderby(orderby []string) ApiUsersInsightsListTrendingRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiUsersInsightsListTrendingRequest) Select_(select_ []string) ApiUsersInsightsListTrendingRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersInsightsListTrendingRequest) Expand(expand []string) ApiUsersInsightsListTrendingRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersInsightsListTrendingRequest) Execute() (CollectionOfTrending, *_nethttp.Response, error) {
	return r.ApiService.UsersInsightsListTrendingExecute(r)
}

/*
UsersInsightsListTrending Get trending from users

Calculated relationship identifying documents trending around a user. Trending documents are calculated based on activity of the user's closest network of people and include files stored in OneDrive for Business and SharePoint. Trending insights help the user to discover potentially useful content that the user has access to, but has never viewed before.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @return ApiUsersInsightsListTrendingRequest
*/
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsListTrending(ctx _context.Context, userId string) ApiUsersInsightsListTrendingRequest {
	return ApiUsersInsightsListTrendingRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return CollectionOfTrending
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsListTrendingExecute(r ApiUsersInsightsListTrendingRequest) (CollectionOfTrending, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfTrending
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersOfficeGraphInsightsApiService.UsersInsightsListTrending")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/trending"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersInsightsListUsedRequest struct {
	ctx _context.Context
	ApiService *UsersOfficeGraphInsightsApiService
	userId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiUsersInsightsListUsedRequest) Top(top int32) ApiUsersInsightsListUsedRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiUsersInsightsListUsedRequest) Skip(skip int32) ApiUsersInsightsListUsedRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiUsersInsightsListUsedRequest) Search(search string) ApiUsersInsightsListUsedRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiUsersInsightsListUsedRequest) Filter(filter string) ApiUsersInsightsListUsedRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiUsersInsightsListUsedRequest) Count(count bool) ApiUsersInsightsListUsedRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiUsersInsightsListUsedRequest) Orderby(orderby []string) ApiUsersInsightsListUsedRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiUsersInsightsListUsedRequest) Select_(select_ []string) ApiUsersInsightsListUsedRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersInsightsListUsedRequest) Expand(expand []string) ApiUsersInsightsListUsedRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersInsightsListUsedRequest) Execute() (CollectionOfUsedInsight, *_nethttp.Response, error) {
	return r.ApiService.UsersInsightsListUsedExecute(r)
}

/*
UsersInsightsListUsed Get used from users

Calculated relationship identifying the latest documents viewed or modified by a user, including OneDrive for Business and SharePoint documents, ranked by recency of use.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @return ApiUsersInsightsListUsedRequest
*/
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsListUsed(ctx _context.Context, userId string) ApiUsersInsightsListUsedRequest {
	return ApiUsersInsightsListUsedRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return CollectionOfUsedInsight
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsListUsedExecute(r ApiUsersInsightsListUsedRequest) (CollectionOfUsedInsight, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfUsedInsight
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersOfficeGraphInsightsApiService.UsersInsightsListUsed")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/used"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersInsightsSharedDeleteRefLastSharedMethodRequest struct {
	ctx _context.Context
	ApiService *UsersOfficeGraphInsightsApiService
	userId string
	sharedInsightId string
	ifMatch *string
}

// ETag
func (r ApiUsersInsightsSharedDeleteRefLastSharedMethodRequest) IfMatch(ifMatch string) ApiUsersInsightsSharedDeleteRefLastSharedMethodRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersInsightsSharedDeleteRefLastSharedMethodRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersInsightsSharedDeleteRefLastSharedMethodExecute(r)
}

/*
UsersInsightsSharedDeleteRefLastSharedMethod Delete ref of navigation property lastSharedMethod for users

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersInsightsSharedDeleteRefLastSharedMethodRequest
*/
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsSharedDeleteRefLastSharedMethod(ctx _context.Context, userId string, sharedInsightId string) ApiUsersInsightsSharedDeleteRefLastSharedMethodRequest {
	return ApiUsersInsightsSharedDeleteRefLastSharedMethodRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsSharedDeleteRefLastSharedMethodExecute(r ApiUsersInsightsSharedDeleteRefLastSharedMethodRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersOfficeGraphInsightsApiService.UsersInsightsSharedDeleteRefLastSharedMethod")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/lastSharedMethod/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersInsightsSharedDeleteRefResourceRequest struct {
	ctx _context.Context
	ApiService *UsersOfficeGraphInsightsApiService
	userId string
	sharedInsightId string
	ifMatch *string
}

// ETag
func (r ApiUsersInsightsSharedDeleteRefResourceRequest) IfMatch(ifMatch string) ApiUsersInsightsSharedDeleteRefResourceRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersInsightsSharedDeleteRefResourceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersInsightsSharedDeleteRefResourceExecute(r)
}

/*
UsersInsightsSharedDeleteRefResource Delete ref of navigation property resource for users

Used for navigating to the item that was shared. For file attachments, the type is fileAttachment. For linked attachments, the type is driveItem.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersInsightsSharedDeleteRefResourceRequest
*/
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsSharedDeleteRefResource(ctx _context.Context, userId string, sharedInsightId string) ApiUsersInsightsSharedDeleteRefResourceRequest {
	return ApiUsersInsightsSharedDeleteRefResourceRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsSharedDeleteRefResourceExecute(r ApiUsersInsightsSharedDeleteRefResourceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersOfficeGraphInsightsApiService.UsersInsightsSharedDeleteRefResource")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/resource/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersInsightsSharedGetLastSharedMethodRequest struct {
	ctx _context.Context
	ApiService *UsersOfficeGraphInsightsApiService
	userId string
	sharedInsightId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiUsersInsightsSharedGetLastSharedMethodRequest) Select_(select_ []string) ApiUsersInsightsSharedGetLastSharedMethodRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersInsightsSharedGetLastSharedMethodRequest) Expand(expand []string) ApiUsersInsightsSharedGetLastSharedMethodRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersInsightsSharedGetLastSharedMethodRequest) Execute() (MicrosoftGraphEntity, *_nethttp.Response, error) {
	return r.ApiService.UsersInsightsSharedGetLastSharedMethodExecute(r)
}

/*
UsersInsightsSharedGetLastSharedMethod Get lastSharedMethod from users

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersInsightsSharedGetLastSharedMethodRequest
*/
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsSharedGetLastSharedMethod(ctx _context.Context, userId string, sharedInsightId string) ApiUsersInsightsSharedGetLastSharedMethodRequest {
	return ApiUsersInsightsSharedGetLastSharedMethodRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEntity
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsSharedGetLastSharedMethodExecute(r ApiUsersInsightsSharedGetLastSharedMethodRequest) (MicrosoftGraphEntity, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersOfficeGraphInsightsApiService.UsersInsightsSharedGetLastSharedMethod")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/lastSharedMethod"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersInsightsSharedGetRefLastSharedMethodRequest struct {
	ctx _context.Context
	ApiService *UsersOfficeGraphInsightsApiService
	userId string
	sharedInsightId string
}


func (r ApiUsersInsightsSharedGetRefLastSharedMethodRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.UsersInsightsSharedGetRefLastSharedMethodExecute(r)
}

/*
UsersInsightsSharedGetRefLastSharedMethod Get ref of lastSharedMethod from users

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersInsightsSharedGetRefLastSharedMethodRequest
*/
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsSharedGetRefLastSharedMethod(ctx _context.Context, userId string, sharedInsightId string) ApiUsersInsightsSharedGetRefLastSharedMethodRequest {
	return ApiUsersInsightsSharedGetRefLastSharedMethodRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
//  @return string
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsSharedGetRefLastSharedMethodExecute(r ApiUsersInsightsSharedGetRefLastSharedMethodRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersOfficeGraphInsightsApiService.UsersInsightsSharedGetRefLastSharedMethod")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/lastSharedMethod/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersInsightsSharedGetRefResourceRequest struct {
	ctx _context.Context
	ApiService *UsersOfficeGraphInsightsApiService
	userId string
	sharedInsightId string
}


func (r ApiUsersInsightsSharedGetRefResourceRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.UsersInsightsSharedGetRefResourceExecute(r)
}

/*
UsersInsightsSharedGetRefResource Get ref of resource from users

Used for navigating to the item that was shared. For file attachments, the type is fileAttachment. For linked attachments, the type is driveItem.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersInsightsSharedGetRefResourceRequest
*/
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsSharedGetRefResource(ctx _context.Context, userId string, sharedInsightId string) ApiUsersInsightsSharedGetRefResourceRequest {
	return ApiUsersInsightsSharedGetRefResourceRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
//  @return string
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsSharedGetRefResourceExecute(r ApiUsersInsightsSharedGetRefResourceRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersOfficeGraphInsightsApiService.UsersInsightsSharedGetRefResource")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/resource/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersInsightsSharedGetResourceRequest struct {
	ctx _context.Context
	ApiService *UsersOfficeGraphInsightsApiService
	userId string
	sharedInsightId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiUsersInsightsSharedGetResourceRequest) Select_(select_ []string) ApiUsersInsightsSharedGetResourceRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersInsightsSharedGetResourceRequest) Expand(expand []string) ApiUsersInsightsSharedGetResourceRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersInsightsSharedGetResourceRequest) Execute() (MicrosoftGraphEntity, *_nethttp.Response, error) {
	return r.ApiService.UsersInsightsSharedGetResourceExecute(r)
}

/*
UsersInsightsSharedGetResource Get resource from users

Used for navigating to the item that was shared. For file attachments, the type is fileAttachment. For linked attachments, the type is driveItem.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersInsightsSharedGetResourceRequest
*/
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsSharedGetResource(ctx _context.Context, userId string, sharedInsightId string) ApiUsersInsightsSharedGetResourceRequest {
	return ApiUsersInsightsSharedGetResourceRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEntity
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsSharedGetResourceExecute(r ApiUsersInsightsSharedGetResourceRequest) (MicrosoftGraphEntity, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersOfficeGraphInsightsApiService.UsersInsightsSharedGetResource")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/resource"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersInsightsSharedUpdateRefLastSharedMethodRequest struct {
	ctx _context.Context
	ApiService *UsersOfficeGraphInsightsApiService
	userId string
	sharedInsightId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiUsersInsightsSharedUpdateRefLastSharedMethodRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiUsersInsightsSharedUpdateRefLastSharedMethodRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiUsersInsightsSharedUpdateRefLastSharedMethodRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersInsightsSharedUpdateRefLastSharedMethodExecute(r)
}

/*
UsersInsightsSharedUpdateRefLastSharedMethod Update the ref of navigation property lastSharedMethod in users

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersInsightsSharedUpdateRefLastSharedMethodRequest
*/
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsSharedUpdateRefLastSharedMethod(ctx _context.Context, userId string, sharedInsightId string) ApiUsersInsightsSharedUpdateRefLastSharedMethodRequest {
	return ApiUsersInsightsSharedUpdateRefLastSharedMethodRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsSharedUpdateRefLastSharedMethodExecute(r ApiUsersInsightsSharedUpdateRefLastSharedMethodRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersOfficeGraphInsightsApiService.UsersInsightsSharedUpdateRefLastSharedMethod")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/lastSharedMethod/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersInsightsSharedUpdateRefResourceRequest struct {
	ctx _context.Context
	ApiService *UsersOfficeGraphInsightsApiService
	userId string
	sharedInsightId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiUsersInsightsSharedUpdateRefResourceRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiUsersInsightsSharedUpdateRefResourceRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiUsersInsightsSharedUpdateRefResourceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersInsightsSharedUpdateRefResourceExecute(r)
}

/*
UsersInsightsSharedUpdateRefResource Update the ref of navigation property resource in users

Used for navigating to the item that was shared. For file attachments, the type is fileAttachment. For linked attachments, the type is driveItem.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersInsightsSharedUpdateRefResourceRequest
*/
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsSharedUpdateRefResource(ctx _context.Context, userId string, sharedInsightId string) ApiUsersInsightsSharedUpdateRefResourceRequest {
	return ApiUsersInsightsSharedUpdateRefResourceRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsSharedUpdateRefResourceExecute(r ApiUsersInsightsSharedUpdateRefResourceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersOfficeGraphInsightsApiService.UsersInsightsSharedUpdateRefResource")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}/resource/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersInsightsTrendingDeleteRefResourceRequest struct {
	ctx _context.Context
	ApiService *UsersOfficeGraphInsightsApiService
	userId string
	trendingId string
	ifMatch *string
}

// ETag
func (r ApiUsersInsightsTrendingDeleteRefResourceRequest) IfMatch(ifMatch string) ApiUsersInsightsTrendingDeleteRefResourceRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersInsightsTrendingDeleteRefResourceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersInsightsTrendingDeleteRefResourceExecute(r)
}

/*
UsersInsightsTrendingDeleteRefResource Delete ref of navigation property resource for users

Used for navigating to the trending document.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param trendingId key: id of trending
 @return ApiUsersInsightsTrendingDeleteRefResourceRequest
*/
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsTrendingDeleteRefResource(ctx _context.Context, userId string, trendingId string) ApiUsersInsightsTrendingDeleteRefResourceRequest {
	return ApiUsersInsightsTrendingDeleteRefResourceRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		trendingId: trendingId,
	}
}

// Execute executes the request
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsTrendingDeleteRefResourceExecute(r ApiUsersInsightsTrendingDeleteRefResourceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersOfficeGraphInsightsApiService.UsersInsightsTrendingDeleteRefResource")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/trending/{trending-id}/resource/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersInsightsTrendingGetRefResourceRequest struct {
	ctx _context.Context
	ApiService *UsersOfficeGraphInsightsApiService
	userId string
	trendingId string
}


func (r ApiUsersInsightsTrendingGetRefResourceRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.UsersInsightsTrendingGetRefResourceExecute(r)
}

/*
UsersInsightsTrendingGetRefResource Get ref of resource from users

Used for navigating to the trending document.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param trendingId key: id of trending
 @return ApiUsersInsightsTrendingGetRefResourceRequest
*/
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsTrendingGetRefResource(ctx _context.Context, userId string, trendingId string) ApiUsersInsightsTrendingGetRefResourceRequest {
	return ApiUsersInsightsTrendingGetRefResourceRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		trendingId: trendingId,
	}
}

// Execute executes the request
//  @return string
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsTrendingGetRefResourceExecute(r ApiUsersInsightsTrendingGetRefResourceRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersOfficeGraphInsightsApiService.UsersInsightsTrendingGetRefResource")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/trending/{trending-id}/resource/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersInsightsTrendingGetResourceRequest struct {
	ctx _context.Context
	ApiService *UsersOfficeGraphInsightsApiService
	userId string
	trendingId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiUsersInsightsTrendingGetResourceRequest) Select_(select_ []string) ApiUsersInsightsTrendingGetResourceRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersInsightsTrendingGetResourceRequest) Expand(expand []string) ApiUsersInsightsTrendingGetResourceRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersInsightsTrendingGetResourceRequest) Execute() (MicrosoftGraphEntity, *_nethttp.Response, error) {
	return r.ApiService.UsersInsightsTrendingGetResourceExecute(r)
}

/*
UsersInsightsTrendingGetResource Get resource from users

Used for navigating to the trending document.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param trendingId key: id of trending
 @return ApiUsersInsightsTrendingGetResourceRequest
*/
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsTrendingGetResource(ctx _context.Context, userId string, trendingId string) ApiUsersInsightsTrendingGetResourceRequest {
	return ApiUsersInsightsTrendingGetResourceRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		trendingId: trendingId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEntity
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsTrendingGetResourceExecute(r ApiUsersInsightsTrendingGetResourceRequest) (MicrosoftGraphEntity, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersOfficeGraphInsightsApiService.UsersInsightsTrendingGetResource")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/trending/{trending-id}/resource"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersInsightsTrendingUpdateRefResourceRequest struct {
	ctx _context.Context
	ApiService *UsersOfficeGraphInsightsApiService
	userId string
	trendingId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiUsersInsightsTrendingUpdateRefResourceRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiUsersInsightsTrendingUpdateRefResourceRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiUsersInsightsTrendingUpdateRefResourceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersInsightsTrendingUpdateRefResourceExecute(r)
}

/*
UsersInsightsTrendingUpdateRefResource Update the ref of navigation property resource in users

Used for navigating to the trending document.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param trendingId key: id of trending
 @return ApiUsersInsightsTrendingUpdateRefResourceRequest
*/
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsTrendingUpdateRefResource(ctx _context.Context, userId string, trendingId string) ApiUsersInsightsTrendingUpdateRefResourceRequest {
	return ApiUsersInsightsTrendingUpdateRefResourceRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		trendingId: trendingId,
	}
}

// Execute executes the request
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsTrendingUpdateRefResourceExecute(r ApiUsersInsightsTrendingUpdateRefResourceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersOfficeGraphInsightsApiService.UsersInsightsTrendingUpdateRefResource")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/trending/{trending-id}/resource/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersInsightsUpdateSharedRequest struct {
	ctx _context.Context
	ApiService *UsersOfficeGraphInsightsApiService
	userId string
	sharedInsightId string
	microsoftGraphSharedInsight *MicrosoftGraphSharedInsight
}

// New navigation property values
func (r ApiUsersInsightsUpdateSharedRequest) MicrosoftGraphSharedInsight(microsoftGraphSharedInsight MicrosoftGraphSharedInsight) ApiUsersInsightsUpdateSharedRequest {
	r.microsoftGraphSharedInsight = &microsoftGraphSharedInsight
	return r
}

func (r ApiUsersInsightsUpdateSharedRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersInsightsUpdateSharedExecute(r)
}

/*
UsersInsightsUpdateShared Update the navigation property shared in users

Calculated relationship identifying documents shared with or by the user. This includes URLs, file attachments, and reference attachments to OneDrive for Business and SharePoint files found in Outlook messages and meetings. This also includes URLs and reference attachments to Teams conversations. Ordered by recency of share.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param sharedInsightId key: id of sharedInsight
 @return ApiUsersInsightsUpdateSharedRequest
*/
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsUpdateShared(ctx _context.Context, userId string, sharedInsightId string) ApiUsersInsightsUpdateSharedRequest {
	return ApiUsersInsightsUpdateSharedRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsUpdateSharedExecute(r ApiUsersInsightsUpdateSharedRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersOfficeGraphInsightsApiService.UsersInsightsUpdateShared")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/shared/{sharedInsight-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphSharedInsight == nil {
		return nil, reportError("microsoftGraphSharedInsight is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphSharedInsight
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersInsightsUpdateTrendingRequest struct {
	ctx _context.Context
	ApiService *UsersOfficeGraphInsightsApiService
	userId string
	trendingId string
	microsoftGraphTrending *MicrosoftGraphTrending
}

// New navigation property values
func (r ApiUsersInsightsUpdateTrendingRequest) MicrosoftGraphTrending(microsoftGraphTrending MicrosoftGraphTrending) ApiUsersInsightsUpdateTrendingRequest {
	r.microsoftGraphTrending = &microsoftGraphTrending
	return r
}

func (r ApiUsersInsightsUpdateTrendingRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersInsightsUpdateTrendingExecute(r)
}

/*
UsersInsightsUpdateTrending Update the navigation property trending in users

Calculated relationship identifying documents trending around a user. Trending documents are calculated based on activity of the user's closest network of people and include files stored in OneDrive for Business and SharePoint. Trending insights help the user to discover potentially useful content that the user has access to, but has never viewed before.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param trendingId key: id of trending
 @return ApiUsersInsightsUpdateTrendingRequest
*/
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsUpdateTrending(ctx _context.Context, userId string, trendingId string) ApiUsersInsightsUpdateTrendingRequest {
	return ApiUsersInsightsUpdateTrendingRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		trendingId: trendingId,
	}
}

// Execute executes the request
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsUpdateTrendingExecute(r ApiUsersInsightsUpdateTrendingRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersOfficeGraphInsightsApiService.UsersInsightsUpdateTrending")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/trending/{trending-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTrending == nil {
		return nil, reportError("microsoftGraphTrending is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTrending
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersInsightsUpdateUsedRequest struct {
	ctx _context.Context
	ApiService *UsersOfficeGraphInsightsApiService
	userId string
	usedInsightId string
	microsoftGraphUsedInsight *MicrosoftGraphUsedInsight
}

// New navigation property values
func (r ApiUsersInsightsUpdateUsedRequest) MicrosoftGraphUsedInsight(microsoftGraphUsedInsight MicrosoftGraphUsedInsight) ApiUsersInsightsUpdateUsedRequest {
	r.microsoftGraphUsedInsight = &microsoftGraphUsedInsight
	return r
}

func (r ApiUsersInsightsUpdateUsedRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersInsightsUpdateUsedExecute(r)
}

/*
UsersInsightsUpdateUsed Update the navigation property used in users

Calculated relationship identifying the latest documents viewed or modified by a user, including OneDrive for Business and SharePoint documents, ranked by recency of use.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param usedInsightId key: id of usedInsight
 @return ApiUsersInsightsUpdateUsedRequest
*/
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsUpdateUsed(ctx _context.Context, userId string, usedInsightId string) ApiUsersInsightsUpdateUsedRequest {
	return ApiUsersInsightsUpdateUsedRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsUpdateUsedExecute(r ApiUsersInsightsUpdateUsedRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersOfficeGraphInsightsApiService.UsersInsightsUpdateUsed")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/used/{usedInsight-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphUsedInsight == nil {
		return nil, reportError("microsoftGraphUsedInsight is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphUsedInsight
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersInsightsUsedDeleteRefResourceRequest struct {
	ctx _context.Context
	ApiService *UsersOfficeGraphInsightsApiService
	userId string
	usedInsightId string
	ifMatch *string
}

// ETag
func (r ApiUsersInsightsUsedDeleteRefResourceRequest) IfMatch(ifMatch string) ApiUsersInsightsUsedDeleteRefResourceRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersInsightsUsedDeleteRefResourceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersInsightsUsedDeleteRefResourceExecute(r)
}

/*
UsersInsightsUsedDeleteRefResource Delete ref of navigation property resource for users

Used for navigating to the item that was used. For file attachments, the type is fileAttachment. For linked attachments, the type is driveItem.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param usedInsightId key: id of usedInsight
 @return ApiUsersInsightsUsedDeleteRefResourceRequest
*/
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsUsedDeleteRefResource(ctx _context.Context, userId string, usedInsightId string) ApiUsersInsightsUsedDeleteRefResourceRequest {
	return ApiUsersInsightsUsedDeleteRefResourceRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsUsedDeleteRefResourceExecute(r ApiUsersInsightsUsedDeleteRefResourceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersOfficeGraphInsightsApiService.UsersInsightsUsedDeleteRefResource")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/used/{usedInsight-id}/resource/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersInsightsUsedGetRefResourceRequest struct {
	ctx _context.Context
	ApiService *UsersOfficeGraphInsightsApiService
	userId string
	usedInsightId string
}


func (r ApiUsersInsightsUsedGetRefResourceRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.UsersInsightsUsedGetRefResourceExecute(r)
}

/*
UsersInsightsUsedGetRefResource Get ref of resource from users

Used for navigating to the item that was used. For file attachments, the type is fileAttachment. For linked attachments, the type is driveItem.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param usedInsightId key: id of usedInsight
 @return ApiUsersInsightsUsedGetRefResourceRequest
*/
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsUsedGetRefResource(ctx _context.Context, userId string, usedInsightId string) ApiUsersInsightsUsedGetRefResourceRequest {
	return ApiUsersInsightsUsedGetRefResourceRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
//  @return string
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsUsedGetRefResourceExecute(r ApiUsersInsightsUsedGetRefResourceRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersOfficeGraphInsightsApiService.UsersInsightsUsedGetRefResource")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/used/{usedInsight-id}/resource/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersInsightsUsedGetResourceRequest struct {
	ctx _context.Context
	ApiService *UsersOfficeGraphInsightsApiService
	userId string
	usedInsightId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiUsersInsightsUsedGetResourceRequest) Select_(select_ []string) ApiUsersInsightsUsedGetResourceRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersInsightsUsedGetResourceRequest) Expand(expand []string) ApiUsersInsightsUsedGetResourceRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersInsightsUsedGetResourceRequest) Execute() (MicrosoftGraphEntity, *_nethttp.Response, error) {
	return r.ApiService.UsersInsightsUsedGetResourceExecute(r)
}

/*
UsersInsightsUsedGetResource Get resource from users

Used for navigating to the item that was used. For file attachments, the type is fileAttachment. For linked attachments, the type is driveItem.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param usedInsightId key: id of usedInsight
 @return ApiUsersInsightsUsedGetResourceRequest
*/
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsUsedGetResource(ctx _context.Context, userId string, usedInsightId string) ApiUsersInsightsUsedGetResourceRequest {
	return ApiUsersInsightsUsedGetResourceRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEntity
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsUsedGetResourceExecute(r ApiUsersInsightsUsedGetResourceRequest) (MicrosoftGraphEntity, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersOfficeGraphInsightsApiService.UsersInsightsUsedGetResource")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/used/{usedInsight-id}/resource"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersInsightsUsedUpdateRefResourceRequest struct {
	ctx _context.Context
	ApiService *UsersOfficeGraphInsightsApiService
	userId string
	usedInsightId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiUsersInsightsUsedUpdateRefResourceRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiUsersInsightsUsedUpdateRefResourceRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiUsersInsightsUsedUpdateRefResourceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersInsightsUsedUpdateRefResourceExecute(r)
}

/*
UsersInsightsUsedUpdateRefResource Update the ref of navigation property resource in users

Used for navigating to the item that was used. For file attachments, the type is fileAttachment. For linked attachments, the type is driveItem.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param usedInsightId key: id of usedInsight
 @return ApiUsersInsightsUsedUpdateRefResourceRequest
*/
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsUsedUpdateRefResource(ctx _context.Context, userId string, usedInsightId string) ApiUsersInsightsUsedUpdateRefResourceRequest {
	return ApiUsersInsightsUsedUpdateRefResourceRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
func (a *UsersOfficeGraphInsightsApiService) UsersInsightsUsedUpdateRefResourceExecute(r ApiUsersInsightsUsedUpdateRefResourceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersOfficeGraphInsightsApiService.UsersInsightsUsedUpdateRefResource")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights/used/{usedInsight-id}/resource/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUpdateInsightsRequest struct {
	ctx _context.Context
	ApiService *UsersOfficeGraphInsightsApiService
	userId string
	microsoftGraphOfficeGraphInsights *MicrosoftGraphOfficeGraphInsights
}

// New navigation property values
func (r ApiUsersUpdateInsightsRequest) MicrosoftGraphOfficeGraphInsights(microsoftGraphOfficeGraphInsights MicrosoftGraphOfficeGraphInsights) ApiUsersUpdateInsightsRequest {
	r.microsoftGraphOfficeGraphInsights = &microsoftGraphOfficeGraphInsights
	return r
}

func (r ApiUsersUpdateInsightsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUpdateInsightsExecute(r)
}

/*
UsersUpdateInsights Update the navigation property insights in users

Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @return ApiUsersUpdateInsightsRequest
*/
func (a *UsersOfficeGraphInsightsApiService) UsersUpdateInsights(ctx _context.Context, userId string) ApiUsersUpdateInsightsRequest {
	return ApiUsersUpdateInsightsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
func (a *UsersOfficeGraphInsightsApiService) UsersUpdateInsightsExecute(r ApiUsersUpdateInsightsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersOfficeGraphInsightsApiService.UsersUpdateInsights")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/insights"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphOfficeGraphInsights == nil {
		return nil, reportError("microsoftGraphOfficeGraphInsights is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphOfficeGraphInsights
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
