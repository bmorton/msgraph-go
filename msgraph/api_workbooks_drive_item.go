/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"os"
)

// Linger please
var (
	_ _context.Context
)

// WorkbooksDriveItemApiService WorkbooksDriveItemApi service
type WorkbooksDriveItemApiService service

type ApiWorkbooksCreateChildrenRequest struct {
	ctx _context.Context
	ApiService *WorkbooksDriveItemApiService
	driveItemId string
	microsoftGraphDriveItem *MicrosoftGraphDriveItem
}

// New navigation property
func (r ApiWorkbooksCreateChildrenRequest) MicrosoftGraphDriveItem(microsoftGraphDriveItem MicrosoftGraphDriveItem) ApiWorkbooksCreateChildrenRequest {
	r.microsoftGraphDriveItem = &microsoftGraphDriveItem
	return r
}

func (r ApiWorkbooksCreateChildrenRequest) Execute() (MicrosoftGraphDriveItem, *_nethttp.Response, error) {
	return r.ApiService.WorkbooksCreateChildrenExecute(r)
}

/*
WorkbooksCreateChildren Create new navigation property to children for workbooks

Collection containing Item objects for the immediate children of Item. Only items representing folders have children. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveItemId key: id of driveItem
 @return ApiWorkbooksCreateChildrenRequest
*/
func (a *WorkbooksDriveItemApiService) WorkbooksCreateChildren(ctx _context.Context, driveItemId string) ApiWorkbooksCreateChildrenRequest {
	return ApiWorkbooksCreateChildrenRequest{
		ApiService: a,
		ctx: ctx,
		driveItemId: driveItemId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphDriveItem
func (a *WorkbooksDriveItemApiService) WorkbooksCreateChildrenExecute(r ApiWorkbooksCreateChildrenRequest) (MicrosoftGraphDriveItem, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphDriveItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkbooksDriveItemApiService.WorkbooksCreateChildren")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workbooks/{driveItem-id}/children"
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphDriveItem == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphDriveItem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphDriveItem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWorkbooksDeleteChildrenRequest struct {
	ctx _context.Context
	ApiService *WorkbooksDriveItemApiService
	driveItemId string
	driveItemId1 string
	ifMatch *string
}

// ETag
func (r ApiWorkbooksDeleteChildrenRequest) IfMatch(ifMatch string) ApiWorkbooksDeleteChildrenRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiWorkbooksDeleteChildrenRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkbooksDeleteChildrenExecute(r)
}

/*
WorkbooksDeleteChildren Delete navigation property children for workbooks

Collection containing Item objects for the immediate children of Item. Only items representing folders have children. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveItemId key: id of driveItem
 @param driveItemId1 key: id of driveItem
 @return ApiWorkbooksDeleteChildrenRequest
*/
func (a *WorkbooksDriveItemApiService) WorkbooksDeleteChildren(ctx _context.Context, driveItemId string, driveItemId1 string) ApiWorkbooksDeleteChildrenRequest {
	return ApiWorkbooksDeleteChildrenRequest{
		ApiService: a,
		ctx: ctx,
		driveItemId: driveItemId,
		driveItemId1: driveItemId1,
	}
}

// Execute executes the request
func (a *WorkbooksDriveItemApiService) WorkbooksDeleteChildrenExecute(r ApiWorkbooksDeleteChildrenRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkbooksDriveItemApiService.WorkbooksDeleteChildren")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workbooks/{driveItem-id}/children/{driveItem-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id1"+"}", _neturl.PathEscape(parameterToString(r.driveItemId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkbooksDriveItemCreateDriveItemRequest struct {
	ctx _context.Context
	ApiService *WorkbooksDriveItemApiService
	microsoftGraphDriveItem *MicrosoftGraphDriveItem
}

// New entity
func (r ApiWorkbooksDriveItemCreateDriveItemRequest) MicrosoftGraphDriveItem(microsoftGraphDriveItem MicrosoftGraphDriveItem) ApiWorkbooksDriveItemCreateDriveItemRequest {
	r.microsoftGraphDriveItem = &microsoftGraphDriveItem
	return r
}

func (r ApiWorkbooksDriveItemCreateDriveItemRequest) Execute() (MicrosoftGraphDriveItem, *_nethttp.Response, error) {
	return r.ApiService.WorkbooksDriveItemCreateDriveItemExecute(r)
}

/*
WorkbooksDriveItemCreateDriveItem Add new entity to workbooks

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWorkbooksDriveItemCreateDriveItemRequest
*/
func (a *WorkbooksDriveItemApiService) WorkbooksDriveItemCreateDriveItem(ctx _context.Context) ApiWorkbooksDriveItemCreateDriveItemRequest {
	return ApiWorkbooksDriveItemCreateDriveItemRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphDriveItem
func (a *WorkbooksDriveItemApiService) WorkbooksDriveItemCreateDriveItemExecute(r ApiWorkbooksDriveItemCreateDriveItemRequest) (MicrosoftGraphDriveItem, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphDriveItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkbooksDriveItemApiService.WorkbooksDriveItemCreateDriveItem")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workbooks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphDriveItem == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphDriveItem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphDriveItem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWorkbooksDriveItemDeleteDriveItemRequest struct {
	ctx _context.Context
	ApiService *WorkbooksDriveItemApiService
	driveItemId string
	ifMatch *string
}

// ETag
func (r ApiWorkbooksDriveItemDeleteDriveItemRequest) IfMatch(ifMatch string) ApiWorkbooksDriveItemDeleteDriveItemRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiWorkbooksDriveItemDeleteDriveItemRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkbooksDriveItemDeleteDriveItemExecute(r)
}

/*
WorkbooksDriveItemDeleteDriveItem Delete entity from workbooks

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveItemId key: id of driveItem
 @return ApiWorkbooksDriveItemDeleteDriveItemRequest
*/
func (a *WorkbooksDriveItemApiService) WorkbooksDriveItemDeleteDriveItem(ctx _context.Context, driveItemId string) ApiWorkbooksDriveItemDeleteDriveItemRequest {
	return ApiWorkbooksDriveItemDeleteDriveItemRequest{
		ApiService: a,
		ctx: ctx,
		driveItemId: driveItemId,
	}
}

// Execute executes the request
func (a *WorkbooksDriveItemApiService) WorkbooksDriveItemDeleteDriveItemExecute(r ApiWorkbooksDriveItemDeleteDriveItemRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkbooksDriveItemApiService.WorkbooksDriveItemDeleteDriveItem")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workbooks/{driveItem-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkbooksDriveItemGetContentRequest struct {
	ctx _context.Context
	ApiService *WorkbooksDriveItemApiService
	driveItemId string
}


func (r ApiWorkbooksDriveItemGetContentRequest) Execute() (*os.File, *_nethttp.Response, error) {
	return r.ApiService.WorkbooksDriveItemGetContentExecute(r)
}

/*
WorkbooksDriveItemGetContent Get media content for driveItem from workbooks

The content stream, if the item represents a file.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveItemId key: id of driveItem
 @return ApiWorkbooksDriveItemGetContentRequest
*/
func (a *WorkbooksDriveItemApiService) WorkbooksDriveItemGetContent(ctx _context.Context, driveItemId string) ApiWorkbooksDriveItemGetContentRequest {
	return ApiWorkbooksDriveItemGetContentRequest{
		ApiService: a,
		ctx: ctx,
		driveItemId: driveItemId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *WorkbooksDriveItemApiService) WorkbooksDriveItemGetContentExecute(r ApiWorkbooksDriveItemGetContentRequest) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkbooksDriveItemApiService.WorkbooksDriveItemGetContent")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workbooks/{driveItem-id}/content"
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWorkbooksDriveItemGetDriveItemRequest struct {
	ctx _context.Context
	ApiService *WorkbooksDriveItemApiService
	driveItemId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiWorkbooksDriveItemGetDriveItemRequest) Select_(select_ []string) ApiWorkbooksDriveItemGetDriveItemRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiWorkbooksDriveItemGetDriveItemRequest) Expand(expand []string) ApiWorkbooksDriveItemGetDriveItemRequest {
	r.expand = &expand
	return r
}

func (r ApiWorkbooksDriveItemGetDriveItemRequest) Execute() (MicrosoftGraphDriveItem, *_nethttp.Response, error) {
	return r.ApiService.WorkbooksDriveItemGetDriveItemExecute(r)
}

/*
WorkbooksDriveItemGetDriveItem Get entity from workbooks by key

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveItemId key: id of driveItem
 @return ApiWorkbooksDriveItemGetDriveItemRequest
*/
func (a *WorkbooksDriveItemApiService) WorkbooksDriveItemGetDriveItem(ctx _context.Context, driveItemId string) ApiWorkbooksDriveItemGetDriveItemRequest {
	return ApiWorkbooksDriveItemGetDriveItemRequest{
		ApiService: a,
		ctx: ctx,
		driveItemId: driveItemId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphDriveItem
func (a *WorkbooksDriveItemApiService) WorkbooksDriveItemGetDriveItemExecute(r ApiWorkbooksDriveItemGetDriveItemRequest) (MicrosoftGraphDriveItem, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphDriveItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkbooksDriveItemApiService.WorkbooksDriveItemGetDriveItem")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workbooks/{driveItem-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWorkbooksDriveItemListDriveItemRequest struct {
	ctx _context.Context
	ApiService *WorkbooksDriveItemApiService
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiWorkbooksDriveItemListDriveItemRequest) Top(top int32) ApiWorkbooksDriveItemListDriveItemRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiWorkbooksDriveItemListDriveItemRequest) Skip(skip int32) ApiWorkbooksDriveItemListDriveItemRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiWorkbooksDriveItemListDriveItemRequest) Search(search string) ApiWorkbooksDriveItemListDriveItemRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiWorkbooksDriveItemListDriveItemRequest) Filter(filter string) ApiWorkbooksDriveItemListDriveItemRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiWorkbooksDriveItemListDriveItemRequest) Count(count bool) ApiWorkbooksDriveItemListDriveItemRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiWorkbooksDriveItemListDriveItemRequest) Orderby(orderby []string) ApiWorkbooksDriveItemListDriveItemRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiWorkbooksDriveItemListDriveItemRequest) Select_(select_ []string) ApiWorkbooksDriveItemListDriveItemRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiWorkbooksDriveItemListDriveItemRequest) Expand(expand []string) ApiWorkbooksDriveItemListDriveItemRequest {
	r.expand = &expand
	return r
}

func (r ApiWorkbooksDriveItemListDriveItemRequest) Execute() (CollectionOfDriveItem, *_nethttp.Response, error) {
	return r.ApiService.WorkbooksDriveItemListDriveItemExecute(r)
}

/*
WorkbooksDriveItemListDriveItem Get entities from workbooks

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWorkbooksDriveItemListDriveItemRequest
*/
func (a *WorkbooksDriveItemApiService) WorkbooksDriveItemListDriveItem(ctx _context.Context) ApiWorkbooksDriveItemListDriveItemRequest {
	return ApiWorkbooksDriveItemListDriveItemRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionOfDriveItem
func (a *WorkbooksDriveItemApiService) WorkbooksDriveItemListDriveItemExecute(r ApiWorkbooksDriveItemListDriveItemRequest) (CollectionOfDriveItem, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfDriveItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkbooksDriveItemApiService.WorkbooksDriveItemListDriveItem")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workbooks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWorkbooksDriveItemUpdateContentRequest struct {
	ctx _context.Context
	ApiService *WorkbooksDriveItemApiService
	driveItemId string
	body **os.File
}

// New media content.
func (r ApiWorkbooksDriveItemUpdateContentRequest) Body(body *os.File) ApiWorkbooksDriveItemUpdateContentRequest {
	r.body = &body
	return r
}

func (r ApiWorkbooksDriveItemUpdateContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkbooksDriveItemUpdateContentExecute(r)
}

/*
WorkbooksDriveItemUpdateContent Update media content for driveItem in workbooks

The content stream, if the item represents a file.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveItemId key: id of driveItem
 @return ApiWorkbooksDriveItemUpdateContentRequest
*/
func (a *WorkbooksDriveItemApiService) WorkbooksDriveItemUpdateContent(ctx _context.Context, driveItemId string) ApiWorkbooksDriveItemUpdateContentRequest {
	return ApiWorkbooksDriveItemUpdateContentRequest{
		ApiService: a,
		ctx: ctx,
		driveItemId: driveItemId,
	}
}

// Execute executes the request
func (a *WorkbooksDriveItemApiService) WorkbooksDriveItemUpdateContentExecute(r ApiWorkbooksDriveItemUpdateContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkbooksDriveItemApiService.WorkbooksDriveItemUpdateContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workbooks/{driveItem-id}/content"
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkbooksDriveItemUpdateDriveItemRequest struct {
	ctx _context.Context
	ApiService *WorkbooksDriveItemApiService
	driveItemId string
	microsoftGraphDriveItem *MicrosoftGraphDriveItem
}

// New property values
func (r ApiWorkbooksDriveItemUpdateDriveItemRequest) MicrosoftGraphDriveItem(microsoftGraphDriveItem MicrosoftGraphDriveItem) ApiWorkbooksDriveItemUpdateDriveItemRequest {
	r.microsoftGraphDriveItem = &microsoftGraphDriveItem
	return r
}

func (r ApiWorkbooksDriveItemUpdateDriveItemRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkbooksDriveItemUpdateDriveItemExecute(r)
}

/*
WorkbooksDriveItemUpdateDriveItem Update entity in workbooks

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveItemId key: id of driveItem
 @return ApiWorkbooksDriveItemUpdateDriveItemRequest
*/
func (a *WorkbooksDriveItemApiService) WorkbooksDriveItemUpdateDriveItem(ctx _context.Context, driveItemId string) ApiWorkbooksDriveItemUpdateDriveItemRequest {
	return ApiWorkbooksDriveItemUpdateDriveItemRequest{
		ApiService: a,
		ctx: ctx,
		driveItemId: driveItemId,
	}
}

// Execute executes the request
func (a *WorkbooksDriveItemApiService) WorkbooksDriveItemUpdateDriveItemExecute(r ApiWorkbooksDriveItemUpdateDriveItemRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkbooksDriveItemApiService.WorkbooksDriveItemUpdateDriveItem")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workbooks/{driveItem-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphDriveItem == nil {
		return nil, reportError("microsoftGraphDriveItem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphDriveItem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkbooksGetChildrenRequest struct {
	ctx _context.Context
	ApiService *WorkbooksDriveItemApiService
	driveItemId string
	driveItemId1 string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiWorkbooksGetChildrenRequest) Select_(select_ []string) ApiWorkbooksGetChildrenRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiWorkbooksGetChildrenRequest) Expand(expand []string) ApiWorkbooksGetChildrenRequest {
	r.expand = &expand
	return r
}

func (r ApiWorkbooksGetChildrenRequest) Execute() (MicrosoftGraphDriveItem, *_nethttp.Response, error) {
	return r.ApiService.WorkbooksGetChildrenExecute(r)
}

/*
WorkbooksGetChildren Get children from workbooks

Collection containing Item objects for the immediate children of Item. Only items representing folders have children. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveItemId key: id of driveItem
 @param driveItemId1 key: id of driveItem
 @return ApiWorkbooksGetChildrenRequest
*/
func (a *WorkbooksDriveItemApiService) WorkbooksGetChildren(ctx _context.Context, driveItemId string, driveItemId1 string) ApiWorkbooksGetChildrenRequest {
	return ApiWorkbooksGetChildrenRequest{
		ApiService: a,
		ctx: ctx,
		driveItemId: driveItemId,
		driveItemId1: driveItemId1,
	}
}

// Execute executes the request
//  @return MicrosoftGraphDriveItem
func (a *WorkbooksDriveItemApiService) WorkbooksGetChildrenExecute(r ApiWorkbooksGetChildrenRequest) (MicrosoftGraphDriveItem, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphDriveItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkbooksDriveItemApiService.WorkbooksGetChildren")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workbooks/{driveItem-id}/children/{driveItem-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id1"+"}", _neturl.PathEscape(parameterToString(r.driveItemId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWorkbooksGetChildrenContentRequest struct {
	ctx _context.Context
	ApiService *WorkbooksDriveItemApiService
	driveItemId string
	driveItemId1 string
}


func (r ApiWorkbooksGetChildrenContentRequest) Execute() (*os.File, *_nethttp.Response, error) {
	return r.ApiService.WorkbooksGetChildrenContentExecute(r)
}

/*
WorkbooksGetChildrenContent Get media content for the navigation property children from workbooks

The content stream, if the item represents a file.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveItemId key: id of driveItem
 @param driveItemId1 key: id of driveItem
 @return ApiWorkbooksGetChildrenContentRequest
*/
func (a *WorkbooksDriveItemApiService) WorkbooksGetChildrenContent(ctx _context.Context, driveItemId string, driveItemId1 string) ApiWorkbooksGetChildrenContentRequest {
	return ApiWorkbooksGetChildrenContentRequest{
		ApiService: a,
		ctx: ctx,
		driveItemId: driveItemId,
		driveItemId1: driveItemId1,
	}
}

// Execute executes the request
//  @return *os.File
func (a *WorkbooksDriveItemApiService) WorkbooksGetChildrenContentExecute(r ApiWorkbooksGetChildrenContentRequest) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkbooksDriveItemApiService.WorkbooksGetChildrenContent")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workbooks/{driveItem-id}/children/{driveItem-id1}/content"
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id1"+"}", _neturl.PathEscape(parameterToString(r.driveItemId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWorkbooksListChildrenRequest struct {
	ctx _context.Context
	ApiService *WorkbooksDriveItemApiService
	driveItemId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiWorkbooksListChildrenRequest) Top(top int32) ApiWorkbooksListChildrenRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiWorkbooksListChildrenRequest) Skip(skip int32) ApiWorkbooksListChildrenRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiWorkbooksListChildrenRequest) Search(search string) ApiWorkbooksListChildrenRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiWorkbooksListChildrenRequest) Filter(filter string) ApiWorkbooksListChildrenRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiWorkbooksListChildrenRequest) Count(count bool) ApiWorkbooksListChildrenRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiWorkbooksListChildrenRequest) Orderby(orderby []string) ApiWorkbooksListChildrenRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiWorkbooksListChildrenRequest) Select_(select_ []string) ApiWorkbooksListChildrenRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiWorkbooksListChildrenRequest) Expand(expand []string) ApiWorkbooksListChildrenRequest {
	r.expand = &expand
	return r
}

func (r ApiWorkbooksListChildrenRequest) Execute() (CollectionOfDriveItem, *_nethttp.Response, error) {
	return r.ApiService.WorkbooksListChildrenExecute(r)
}

/*
WorkbooksListChildren Get children from workbooks

Collection containing Item objects for the immediate children of Item. Only items representing folders have children. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveItemId key: id of driveItem
 @return ApiWorkbooksListChildrenRequest
*/
func (a *WorkbooksDriveItemApiService) WorkbooksListChildren(ctx _context.Context, driveItemId string) ApiWorkbooksListChildrenRequest {
	return ApiWorkbooksListChildrenRequest{
		ApiService: a,
		ctx: ctx,
		driveItemId: driveItemId,
	}
}

// Execute executes the request
//  @return CollectionOfDriveItem
func (a *WorkbooksDriveItemApiService) WorkbooksListChildrenExecute(r ApiWorkbooksListChildrenRequest) (CollectionOfDriveItem, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfDriveItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkbooksDriveItemApiService.WorkbooksListChildren")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workbooks/{driveItem-id}/children"
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWorkbooksUpdateChildrenRequest struct {
	ctx _context.Context
	ApiService *WorkbooksDriveItemApiService
	driveItemId string
	driveItemId1 string
	microsoftGraphDriveItem *MicrosoftGraphDriveItem
}

// New navigation property values
func (r ApiWorkbooksUpdateChildrenRequest) MicrosoftGraphDriveItem(microsoftGraphDriveItem MicrosoftGraphDriveItem) ApiWorkbooksUpdateChildrenRequest {
	r.microsoftGraphDriveItem = &microsoftGraphDriveItem
	return r
}

func (r ApiWorkbooksUpdateChildrenRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkbooksUpdateChildrenExecute(r)
}

/*
WorkbooksUpdateChildren Update the navigation property children in workbooks

Collection containing Item objects for the immediate children of Item. Only items representing folders have children. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveItemId key: id of driveItem
 @param driveItemId1 key: id of driveItem
 @return ApiWorkbooksUpdateChildrenRequest
*/
func (a *WorkbooksDriveItemApiService) WorkbooksUpdateChildren(ctx _context.Context, driveItemId string, driveItemId1 string) ApiWorkbooksUpdateChildrenRequest {
	return ApiWorkbooksUpdateChildrenRequest{
		ApiService: a,
		ctx: ctx,
		driveItemId: driveItemId,
		driveItemId1: driveItemId1,
	}
}

// Execute executes the request
func (a *WorkbooksDriveItemApiService) WorkbooksUpdateChildrenExecute(r ApiWorkbooksUpdateChildrenRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkbooksDriveItemApiService.WorkbooksUpdateChildren")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workbooks/{driveItem-id}/children/{driveItem-id1}"
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id1"+"}", _neturl.PathEscape(parameterToString(r.driveItemId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphDriveItem == nil {
		return nil, reportError("microsoftGraphDriveItem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphDriveItem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkbooksUpdateChildrenContentRequest struct {
	ctx _context.Context
	ApiService *WorkbooksDriveItemApiService
	driveItemId string
	driveItemId1 string
	body **os.File
}

// New media content.
func (r ApiWorkbooksUpdateChildrenContentRequest) Body(body *os.File) ApiWorkbooksUpdateChildrenContentRequest {
	r.body = &body
	return r
}

func (r ApiWorkbooksUpdateChildrenContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkbooksUpdateChildrenContentExecute(r)
}

/*
WorkbooksUpdateChildrenContent Update media content for the navigation property children in workbooks

The content stream, if the item represents a file.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveItemId key: id of driveItem
 @param driveItemId1 key: id of driveItem
 @return ApiWorkbooksUpdateChildrenContentRequest
*/
func (a *WorkbooksDriveItemApiService) WorkbooksUpdateChildrenContent(ctx _context.Context, driveItemId string, driveItemId1 string) ApiWorkbooksUpdateChildrenContentRequest {
	return ApiWorkbooksUpdateChildrenContentRequest{
		ApiService: a,
		ctx: ctx,
		driveItemId: driveItemId,
		driveItemId1: driveItemId1,
	}
}

// Execute executes the request
func (a *WorkbooksDriveItemApiService) WorkbooksUpdateChildrenContentExecute(r ApiWorkbooksUpdateChildrenContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkbooksDriveItemApiService.WorkbooksUpdateChildrenContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workbooks/{driveItem-id}/children/{driveItem-id1}/content"
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id"+"}", _neturl.PathEscape(parameterToString(r.driveItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"driveItem-id1"+"}", _neturl.PathEscape(parameterToString(r.driveItemId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
