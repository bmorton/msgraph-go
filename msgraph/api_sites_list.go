/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"os"
)

// Linger please
var (
	_ _context.Context
)

// SitesListApiService SitesListApi service
type SitesListApiService service

type ApiSitesCreateListsRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	microsoftGraphList *MicrosoftGraphList
}

// New navigation property
func (r ApiSitesCreateListsRequest) MicrosoftGraphList(microsoftGraphList MicrosoftGraphList) ApiSitesCreateListsRequest {
	r.microsoftGraphList = &microsoftGraphList
	return r
}

func (r ApiSitesCreateListsRequest) Execute() (MicrosoftGraphList, *_nethttp.Response, error) {
	return r.ApiService.SitesCreateListsExecute(r)
}

/*
SitesCreateLists Create new navigation property to lists for sites

The collection of lists under this site.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @return ApiSitesCreateListsRequest
*/
func (a *SitesListApiService) SitesCreateLists(ctx _context.Context, siteId string) ApiSitesCreateListsRequest {
	return ApiSitesCreateListsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphList
func (a *SitesListApiService) SitesCreateListsExecute(r ApiSitesCreateListsRequest) (MicrosoftGraphList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesCreateLists")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphList == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphList is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphList
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesDeleteListsRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	ifMatch *string
}

// ETag
func (r ApiSitesDeleteListsRequest) IfMatch(ifMatch string) ApiSitesDeleteListsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesDeleteListsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesDeleteListsExecute(r)
}

/*
SitesDeleteLists Delete navigation property lists for sites

The collection of lists under this site.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @return ApiSitesDeleteListsRequest
*/
func (a *SitesListApiService) SitesDeleteLists(ctx _context.Context, siteId string, listId string) ApiSitesDeleteListsRequest {
	return ApiSitesDeleteListsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
	}
}

// Execute executes the request
func (a *SitesListApiService) SitesDeleteListsExecute(r ApiSitesDeleteListsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesDeleteLists")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesGetListsRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesGetListsRequest) Select_(select_ []string) ApiSitesGetListsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesGetListsRequest) Expand(expand []string) ApiSitesGetListsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesGetListsRequest) Execute() (MicrosoftGraphList, *_nethttp.Response, error) {
	return r.ApiService.SitesGetListsExecute(r)
}

/*
SitesGetLists Get lists from sites

The collection of lists under this site.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @return ApiSitesGetListsRequest
*/
func (a *SitesListApiService) SitesGetLists(ctx _context.Context, siteId string, listId string) ApiSitesGetListsRequest {
	return ApiSitesGetListsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphList
func (a *SitesListApiService) SitesGetListsExecute(r ApiSitesGetListsRequest) (MicrosoftGraphList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesGetLists")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesListListsRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesListListsRequest) Top(top int32) ApiSitesListListsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesListListsRequest) Skip(skip int32) ApiSitesListListsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesListListsRequest) Search(search string) ApiSitesListListsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesListListsRequest) Filter(filter string) ApiSitesListListsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesListListsRequest) Count(count bool) ApiSitesListListsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesListListsRequest) Orderby(orderby []string) ApiSitesListListsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesListListsRequest) Select_(select_ []string) ApiSitesListListsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesListListsRequest) Expand(expand []string) ApiSitesListListsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesListListsRequest) Execute() (CollectionOfList, *_nethttp.Response, error) {
	return r.ApiService.SitesListListsExecute(r)
}

/*
SitesListLists Get lists from sites

The collection of lists under this site.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @return ApiSitesListListsRequest
*/
func (a *SitesListApiService) SitesListLists(ctx _context.Context, siteId string) ApiSitesListListsRequest {
	return ApiSitesListListsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return CollectionOfList
func (a *SitesListApiService) SitesListListsExecute(r ApiSitesListListsRequest) (CollectionOfList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListLists")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesListsColumnsDeleteRefSourceColumnRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	columnDefinitionId string
	ifMatch *string
}

// ETag
func (r ApiSitesListsColumnsDeleteRefSourceColumnRequest) IfMatch(ifMatch string) ApiSitesListsColumnsDeleteRefSourceColumnRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesListsColumnsDeleteRefSourceColumnRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesListsColumnsDeleteRefSourceColumnExecute(r)
}

/*
SitesListsColumnsDeleteRefSourceColumn Delete ref of navigation property sourceColumn for sites

The source column for the content type column.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param columnDefinitionId key: id of columnDefinition
 @return ApiSitesListsColumnsDeleteRefSourceColumnRequest
*/
func (a *SitesListApiService) SitesListsColumnsDeleteRefSourceColumn(ctx _context.Context, siteId string, listId string, columnDefinitionId string) ApiSitesListsColumnsDeleteRefSourceColumnRequest {
	return ApiSitesListsColumnsDeleteRefSourceColumnRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
func (a *SitesListApiService) SitesListsColumnsDeleteRefSourceColumnExecute(r ApiSitesListsColumnsDeleteRefSourceColumnRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsColumnsDeleteRefSourceColumn")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/columns/{columnDefinition-id}/sourceColumn/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesListsColumnsGetRefSourceColumnRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	columnDefinitionId string
}


func (r ApiSitesListsColumnsGetRefSourceColumnRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SitesListsColumnsGetRefSourceColumnExecute(r)
}

/*
SitesListsColumnsGetRefSourceColumn Get ref of sourceColumn from sites

The source column for the content type column.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param columnDefinitionId key: id of columnDefinition
 @return ApiSitesListsColumnsGetRefSourceColumnRequest
*/
func (a *SitesListApiService) SitesListsColumnsGetRefSourceColumn(ctx _context.Context, siteId string, listId string, columnDefinitionId string) ApiSitesListsColumnsGetRefSourceColumnRequest {
	return ApiSitesListsColumnsGetRefSourceColumnRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
//  @return string
func (a *SitesListApiService) SitesListsColumnsGetRefSourceColumnExecute(r ApiSitesListsColumnsGetRefSourceColumnRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsColumnsGetRefSourceColumn")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/columns/{columnDefinition-id}/sourceColumn/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesListsColumnsGetSourceColumnRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	columnDefinitionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesListsColumnsGetSourceColumnRequest) Select_(select_ []string) ApiSitesListsColumnsGetSourceColumnRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesListsColumnsGetSourceColumnRequest) Expand(expand []string) ApiSitesListsColumnsGetSourceColumnRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesListsColumnsGetSourceColumnRequest) Execute() (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.SitesListsColumnsGetSourceColumnExecute(r)
}

/*
SitesListsColumnsGetSourceColumn Get sourceColumn from sites

The source column for the content type column.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param columnDefinitionId key: id of columnDefinition
 @return ApiSitesListsColumnsGetSourceColumnRequest
*/
func (a *SitesListApiService) SitesListsColumnsGetSourceColumn(ctx _context.Context, siteId string, listId string, columnDefinitionId string) ApiSitesListsColumnsGetSourceColumnRequest {
	return ApiSitesListsColumnsGetSourceColumnRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphColumnDefinition
func (a *SitesListApiService) SitesListsColumnsGetSourceColumnExecute(r ApiSitesListsColumnsGetSourceColumnRequest) (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsColumnsGetSourceColumn")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/columns/{columnDefinition-id}/sourceColumn"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesListsColumnsUpdateRefSourceColumnRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	columnDefinitionId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSitesListsColumnsUpdateRefSourceColumnRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesListsColumnsUpdateRefSourceColumnRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesListsColumnsUpdateRefSourceColumnRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesListsColumnsUpdateRefSourceColumnExecute(r)
}

/*
SitesListsColumnsUpdateRefSourceColumn Update the ref of navigation property sourceColumn in sites

The source column for the content type column.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param columnDefinitionId key: id of columnDefinition
 @return ApiSitesListsColumnsUpdateRefSourceColumnRequest
*/
func (a *SitesListApiService) SitesListsColumnsUpdateRefSourceColumn(ctx _context.Context, siteId string, listId string, columnDefinitionId string) ApiSitesListsColumnsUpdateRefSourceColumnRequest {
	return ApiSitesListsColumnsUpdateRefSourceColumnRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
func (a *SitesListApiService) SitesListsColumnsUpdateRefSourceColumnExecute(r ApiSitesListsColumnsUpdateRefSourceColumnRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsColumnsUpdateRefSourceColumn")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/columns/{columnDefinition-id}/sourceColumn/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesListsContentTypesColumnsDeleteRefSourceColumnRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	contentTypeId string
	columnDefinitionId string
	ifMatch *string
}

// ETag
func (r ApiSitesListsContentTypesColumnsDeleteRefSourceColumnRequest) IfMatch(ifMatch string) ApiSitesListsContentTypesColumnsDeleteRefSourceColumnRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesListsContentTypesColumnsDeleteRefSourceColumnRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesListsContentTypesColumnsDeleteRefSourceColumnExecute(r)
}

/*
SitesListsContentTypesColumnsDeleteRefSourceColumn Delete ref of navigation property sourceColumn for sites

The source column for the content type column.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param contentTypeId key: id of contentType
 @param columnDefinitionId key: id of columnDefinition
 @return ApiSitesListsContentTypesColumnsDeleteRefSourceColumnRequest
*/
func (a *SitesListApiService) SitesListsContentTypesColumnsDeleteRefSourceColumn(ctx _context.Context, siteId string, listId string, contentTypeId string, columnDefinitionId string) ApiSitesListsContentTypesColumnsDeleteRefSourceColumnRequest {
	return ApiSitesListsContentTypesColumnsDeleteRefSourceColumnRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		contentTypeId: contentTypeId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
func (a *SitesListApiService) SitesListsContentTypesColumnsDeleteRefSourceColumnExecute(r ApiSitesListsContentTypesColumnsDeleteRefSourceColumnRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsContentTypesColumnsDeleteRefSourceColumn")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/contentTypes/{contentType-id}/columns/{columnDefinition-id}/sourceColumn/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesListsContentTypesColumnsGetRefSourceColumnRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	contentTypeId string
	columnDefinitionId string
}


func (r ApiSitesListsContentTypesColumnsGetRefSourceColumnRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SitesListsContentTypesColumnsGetRefSourceColumnExecute(r)
}

/*
SitesListsContentTypesColumnsGetRefSourceColumn Get ref of sourceColumn from sites

The source column for the content type column.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param contentTypeId key: id of contentType
 @param columnDefinitionId key: id of columnDefinition
 @return ApiSitesListsContentTypesColumnsGetRefSourceColumnRequest
*/
func (a *SitesListApiService) SitesListsContentTypesColumnsGetRefSourceColumn(ctx _context.Context, siteId string, listId string, contentTypeId string, columnDefinitionId string) ApiSitesListsContentTypesColumnsGetRefSourceColumnRequest {
	return ApiSitesListsContentTypesColumnsGetRefSourceColumnRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		contentTypeId: contentTypeId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
//  @return string
func (a *SitesListApiService) SitesListsContentTypesColumnsGetRefSourceColumnExecute(r ApiSitesListsContentTypesColumnsGetRefSourceColumnRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsContentTypesColumnsGetRefSourceColumn")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/contentTypes/{contentType-id}/columns/{columnDefinition-id}/sourceColumn/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesListsContentTypesColumnsGetSourceColumnRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	contentTypeId string
	columnDefinitionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesListsContentTypesColumnsGetSourceColumnRequest) Select_(select_ []string) ApiSitesListsContentTypesColumnsGetSourceColumnRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesListsContentTypesColumnsGetSourceColumnRequest) Expand(expand []string) ApiSitesListsContentTypesColumnsGetSourceColumnRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesListsContentTypesColumnsGetSourceColumnRequest) Execute() (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.SitesListsContentTypesColumnsGetSourceColumnExecute(r)
}

/*
SitesListsContentTypesColumnsGetSourceColumn Get sourceColumn from sites

The source column for the content type column.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param contentTypeId key: id of contentType
 @param columnDefinitionId key: id of columnDefinition
 @return ApiSitesListsContentTypesColumnsGetSourceColumnRequest
*/
func (a *SitesListApiService) SitesListsContentTypesColumnsGetSourceColumn(ctx _context.Context, siteId string, listId string, contentTypeId string, columnDefinitionId string) ApiSitesListsContentTypesColumnsGetSourceColumnRequest {
	return ApiSitesListsContentTypesColumnsGetSourceColumnRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		contentTypeId: contentTypeId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphColumnDefinition
func (a *SitesListApiService) SitesListsContentTypesColumnsGetSourceColumnExecute(r ApiSitesListsContentTypesColumnsGetSourceColumnRequest) (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsContentTypesColumnsGetSourceColumn")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/contentTypes/{contentType-id}/columns/{columnDefinition-id}/sourceColumn"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesListsContentTypesColumnsUpdateRefSourceColumnRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	contentTypeId string
	columnDefinitionId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSitesListsContentTypesColumnsUpdateRefSourceColumnRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesListsContentTypesColumnsUpdateRefSourceColumnRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesListsContentTypesColumnsUpdateRefSourceColumnRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesListsContentTypesColumnsUpdateRefSourceColumnExecute(r)
}

/*
SitesListsContentTypesColumnsUpdateRefSourceColumn Update the ref of navigation property sourceColumn in sites

The source column for the content type column.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param contentTypeId key: id of contentType
 @param columnDefinitionId key: id of columnDefinition
 @return ApiSitesListsContentTypesColumnsUpdateRefSourceColumnRequest
*/
func (a *SitesListApiService) SitesListsContentTypesColumnsUpdateRefSourceColumn(ctx _context.Context, siteId string, listId string, contentTypeId string, columnDefinitionId string) ApiSitesListsContentTypesColumnsUpdateRefSourceColumnRequest {
	return ApiSitesListsContentTypesColumnsUpdateRefSourceColumnRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		contentTypeId: contentTypeId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
func (a *SitesListApiService) SitesListsContentTypesColumnsUpdateRefSourceColumnExecute(r ApiSitesListsContentTypesColumnsUpdateRefSourceColumnRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsContentTypesColumnsUpdateRefSourceColumn")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/contentTypes/{contentType-id}/columns/{columnDefinition-id}/sourceColumn/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesListsContentTypesCreateColumnLinksRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	contentTypeId string
	microsoftGraphColumnLink *MicrosoftGraphColumnLink
}

// New navigation property
func (r ApiSitesListsContentTypesCreateColumnLinksRequest) MicrosoftGraphColumnLink(microsoftGraphColumnLink MicrosoftGraphColumnLink) ApiSitesListsContentTypesCreateColumnLinksRequest {
	r.microsoftGraphColumnLink = &microsoftGraphColumnLink
	return r
}

func (r ApiSitesListsContentTypesCreateColumnLinksRequest) Execute() (MicrosoftGraphColumnLink, *_nethttp.Response, error) {
	return r.ApiService.SitesListsContentTypesCreateColumnLinksExecute(r)
}

/*
SitesListsContentTypesCreateColumnLinks Create new navigation property to columnLinks for sites

The collection of columns that are required by this content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param contentTypeId key: id of contentType
 @return ApiSitesListsContentTypesCreateColumnLinksRequest
*/
func (a *SitesListApiService) SitesListsContentTypesCreateColumnLinks(ctx _context.Context, siteId string, listId string, contentTypeId string) ApiSitesListsContentTypesCreateColumnLinksRequest {
	return ApiSitesListsContentTypesCreateColumnLinksRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphColumnLink
func (a *SitesListApiService) SitesListsContentTypesCreateColumnLinksExecute(r ApiSitesListsContentTypesCreateColumnLinksRequest) (MicrosoftGraphColumnLink, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphColumnLink
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsContentTypesCreateColumnLinks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/contentTypes/{contentType-id}/columnLinks"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphColumnLink == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphColumnLink is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphColumnLink
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesListsContentTypesCreateColumnsRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	contentTypeId string
	microsoftGraphColumnDefinition *MicrosoftGraphColumnDefinition
}

// New navigation property
func (r ApiSitesListsContentTypesCreateColumnsRequest) MicrosoftGraphColumnDefinition(microsoftGraphColumnDefinition MicrosoftGraphColumnDefinition) ApiSitesListsContentTypesCreateColumnsRequest {
	r.microsoftGraphColumnDefinition = &microsoftGraphColumnDefinition
	return r
}

func (r ApiSitesListsContentTypesCreateColumnsRequest) Execute() (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.SitesListsContentTypesCreateColumnsExecute(r)
}

/*
SitesListsContentTypesCreateColumns Create new navigation property to columns for sites

The collection of column definitions for this contentType.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param contentTypeId key: id of contentType
 @return ApiSitesListsContentTypesCreateColumnsRequest
*/
func (a *SitesListApiService) SitesListsContentTypesCreateColumns(ctx _context.Context, siteId string, listId string, contentTypeId string) ApiSitesListsContentTypesCreateColumnsRequest {
	return ApiSitesListsContentTypesCreateColumnsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphColumnDefinition
func (a *SitesListApiService) SitesListsContentTypesCreateColumnsExecute(r ApiSitesListsContentTypesCreateColumnsRequest) (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsContentTypesCreateColumns")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/contentTypes/{contentType-id}/columns"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphColumnDefinition == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphColumnDefinition is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphColumnDefinition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesListsContentTypesCreateRefBaseTypesRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	contentTypeId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref value
func (r ApiSitesListsContentTypesCreateRefBaseTypesRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesListsContentTypesCreateRefBaseTypesRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesListsContentTypesCreateRefBaseTypesRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.SitesListsContentTypesCreateRefBaseTypesExecute(r)
}

/*
SitesListsContentTypesCreateRefBaseTypes Create new navigation property ref to baseTypes for sites

The collection of content types that are ancestors of this content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param contentTypeId key: id of contentType
 @return ApiSitesListsContentTypesCreateRefBaseTypesRequest
*/
func (a *SitesListApiService) SitesListsContentTypesCreateRefBaseTypes(ctx _context.Context, siteId string, listId string, contentTypeId string) ApiSitesListsContentTypesCreateRefBaseTypesRequest {
	return ApiSitesListsContentTypesCreateRefBaseTypesRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *SitesListApiService) SitesListsContentTypesCreateRefBaseTypesExecute(r ApiSitesListsContentTypesCreateRefBaseTypesRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsContentTypesCreateRefBaseTypes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/contentTypes/{contentType-id}/baseTypes/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesListsContentTypesCreateRefColumnPositionsRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	contentTypeId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref value
func (r ApiSitesListsContentTypesCreateRefColumnPositionsRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesListsContentTypesCreateRefColumnPositionsRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesListsContentTypesCreateRefColumnPositionsRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.SitesListsContentTypesCreateRefColumnPositionsExecute(r)
}

/*
SitesListsContentTypesCreateRefColumnPositions Create new navigation property ref to columnPositions for sites

Column order information in a content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param contentTypeId key: id of contentType
 @return ApiSitesListsContentTypesCreateRefColumnPositionsRequest
*/
func (a *SitesListApiService) SitesListsContentTypesCreateRefColumnPositions(ctx _context.Context, siteId string, listId string, contentTypeId string) ApiSitesListsContentTypesCreateRefColumnPositionsRequest {
	return ApiSitesListsContentTypesCreateRefColumnPositionsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *SitesListApiService) SitesListsContentTypesCreateRefColumnPositionsExecute(r ApiSitesListsContentTypesCreateRefColumnPositionsRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsContentTypesCreateRefColumnPositions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/contentTypes/{contentType-id}/columnPositions/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesListsContentTypesDeleteColumnLinksRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	contentTypeId string
	columnLinkId string
	ifMatch *string
}

// ETag
func (r ApiSitesListsContentTypesDeleteColumnLinksRequest) IfMatch(ifMatch string) ApiSitesListsContentTypesDeleteColumnLinksRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesListsContentTypesDeleteColumnLinksRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesListsContentTypesDeleteColumnLinksExecute(r)
}

/*
SitesListsContentTypesDeleteColumnLinks Delete navigation property columnLinks for sites

The collection of columns that are required by this content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param contentTypeId key: id of contentType
 @param columnLinkId key: id of columnLink
 @return ApiSitesListsContentTypesDeleteColumnLinksRequest
*/
func (a *SitesListApiService) SitesListsContentTypesDeleteColumnLinks(ctx _context.Context, siteId string, listId string, contentTypeId string, columnLinkId string) ApiSitesListsContentTypesDeleteColumnLinksRequest {
	return ApiSitesListsContentTypesDeleteColumnLinksRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		contentTypeId: contentTypeId,
		columnLinkId: columnLinkId,
	}
}

// Execute executes the request
func (a *SitesListApiService) SitesListsContentTypesDeleteColumnLinksExecute(r ApiSitesListsContentTypesDeleteColumnLinksRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsContentTypesDeleteColumnLinks")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/contentTypes/{contentType-id}/columnLinks/{columnLink-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnLink-id"+"}", _neturl.PathEscape(parameterToString(r.columnLinkId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesListsContentTypesDeleteColumnsRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	contentTypeId string
	columnDefinitionId string
	ifMatch *string
}

// ETag
func (r ApiSitesListsContentTypesDeleteColumnsRequest) IfMatch(ifMatch string) ApiSitesListsContentTypesDeleteColumnsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesListsContentTypesDeleteColumnsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesListsContentTypesDeleteColumnsExecute(r)
}

/*
SitesListsContentTypesDeleteColumns Delete navigation property columns for sites

The collection of column definitions for this contentType.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param contentTypeId key: id of contentType
 @param columnDefinitionId key: id of columnDefinition
 @return ApiSitesListsContentTypesDeleteColumnsRequest
*/
func (a *SitesListApiService) SitesListsContentTypesDeleteColumns(ctx _context.Context, siteId string, listId string, contentTypeId string, columnDefinitionId string) ApiSitesListsContentTypesDeleteColumnsRequest {
	return ApiSitesListsContentTypesDeleteColumnsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		contentTypeId: contentTypeId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
func (a *SitesListApiService) SitesListsContentTypesDeleteColumnsExecute(r ApiSitesListsContentTypesDeleteColumnsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsContentTypesDeleteColumns")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/contentTypes/{contentType-id}/columns/{columnDefinition-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesListsContentTypesDeleteRefBaseRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	contentTypeId string
	ifMatch *string
}

// ETag
func (r ApiSitesListsContentTypesDeleteRefBaseRequest) IfMatch(ifMatch string) ApiSitesListsContentTypesDeleteRefBaseRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesListsContentTypesDeleteRefBaseRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesListsContentTypesDeleteRefBaseExecute(r)
}

/*
SitesListsContentTypesDeleteRefBase Delete ref of navigation property base for sites

Parent contentType from which this content type is derived.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param contentTypeId key: id of contentType
 @return ApiSitesListsContentTypesDeleteRefBaseRequest
*/
func (a *SitesListApiService) SitesListsContentTypesDeleteRefBase(ctx _context.Context, siteId string, listId string, contentTypeId string) ApiSitesListsContentTypesDeleteRefBaseRequest {
	return ApiSitesListsContentTypesDeleteRefBaseRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
func (a *SitesListApiService) SitesListsContentTypesDeleteRefBaseExecute(r ApiSitesListsContentTypesDeleteRefBaseRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsContentTypesDeleteRefBase")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/contentTypes/{contentType-id}/base/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesListsContentTypesGetBaseRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	contentTypeId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesListsContentTypesGetBaseRequest) Select_(select_ []string) ApiSitesListsContentTypesGetBaseRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesListsContentTypesGetBaseRequest) Expand(expand []string) ApiSitesListsContentTypesGetBaseRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesListsContentTypesGetBaseRequest) Execute() (MicrosoftGraphContentType, *_nethttp.Response, error) {
	return r.ApiService.SitesListsContentTypesGetBaseExecute(r)
}

/*
SitesListsContentTypesGetBase Get base from sites

Parent contentType from which this content type is derived.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param contentTypeId key: id of contentType
 @return ApiSitesListsContentTypesGetBaseRequest
*/
func (a *SitesListApiService) SitesListsContentTypesGetBase(ctx _context.Context, siteId string, listId string, contentTypeId string) ApiSitesListsContentTypesGetBaseRequest {
	return ApiSitesListsContentTypesGetBaseRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphContentType
func (a *SitesListApiService) SitesListsContentTypesGetBaseExecute(r ApiSitesListsContentTypesGetBaseRequest) (MicrosoftGraphContentType, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphContentType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsContentTypesGetBase")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/contentTypes/{contentType-id}/base"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesListsContentTypesGetColumnLinksRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	contentTypeId string
	columnLinkId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesListsContentTypesGetColumnLinksRequest) Select_(select_ []string) ApiSitesListsContentTypesGetColumnLinksRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesListsContentTypesGetColumnLinksRequest) Expand(expand []string) ApiSitesListsContentTypesGetColumnLinksRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesListsContentTypesGetColumnLinksRequest) Execute() (MicrosoftGraphColumnLink, *_nethttp.Response, error) {
	return r.ApiService.SitesListsContentTypesGetColumnLinksExecute(r)
}

/*
SitesListsContentTypesGetColumnLinks Get columnLinks from sites

The collection of columns that are required by this content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param contentTypeId key: id of contentType
 @param columnLinkId key: id of columnLink
 @return ApiSitesListsContentTypesGetColumnLinksRequest
*/
func (a *SitesListApiService) SitesListsContentTypesGetColumnLinks(ctx _context.Context, siteId string, listId string, contentTypeId string, columnLinkId string) ApiSitesListsContentTypesGetColumnLinksRequest {
	return ApiSitesListsContentTypesGetColumnLinksRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		contentTypeId: contentTypeId,
		columnLinkId: columnLinkId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphColumnLink
func (a *SitesListApiService) SitesListsContentTypesGetColumnLinksExecute(r ApiSitesListsContentTypesGetColumnLinksRequest) (MicrosoftGraphColumnLink, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphColumnLink
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsContentTypesGetColumnLinks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/contentTypes/{contentType-id}/columnLinks/{columnLink-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnLink-id"+"}", _neturl.PathEscape(parameterToString(r.columnLinkId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesListsContentTypesGetColumnsRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	contentTypeId string
	columnDefinitionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesListsContentTypesGetColumnsRequest) Select_(select_ []string) ApiSitesListsContentTypesGetColumnsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesListsContentTypesGetColumnsRequest) Expand(expand []string) ApiSitesListsContentTypesGetColumnsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesListsContentTypesGetColumnsRequest) Execute() (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.SitesListsContentTypesGetColumnsExecute(r)
}

/*
SitesListsContentTypesGetColumns Get columns from sites

The collection of column definitions for this contentType.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param contentTypeId key: id of contentType
 @param columnDefinitionId key: id of columnDefinition
 @return ApiSitesListsContentTypesGetColumnsRequest
*/
func (a *SitesListApiService) SitesListsContentTypesGetColumns(ctx _context.Context, siteId string, listId string, contentTypeId string, columnDefinitionId string) ApiSitesListsContentTypesGetColumnsRequest {
	return ApiSitesListsContentTypesGetColumnsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		contentTypeId: contentTypeId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphColumnDefinition
func (a *SitesListApiService) SitesListsContentTypesGetColumnsExecute(r ApiSitesListsContentTypesGetColumnsRequest) (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsContentTypesGetColumns")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/contentTypes/{contentType-id}/columns/{columnDefinition-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesListsContentTypesGetRefBaseRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	contentTypeId string
}


func (r ApiSitesListsContentTypesGetRefBaseRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SitesListsContentTypesGetRefBaseExecute(r)
}

/*
SitesListsContentTypesGetRefBase Get ref of base from sites

Parent contentType from which this content type is derived.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param contentTypeId key: id of contentType
 @return ApiSitesListsContentTypesGetRefBaseRequest
*/
func (a *SitesListApiService) SitesListsContentTypesGetRefBase(ctx _context.Context, siteId string, listId string, contentTypeId string) ApiSitesListsContentTypesGetRefBaseRequest {
	return ApiSitesListsContentTypesGetRefBaseRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return string
func (a *SitesListApiService) SitesListsContentTypesGetRefBaseExecute(r ApiSitesListsContentTypesGetRefBaseRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsContentTypesGetRefBase")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/contentTypes/{contentType-id}/base/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesListsContentTypesListBaseTypesRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	contentTypeId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesListsContentTypesListBaseTypesRequest) Top(top int32) ApiSitesListsContentTypesListBaseTypesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesListsContentTypesListBaseTypesRequest) Skip(skip int32) ApiSitesListsContentTypesListBaseTypesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesListsContentTypesListBaseTypesRequest) Search(search string) ApiSitesListsContentTypesListBaseTypesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesListsContentTypesListBaseTypesRequest) Filter(filter string) ApiSitesListsContentTypesListBaseTypesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesListsContentTypesListBaseTypesRequest) Count(count bool) ApiSitesListsContentTypesListBaseTypesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesListsContentTypesListBaseTypesRequest) Orderby(orderby []string) ApiSitesListsContentTypesListBaseTypesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesListsContentTypesListBaseTypesRequest) Select_(select_ []string) ApiSitesListsContentTypesListBaseTypesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesListsContentTypesListBaseTypesRequest) Expand(expand []string) ApiSitesListsContentTypesListBaseTypesRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesListsContentTypesListBaseTypesRequest) Execute() (CollectionOfContentType, *_nethttp.Response, error) {
	return r.ApiService.SitesListsContentTypesListBaseTypesExecute(r)
}

/*
SitesListsContentTypesListBaseTypes Get baseTypes from sites

The collection of content types that are ancestors of this content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param contentTypeId key: id of contentType
 @return ApiSitesListsContentTypesListBaseTypesRequest
*/
func (a *SitesListApiService) SitesListsContentTypesListBaseTypes(ctx _context.Context, siteId string, listId string, contentTypeId string) ApiSitesListsContentTypesListBaseTypesRequest {
	return ApiSitesListsContentTypesListBaseTypesRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return CollectionOfContentType
func (a *SitesListApiService) SitesListsContentTypesListBaseTypesExecute(r ApiSitesListsContentTypesListBaseTypesRequest) (CollectionOfContentType, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfContentType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsContentTypesListBaseTypes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/contentTypes/{contentType-id}/baseTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesListsContentTypesListColumnLinksRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	contentTypeId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesListsContentTypesListColumnLinksRequest) Top(top int32) ApiSitesListsContentTypesListColumnLinksRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesListsContentTypesListColumnLinksRequest) Skip(skip int32) ApiSitesListsContentTypesListColumnLinksRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesListsContentTypesListColumnLinksRequest) Search(search string) ApiSitesListsContentTypesListColumnLinksRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesListsContentTypesListColumnLinksRequest) Filter(filter string) ApiSitesListsContentTypesListColumnLinksRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesListsContentTypesListColumnLinksRequest) Count(count bool) ApiSitesListsContentTypesListColumnLinksRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesListsContentTypesListColumnLinksRequest) Orderby(orderby []string) ApiSitesListsContentTypesListColumnLinksRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesListsContentTypesListColumnLinksRequest) Select_(select_ []string) ApiSitesListsContentTypesListColumnLinksRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesListsContentTypesListColumnLinksRequest) Expand(expand []string) ApiSitesListsContentTypesListColumnLinksRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesListsContentTypesListColumnLinksRequest) Execute() (CollectionOfColumnLink, *_nethttp.Response, error) {
	return r.ApiService.SitesListsContentTypesListColumnLinksExecute(r)
}

/*
SitesListsContentTypesListColumnLinks Get columnLinks from sites

The collection of columns that are required by this content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param contentTypeId key: id of contentType
 @return ApiSitesListsContentTypesListColumnLinksRequest
*/
func (a *SitesListApiService) SitesListsContentTypesListColumnLinks(ctx _context.Context, siteId string, listId string, contentTypeId string) ApiSitesListsContentTypesListColumnLinksRequest {
	return ApiSitesListsContentTypesListColumnLinksRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return CollectionOfColumnLink
func (a *SitesListApiService) SitesListsContentTypesListColumnLinksExecute(r ApiSitesListsContentTypesListColumnLinksRequest) (CollectionOfColumnLink, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfColumnLink
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsContentTypesListColumnLinks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/contentTypes/{contentType-id}/columnLinks"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesListsContentTypesListColumnPositionsRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	contentTypeId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesListsContentTypesListColumnPositionsRequest) Top(top int32) ApiSitesListsContentTypesListColumnPositionsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesListsContentTypesListColumnPositionsRequest) Skip(skip int32) ApiSitesListsContentTypesListColumnPositionsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesListsContentTypesListColumnPositionsRequest) Search(search string) ApiSitesListsContentTypesListColumnPositionsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesListsContentTypesListColumnPositionsRequest) Filter(filter string) ApiSitesListsContentTypesListColumnPositionsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesListsContentTypesListColumnPositionsRequest) Count(count bool) ApiSitesListsContentTypesListColumnPositionsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesListsContentTypesListColumnPositionsRequest) Orderby(orderby []string) ApiSitesListsContentTypesListColumnPositionsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesListsContentTypesListColumnPositionsRequest) Select_(select_ []string) ApiSitesListsContentTypesListColumnPositionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesListsContentTypesListColumnPositionsRequest) Expand(expand []string) ApiSitesListsContentTypesListColumnPositionsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesListsContentTypesListColumnPositionsRequest) Execute() (CollectionOfColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.SitesListsContentTypesListColumnPositionsExecute(r)
}

/*
SitesListsContentTypesListColumnPositions Get columnPositions from sites

Column order information in a content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param contentTypeId key: id of contentType
 @return ApiSitesListsContentTypesListColumnPositionsRequest
*/
func (a *SitesListApiService) SitesListsContentTypesListColumnPositions(ctx _context.Context, siteId string, listId string, contentTypeId string) ApiSitesListsContentTypesListColumnPositionsRequest {
	return ApiSitesListsContentTypesListColumnPositionsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return CollectionOfColumnDefinition
func (a *SitesListApiService) SitesListsContentTypesListColumnPositionsExecute(r ApiSitesListsContentTypesListColumnPositionsRequest) (CollectionOfColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsContentTypesListColumnPositions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/contentTypes/{contentType-id}/columnPositions"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesListsContentTypesListColumnsRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	contentTypeId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesListsContentTypesListColumnsRequest) Top(top int32) ApiSitesListsContentTypesListColumnsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesListsContentTypesListColumnsRequest) Skip(skip int32) ApiSitesListsContentTypesListColumnsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesListsContentTypesListColumnsRequest) Search(search string) ApiSitesListsContentTypesListColumnsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesListsContentTypesListColumnsRequest) Filter(filter string) ApiSitesListsContentTypesListColumnsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesListsContentTypesListColumnsRequest) Count(count bool) ApiSitesListsContentTypesListColumnsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesListsContentTypesListColumnsRequest) Orderby(orderby []string) ApiSitesListsContentTypesListColumnsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesListsContentTypesListColumnsRequest) Select_(select_ []string) ApiSitesListsContentTypesListColumnsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesListsContentTypesListColumnsRequest) Expand(expand []string) ApiSitesListsContentTypesListColumnsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesListsContentTypesListColumnsRequest) Execute() (CollectionOfColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.SitesListsContentTypesListColumnsExecute(r)
}

/*
SitesListsContentTypesListColumns Get columns from sites

The collection of column definitions for this contentType.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param contentTypeId key: id of contentType
 @return ApiSitesListsContentTypesListColumnsRequest
*/
func (a *SitesListApiService) SitesListsContentTypesListColumns(ctx _context.Context, siteId string, listId string, contentTypeId string) ApiSitesListsContentTypesListColumnsRequest {
	return ApiSitesListsContentTypesListColumnsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return CollectionOfColumnDefinition
func (a *SitesListApiService) SitesListsContentTypesListColumnsExecute(r ApiSitesListsContentTypesListColumnsRequest) (CollectionOfColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsContentTypesListColumns")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/contentTypes/{contentType-id}/columns"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesListsContentTypesListRefBaseTypesRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	contentTypeId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
}

// Show only the first n items
func (r ApiSitesListsContentTypesListRefBaseTypesRequest) Top(top int32) ApiSitesListsContentTypesListRefBaseTypesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesListsContentTypesListRefBaseTypesRequest) Skip(skip int32) ApiSitesListsContentTypesListRefBaseTypesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesListsContentTypesListRefBaseTypesRequest) Search(search string) ApiSitesListsContentTypesListRefBaseTypesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesListsContentTypesListRefBaseTypesRequest) Filter(filter string) ApiSitesListsContentTypesListRefBaseTypesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesListsContentTypesListRefBaseTypesRequest) Count(count bool) ApiSitesListsContentTypesListRefBaseTypesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesListsContentTypesListRefBaseTypesRequest) Orderby(orderby []string) ApiSitesListsContentTypesListRefBaseTypesRequest {
	r.orderby = &orderby
	return r
}

func (r ApiSitesListsContentTypesListRefBaseTypesRequest) Execute() (CollectionOfLinksOfContentType, *_nethttp.Response, error) {
	return r.ApiService.SitesListsContentTypesListRefBaseTypesExecute(r)
}

/*
SitesListsContentTypesListRefBaseTypes Get ref of baseTypes from sites

The collection of content types that are ancestors of this content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param contentTypeId key: id of contentType
 @return ApiSitesListsContentTypesListRefBaseTypesRequest
*/
func (a *SitesListApiService) SitesListsContentTypesListRefBaseTypes(ctx _context.Context, siteId string, listId string, contentTypeId string) ApiSitesListsContentTypesListRefBaseTypesRequest {
	return ApiSitesListsContentTypesListRefBaseTypesRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return CollectionOfLinksOfContentType
func (a *SitesListApiService) SitesListsContentTypesListRefBaseTypesExecute(r ApiSitesListsContentTypesListRefBaseTypesRequest) (CollectionOfLinksOfContentType, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfLinksOfContentType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsContentTypesListRefBaseTypes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/contentTypes/{contentType-id}/baseTypes/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesListsContentTypesListRefColumnPositionsRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	contentTypeId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
}

// Show only the first n items
func (r ApiSitesListsContentTypesListRefColumnPositionsRequest) Top(top int32) ApiSitesListsContentTypesListRefColumnPositionsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesListsContentTypesListRefColumnPositionsRequest) Skip(skip int32) ApiSitesListsContentTypesListRefColumnPositionsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesListsContentTypesListRefColumnPositionsRequest) Search(search string) ApiSitesListsContentTypesListRefColumnPositionsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesListsContentTypesListRefColumnPositionsRequest) Filter(filter string) ApiSitesListsContentTypesListRefColumnPositionsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesListsContentTypesListRefColumnPositionsRequest) Count(count bool) ApiSitesListsContentTypesListRefColumnPositionsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesListsContentTypesListRefColumnPositionsRequest) Orderby(orderby []string) ApiSitesListsContentTypesListRefColumnPositionsRequest {
	r.orderby = &orderby
	return r
}

func (r ApiSitesListsContentTypesListRefColumnPositionsRequest) Execute() (CollectionOfLinksOfColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.SitesListsContentTypesListRefColumnPositionsExecute(r)
}

/*
SitesListsContentTypesListRefColumnPositions Get ref of columnPositions from sites

Column order information in a content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param contentTypeId key: id of contentType
 @return ApiSitesListsContentTypesListRefColumnPositionsRequest
*/
func (a *SitesListApiService) SitesListsContentTypesListRefColumnPositions(ctx _context.Context, siteId string, listId string, contentTypeId string) ApiSitesListsContentTypesListRefColumnPositionsRequest {
	return ApiSitesListsContentTypesListRefColumnPositionsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return CollectionOfLinksOfColumnDefinition
func (a *SitesListApiService) SitesListsContentTypesListRefColumnPositionsExecute(r ApiSitesListsContentTypesListRefColumnPositionsRequest) (CollectionOfLinksOfColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfLinksOfColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsContentTypesListRefColumnPositions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/contentTypes/{contentType-id}/columnPositions/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesListsContentTypesUpdateColumnLinksRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	contentTypeId string
	columnLinkId string
	microsoftGraphColumnLink *MicrosoftGraphColumnLink
}

// New navigation property values
func (r ApiSitesListsContentTypesUpdateColumnLinksRequest) MicrosoftGraphColumnLink(microsoftGraphColumnLink MicrosoftGraphColumnLink) ApiSitesListsContentTypesUpdateColumnLinksRequest {
	r.microsoftGraphColumnLink = &microsoftGraphColumnLink
	return r
}

func (r ApiSitesListsContentTypesUpdateColumnLinksRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesListsContentTypesUpdateColumnLinksExecute(r)
}

/*
SitesListsContentTypesUpdateColumnLinks Update the navigation property columnLinks in sites

The collection of columns that are required by this content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param contentTypeId key: id of contentType
 @param columnLinkId key: id of columnLink
 @return ApiSitesListsContentTypesUpdateColumnLinksRequest
*/
func (a *SitesListApiService) SitesListsContentTypesUpdateColumnLinks(ctx _context.Context, siteId string, listId string, contentTypeId string, columnLinkId string) ApiSitesListsContentTypesUpdateColumnLinksRequest {
	return ApiSitesListsContentTypesUpdateColumnLinksRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		contentTypeId: contentTypeId,
		columnLinkId: columnLinkId,
	}
}

// Execute executes the request
func (a *SitesListApiService) SitesListsContentTypesUpdateColumnLinksExecute(r ApiSitesListsContentTypesUpdateColumnLinksRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsContentTypesUpdateColumnLinks")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/contentTypes/{contentType-id}/columnLinks/{columnLink-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnLink-id"+"}", _neturl.PathEscape(parameterToString(r.columnLinkId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphColumnLink == nil {
		return nil, reportError("microsoftGraphColumnLink is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphColumnLink
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesListsContentTypesUpdateColumnsRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	contentTypeId string
	columnDefinitionId string
	microsoftGraphColumnDefinition *MicrosoftGraphColumnDefinition
}

// New navigation property values
func (r ApiSitesListsContentTypesUpdateColumnsRequest) MicrosoftGraphColumnDefinition(microsoftGraphColumnDefinition MicrosoftGraphColumnDefinition) ApiSitesListsContentTypesUpdateColumnsRequest {
	r.microsoftGraphColumnDefinition = &microsoftGraphColumnDefinition
	return r
}

func (r ApiSitesListsContentTypesUpdateColumnsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesListsContentTypesUpdateColumnsExecute(r)
}

/*
SitesListsContentTypesUpdateColumns Update the navigation property columns in sites

The collection of column definitions for this contentType.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param contentTypeId key: id of contentType
 @param columnDefinitionId key: id of columnDefinition
 @return ApiSitesListsContentTypesUpdateColumnsRequest
*/
func (a *SitesListApiService) SitesListsContentTypesUpdateColumns(ctx _context.Context, siteId string, listId string, contentTypeId string, columnDefinitionId string) ApiSitesListsContentTypesUpdateColumnsRequest {
	return ApiSitesListsContentTypesUpdateColumnsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		contentTypeId: contentTypeId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
func (a *SitesListApiService) SitesListsContentTypesUpdateColumnsExecute(r ApiSitesListsContentTypesUpdateColumnsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsContentTypesUpdateColumns")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/contentTypes/{contentType-id}/columns/{columnDefinition-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphColumnDefinition == nil {
		return nil, reportError("microsoftGraphColumnDefinition is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphColumnDefinition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesListsContentTypesUpdateRefBaseRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	contentTypeId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSitesListsContentTypesUpdateRefBaseRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesListsContentTypesUpdateRefBaseRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesListsContentTypesUpdateRefBaseRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesListsContentTypesUpdateRefBaseExecute(r)
}

/*
SitesListsContentTypesUpdateRefBase Update the ref of navigation property base in sites

Parent contentType from which this content type is derived.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param contentTypeId key: id of contentType
 @return ApiSitesListsContentTypesUpdateRefBaseRequest
*/
func (a *SitesListApiService) SitesListsContentTypesUpdateRefBase(ctx _context.Context, siteId string, listId string, contentTypeId string) ApiSitesListsContentTypesUpdateRefBaseRequest {
	return ApiSitesListsContentTypesUpdateRefBaseRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
func (a *SitesListApiService) SitesListsContentTypesUpdateRefBaseExecute(r ApiSitesListsContentTypesUpdateRefBaseRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsContentTypesUpdateRefBase")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/contentTypes/{contentType-id}/base/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesListsCreateColumnsRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	microsoftGraphColumnDefinition *MicrosoftGraphColumnDefinition
}

// New navigation property
func (r ApiSitesListsCreateColumnsRequest) MicrosoftGraphColumnDefinition(microsoftGraphColumnDefinition MicrosoftGraphColumnDefinition) ApiSitesListsCreateColumnsRequest {
	r.microsoftGraphColumnDefinition = &microsoftGraphColumnDefinition
	return r
}

func (r ApiSitesListsCreateColumnsRequest) Execute() (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.SitesListsCreateColumnsExecute(r)
}

/*
SitesListsCreateColumns Create new navigation property to columns for sites

The collection of field definitions for this list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @return ApiSitesListsCreateColumnsRequest
*/
func (a *SitesListApiService) SitesListsCreateColumns(ctx _context.Context, siteId string, listId string) ApiSitesListsCreateColumnsRequest {
	return ApiSitesListsCreateColumnsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphColumnDefinition
func (a *SitesListApiService) SitesListsCreateColumnsExecute(r ApiSitesListsCreateColumnsRequest) (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsCreateColumns")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/columns"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphColumnDefinition == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphColumnDefinition is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphColumnDefinition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesListsCreateContentTypesRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	microsoftGraphContentType *MicrosoftGraphContentType
}

// New navigation property
func (r ApiSitesListsCreateContentTypesRequest) MicrosoftGraphContentType(microsoftGraphContentType MicrosoftGraphContentType) ApiSitesListsCreateContentTypesRequest {
	r.microsoftGraphContentType = &microsoftGraphContentType
	return r
}

func (r ApiSitesListsCreateContentTypesRequest) Execute() (MicrosoftGraphContentType, *_nethttp.Response, error) {
	return r.ApiService.SitesListsCreateContentTypesExecute(r)
}

/*
SitesListsCreateContentTypes Create new navigation property to contentTypes for sites

The collection of content types present in this list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @return ApiSitesListsCreateContentTypesRequest
*/
func (a *SitesListApiService) SitesListsCreateContentTypes(ctx _context.Context, siteId string, listId string) ApiSitesListsCreateContentTypesRequest {
	return ApiSitesListsCreateContentTypesRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphContentType
func (a *SitesListApiService) SitesListsCreateContentTypesExecute(r ApiSitesListsCreateContentTypesRequest) (MicrosoftGraphContentType, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphContentType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsCreateContentTypes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/contentTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphContentType == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphContentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphContentType
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesListsCreateItemsRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	microsoftGraphListItem *MicrosoftGraphListItem
}

// New navigation property
func (r ApiSitesListsCreateItemsRequest) MicrosoftGraphListItem(microsoftGraphListItem MicrosoftGraphListItem) ApiSitesListsCreateItemsRequest {
	r.microsoftGraphListItem = &microsoftGraphListItem
	return r
}

func (r ApiSitesListsCreateItemsRequest) Execute() (MicrosoftGraphListItem, *_nethttp.Response, error) {
	return r.ApiService.SitesListsCreateItemsExecute(r)
}

/*
SitesListsCreateItems Create new navigation property to items for sites

All items contained in the list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @return ApiSitesListsCreateItemsRequest
*/
func (a *SitesListApiService) SitesListsCreateItems(ctx _context.Context, siteId string, listId string) ApiSitesListsCreateItemsRequest {
	return ApiSitesListsCreateItemsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphListItem
func (a *SitesListApiService) SitesListsCreateItemsExecute(r ApiSitesListsCreateItemsRequest) (MicrosoftGraphListItem, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphListItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsCreateItems")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/items"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphListItem == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphListItem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphListItem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesListsCreateSubscriptionsRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	microsoftGraphSubscription *MicrosoftGraphSubscription
}

// New navigation property
func (r ApiSitesListsCreateSubscriptionsRequest) MicrosoftGraphSubscription(microsoftGraphSubscription MicrosoftGraphSubscription) ApiSitesListsCreateSubscriptionsRequest {
	r.microsoftGraphSubscription = &microsoftGraphSubscription
	return r
}

func (r ApiSitesListsCreateSubscriptionsRequest) Execute() (MicrosoftGraphSubscription, *_nethttp.Response, error) {
	return r.ApiService.SitesListsCreateSubscriptionsExecute(r)
}

/*
SitesListsCreateSubscriptions Create new navigation property to subscriptions for sites

The set of subscriptions on the list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @return ApiSitesListsCreateSubscriptionsRequest
*/
func (a *SitesListApiService) SitesListsCreateSubscriptions(ctx _context.Context, siteId string, listId string) ApiSitesListsCreateSubscriptionsRequest {
	return ApiSitesListsCreateSubscriptionsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphSubscription
func (a *SitesListApiService) SitesListsCreateSubscriptionsExecute(r ApiSitesListsCreateSubscriptionsRequest) (MicrosoftGraphSubscription, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphSubscription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsCreateSubscriptions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/subscriptions"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphSubscription == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphSubscription is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphSubscription
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesListsDeleteColumnsRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	columnDefinitionId string
	ifMatch *string
}

// ETag
func (r ApiSitesListsDeleteColumnsRequest) IfMatch(ifMatch string) ApiSitesListsDeleteColumnsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesListsDeleteColumnsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesListsDeleteColumnsExecute(r)
}

/*
SitesListsDeleteColumns Delete navigation property columns for sites

The collection of field definitions for this list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param columnDefinitionId key: id of columnDefinition
 @return ApiSitesListsDeleteColumnsRequest
*/
func (a *SitesListApiService) SitesListsDeleteColumns(ctx _context.Context, siteId string, listId string, columnDefinitionId string) ApiSitesListsDeleteColumnsRequest {
	return ApiSitesListsDeleteColumnsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
func (a *SitesListApiService) SitesListsDeleteColumnsExecute(r ApiSitesListsDeleteColumnsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsDeleteColumns")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/columns/{columnDefinition-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesListsDeleteContentTypesRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	contentTypeId string
	ifMatch *string
}

// ETag
func (r ApiSitesListsDeleteContentTypesRequest) IfMatch(ifMatch string) ApiSitesListsDeleteContentTypesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesListsDeleteContentTypesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesListsDeleteContentTypesExecute(r)
}

/*
SitesListsDeleteContentTypes Delete navigation property contentTypes for sites

The collection of content types present in this list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param contentTypeId key: id of contentType
 @return ApiSitesListsDeleteContentTypesRequest
*/
func (a *SitesListApiService) SitesListsDeleteContentTypes(ctx _context.Context, siteId string, listId string, contentTypeId string) ApiSitesListsDeleteContentTypesRequest {
	return ApiSitesListsDeleteContentTypesRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
func (a *SitesListApiService) SitesListsDeleteContentTypesExecute(r ApiSitesListsDeleteContentTypesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsDeleteContentTypes")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/contentTypes/{contentType-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesListsDeleteDriveRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	ifMatch *string
}

// ETag
func (r ApiSitesListsDeleteDriveRequest) IfMatch(ifMatch string) ApiSitesListsDeleteDriveRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesListsDeleteDriveRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesListsDeleteDriveExecute(r)
}

/*
SitesListsDeleteDrive Delete navigation property drive for sites

Only present on document libraries. Allows access to the list as a [drive][] resource with [driveItems][driveItem].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @return ApiSitesListsDeleteDriveRequest
*/
func (a *SitesListApiService) SitesListsDeleteDrive(ctx _context.Context, siteId string, listId string) ApiSitesListsDeleteDriveRequest {
	return ApiSitesListsDeleteDriveRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
	}
}

// Execute executes the request
func (a *SitesListApiService) SitesListsDeleteDriveExecute(r ApiSitesListsDeleteDriveRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsDeleteDrive")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/drive"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesListsDeleteItemsRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	listItemId string
	ifMatch *string
}

// ETag
func (r ApiSitesListsDeleteItemsRequest) IfMatch(ifMatch string) ApiSitesListsDeleteItemsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesListsDeleteItemsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesListsDeleteItemsExecute(r)
}

/*
SitesListsDeleteItems Delete navigation property items for sites

All items contained in the list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param listItemId key: id of listItem
 @return ApiSitesListsDeleteItemsRequest
*/
func (a *SitesListApiService) SitesListsDeleteItems(ctx _context.Context, siteId string, listId string, listItemId string) ApiSitesListsDeleteItemsRequest {
	return ApiSitesListsDeleteItemsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		listItemId: listItemId,
	}
}

// Execute executes the request
func (a *SitesListApiService) SitesListsDeleteItemsExecute(r ApiSitesListsDeleteItemsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsDeleteItems")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/items/{listItem-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesListsDeleteSubscriptionsRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	subscriptionId string
	ifMatch *string
}

// ETag
func (r ApiSitesListsDeleteSubscriptionsRequest) IfMatch(ifMatch string) ApiSitesListsDeleteSubscriptionsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesListsDeleteSubscriptionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesListsDeleteSubscriptionsExecute(r)
}

/*
SitesListsDeleteSubscriptions Delete navigation property subscriptions for sites

The set of subscriptions on the list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param subscriptionId key: id of subscription
 @return ApiSitesListsDeleteSubscriptionsRequest
*/
func (a *SitesListApiService) SitesListsDeleteSubscriptions(ctx _context.Context, siteId string, listId string, subscriptionId string) ApiSitesListsDeleteSubscriptionsRequest {
	return ApiSitesListsDeleteSubscriptionsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		subscriptionId: subscriptionId,
	}
}

// Execute executes the request
func (a *SitesListApiService) SitesListsDeleteSubscriptionsExecute(r ApiSitesListsDeleteSubscriptionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsDeleteSubscriptions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/subscriptions/{subscription-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscription-id"+"}", _neturl.PathEscape(parameterToString(r.subscriptionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesListsGetColumnsRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	columnDefinitionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesListsGetColumnsRequest) Select_(select_ []string) ApiSitesListsGetColumnsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesListsGetColumnsRequest) Expand(expand []string) ApiSitesListsGetColumnsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesListsGetColumnsRequest) Execute() (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.SitesListsGetColumnsExecute(r)
}

/*
SitesListsGetColumns Get columns from sites

The collection of field definitions for this list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param columnDefinitionId key: id of columnDefinition
 @return ApiSitesListsGetColumnsRequest
*/
func (a *SitesListApiService) SitesListsGetColumns(ctx _context.Context, siteId string, listId string, columnDefinitionId string) ApiSitesListsGetColumnsRequest {
	return ApiSitesListsGetColumnsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphColumnDefinition
func (a *SitesListApiService) SitesListsGetColumnsExecute(r ApiSitesListsGetColumnsRequest) (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsGetColumns")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/columns/{columnDefinition-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesListsGetContentTypesRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	contentTypeId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesListsGetContentTypesRequest) Select_(select_ []string) ApiSitesListsGetContentTypesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesListsGetContentTypesRequest) Expand(expand []string) ApiSitesListsGetContentTypesRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesListsGetContentTypesRequest) Execute() (MicrosoftGraphContentType, *_nethttp.Response, error) {
	return r.ApiService.SitesListsGetContentTypesExecute(r)
}

/*
SitesListsGetContentTypes Get contentTypes from sites

The collection of content types present in this list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param contentTypeId key: id of contentType
 @return ApiSitesListsGetContentTypesRequest
*/
func (a *SitesListApiService) SitesListsGetContentTypes(ctx _context.Context, siteId string, listId string, contentTypeId string) ApiSitesListsGetContentTypesRequest {
	return ApiSitesListsGetContentTypesRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphContentType
func (a *SitesListApiService) SitesListsGetContentTypesExecute(r ApiSitesListsGetContentTypesRequest) (MicrosoftGraphContentType, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphContentType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsGetContentTypes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/contentTypes/{contentType-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesListsGetDriveRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesListsGetDriveRequest) Select_(select_ []string) ApiSitesListsGetDriveRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesListsGetDriveRequest) Expand(expand []string) ApiSitesListsGetDriveRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesListsGetDriveRequest) Execute() (MicrosoftGraphDrive, *_nethttp.Response, error) {
	return r.ApiService.SitesListsGetDriveExecute(r)
}

/*
SitesListsGetDrive Get drive from sites

Only present on document libraries. Allows access to the list as a [drive][] resource with [driveItems][driveItem].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @return ApiSitesListsGetDriveRequest
*/
func (a *SitesListApiService) SitesListsGetDrive(ctx _context.Context, siteId string, listId string) ApiSitesListsGetDriveRequest {
	return ApiSitesListsGetDriveRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphDrive
func (a *SitesListApiService) SitesListsGetDriveExecute(r ApiSitesListsGetDriveRequest) (MicrosoftGraphDrive, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphDrive
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsGetDrive")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/drive"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesListsGetItemsRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	listItemId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesListsGetItemsRequest) Select_(select_ []string) ApiSitesListsGetItemsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesListsGetItemsRequest) Expand(expand []string) ApiSitesListsGetItemsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesListsGetItemsRequest) Execute() (MicrosoftGraphListItem, *_nethttp.Response, error) {
	return r.ApiService.SitesListsGetItemsExecute(r)
}

/*
SitesListsGetItems Get items from sites

All items contained in the list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param listItemId key: id of listItem
 @return ApiSitesListsGetItemsRequest
*/
func (a *SitesListApiService) SitesListsGetItems(ctx _context.Context, siteId string, listId string, listItemId string) ApiSitesListsGetItemsRequest {
	return ApiSitesListsGetItemsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		listItemId: listItemId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphListItem
func (a *SitesListApiService) SitesListsGetItemsExecute(r ApiSitesListsGetItemsRequest) (MicrosoftGraphListItem, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphListItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsGetItems")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/items/{listItem-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesListsGetSubscriptionsRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	subscriptionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesListsGetSubscriptionsRequest) Select_(select_ []string) ApiSitesListsGetSubscriptionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesListsGetSubscriptionsRequest) Expand(expand []string) ApiSitesListsGetSubscriptionsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesListsGetSubscriptionsRequest) Execute() (MicrosoftGraphSubscription, *_nethttp.Response, error) {
	return r.ApiService.SitesListsGetSubscriptionsExecute(r)
}

/*
SitesListsGetSubscriptions Get subscriptions from sites

The set of subscriptions on the list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param subscriptionId key: id of subscription
 @return ApiSitesListsGetSubscriptionsRequest
*/
func (a *SitesListApiService) SitesListsGetSubscriptions(ctx _context.Context, siteId string, listId string, subscriptionId string) ApiSitesListsGetSubscriptionsRequest {
	return ApiSitesListsGetSubscriptionsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		subscriptionId: subscriptionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphSubscription
func (a *SitesListApiService) SitesListsGetSubscriptionsExecute(r ApiSitesListsGetSubscriptionsRequest) (MicrosoftGraphSubscription, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphSubscription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsGetSubscriptions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/subscriptions/{subscription-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscription-id"+"}", _neturl.PathEscape(parameterToString(r.subscriptionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesListsItemsCreateVersionsRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	listItemId string
	microsoftGraphListItemVersion *MicrosoftGraphListItemVersion
}

// New navigation property
func (r ApiSitesListsItemsCreateVersionsRequest) MicrosoftGraphListItemVersion(microsoftGraphListItemVersion MicrosoftGraphListItemVersion) ApiSitesListsItemsCreateVersionsRequest {
	r.microsoftGraphListItemVersion = &microsoftGraphListItemVersion
	return r
}

func (r ApiSitesListsItemsCreateVersionsRequest) Execute() (MicrosoftGraphListItemVersion, *_nethttp.Response, error) {
	return r.ApiService.SitesListsItemsCreateVersionsExecute(r)
}

/*
SitesListsItemsCreateVersions Create new navigation property to versions for sites

The list of previous versions of the list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param listItemId key: id of listItem
 @return ApiSitesListsItemsCreateVersionsRequest
*/
func (a *SitesListApiService) SitesListsItemsCreateVersions(ctx _context.Context, siteId string, listId string, listItemId string) ApiSitesListsItemsCreateVersionsRequest {
	return ApiSitesListsItemsCreateVersionsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		listItemId: listItemId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphListItemVersion
func (a *SitesListApiService) SitesListsItemsCreateVersionsExecute(r ApiSitesListsItemsCreateVersionsRequest) (MicrosoftGraphListItemVersion, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphListItemVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsItemsCreateVersions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/items/{listItem-id}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphListItemVersion == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphListItemVersion is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphListItemVersion
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesListsItemsDeleteDriveItemRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	listItemId string
	ifMatch *string
}

// ETag
func (r ApiSitesListsItemsDeleteDriveItemRequest) IfMatch(ifMatch string) ApiSitesListsItemsDeleteDriveItemRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesListsItemsDeleteDriveItemRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesListsItemsDeleteDriveItemExecute(r)
}

/*
SitesListsItemsDeleteDriveItem Delete navigation property driveItem for sites

For document libraries, the driveItem relationship exposes the listItem as a [driveItem][]

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param listItemId key: id of listItem
 @return ApiSitesListsItemsDeleteDriveItemRequest
*/
func (a *SitesListApiService) SitesListsItemsDeleteDriveItem(ctx _context.Context, siteId string, listId string, listItemId string) ApiSitesListsItemsDeleteDriveItemRequest {
	return ApiSitesListsItemsDeleteDriveItemRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		listItemId: listItemId,
	}
}

// Execute executes the request
func (a *SitesListApiService) SitesListsItemsDeleteDriveItemExecute(r ApiSitesListsItemsDeleteDriveItemRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsItemsDeleteDriveItem")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/items/{listItem-id}/driveItem"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesListsItemsDeleteFieldsRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	listItemId string
	ifMatch *string
}

// ETag
func (r ApiSitesListsItemsDeleteFieldsRequest) IfMatch(ifMatch string) ApiSitesListsItemsDeleteFieldsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesListsItemsDeleteFieldsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesListsItemsDeleteFieldsExecute(r)
}

/*
SitesListsItemsDeleteFields Delete navigation property fields for sites

The values of the columns set on this list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param listItemId key: id of listItem
 @return ApiSitesListsItemsDeleteFieldsRequest
*/
func (a *SitesListApiService) SitesListsItemsDeleteFields(ctx _context.Context, siteId string, listId string, listItemId string) ApiSitesListsItemsDeleteFieldsRequest {
	return ApiSitesListsItemsDeleteFieldsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		listItemId: listItemId,
	}
}

// Execute executes the request
func (a *SitesListApiService) SitesListsItemsDeleteFieldsExecute(r ApiSitesListsItemsDeleteFieldsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsItemsDeleteFields")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/items/{listItem-id}/fields"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesListsItemsDeleteRefAnalyticsRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	listItemId string
	ifMatch *string
}

// ETag
func (r ApiSitesListsItemsDeleteRefAnalyticsRequest) IfMatch(ifMatch string) ApiSitesListsItemsDeleteRefAnalyticsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesListsItemsDeleteRefAnalyticsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesListsItemsDeleteRefAnalyticsExecute(r)
}

/*
SitesListsItemsDeleteRefAnalytics Delete ref of navigation property analytics for sites

Analytics about the view activities that took place on this item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param listItemId key: id of listItem
 @return ApiSitesListsItemsDeleteRefAnalyticsRequest
*/
func (a *SitesListApiService) SitesListsItemsDeleteRefAnalytics(ctx _context.Context, siteId string, listId string, listItemId string) ApiSitesListsItemsDeleteRefAnalyticsRequest {
	return ApiSitesListsItemsDeleteRefAnalyticsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		listItemId: listItemId,
	}
}

// Execute executes the request
func (a *SitesListApiService) SitesListsItemsDeleteRefAnalyticsExecute(r ApiSitesListsItemsDeleteRefAnalyticsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsItemsDeleteRefAnalytics")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/items/{listItem-id}/analytics/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesListsItemsDeleteVersionsRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	listItemId string
	listItemVersionId string
	ifMatch *string
}

// ETag
func (r ApiSitesListsItemsDeleteVersionsRequest) IfMatch(ifMatch string) ApiSitesListsItemsDeleteVersionsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesListsItemsDeleteVersionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesListsItemsDeleteVersionsExecute(r)
}

/*
SitesListsItemsDeleteVersions Delete navigation property versions for sites

The list of previous versions of the list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param listItemId key: id of listItem
 @param listItemVersionId key: id of listItemVersion
 @return ApiSitesListsItemsDeleteVersionsRequest
*/
func (a *SitesListApiService) SitesListsItemsDeleteVersions(ctx _context.Context, siteId string, listId string, listItemId string, listItemVersionId string) ApiSitesListsItemsDeleteVersionsRequest {
	return ApiSitesListsItemsDeleteVersionsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		listItemId: listItemId,
		listItemVersionId: listItemVersionId,
	}
}

// Execute executes the request
func (a *SitesListApiService) SitesListsItemsDeleteVersionsExecute(r ApiSitesListsItemsDeleteVersionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsItemsDeleteVersions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/items/{listItem-id}/versions/{listItemVersion-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItemVersion-id"+"}", _neturl.PathEscape(parameterToString(r.listItemVersionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesListsItemsGetAnalyticsRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	listItemId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesListsItemsGetAnalyticsRequest) Select_(select_ []string) ApiSitesListsItemsGetAnalyticsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesListsItemsGetAnalyticsRequest) Expand(expand []string) ApiSitesListsItemsGetAnalyticsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesListsItemsGetAnalyticsRequest) Execute() (MicrosoftGraphItemAnalytics, *_nethttp.Response, error) {
	return r.ApiService.SitesListsItemsGetAnalyticsExecute(r)
}

/*
SitesListsItemsGetAnalytics Get analytics from sites

Analytics about the view activities that took place on this item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param listItemId key: id of listItem
 @return ApiSitesListsItemsGetAnalyticsRequest
*/
func (a *SitesListApiService) SitesListsItemsGetAnalytics(ctx _context.Context, siteId string, listId string, listItemId string) ApiSitesListsItemsGetAnalyticsRequest {
	return ApiSitesListsItemsGetAnalyticsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		listItemId: listItemId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphItemAnalytics
func (a *SitesListApiService) SitesListsItemsGetAnalyticsExecute(r ApiSitesListsItemsGetAnalyticsRequest) (MicrosoftGraphItemAnalytics, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphItemAnalytics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsItemsGetAnalytics")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/items/{listItem-id}/analytics"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesListsItemsGetDriveItemRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	listItemId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesListsItemsGetDriveItemRequest) Select_(select_ []string) ApiSitesListsItemsGetDriveItemRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesListsItemsGetDriveItemRequest) Expand(expand []string) ApiSitesListsItemsGetDriveItemRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesListsItemsGetDriveItemRequest) Execute() (MicrosoftGraphDriveItem, *_nethttp.Response, error) {
	return r.ApiService.SitesListsItemsGetDriveItemExecute(r)
}

/*
SitesListsItemsGetDriveItem Get driveItem from sites

For document libraries, the driveItem relationship exposes the listItem as a [driveItem][]

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param listItemId key: id of listItem
 @return ApiSitesListsItemsGetDriveItemRequest
*/
func (a *SitesListApiService) SitesListsItemsGetDriveItem(ctx _context.Context, siteId string, listId string, listItemId string) ApiSitesListsItemsGetDriveItemRequest {
	return ApiSitesListsItemsGetDriveItemRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		listItemId: listItemId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphDriveItem
func (a *SitesListApiService) SitesListsItemsGetDriveItemExecute(r ApiSitesListsItemsGetDriveItemRequest) (MicrosoftGraphDriveItem, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphDriveItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsItemsGetDriveItem")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/items/{listItem-id}/driveItem"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesListsItemsGetDriveItemContentRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	listItemId string
}


func (r ApiSitesListsItemsGetDriveItemContentRequest) Execute() (*os.File, *_nethttp.Response, error) {
	return r.ApiService.SitesListsItemsGetDriveItemContentExecute(r)
}

/*
SitesListsItemsGetDriveItemContent Get media content for the navigation property driveItem from sites

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param listItemId key: id of listItem
 @return ApiSitesListsItemsGetDriveItemContentRequest
*/
func (a *SitesListApiService) SitesListsItemsGetDriveItemContent(ctx _context.Context, siteId string, listId string, listItemId string) ApiSitesListsItemsGetDriveItemContentRequest {
	return ApiSitesListsItemsGetDriveItemContentRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		listItemId: listItemId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *SitesListApiService) SitesListsItemsGetDriveItemContentExecute(r ApiSitesListsItemsGetDriveItemContentRequest) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsItemsGetDriveItemContent")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/items/{listItem-id}/driveItem/content"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesListsItemsGetFieldsRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	listItemId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesListsItemsGetFieldsRequest) Select_(select_ []string) ApiSitesListsItemsGetFieldsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesListsItemsGetFieldsRequest) Expand(expand []string) ApiSitesListsItemsGetFieldsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesListsItemsGetFieldsRequest) Execute() (MicrosoftGraphFieldValueSet, *_nethttp.Response, error) {
	return r.ApiService.SitesListsItemsGetFieldsExecute(r)
}

/*
SitesListsItemsGetFields Get fields from sites

The values of the columns set on this list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param listItemId key: id of listItem
 @return ApiSitesListsItemsGetFieldsRequest
*/
func (a *SitesListApiService) SitesListsItemsGetFields(ctx _context.Context, siteId string, listId string, listItemId string) ApiSitesListsItemsGetFieldsRequest {
	return ApiSitesListsItemsGetFieldsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		listItemId: listItemId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphFieldValueSet
func (a *SitesListApiService) SitesListsItemsGetFieldsExecute(r ApiSitesListsItemsGetFieldsRequest) (MicrosoftGraphFieldValueSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphFieldValueSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsItemsGetFields")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/items/{listItem-id}/fields"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesListsItemsGetRefAnalyticsRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	listItemId string
}


func (r ApiSitesListsItemsGetRefAnalyticsRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SitesListsItemsGetRefAnalyticsExecute(r)
}

/*
SitesListsItemsGetRefAnalytics Get ref of analytics from sites

Analytics about the view activities that took place on this item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param listItemId key: id of listItem
 @return ApiSitesListsItemsGetRefAnalyticsRequest
*/
func (a *SitesListApiService) SitesListsItemsGetRefAnalytics(ctx _context.Context, siteId string, listId string, listItemId string) ApiSitesListsItemsGetRefAnalyticsRequest {
	return ApiSitesListsItemsGetRefAnalyticsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		listItemId: listItemId,
	}
}

// Execute executes the request
//  @return string
func (a *SitesListApiService) SitesListsItemsGetRefAnalyticsExecute(r ApiSitesListsItemsGetRefAnalyticsRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsItemsGetRefAnalytics")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/items/{listItem-id}/analytics/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesListsItemsGetVersionsRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	listItemId string
	listItemVersionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesListsItemsGetVersionsRequest) Select_(select_ []string) ApiSitesListsItemsGetVersionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesListsItemsGetVersionsRequest) Expand(expand []string) ApiSitesListsItemsGetVersionsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesListsItemsGetVersionsRequest) Execute() (MicrosoftGraphListItemVersion, *_nethttp.Response, error) {
	return r.ApiService.SitesListsItemsGetVersionsExecute(r)
}

/*
SitesListsItemsGetVersions Get versions from sites

The list of previous versions of the list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param listItemId key: id of listItem
 @param listItemVersionId key: id of listItemVersion
 @return ApiSitesListsItemsGetVersionsRequest
*/
func (a *SitesListApiService) SitesListsItemsGetVersions(ctx _context.Context, siteId string, listId string, listItemId string, listItemVersionId string) ApiSitesListsItemsGetVersionsRequest {
	return ApiSitesListsItemsGetVersionsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		listItemId: listItemId,
		listItemVersionId: listItemVersionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphListItemVersion
func (a *SitesListApiService) SitesListsItemsGetVersionsExecute(r ApiSitesListsItemsGetVersionsRequest) (MicrosoftGraphListItemVersion, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphListItemVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsItemsGetVersions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/items/{listItem-id}/versions/{listItemVersion-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItemVersion-id"+"}", _neturl.PathEscape(parameterToString(r.listItemVersionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesListsItemsListVersionsRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	listItemId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesListsItemsListVersionsRequest) Top(top int32) ApiSitesListsItemsListVersionsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesListsItemsListVersionsRequest) Skip(skip int32) ApiSitesListsItemsListVersionsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesListsItemsListVersionsRequest) Search(search string) ApiSitesListsItemsListVersionsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesListsItemsListVersionsRequest) Filter(filter string) ApiSitesListsItemsListVersionsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesListsItemsListVersionsRequest) Count(count bool) ApiSitesListsItemsListVersionsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesListsItemsListVersionsRequest) Orderby(orderby []string) ApiSitesListsItemsListVersionsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesListsItemsListVersionsRequest) Select_(select_ []string) ApiSitesListsItemsListVersionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesListsItemsListVersionsRequest) Expand(expand []string) ApiSitesListsItemsListVersionsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesListsItemsListVersionsRequest) Execute() (CollectionOfListItemVersion, *_nethttp.Response, error) {
	return r.ApiService.SitesListsItemsListVersionsExecute(r)
}

/*
SitesListsItemsListVersions Get versions from sites

The list of previous versions of the list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param listItemId key: id of listItem
 @return ApiSitesListsItemsListVersionsRequest
*/
func (a *SitesListApiService) SitesListsItemsListVersions(ctx _context.Context, siteId string, listId string, listItemId string) ApiSitesListsItemsListVersionsRequest {
	return ApiSitesListsItemsListVersionsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		listItemId: listItemId,
	}
}

// Execute executes the request
//  @return CollectionOfListItemVersion
func (a *SitesListApiService) SitesListsItemsListVersionsExecute(r ApiSitesListsItemsListVersionsRequest) (CollectionOfListItemVersion, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfListItemVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsItemsListVersions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/items/{listItem-id}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesListsItemsUpdateDriveItemRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	listItemId string
	microsoftGraphDriveItem *MicrosoftGraphDriveItem
}

// New navigation property values
func (r ApiSitesListsItemsUpdateDriveItemRequest) MicrosoftGraphDriveItem(microsoftGraphDriveItem MicrosoftGraphDriveItem) ApiSitesListsItemsUpdateDriveItemRequest {
	r.microsoftGraphDriveItem = &microsoftGraphDriveItem
	return r
}

func (r ApiSitesListsItemsUpdateDriveItemRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesListsItemsUpdateDriveItemExecute(r)
}

/*
SitesListsItemsUpdateDriveItem Update the navigation property driveItem in sites

For document libraries, the driveItem relationship exposes the listItem as a [driveItem][]

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param listItemId key: id of listItem
 @return ApiSitesListsItemsUpdateDriveItemRequest
*/
func (a *SitesListApiService) SitesListsItemsUpdateDriveItem(ctx _context.Context, siteId string, listId string, listItemId string) ApiSitesListsItemsUpdateDriveItemRequest {
	return ApiSitesListsItemsUpdateDriveItemRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		listItemId: listItemId,
	}
}

// Execute executes the request
func (a *SitesListApiService) SitesListsItemsUpdateDriveItemExecute(r ApiSitesListsItemsUpdateDriveItemRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsItemsUpdateDriveItem")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/items/{listItem-id}/driveItem"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphDriveItem == nil {
		return nil, reportError("microsoftGraphDriveItem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphDriveItem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesListsItemsUpdateDriveItemContentRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	listItemId string
	body **os.File
}

// New media content.
func (r ApiSitesListsItemsUpdateDriveItemContentRequest) Body(body *os.File) ApiSitesListsItemsUpdateDriveItemContentRequest {
	r.body = &body
	return r
}

func (r ApiSitesListsItemsUpdateDriveItemContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesListsItemsUpdateDriveItemContentExecute(r)
}

/*
SitesListsItemsUpdateDriveItemContent Update media content for the navigation property driveItem in sites

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param listItemId key: id of listItem
 @return ApiSitesListsItemsUpdateDriveItemContentRequest
*/
func (a *SitesListApiService) SitesListsItemsUpdateDriveItemContent(ctx _context.Context, siteId string, listId string, listItemId string) ApiSitesListsItemsUpdateDriveItemContentRequest {
	return ApiSitesListsItemsUpdateDriveItemContentRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		listItemId: listItemId,
	}
}

// Execute executes the request
func (a *SitesListApiService) SitesListsItemsUpdateDriveItemContentExecute(r ApiSitesListsItemsUpdateDriveItemContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsItemsUpdateDriveItemContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/items/{listItem-id}/driveItem/content"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesListsItemsUpdateFieldsRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	listItemId string
	microsoftGraphFieldValueSet *MicrosoftGraphFieldValueSet
}

// New navigation property values
func (r ApiSitesListsItemsUpdateFieldsRequest) MicrosoftGraphFieldValueSet(microsoftGraphFieldValueSet MicrosoftGraphFieldValueSet) ApiSitesListsItemsUpdateFieldsRequest {
	r.microsoftGraphFieldValueSet = &microsoftGraphFieldValueSet
	return r
}

func (r ApiSitesListsItemsUpdateFieldsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesListsItemsUpdateFieldsExecute(r)
}

/*
SitesListsItemsUpdateFields Update the navigation property fields in sites

The values of the columns set on this list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param listItemId key: id of listItem
 @return ApiSitesListsItemsUpdateFieldsRequest
*/
func (a *SitesListApiService) SitesListsItemsUpdateFields(ctx _context.Context, siteId string, listId string, listItemId string) ApiSitesListsItemsUpdateFieldsRequest {
	return ApiSitesListsItemsUpdateFieldsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		listItemId: listItemId,
	}
}

// Execute executes the request
func (a *SitesListApiService) SitesListsItemsUpdateFieldsExecute(r ApiSitesListsItemsUpdateFieldsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsItemsUpdateFields")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/items/{listItem-id}/fields"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphFieldValueSet == nil {
		return nil, reportError("microsoftGraphFieldValueSet is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphFieldValueSet
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesListsItemsUpdateRefAnalyticsRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	listItemId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSitesListsItemsUpdateRefAnalyticsRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesListsItemsUpdateRefAnalyticsRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesListsItemsUpdateRefAnalyticsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesListsItemsUpdateRefAnalyticsExecute(r)
}

/*
SitesListsItemsUpdateRefAnalytics Update the ref of navigation property analytics in sites

Analytics about the view activities that took place on this item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param listItemId key: id of listItem
 @return ApiSitesListsItemsUpdateRefAnalyticsRequest
*/
func (a *SitesListApiService) SitesListsItemsUpdateRefAnalytics(ctx _context.Context, siteId string, listId string, listItemId string) ApiSitesListsItemsUpdateRefAnalyticsRequest {
	return ApiSitesListsItemsUpdateRefAnalyticsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		listItemId: listItemId,
	}
}

// Execute executes the request
func (a *SitesListApiService) SitesListsItemsUpdateRefAnalyticsExecute(r ApiSitesListsItemsUpdateRefAnalyticsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsItemsUpdateRefAnalytics")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/items/{listItem-id}/analytics/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesListsItemsUpdateVersionsRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	listItemId string
	listItemVersionId string
	microsoftGraphListItemVersion *MicrosoftGraphListItemVersion
}

// New navigation property values
func (r ApiSitesListsItemsUpdateVersionsRequest) MicrosoftGraphListItemVersion(microsoftGraphListItemVersion MicrosoftGraphListItemVersion) ApiSitesListsItemsUpdateVersionsRequest {
	r.microsoftGraphListItemVersion = &microsoftGraphListItemVersion
	return r
}

func (r ApiSitesListsItemsUpdateVersionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesListsItemsUpdateVersionsExecute(r)
}

/*
SitesListsItemsUpdateVersions Update the navigation property versions in sites

The list of previous versions of the list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param listItemId key: id of listItem
 @param listItemVersionId key: id of listItemVersion
 @return ApiSitesListsItemsUpdateVersionsRequest
*/
func (a *SitesListApiService) SitesListsItemsUpdateVersions(ctx _context.Context, siteId string, listId string, listItemId string, listItemVersionId string) ApiSitesListsItemsUpdateVersionsRequest {
	return ApiSitesListsItemsUpdateVersionsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		listItemId: listItemId,
		listItemVersionId: listItemVersionId,
	}
}

// Execute executes the request
func (a *SitesListApiService) SitesListsItemsUpdateVersionsExecute(r ApiSitesListsItemsUpdateVersionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsItemsUpdateVersions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/items/{listItem-id}/versions/{listItemVersion-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItemVersion-id"+"}", _neturl.PathEscape(parameterToString(r.listItemVersionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphListItemVersion == nil {
		return nil, reportError("microsoftGraphListItemVersion is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphListItemVersion
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesListsItemsVersionsDeleteFieldsRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	listItemId string
	listItemVersionId string
	ifMatch *string
}

// ETag
func (r ApiSitesListsItemsVersionsDeleteFieldsRequest) IfMatch(ifMatch string) ApiSitesListsItemsVersionsDeleteFieldsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesListsItemsVersionsDeleteFieldsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesListsItemsVersionsDeleteFieldsExecute(r)
}

/*
SitesListsItemsVersionsDeleteFields Delete navigation property fields for sites

A collection of the fields and values for this version of the list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param listItemId key: id of listItem
 @param listItemVersionId key: id of listItemVersion
 @return ApiSitesListsItemsVersionsDeleteFieldsRequest
*/
func (a *SitesListApiService) SitesListsItemsVersionsDeleteFields(ctx _context.Context, siteId string, listId string, listItemId string, listItemVersionId string) ApiSitesListsItemsVersionsDeleteFieldsRequest {
	return ApiSitesListsItemsVersionsDeleteFieldsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		listItemId: listItemId,
		listItemVersionId: listItemVersionId,
	}
}

// Execute executes the request
func (a *SitesListApiService) SitesListsItemsVersionsDeleteFieldsExecute(r ApiSitesListsItemsVersionsDeleteFieldsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsItemsVersionsDeleteFields")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/items/{listItem-id}/versions/{listItemVersion-id}/fields"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItemVersion-id"+"}", _neturl.PathEscape(parameterToString(r.listItemVersionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesListsItemsVersionsGetFieldsRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	listItemId string
	listItemVersionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesListsItemsVersionsGetFieldsRequest) Select_(select_ []string) ApiSitesListsItemsVersionsGetFieldsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesListsItemsVersionsGetFieldsRequest) Expand(expand []string) ApiSitesListsItemsVersionsGetFieldsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesListsItemsVersionsGetFieldsRequest) Execute() (MicrosoftGraphFieldValueSet, *_nethttp.Response, error) {
	return r.ApiService.SitesListsItemsVersionsGetFieldsExecute(r)
}

/*
SitesListsItemsVersionsGetFields Get fields from sites

A collection of the fields and values for this version of the list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param listItemId key: id of listItem
 @param listItemVersionId key: id of listItemVersion
 @return ApiSitesListsItemsVersionsGetFieldsRequest
*/
func (a *SitesListApiService) SitesListsItemsVersionsGetFields(ctx _context.Context, siteId string, listId string, listItemId string, listItemVersionId string) ApiSitesListsItemsVersionsGetFieldsRequest {
	return ApiSitesListsItemsVersionsGetFieldsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		listItemId: listItemId,
		listItemVersionId: listItemVersionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphFieldValueSet
func (a *SitesListApiService) SitesListsItemsVersionsGetFieldsExecute(r ApiSitesListsItemsVersionsGetFieldsRequest) (MicrosoftGraphFieldValueSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphFieldValueSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsItemsVersionsGetFields")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/items/{listItem-id}/versions/{listItemVersion-id}/fields"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItemVersion-id"+"}", _neturl.PathEscape(parameterToString(r.listItemVersionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesListsItemsVersionsUpdateFieldsRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	listItemId string
	listItemVersionId string
	microsoftGraphFieldValueSet *MicrosoftGraphFieldValueSet
}

// New navigation property values
func (r ApiSitesListsItemsVersionsUpdateFieldsRequest) MicrosoftGraphFieldValueSet(microsoftGraphFieldValueSet MicrosoftGraphFieldValueSet) ApiSitesListsItemsVersionsUpdateFieldsRequest {
	r.microsoftGraphFieldValueSet = &microsoftGraphFieldValueSet
	return r
}

func (r ApiSitesListsItemsVersionsUpdateFieldsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesListsItemsVersionsUpdateFieldsExecute(r)
}

/*
SitesListsItemsVersionsUpdateFields Update the navigation property fields in sites

A collection of the fields and values for this version of the list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param listItemId key: id of listItem
 @param listItemVersionId key: id of listItemVersion
 @return ApiSitesListsItemsVersionsUpdateFieldsRequest
*/
func (a *SitesListApiService) SitesListsItemsVersionsUpdateFields(ctx _context.Context, siteId string, listId string, listItemId string, listItemVersionId string) ApiSitesListsItemsVersionsUpdateFieldsRequest {
	return ApiSitesListsItemsVersionsUpdateFieldsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		listItemId: listItemId,
		listItemVersionId: listItemVersionId,
	}
}

// Execute executes the request
func (a *SitesListApiService) SitesListsItemsVersionsUpdateFieldsExecute(r ApiSitesListsItemsVersionsUpdateFieldsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsItemsVersionsUpdateFields")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/items/{listItem-id}/versions/{listItemVersion-id}/fields"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItemVersion-id"+"}", _neturl.PathEscape(parameterToString(r.listItemVersionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphFieldValueSet == nil {
		return nil, reportError("microsoftGraphFieldValueSet is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphFieldValueSet
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesListsListColumnsRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesListsListColumnsRequest) Top(top int32) ApiSitesListsListColumnsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesListsListColumnsRequest) Skip(skip int32) ApiSitesListsListColumnsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesListsListColumnsRequest) Search(search string) ApiSitesListsListColumnsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesListsListColumnsRequest) Filter(filter string) ApiSitesListsListColumnsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesListsListColumnsRequest) Count(count bool) ApiSitesListsListColumnsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesListsListColumnsRequest) Orderby(orderby []string) ApiSitesListsListColumnsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesListsListColumnsRequest) Select_(select_ []string) ApiSitesListsListColumnsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesListsListColumnsRequest) Expand(expand []string) ApiSitesListsListColumnsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesListsListColumnsRequest) Execute() (CollectionOfColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.SitesListsListColumnsExecute(r)
}

/*
SitesListsListColumns Get columns from sites

The collection of field definitions for this list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @return ApiSitesListsListColumnsRequest
*/
func (a *SitesListApiService) SitesListsListColumns(ctx _context.Context, siteId string, listId string) ApiSitesListsListColumnsRequest {
	return ApiSitesListsListColumnsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
	}
}

// Execute executes the request
//  @return CollectionOfColumnDefinition
func (a *SitesListApiService) SitesListsListColumnsExecute(r ApiSitesListsListColumnsRequest) (CollectionOfColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsListColumns")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/columns"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesListsListContentTypesRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesListsListContentTypesRequest) Top(top int32) ApiSitesListsListContentTypesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesListsListContentTypesRequest) Skip(skip int32) ApiSitesListsListContentTypesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesListsListContentTypesRequest) Search(search string) ApiSitesListsListContentTypesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesListsListContentTypesRequest) Filter(filter string) ApiSitesListsListContentTypesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesListsListContentTypesRequest) Count(count bool) ApiSitesListsListContentTypesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesListsListContentTypesRequest) Orderby(orderby []string) ApiSitesListsListContentTypesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesListsListContentTypesRequest) Select_(select_ []string) ApiSitesListsListContentTypesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesListsListContentTypesRequest) Expand(expand []string) ApiSitesListsListContentTypesRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesListsListContentTypesRequest) Execute() (CollectionOfContentType, *_nethttp.Response, error) {
	return r.ApiService.SitesListsListContentTypesExecute(r)
}

/*
SitesListsListContentTypes Get contentTypes from sites

The collection of content types present in this list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @return ApiSitesListsListContentTypesRequest
*/
func (a *SitesListApiService) SitesListsListContentTypes(ctx _context.Context, siteId string, listId string) ApiSitesListsListContentTypesRequest {
	return ApiSitesListsListContentTypesRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
	}
}

// Execute executes the request
//  @return CollectionOfContentType
func (a *SitesListApiService) SitesListsListContentTypesExecute(r ApiSitesListsListContentTypesRequest) (CollectionOfContentType, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfContentType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsListContentTypes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/contentTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesListsListItemsRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesListsListItemsRequest) Top(top int32) ApiSitesListsListItemsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesListsListItemsRequest) Skip(skip int32) ApiSitesListsListItemsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesListsListItemsRequest) Search(search string) ApiSitesListsListItemsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesListsListItemsRequest) Filter(filter string) ApiSitesListsListItemsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesListsListItemsRequest) Count(count bool) ApiSitesListsListItemsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesListsListItemsRequest) Orderby(orderby []string) ApiSitesListsListItemsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesListsListItemsRequest) Select_(select_ []string) ApiSitesListsListItemsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesListsListItemsRequest) Expand(expand []string) ApiSitesListsListItemsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesListsListItemsRequest) Execute() (CollectionOfListItem, *_nethttp.Response, error) {
	return r.ApiService.SitesListsListItemsExecute(r)
}

/*
SitesListsListItems Get items from sites

All items contained in the list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @return ApiSitesListsListItemsRequest
*/
func (a *SitesListApiService) SitesListsListItems(ctx _context.Context, siteId string, listId string) ApiSitesListsListItemsRequest {
	return ApiSitesListsListItemsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
	}
}

// Execute executes the request
//  @return CollectionOfListItem
func (a *SitesListApiService) SitesListsListItemsExecute(r ApiSitesListsListItemsRequest) (CollectionOfListItem, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfListItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsListItems")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/items"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesListsListSubscriptionsRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesListsListSubscriptionsRequest) Top(top int32) ApiSitesListsListSubscriptionsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesListsListSubscriptionsRequest) Skip(skip int32) ApiSitesListsListSubscriptionsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesListsListSubscriptionsRequest) Search(search string) ApiSitesListsListSubscriptionsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesListsListSubscriptionsRequest) Filter(filter string) ApiSitesListsListSubscriptionsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesListsListSubscriptionsRequest) Count(count bool) ApiSitesListsListSubscriptionsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesListsListSubscriptionsRequest) Orderby(orderby []string) ApiSitesListsListSubscriptionsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesListsListSubscriptionsRequest) Select_(select_ []string) ApiSitesListsListSubscriptionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesListsListSubscriptionsRequest) Expand(expand []string) ApiSitesListsListSubscriptionsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesListsListSubscriptionsRequest) Execute() (CollectionOfSubscription, *_nethttp.Response, error) {
	return r.ApiService.SitesListsListSubscriptionsExecute(r)
}

/*
SitesListsListSubscriptions Get subscriptions from sites

The set of subscriptions on the list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @return ApiSitesListsListSubscriptionsRequest
*/
func (a *SitesListApiService) SitesListsListSubscriptions(ctx _context.Context, siteId string, listId string) ApiSitesListsListSubscriptionsRequest {
	return ApiSitesListsListSubscriptionsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
	}
}

// Execute executes the request
//  @return CollectionOfSubscription
func (a *SitesListApiService) SitesListsListSubscriptionsExecute(r ApiSitesListsListSubscriptionsRequest) (CollectionOfSubscription, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfSubscription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsListSubscriptions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/subscriptions"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesListsUpdateColumnsRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	columnDefinitionId string
	microsoftGraphColumnDefinition *MicrosoftGraphColumnDefinition
}

// New navigation property values
func (r ApiSitesListsUpdateColumnsRequest) MicrosoftGraphColumnDefinition(microsoftGraphColumnDefinition MicrosoftGraphColumnDefinition) ApiSitesListsUpdateColumnsRequest {
	r.microsoftGraphColumnDefinition = &microsoftGraphColumnDefinition
	return r
}

func (r ApiSitesListsUpdateColumnsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesListsUpdateColumnsExecute(r)
}

/*
SitesListsUpdateColumns Update the navigation property columns in sites

The collection of field definitions for this list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param columnDefinitionId key: id of columnDefinition
 @return ApiSitesListsUpdateColumnsRequest
*/
func (a *SitesListApiService) SitesListsUpdateColumns(ctx _context.Context, siteId string, listId string, columnDefinitionId string) ApiSitesListsUpdateColumnsRequest {
	return ApiSitesListsUpdateColumnsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
func (a *SitesListApiService) SitesListsUpdateColumnsExecute(r ApiSitesListsUpdateColumnsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsUpdateColumns")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/columns/{columnDefinition-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphColumnDefinition == nil {
		return nil, reportError("microsoftGraphColumnDefinition is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphColumnDefinition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesListsUpdateContentTypesRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	contentTypeId string
	microsoftGraphContentType *MicrosoftGraphContentType
}

// New navigation property values
func (r ApiSitesListsUpdateContentTypesRequest) MicrosoftGraphContentType(microsoftGraphContentType MicrosoftGraphContentType) ApiSitesListsUpdateContentTypesRequest {
	r.microsoftGraphContentType = &microsoftGraphContentType
	return r
}

func (r ApiSitesListsUpdateContentTypesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesListsUpdateContentTypesExecute(r)
}

/*
SitesListsUpdateContentTypes Update the navigation property contentTypes in sites

The collection of content types present in this list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param contentTypeId key: id of contentType
 @return ApiSitesListsUpdateContentTypesRequest
*/
func (a *SitesListApiService) SitesListsUpdateContentTypes(ctx _context.Context, siteId string, listId string, contentTypeId string) ApiSitesListsUpdateContentTypesRequest {
	return ApiSitesListsUpdateContentTypesRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
func (a *SitesListApiService) SitesListsUpdateContentTypesExecute(r ApiSitesListsUpdateContentTypesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsUpdateContentTypes")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/contentTypes/{contentType-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphContentType == nil {
		return nil, reportError("microsoftGraphContentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphContentType
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesListsUpdateDriveRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	microsoftGraphDrive *MicrosoftGraphDrive
}

// New navigation property values
func (r ApiSitesListsUpdateDriveRequest) MicrosoftGraphDrive(microsoftGraphDrive MicrosoftGraphDrive) ApiSitesListsUpdateDriveRequest {
	r.microsoftGraphDrive = &microsoftGraphDrive
	return r
}

func (r ApiSitesListsUpdateDriveRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesListsUpdateDriveExecute(r)
}

/*
SitesListsUpdateDrive Update the navigation property drive in sites

Only present on document libraries. Allows access to the list as a [drive][] resource with [driveItems][driveItem].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @return ApiSitesListsUpdateDriveRequest
*/
func (a *SitesListApiService) SitesListsUpdateDrive(ctx _context.Context, siteId string, listId string) ApiSitesListsUpdateDriveRequest {
	return ApiSitesListsUpdateDriveRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
	}
}

// Execute executes the request
func (a *SitesListApiService) SitesListsUpdateDriveExecute(r ApiSitesListsUpdateDriveRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsUpdateDrive")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/drive"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphDrive == nil {
		return nil, reportError("microsoftGraphDrive is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphDrive
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesListsUpdateItemsRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	listItemId string
	microsoftGraphListItem *MicrosoftGraphListItem
}

// New navigation property values
func (r ApiSitesListsUpdateItemsRequest) MicrosoftGraphListItem(microsoftGraphListItem MicrosoftGraphListItem) ApiSitesListsUpdateItemsRequest {
	r.microsoftGraphListItem = &microsoftGraphListItem
	return r
}

func (r ApiSitesListsUpdateItemsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesListsUpdateItemsExecute(r)
}

/*
SitesListsUpdateItems Update the navigation property items in sites

All items contained in the list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param listItemId key: id of listItem
 @return ApiSitesListsUpdateItemsRequest
*/
func (a *SitesListApiService) SitesListsUpdateItems(ctx _context.Context, siteId string, listId string, listItemId string) ApiSitesListsUpdateItemsRequest {
	return ApiSitesListsUpdateItemsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		listItemId: listItemId,
	}
}

// Execute executes the request
func (a *SitesListApiService) SitesListsUpdateItemsExecute(r ApiSitesListsUpdateItemsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsUpdateItems")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/items/{listItem-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphListItem == nil {
		return nil, reportError("microsoftGraphListItem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphListItem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesListsUpdateSubscriptionsRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	subscriptionId string
	microsoftGraphSubscription *MicrosoftGraphSubscription
}

// New navigation property values
func (r ApiSitesListsUpdateSubscriptionsRequest) MicrosoftGraphSubscription(microsoftGraphSubscription MicrosoftGraphSubscription) ApiSitesListsUpdateSubscriptionsRequest {
	r.microsoftGraphSubscription = &microsoftGraphSubscription
	return r
}

func (r ApiSitesListsUpdateSubscriptionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesListsUpdateSubscriptionsExecute(r)
}

/*
SitesListsUpdateSubscriptions Update the navigation property subscriptions in sites

The set of subscriptions on the list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @param subscriptionId key: id of subscription
 @return ApiSitesListsUpdateSubscriptionsRequest
*/
func (a *SitesListApiService) SitesListsUpdateSubscriptions(ctx _context.Context, siteId string, listId string, subscriptionId string) ApiSitesListsUpdateSubscriptionsRequest {
	return ApiSitesListsUpdateSubscriptionsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
		subscriptionId: subscriptionId,
	}
}

// Execute executes the request
func (a *SitesListApiService) SitesListsUpdateSubscriptionsExecute(r ApiSitesListsUpdateSubscriptionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesListsUpdateSubscriptions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}/subscriptions/{subscription-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscription-id"+"}", _neturl.PathEscape(parameterToString(r.subscriptionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphSubscription == nil {
		return nil, reportError("microsoftGraphSubscription is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphSubscription
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesUpdateListsRequest struct {
	ctx _context.Context
	ApiService *SitesListApiService
	siteId string
	listId string
	microsoftGraphList *MicrosoftGraphList
}

// New navigation property values
func (r ApiSitesUpdateListsRequest) MicrosoftGraphList(microsoftGraphList MicrosoftGraphList) ApiSitesUpdateListsRequest {
	r.microsoftGraphList = &microsoftGraphList
	return r
}

func (r ApiSitesUpdateListsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesUpdateListsExecute(r)
}

/*
SitesUpdateLists Update the navigation property lists in sites

The collection of lists under this site.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param listId key: id of list
 @return ApiSitesUpdateListsRequest
*/
func (a *SitesListApiService) SitesUpdateLists(ctx _context.Context, siteId string, listId string) ApiSitesUpdateListsRequest {
	return ApiSitesUpdateListsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		listId: listId,
	}
}

// Execute executes the request
func (a *SitesListApiService) SitesUpdateListsExecute(r ApiSitesUpdateListsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesListApiService.SitesUpdateLists")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/lists/{list-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list-id"+"}", _neturl.PathEscape(parameterToString(r.listId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphList == nil {
		return nil, reportError("microsoftGraphList is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphList
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
