/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// CommunicationsCallRecordApiService CommunicationsCallRecordApi service
type CommunicationsCallRecordApiService service

type ApiCommunicationsCallRecordsCreateSessionsRequest struct {
	ctx _context.Context
	ApiService *CommunicationsCallRecordApiService
	callRecordId string
	microsoftGraphCallRecordsSession *MicrosoftGraphCallRecordsSession
}

// New navigation property
func (r ApiCommunicationsCallRecordsCreateSessionsRequest) MicrosoftGraphCallRecordsSession(microsoftGraphCallRecordsSession MicrosoftGraphCallRecordsSession) ApiCommunicationsCallRecordsCreateSessionsRequest {
	r.microsoftGraphCallRecordsSession = &microsoftGraphCallRecordsSession
	return r
}

func (r ApiCommunicationsCallRecordsCreateSessionsRequest) Execute() (MicrosoftGraphCallRecordsSession, *_nethttp.Response, error) {
	return r.ApiService.CommunicationsCallRecordsCreateSessionsExecute(r)
}

/*
CommunicationsCallRecordsCreateSessions Create new navigation property to sessions for communications

List of sessions involved in the call. Peer-to-peer calls typically only have one session, whereas group calls typically have at least one session per participant. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callRecordId key: id of callRecord
 @return ApiCommunicationsCallRecordsCreateSessionsRequest
*/
func (a *CommunicationsCallRecordApiService) CommunicationsCallRecordsCreateSessions(ctx _context.Context, callRecordId string) ApiCommunicationsCallRecordsCreateSessionsRequest {
	return ApiCommunicationsCallRecordsCreateSessionsRequest{
		ApiService: a,
		ctx: ctx,
		callRecordId: callRecordId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphCallRecordsSession
func (a *CommunicationsCallRecordApiService) CommunicationsCallRecordsCreateSessionsExecute(r ApiCommunicationsCallRecordsCreateSessionsRequest) (MicrosoftGraphCallRecordsSession, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphCallRecordsSession
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsCallRecordApiService.CommunicationsCallRecordsCreateSessions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/callRecords/{callRecord-id}/sessions"
	localVarPath = strings.Replace(localVarPath, "{"+"callRecord-id"+"}", _neturl.PathEscape(parameterToString(r.callRecordId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphCallRecordsSession == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphCallRecordsSession is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphCallRecordsSession
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCommunicationsCallRecordsDeleteSessionsRequest struct {
	ctx _context.Context
	ApiService *CommunicationsCallRecordApiService
	callRecordId string
	sessionId string
	ifMatch *string
}

// ETag
func (r ApiCommunicationsCallRecordsDeleteSessionsRequest) IfMatch(ifMatch string) ApiCommunicationsCallRecordsDeleteSessionsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiCommunicationsCallRecordsDeleteSessionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CommunicationsCallRecordsDeleteSessionsExecute(r)
}

/*
CommunicationsCallRecordsDeleteSessions Delete navigation property sessions for communications

List of sessions involved in the call. Peer-to-peer calls typically only have one session, whereas group calls typically have at least one session per participant. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callRecordId key: id of callRecord
 @param sessionId key: id of session
 @return ApiCommunicationsCallRecordsDeleteSessionsRequest
*/
func (a *CommunicationsCallRecordApiService) CommunicationsCallRecordsDeleteSessions(ctx _context.Context, callRecordId string, sessionId string) ApiCommunicationsCallRecordsDeleteSessionsRequest {
	return ApiCommunicationsCallRecordsDeleteSessionsRequest{
		ApiService: a,
		ctx: ctx,
		callRecordId: callRecordId,
		sessionId: sessionId,
	}
}

// Execute executes the request
func (a *CommunicationsCallRecordApiService) CommunicationsCallRecordsDeleteSessionsExecute(r ApiCommunicationsCallRecordsDeleteSessionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsCallRecordApiService.CommunicationsCallRecordsDeleteSessions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/callRecords/{callRecord-id}/sessions/{session-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"callRecord-id"+"}", _neturl.PathEscape(parameterToString(r.callRecordId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"session-id"+"}", _neturl.PathEscape(parameterToString(r.sessionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCommunicationsCallRecordsGetSessionsRequest struct {
	ctx _context.Context
	ApiService *CommunicationsCallRecordApiService
	callRecordId string
	sessionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiCommunicationsCallRecordsGetSessionsRequest) Select_(select_ []string) ApiCommunicationsCallRecordsGetSessionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiCommunicationsCallRecordsGetSessionsRequest) Expand(expand []string) ApiCommunicationsCallRecordsGetSessionsRequest {
	r.expand = &expand
	return r
}

func (r ApiCommunicationsCallRecordsGetSessionsRequest) Execute() (MicrosoftGraphCallRecordsSession, *_nethttp.Response, error) {
	return r.ApiService.CommunicationsCallRecordsGetSessionsExecute(r)
}

/*
CommunicationsCallRecordsGetSessions Get sessions from communications

List of sessions involved in the call. Peer-to-peer calls typically only have one session, whereas group calls typically have at least one session per participant. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callRecordId key: id of callRecord
 @param sessionId key: id of session
 @return ApiCommunicationsCallRecordsGetSessionsRequest
*/
func (a *CommunicationsCallRecordApiService) CommunicationsCallRecordsGetSessions(ctx _context.Context, callRecordId string, sessionId string) ApiCommunicationsCallRecordsGetSessionsRequest {
	return ApiCommunicationsCallRecordsGetSessionsRequest{
		ApiService: a,
		ctx: ctx,
		callRecordId: callRecordId,
		sessionId: sessionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphCallRecordsSession
func (a *CommunicationsCallRecordApiService) CommunicationsCallRecordsGetSessionsExecute(r ApiCommunicationsCallRecordsGetSessionsRequest) (MicrosoftGraphCallRecordsSession, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphCallRecordsSession
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsCallRecordApiService.CommunicationsCallRecordsGetSessions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/callRecords/{callRecord-id}/sessions/{session-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"callRecord-id"+"}", _neturl.PathEscape(parameterToString(r.callRecordId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"session-id"+"}", _neturl.PathEscape(parameterToString(r.sessionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCommunicationsCallRecordsListSessionsRequest struct {
	ctx _context.Context
	ApiService *CommunicationsCallRecordApiService
	callRecordId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiCommunicationsCallRecordsListSessionsRequest) Top(top int32) ApiCommunicationsCallRecordsListSessionsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiCommunicationsCallRecordsListSessionsRequest) Skip(skip int32) ApiCommunicationsCallRecordsListSessionsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiCommunicationsCallRecordsListSessionsRequest) Search(search string) ApiCommunicationsCallRecordsListSessionsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiCommunicationsCallRecordsListSessionsRequest) Filter(filter string) ApiCommunicationsCallRecordsListSessionsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiCommunicationsCallRecordsListSessionsRequest) Count(count bool) ApiCommunicationsCallRecordsListSessionsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiCommunicationsCallRecordsListSessionsRequest) Orderby(orderby []string) ApiCommunicationsCallRecordsListSessionsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiCommunicationsCallRecordsListSessionsRequest) Select_(select_ []string) ApiCommunicationsCallRecordsListSessionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiCommunicationsCallRecordsListSessionsRequest) Expand(expand []string) ApiCommunicationsCallRecordsListSessionsRequest {
	r.expand = &expand
	return r
}

func (r ApiCommunicationsCallRecordsListSessionsRequest) Execute() (CollectionOfSession, *_nethttp.Response, error) {
	return r.ApiService.CommunicationsCallRecordsListSessionsExecute(r)
}

/*
CommunicationsCallRecordsListSessions Get sessions from communications

List of sessions involved in the call. Peer-to-peer calls typically only have one session, whereas group calls typically have at least one session per participant. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callRecordId key: id of callRecord
 @return ApiCommunicationsCallRecordsListSessionsRequest
*/
func (a *CommunicationsCallRecordApiService) CommunicationsCallRecordsListSessions(ctx _context.Context, callRecordId string) ApiCommunicationsCallRecordsListSessionsRequest {
	return ApiCommunicationsCallRecordsListSessionsRequest{
		ApiService: a,
		ctx: ctx,
		callRecordId: callRecordId,
	}
}

// Execute executes the request
//  @return CollectionOfSession
func (a *CommunicationsCallRecordApiService) CommunicationsCallRecordsListSessionsExecute(r ApiCommunicationsCallRecordsListSessionsRequest) (CollectionOfSession, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfSession
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsCallRecordApiService.CommunicationsCallRecordsListSessions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/callRecords/{callRecord-id}/sessions"
	localVarPath = strings.Replace(localVarPath, "{"+"callRecord-id"+"}", _neturl.PathEscape(parameterToString(r.callRecordId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCommunicationsCallRecordsSessionsCreateSegmentsRequest struct {
	ctx _context.Context
	ApiService *CommunicationsCallRecordApiService
	callRecordId string
	sessionId string
	microsoftGraphCallRecordsSegment *MicrosoftGraphCallRecordsSegment
}

// New navigation property
func (r ApiCommunicationsCallRecordsSessionsCreateSegmentsRequest) MicrosoftGraphCallRecordsSegment(microsoftGraphCallRecordsSegment MicrosoftGraphCallRecordsSegment) ApiCommunicationsCallRecordsSessionsCreateSegmentsRequest {
	r.microsoftGraphCallRecordsSegment = &microsoftGraphCallRecordsSegment
	return r
}

func (r ApiCommunicationsCallRecordsSessionsCreateSegmentsRequest) Execute() (MicrosoftGraphCallRecordsSegment, *_nethttp.Response, error) {
	return r.ApiService.CommunicationsCallRecordsSessionsCreateSegmentsExecute(r)
}

/*
CommunicationsCallRecordsSessionsCreateSegments Create new navigation property to segments for communications

The list of segments involved in the session. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callRecordId key: id of callRecord
 @param sessionId key: id of session
 @return ApiCommunicationsCallRecordsSessionsCreateSegmentsRequest
*/
func (a *CommunicationsCallRecordApiService) CommunicationsCallRecordsSessionsCreateSegments(ctx _context.Context, callRecordId string, sessionId string) ApiCommunicationsCallRecordsSessionsCreateSegmentsRequest {
	return ApiCommunicationsCallRecordsSessionsCreateSegmentsRequest{
		ApiService: a,
		ctx: ctx,
		callRecordId: callRecordId,
		sessionId: sessionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphCallRecordsSegment
func (a *CommunicationsCallRecordApiService) CommunicationsCallRecordsSessionsCreateSegmentsExecute(r ApiCommunicationsCallRecordsSessionsCreateSegmentsRequest) (MicrosoftGraphCallRecordsSegment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphCallRecordsSegment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsCallRecordApiService.CommunicationsCallRecordsSessionsCreateSegments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/callRecords/{callRecord-id}/sessions/{session-id}/segments"
	localVarPath = strings.Replace(localVarPath, "{"+"callRecord-id"+"}", _neturl.PathEscape(parameterToString(r.callRecordId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"session-id"+"}", _neturl.PathEscape(parameterToString(r.sessionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphCallRecordsSegment == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphCallRecordsSegment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphCallRecordsSegment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCommunicationsCallRecordsSessionsDeleteSegmentsRequest struct {
	ctx _context.Context
	ApiService *CommunicationsCallRecordApiService
	callRecordId string
	sessionId string
	segmentId string
	ifMatch *string
}

// ETag
func (r ApiCommunicationsCallRecordsSessionsDeleteSegmentsRequest) IfMatch(ifMatch string) ApiCommunicationsCallRecordsSessionsDeleteSegmentsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiCommunicationsCallRecordsSessionsDeleteSegmentsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CommunicationsCallRecordsSessionsDeleteSegmentsExecute(r)
}

/*
CommunicationsCallRecordsSessionsDeleteSegments Delete navigation property segments for communications

The list of segments involved in the session. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callRecordId key: id of callRecord
 @param sessionId key: id of session
 @param segmentId key: id of segment
 @return ApiCommunicationsCallRecordsSessionsDeleteSegmentsRequest
*/
func (a *CommunicationsCallRecordApiService) CommunicationsCallRecordsSessionsDeleteSegments(ctx _context.Context, callRecordId string, sessionId string, segmentId string) ApiCommunicationsCallRecordsSessionsDeleteSegmentsRequest {
	return ApiCommunicationsCallRecordsSessionsDeleteSegmentsRequest{
		ApiService: a,
		ctx: ctx,
		callRecordId: callRecordId,
		sessionId: sessionId,
		segmentId: segmentId,
	}
}

// Execute executes the request
func (a *CommunicationsCallRecordApiService) CommunicationsCallRecordsSessionsDeleteSegmentsExecute(r ApiCommunicationsCallRecordsSessionsDeleteSegmentsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsCallRecordApiService.CommunicationsCallRecordsSessionsDeleteSegments")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/callRecords/{callRecord-id}/sessions/{session-id}/segments/{segment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"callRecord-id"+"}", _neturl.PathEscape(parameterToString(r.callRecordId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"session-id"+"}", _neturl.PathEscape(parameterToString(r.sessionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"segment-id"+"}", _neturl.PathEscape(parameterToString(r.segmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCommunicationsCallRecordsSessionsGetSegmentsRequest struct {
	ctx _context.Context
	ApiService *CommunicationsCallRecordApiService
	callRecordId string
	sessionId string
	segmentId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiCommunicationsCallRecordsSessionsGetSegmentsRequest) Select_(select_ []string) ApiCommunicationsCallRecordsSessionsGetSegmentsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiCommunicationsCallRecordsSessionsGetSegmentsRequest) Expand(expand []string) ApiCommunicationsCallRecordsSessionsGetSegmentsRequest {
	r.expand = &expand
	return r
}

func (r ApiCommunicationsCallRecordsSessionsGetSegmentsRequest) Execute() (MicrosoftGraphCallRecordsSegment, *_nethttp.Response, error) {
	return r.ApiService.CommunicationsCallRecordsSessionsGetSegmentsExecute(r)
}

/*
CommunicationsCallRecordsSessionsGetSegments Get segments from communications

The list of segments involved in the session. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callRecordId key: id of callRecord
 @param sessionId key: id of session
 @param segmentId key: id of segment
 @return ApiCommunicationsCallRecordsSessionsGetSegmentsRequest
*/
func (a *CommunicationsCallRecordApiService) CommunicationsCallRecordsSessionsGetSegments(ctx _context.Context, callRecordId string, sessionId string, segmentId string) ApiCommunicationsCallRecordsSessionsGetSegmentsRequest {
	return ApiCommunicationsCallRecordsSessionsGetSegmentsRequest{
		ApiService: a,
		ctx: ctx,
		callRecordId: callRecordId,
		sessionId: sessionId,
		segmentId: segmentId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphCallRecordsSegment
func (a *CommunicationsCallRecordApiService) CommunicationsCallRecordsSessionsGetSegmentsExecute(r ApiCommunicationsCallRecordsSessionsGetSegmentsRequest) (MicrosoftGraphCallRecordsSegment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphCallRecordsSegment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsCallRecordApiService.CommunicationsCallRecordsSessionsGetSegments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/callRecords/{callRecord-id}/sessions/{session-id}/segments/{segment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"callRecord-id"+"}", _neturl.PathEscape(parameterToString(r.callRecordId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"session-id"+"}", _neturl.PathEscape(parameterToString(r.sessionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"segment-id"+"}", _neturl.PathEscape(parameterToString(r.segmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCommunicationsCallRecordsSessionsListSegmentsRequest struct {
	ctx _context.Context
	ApiService *CommunicationsCallRecordApiService
	callRecordId string
	sessionId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiCommunicationsCallRecordsSessionsListSegmentsRequest) Top(top int32) ApiCommunicationsCallRecordsSessionsListSegmentsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiCommunicationsCallRecordsSessionsListSegmentsRequest) Skip(skip int32) ApiCommunicationsCallRecordsSessionsListSegmentsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiCommunicationsCallRecordsSessionsListSegmentsRequest) Search(search string) ApiCommunicationsCallRecordsSessionsListSegmentsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiCommunicationsCallRecordsSessionsListSegmentsRequest) Filter(filter string) ApiCommunicationsCallRecordsSessionsListSegmentsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiCommunicationsCallRecordsSessionsListSegmentsRequest) Count(count bool) ApiCommunicationsCallRecordsSessionsListSegmentsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiCommunicationsCallRecordsSessionsListSegmentsRequest) Orderby(orderby []string) ApiCommunicationsCallRecordsSessionsListSegmentsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiCommunicationsCallRecordsSessionsListSegmentsRequest) Select_(select_ []string) ApiCommunicationsCallRecordsSessionsListSegmentsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiCommunicationsCallRecordsSessionsListSegmentsRequest) Expand(expand []string) ApiCommunicationsCallRecordsSessionsListSegmentsRequest {
	r.expand = &expand
	return r
}

func (r ApiCommunicationsCallRecordsSessionsListSegmentsRequest) Execute() (CollectionOfSegment, *_nethttp.Response, error) {
	return r.ApiService.CommunicationsCallRecordsSessionsListSegmentsExecute(r)
}

/*
CommunicationsCallRecordsSessionsListSegments Get segments from communications

The list of segments involved in the session. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callRecordId key: id of callRecord
 @param sessionId key: id of session
 @return ApiCommunicationsCallRecordsSessionsListSegmentsRequest
*/
func (a *CommunicationsCallRecordApiService) CommunicationsCallRecordsSessionsListSegments(ctx _context.Context, callRecordId string, sessionId string) ApiCommunicationsCallRecordsSessionsListSegmentsRequest {
	return ApiCommunicationsCallRecordsSessionsListSegmentsRequest{
		ApiService: a,
		ctx: ctx,
		callRecordId: callRecordId,
		sessionId: sessionId,
	}
}

// Execute executes the request
//  @return CollectionOfSegment
func (a *CommunicationsCallRecordApiService) CommunicationsCallRecordsSessionsListSegmentsExecute(r ApiCommunicationsCallRecordsSessionsListSegmentsRequest) (CollectionOfSegment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfSegment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsCallRecordApiService.CommunicationsCallRecordsSessionsListSegments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/callRecords/{callRecord-id}/sessions/{session-id}/segments"
	localVarPath = strings.Replace(localVarPath, "{"+"callRecord-id"+"}", _neturl.PathEscape(parameterToString(r.callRecordId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"session-id"+"}", _neturl.PathEscape(parameterToString(r.sessionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCommunicationsCallRecordsSessionsUpdateSegmentsRequest struct {
	ctx _context.Context
	ApiService *CommunicationsCallRecordApiService
	callRecordId string
	sessionId string
	segmentId string
	microsoftGraphCallRecordsSegment *MicrosoftGraphCallRecordsSegment
}

// New navigation property values
func (r ApiCommunicationsCallRecordsSessionsUpdateSegmentsRequest) MicrosoftGraphCallRecordsSegment(microsoftGraphCallRecordsSegment MicrosoftGraphCallRecordsSegment) ApiCommunicationsCallRecordsSessionsUpdateSegmentsRequest {
	r.microsoftGraphCallRecordsSegment = &microsoftGraphCallRecordsSegment
	return r
}

func (r ApiCommunicationsCallRecordsSessionsUpdateSegmentsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CommunicationsCallRecordsSessionsUpdateSegmentsExecute(r)
}

/*
CommunicationsCallRecordsSessionsUpdateSegments Update the navigation property segments in communications

The list of segments involved in the session. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callRecordId key: id of callRecord
 @param sessionId key: id of session
 @param segmentId key: id of segment
 @return ApiCommunicationsCallRecordsSessionsUpdateSegmentsRequest
*/
func (a *CommunicationsCallRecordApiService) CommunicationsCallRecordsSessionsUpdateSegments(ctx _context.Context, callRecordId string, sessionId string, segmentId string) ApiCommunicationsCallRecordsSessionsUpdateSegmentsRequest {
	return ApiCommunicationsCallRecordsSessionsUpdateSegmentsRequest{
		ApiService: a,
		ctx: ctx,
		callRecordId: callRecordId,
		sessionId: sessionId,
		segmentId: segmentId,
	}
}

// Execute executes the request
func (a *CommunicationsCallRecordApiService) CommunicationsCallRecordsSessionsUpdateSegmentsExecute(r ApiCommunicationsCallRecordsSessionsUpdateSegmentsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsCallRecordApiService.CommunicationsCallRecordsSessionsUpdateSegments")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/callRecords/{callRecord-id}/sessions/{session-id}/segments/{segment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"callRecord-id"+"}", _neturl.PathEscape(parameterToString(r.callRecordId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"session-id"+"}", _neturl.PathEscape(parameterToString(r.sessionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"segment-id"+"}", _neturl.PathEscape(parameterToString(r.segmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphCallRecordsSegment == nil {
		return nil, reportError("microsoftGraphCallRecordsSegment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphCallRecordsSegment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCommunicationsCallRecordsUpdateSessionsRequest struct {
	ctx _context.Context
	ApiService *CommunicationsCallRecordApiService
	callRecordId string
	sessionId string
	microsoftGraphCallRecordsSession *MicrosoftGraphCallRecordsSession
}

// New navigation property values
func (r ApiCommunicationsCallRecordsUpdateSessionsRequest) MicrosoftGraphCallRecordsSession(microsoftGraphCallRecordsSession MicrosoftGraphCallRecordsSession) ApiCommunicationsCallRecordsUpdateSessionsRequest {
	r.microsoftGraphCallRecordsSession = &microsoftGraphCallRecordsSession
	return r
}

func (r ApiCommunicationsCallRecordsUpdateSessionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CommunicationsCallRecordsUpdateSessionsExecute(r)
}

/*
CommunicationsCallRecordsUpdateSessions Update the navigation property sessions in communications

List of sessions involved in the call. Peer-to-peer calls typically only have one session, whereas group calls typically have at least one session per participant. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callRecordId key: id of callRecord
 @param sessionId key: id of session
 @return ApiCommunicationsCallRecordsUpdateSessionsRequest
*/
func (a *CommunicationsCallRecordApiService) CommunicationsCallRecordsUpdateSessions(ctx _context.Context, callRecordId string, sessionId string) ApiCommunicationsCallRecordsUpdateSessionsRequest {
	return ApiCommunicationsCallRecordsUpdateSessionsRequest{
		ApiService: a,
		ctx: ctx,
		callRecordId: callRecordId,
		sessionId: sessionId,
	}
}

// Execute executes the request
func (a *CommunicationsCallRecordApiService) CommunicationsCallRecordsUpdateSessionsExecute(r ApiCommunicationsCallRecordsUpdateSessionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsCallRecordApiService.CommunicationsCallRecordsUpdateSessions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/callRecords/{callRecord-id}/sessions/{session-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"callRecord-id"+"}", _neturl.PathEscape(parameterToString(r.callRecordId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"session-id"+"}", _neturl.PathEscape(parameterToString(r.sessionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphCallRecordsSession == nil {
		return nil, reportError("microsoftGraphCallRecordsSession is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphCallRecordsSession
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCommunicationsCreateCallRecordsRequest struct {
	ctx _context.Context
	ApiService *CommunicationsCallRecordApiService
	microsoftGraphCallRecordsCallRecord *MicrosoftGraphCallRecordsCallRecord
}

// New navigation property
func (r ApiCommunicationsCreateCallRecordsRequest) MicrosoftGraphCallRecordsCallRecord(microsoftGraphCallRecordsCallRecord MicrosoftGraphCallRecordsCallRecord) ApiCommunicationsCreateCallRecordsRequest {
	r.microsoftGraphCallRecordsCallRecord = &microsoftGraphCallRecordsCallRecord
	return r
}

func (r ApiCommunicationsCreateCallRecordsRequest) Execute() (MicrosoftGraphCallRecordsCallRecord, *_nethttp.Response, error) {
	return r.ApiService.CommunicationsCreateCallRecordsExecute(r)
}

/*
CommunicationsCreateCallRecords Create new navigation property to callRecords for communications

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCommunicationsCreateCallRecordsRequest
*/
func (a *CommunicationsCallRecordApiService) CommunicationsCreateCallRecords(ctx _context.Context) ApiCommunicationsCreateCallRecordsRequest {
	return ApiCommunicationsCreateCallRecordsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphCallRecordsCallRecord
func (a *CommunicationsCallRecordApiService) CommunicationsCreateCallRecordsExecute(r ApiCommunicationsCreateCallRecordsRequest) (MicrosoftGraphCallRecordsCallRecord, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphCallRecordsCallRecord
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsCallRecordApiService.CommunicationsCreateCallRecords")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/callRecords"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphCallRecordsCallRecord == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphCallRecordsCallRecord is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphCallRecordsCallRecord
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCommunicationsDeleteCallRecordsRequest struct {
	ctx _context.Context
	ApiService *CommunicationsCallRecordApiService
	callRecordId string
	ifMatch *string
}

// ETag
func (r ApiCommunicationsDeleteCallRecordsRequest) IfMatch(ifMatch string) ApiCommunicationsDeleteCallRecordsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiCommunicationsDeleteCallRecordsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CommunicationsDeleteCallRecordsExecute(r)
}

/*
CommunicationsDeleteCallRecords Delete navigation property callRecords for communications

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callRecordId key: id of callRecord
 @return ApiCommunicationsDeleteCallRecordsRequest
*/
func (a *CommunicationsCallRecordApiService) CommunicationsDeleteCallRecords(ctx _context.Context, callRecordId string) ApiCommunicationsDeleteCallRecordsRequest {
	return ApiCommunicationsDeleteCallRecordsRequest{
		ApiService: a,
		ctx: ctx,
		callRecordId: callRecordId,
	}
}

// Execute executes the request
func (a *CommunicationsCallRecordApiService) CommunicationsDeleteCallRecordsExecute(r ApiCommunicationsDeleteCallRecordsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsCallRecordApiService.CommunicationsDeleteCallRecords")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/callRecords/{callRecord-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"callRecord-id"+"}", _neturl.PathEscape(parameterToString(r.callRecordId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCommunicationsGetCallRecordsRequest struct {
	ctx _context.Context
	ApiService *CommunicationsCallRecordApiService
	callRecordId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiCommunicationsGetCallRecordsRequest) Select_(select_ []string) ApiCommunicationsGetCallRecordsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiCommunicationsGetCallRecordsRequest) Expand(expand []string) ApiCommunicationsGetCallRecordsRequest {
	r.expand = &expand
	return r
}

func (r ApiCommunicationsGetCallRecordsRequest) Execute() (MicrosoftGraphCallRecordsCallRecord, *_nethttp.Response, error) {
	return r.ApiService.CommunicationsGetCallRecordsExecute(r)
}

/*
CommunicationsGetCallRecords Get callRecords from communications

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callRecordId key: id of callRecord
 @return ApiCommunicationsGetCallRecordsRequest
*/
func (a *CommunicationsCallRecordApiService) CommunicationsGetCallRecords(ctx _context.Context, callRecordId string) ApiCommunicationsGetCallRecordsRequest {
	return ApiCommunicationsGetCallRecordsRequest{
		ApiService: a,
		ctx: ctx,
		callRecordId: callRecordId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphCallRecordsCallRecord
func (a *CommunicationsCallRecordApiService) CommunicationsGetCallRecordsExecute(r ApiCommunicationsGetCallRecordsRequest) (MicrosoftGraphCallRecordsCallRecord, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphCallRecordsCallRecord
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsCallRecordApiService.CommunicationsGetCallRecords")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/callRecords/{callRecord-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"callRecord-id"+"}", _neturl.PathEscape(parameterToString(r.callRecordId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCommunicationsListCallRecordsRequest struct {
	ctx _context.Context
	ApiService *CommunicationsCallRecordApiService
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiCommunicationsListCallRecordsRequest) Top(top int32) ApiCommunicationsListCallRecordsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiCommunicationsListCallRecordsRequest) Skip(skip int32) ApiCommunicationsListCallRecordsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiCommunicationsListCallRecordsRequest) Search(search string) ApiCommunicationsListCallRecordsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiCommunicationsListCallRecordsRequest) Filter(filter string) ApiCommunicationsListCallRecordsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiCommunicationsListCallRecordsRequest) Count(count bool) ApiCommunicationsListCallRecordsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiCommunicationsListCallRecordsRequest) Orderby(orderby []string) ApiCommunicationsListCallRecordsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiCommunicationsListCallRecordsRequest) Select_(select_ []string) ApiCommunicationsListCallRecordsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiCommunicationsListCallRecordsRequest) Expand(expand []string) ApiCommunicationsListCallRecordsRequest {
	r.expand = &expand
	return r
}

func (r ApiCommunicationsListCallRecordsRequest) Execute() (CollectionOfCallRecord, *_nethttp.Response, error) {
	return r.ApiService.CommunicationsListCallRecordsExecute(r)
}

/*
CommunicationsListCallRecords Get callRecords from communications

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCommunicationsListCallRecordsRequest
*/
func (a *CommunicationsCallRecordApiService) CommunicationsListCallRecords(ctx _context.Context) ApiCommunicationsListCallRecordsRequest {
	return ApiCommunicationsListCallRecordsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionOfCallRecord
func (a *CommunicationsCallRecordApiService) CommunicationsListCallRecordsExecute(r ApiCommunicationsListCallRecordsRequest) (CollectionOfCallRecord, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfCallRecord
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsCallRecordApiService.CommunicationsListCallRecords")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/callRecords"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCommunicationsUpdateCallRecordsRequest struct {
	ctx _context.Context
	ApiService *CommunicationsCallRecordApiService
	callRecordId string
	microsoftGraphCallRecordsCallRecord *MicrosoftGraphCallRecordsCallRecord
}

// New navigation property values
func (r ApiCommunicationsUpdateCallRecordsRequest) MicrosoftGraphCallRecordsCallRecord(microsoftGraphCallRecordsCallRecord MicrosoftGraphCallRecordsCallRecord) ApiCommunicationsUpdateCallRecordsRequest {
	r.microsoftGraphCallRecordsCallRecord = &microsoftGraphCallRecordsCallRecord
	return r
}

func (r ApiCommunicationsUpdateCallRecordsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CommunicationsUpdateCallRecordsExecute(r)
}

/*
CommunicationsUpdateCallRecords Update the navigation property callRecords in communications

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callRecordId key: id of callRecord
 @return ApiCommunicationsUpdateCallRecordsRequest
*/
func (a *CommunicationsCallRecordApiService) CommunicationsUpdateCallRecords(ctx _context.Context, callRecordId string) ApiCommunicationsUpdateCallRecordsRequest {
	return ApiCommunicationsUpdateCallRecordsRequest{
		ApiService: a,
		ctx: ctx,
		callRecordId: callRecordId,
	}
}

// Execute executes the request
func (a *CommunicationsCallRecordApiService) CommunicationsUpdateCallRecordsExecute(r ApiCommunicationsUpdateCallRecordsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsCallRecordApiService.CommunicationsUpdateCallRecords")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/callRecords/{callRecord-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"callRecord-id"+"}", _neturl.PathEscape(parameterToString(r.callRecordId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphCallRecordsCallRecord == nil {
		return nil, reportError("microsoftGraphCallRecordsCallRecord is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphCallRecordsCallRecord
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
