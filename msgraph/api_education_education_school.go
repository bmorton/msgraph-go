/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package msgraph

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// EducationEducationSchoolApiService EducationEducationSchoolApi service
type EducationEducationSchoolApiService service

type ApiEducationCreateSchoolsRequest struct {
	ctx _context.Context
	ApiService *EducationEducationSchoolApiService
	microsoftGraphEducationSchool *MicrosoftGraphEducationSchool
}

// New navigation property
func (r ApiEducationCreateSchoolsRequest) MicrosoftGraphEducationSchool(microsoftGraphEducationSchool MicrosoftGraphEducationSchool) ApiEducationCreateSchoolsRequest {
	r.microsoftGraphEducationSchool = &microsoftGraphEducationSchool
	return r
}

func (r ApiEducationCreateSchoolsRequest) Execute() (MicrosoftGraphEducationSchool, *_nethttp.Response, error) {
	return r.ApiService.EducationCreateSchoolsExecute(r)
}

/*
EducationCreateSchools Create new navigation property to schools for education

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEducationCreateSchoolsRequest
*/
func (a *EducationEducationSchoolApiService) EducationCreateSchools(ctx _context.Context) ApiEducationCreateSchoolsRequest {
	return ApiEducationCreateSchoolsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEducationSchool
func (a *EducationEducationSchoolApiService) EducationCreateSchoolsExecute(r ApiEducationCreateSchoolsRequest) (MicrosoftGraphEducationSchool, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEducationSchool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationSchoolApiService.EducationCreateSchools")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/schools"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphEducationSchool == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphEducationSchool is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphEducationSchool
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEducationDeleteSchoolsRequest struct {
	ctx _context.Context
	ApiService *EducationEducationSchoolApiService
	educationSchoolId string
	ifMatch *string
}

// ETag
func (r ApiEducationDeleteSchoolsRequest) IfMatch(ifMatch string) ApiEducationDeleteSchoolsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiEducationDeleteSchoolsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.EducationDeleteSchoolsExecute(r)
}

/*
EducationDeleteSchools Delete navigation property schools for education

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param educationSchoolId key: id of educationSchool
 @return ApiEducationDeleteSchoolsRequest
*/
func (a *EducationEducationSchoolApiService) EducationDeleteSchools(ctx _context.Context, educationSchoolId string) ApiEducationDeleteSchoolsRequest {
	return ApiEducationDeleteSchoolsRequest{
		ApiService: a,
		ctx: ctx,
		educationSchoolId: educationSchoolId,
	}
}

// Execute executes the request
func (a *EducationEducationSchoolApiService) EducationDeleteSchoolsExecute(r ApiEducationDeleteSchoolsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationSchoolApiService.EducationDeleteSchools")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/schools/{educationSchool-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"educationSchool-id"+"}", _neturl.PathEscape(parameterToString(r.educationSchoolId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEducationGetSchoolsRequest struct {
	ctx _context.Context
	ApiService *EducationEducationSchoolApiService
	educationSchoolId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiEducationGetSchoolsRequest) Select_(select_ []string) ApiEducationGetSchoolsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiEducationGetSchoolsRequest) Expand(expand []string) ApiEducationGetSchoolsRequest {
	r.expand = &expand
	return r
}

func (r ApiEducationGetSchoolsRequest) Execute() (MicrosoftGraphEducationSchool, *_nethttp.Response, error) {
	return r.ApiService.EducationGetSchoolsExecute(r)
}

/*
EducationGetSchools Get schools from education

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param educationSchoolId key: id of educationSchool
 @return ApiEducationGetSchoolsRequest
*/
func (a *EducationEducationSchoolApiService) EducationGetSchools(ctx _context.Context, educationSchoolId string) ApiEducationGetSchoolsRequest {
	return ApiEducationGetSchoolsRequest{
		ApiService: a,
		ctx: ctx,
		educationSchoolId: educationSchoolId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEducationSchool
func (a *EducationEducationSchoolApiService) EducationGetSchoolsExecute(r ApiEducationGetSchoolsRequest) (MicrosoftGraphEducationSchool, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEducationSchool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationSchoolApiService.EducationGetSchools")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/schools/{educationSchool-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"educationSchool-id"+"}", _neturl.PathEscape(parameterToString(r.educationSchoolId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEducationListSchoolsRequest struct {
	ctx _context.Context
	ApiService *EducationEducationSchoolApiService
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiEducationListSchoolsRequest) Top(top int32) ApiEducationListSchoolsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiEducationListSchoolsRequest) Skip(skip int32) ApiEducationListSchoolsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiEducationListSchoolsRequest) Search(search string) ApiEducationListSchoolsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiEducationListSchoolsRequest) Filter(filter string) ApiEducationListSchoolsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiEducationListSchoolsRequest) Count(count bool) ApiEducationListSchoolsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiEducationListSchoolsRequest) Orderby(orderby []string) ApiEducationListSchoolsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiEducationListSchoolsRequest) Select_(select_ []string) ApiEducationListSchoolsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiEducationListSchoolsRequest) Expand(expand []string) ApiEducationListSchoolsRequest {
	r.expand = &expand
	return r
}

func (r ApiEducationListSchoolsRequest) Execute() (CollectionOfEducationSchool, *_nethttp.Response, error) {
	return r.ApiService.EducationListSchoolsExecute(r)
}

/*
EducationListSchools Get schools from education

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEducationListSchoolsRequest
*/
func (a *EducationEducationSchoolApiService) EducationListSchools(ctx _context.Context) ApiEducationListSchoolsRequest {
	return ApiEducationListSchoolsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionOfEducationSchool
func (a *EducationEducationSchoolApiService) EducationListSchoolsExecute(r ApiEducationListSchoolsRequest) (CollectionOfEducationSchool, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfEducationSchool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationSchoolApiService.EducationListSchools")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/schools"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEducationSchoolsCreateRefClassesRequest struct {
	ctx _context.Context
	ApiService *EducationEducationSchoolApiService
	educationSchoolId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref value
func (r ApiEducationSchoolsCreateRefClassesRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiEducationSchoolsCreateRefClassesRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiEducationSchoolsCreateRefClassesRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.EducationSchoolsCreateRefClassesExecute(r)
}

/*
EducationSchoolsCreateRefClasses Create new navigation property ref to classes for education

Classes taught at the school. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param educationSchoolId key: id of educationSchool
 @return ApiEducationSchoolsCreateRefClassesRequest
*/
func (a *EducationEducationSchoolApiService) EducationSchoolsCreateRefClasses(ctx _context.Context, educationSchoolId string) ApiEducationSchoolsCreateRefClassesRequest {
	return ApiEducationSchoolsCreateRefClassesRequest{
		ApiService: a,
		ctx: ctx,
		educationSchoolId: educationSchoolId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *EducationEducationSchoolApiService) EducationSchoolsCreateRefClassesExecute(r ApiEducationSchoolsCreateRefClassesRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationSchoolApiService.EducationSchoolsCreateRefClasses")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/schools/{educationSchool-id}/classes/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"educationSchool-id"+"}", _neturl.PathEscape(parameterToString(r.educationSchoolId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEducationSchoolsCreateRefUsersRequest struct {
	ctx _context.Context
	ApiService *EducationEducationSchoolApiService
	educationSchoolId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref value
func (r ApiEducationSchoolsCreateRefUsersRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiEducationSchoolsCreateRefUsersRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiEducationSchoolsCreateRefUsersRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.EducationSchoolsCreateRefUsersExecute(r)
}

/*
EducationSchoolsCreateRefUsers Create new navigation property ref to users for education

Users in the school. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param educationSchoolId key: id of educationSchool
 @return ApiEducationSchoolsCreateRefUsersRequest
*/
func (a *EducationEducationSchoolApiService) EducationSchoolsCreateRefUsers(ctx _context.Context, educationSchoolId string) ApiEducationSchoolsCreateRefUsersRequest {
	return ApiEducationSchoolsCreateRefUsersRequest{
		ApiService: a,
		ctx: ctx,
		educationSchoolId: educationSchoolId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *EducationEducationSchoolApiService) EducationSchoolsCreateRefUsersExecute(r ApiEducationSchoolsCreateRefUsersRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationSchoolApiService.EducationSchoolsCreateRefUsers")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/schools/{educationSchool-id}/users/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"educationSchool-id"+"}", _neturl.PathEscape(parameterToString(r.educationSchoolId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEducationSchoolsDeleteRefAdministrativeUnitRequest struct {
	ctx _context.Context
	ApiService *EducationEducationSchoolApiService
	educationSchoolId string
	ifMatch *string
}

// ETag
func (r ApiEducationSchoolsDeleteRefAdministrativeUnitRequest) IfMatch(ifMatch string) ApiEducationSchoolsDeleteRefAdministrativeUnitRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiEducationSchoolsDeleteRefAdministrativeUnitRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.EducationSchoolsDeleteRefAdministrativeUnitExecute(r)
}

/*
EducationSchoolsDeleteRefAdministrativeUnit Delete ref of navigation property administrativeUnit for education

The underlying administrativeUnit for this school.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param educationSchoolId key: id of educationSchool
 @return ApiEducationSchoolsDeleteRefAdministrativeUnitRequest
*/
func (a *EducationEducationSchoolApiService) EducationSchoolsDeleteRefAdministrativeUnit(ctx _context.Context, educationSchoolId string) ApiEducationSchoolsDeleteRefAdministrativeUnitRequest {
	return ApiEducationSchoolsDeleteRefAdministrativeUnitRequest{
		ApiService: a,
		ctx: ctx,
		educationSchoolId: educationSchoolId,
	}
}

// Execute executes the request
func (a *EducationEducationSchoolApiService) EducationSchoolsDeleteRefAdministrativeUnitExecute(r ApiEducationSchoolsDeleteRefAdministrativeUnitRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationSchoolApiService.EducationSchoolsDeleteRefAdministrativeUnit")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/schools/{educationSchool-id}/administrativeUnit/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"educationSchool-id"+"}", _neturl.PathEscape(parameterToString(r.educationSchoolId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEducationSchoolsGetAdministrativeUnitRequest struct {
	ctx _context.Context
	ApiService *EducationEducationSchoolApiService
	educationSchoolId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiEducationSchoolsGetAdministrativeUnitRequest) Select_(select_ []string) ApiEducationSchoolsGetAdministrativeUnitRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiEducationSchoolsGetAdministrativeUnitRequest) Expand(expand []string) ApiEducationSchoolsGetAdministrativeUnitRequest {
	r.expand = &expand
	return r
}

func (r ApiEducationSchoolsGetAdministrativeUnitRequest) Execute() (MicrosoftGraphAdministrativeUnit, *_nethttp.Response, error) {
	return r.ApiService.EducationSchoolsGetAdministrativeUnitExecute(r)
}

/*
EducationSchoolsGetAdministrativeUnit Get administrativeUnit from education

The underlying administrativeUnit for this school.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param educationSchoolId key: id of educationSchool
 @return ApiEducationSchoolsGetAdministrativeUnitRequest
*/
func (a *EducationEducationSchoolApiService) EducationSchoolsGetAdministrativeUnit(ctx _context.Context, educationSchoolId string) ApiEducationSchoolsGetAdministrativeUnitRequest {
	return ApiEducationSchoolsGetAdministrativeUnitRequest{
		ApiService: a,
		ctx: ctx,
		educationSchoolId: educationSchoolId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphAdministrativeUnit
func (a *EducationEducationSchoolApiService) EducationSchoolsGetAdministrativeUnitExecute(r ApiEducationSchoolsGetAdministrativeUnitRequest) (MicrosoftGraphAdministrativeUnit, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphAdministrativeUnit
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationSchoolApiService.EducationSchoolsGetAdministrativeUnit")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/schools/{educationSchool-id}/administrativeUnit"
	localVarPath = strings.Replace(localVarPath, "{"+"educationSchool-id"+"}", _neturl.PathEscape(parameterToString(r.educationSchoolId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEducationSchoolsGetRefAdministrativeUnitRequest struct {
	ctx _context.Context
	ApiService *EducationEducationSchoolApiService
	educationSchoolId string
}


func (r ApiEducationSchoolsGetRefAdministrativeUnitRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.EducationSchoolsGetRefAdministrativeUnitExecute(r)
}

/*
EducationSchoolsGetRefAdministrativeUnit Get ref of administrativeUnit from education

The underlying administrativeUnit for this school.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param educationSchoolId key: id of educationSchool
 @return ApiEducationSchoolsGetRefAdministrativeUnitRequest
*/
func (a *EducationEducationSchoolApiService) EducationSchoolsGetRefAdministrativeUnit(ctx _context.Context, educationSchoolId string) ApiEducationSchoolsGetRefAdministrativeUnitRequest {
	return ApiEducationSchoolsGetRefAdministrativeUnitRequest{
		ApiService: a,
		ctx: ctx,
		educationSchoolId: educationSchoolId,
	}
}

// Execute executes the request
//  @return string
func (a *EducationEducationSchoolApiService) EducationSchoolsGetRefAdministrativeUnitExecute(r ApiEducationSchoolsGetRefAdministrativeUnitRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationSchoolApiService.EducationSchoolsGetRefAdministrativeUnit")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/schools/{educationSchool-id}/administrativeUnit/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"educationSchool-id"+"}", _neturl.PathEscape(parameterToString(r.educationSchoolId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEducationSchoolsListClassesRequest struct {
	ctx _context.Context
	ApiService *EducationEducationSchoolApiService
	educationSchoolId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiEducationSchoolsListClassesRequest) Top(top int32) ApiEducationSchoolsListClassesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiEducationSchoolsListClassesRequest) Skip(skip int32) ApiEducationSchoolsListClassesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiEducationSchoolsListClassesRequest) Search(search string) ApiEducationSchoolsListClassesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiEducationSchoolsListClassesRequest) Filter(filter string) ApiEducationSchoolsListClassesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiEducationSchoolsListClassesRequest) Count(count bool) ApiEducationSchoolsListClassesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiEducationSchoolsListClassesRequest) Orderby(orderby []string) ApiEducationSchoolsListClassesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiEducationSchoolsListClassesRequest) Select_(select_ []string) ApiEducationSchoolsListClassesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiEducationSchoolsListClassesRequest) Expand(expand []string) ApiEducationSchoolsListClassesRequest {
	r.expand = &expand
	return r
}

func (r ApiEducationSchoolsListClassesRequest) Execute() (CollectionOfEducationClass, *_nethttp.Response, error) {
	return r.ApiService.EducationSchoolsListClassesExecute(r)
}

/*
EducationSchoolsListClasses Get classes from education

Classes taught at the school. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param educationSchoolId key: id of educationSchool
 @return ApiEducationSchoolsListClassesRequest
*/
func (a *EducationEducationSchoolApiService) EducationSchoolsListClasses(ctx _context.Context, educationSchoolId string) ApiEducationSchoolsListClassesRequest {
	return ApiEducationSchoolsListClassesRequest{
		ApiService: a,
		ctx: ctx,
		educationSchoolId: educationSchoolId,
	}
}

// Execute executes the request
//  @return CollectionOfEducationClass
func (a *EducationEducationSchoolApiService) EducationSchoolsListClassesExecute(r ApiEducationSchoolsListClassesRequest) (CollectionOfEducationClass, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfEducationClass
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationSchoolApiService.EducationSchoolsListClasses")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/schools/{educationSchool-id}/classes"
	localVarPath = strings.Replace(localVarPath, "{"+"educationSchool-id"+"}", _neturl.PathEscape(parameterToString(r.educationSchoolId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEducationSchoolsListRefClassesRequest struct {
	ctx _context.Context
	ApiService *EducationEducationSchoolApiService
	educationSchoolId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
}

// Show only the first n items
func (r ApiEducationSchoolsListRefClassesRequest) Top(top int32) ApiEducationSchoolsListRefClassesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiEducationSchoolsListRefClassesRequest) Skip(skip int32) ApiEducationSchoolsListRefClassesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiEducationSchoolsListRefClassesRequest) Search(search string) ApiEducationSchoolsListRefClassesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiEducationSchoolsListRefClassesRequest) Filter(filter string) ApiEducationSchoolsListRefClassesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiEducationSchoolsListRefClassesRequest) Count(count bool) ApiEducationSchoolsListRefClassesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiEducationSchoolsListRefClassesRequest) Orderby(orderby []string) ApiEducationSchoolsListRefClassesRequest {
	r.orderby = &orderby
	return r
}

func (r ApiEducationSchoolsListRefClassesRequest) Execute() (CollectionOfLinksOfEducationClass, *_nethttp.Response, error) {
	return r.ApiService.EducationSchoolsListRefClassesExecute(r)
}

/*
EducationSchoolsListRefClasses Get ref of classes from education

Classes taught at the school. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param educationSchoolId key: id of educationSchool
 @return ApiEducationSchoolsListRefClassesRequest
*/
func (a *EducationEducationSchoolApiService) EducationSchoolsListRefClasses(ctx _context.Context, educationSchoolId string) ApiEducationSchoolsListRefClassesRequest {
	return ApiEducationSchoolsListRefClassesRequest{
		ApiService: a,
		ctx: ctx,
		educationSchoolId: educationSchoolId,
	}
}

// Execute executes the request
//  @return CollectionOfLinksOfEducationClass
func (a *EducationEducationSchoolApiService) EducationSchoolsListRefClassesExecute(r ApiEducationSchoolsListRefClassesRequest) (CollectionOfLinksOfEducationClass, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfLinksOfEducationClass
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationSchoolApiService.EducationSchoolsListRefClasses")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/schools/{educationSchool-id}/classes/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"educationSchool-id"+"}", _neturl.PathEscape(parameterToString(r.educationSchoolId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEducationSchoolsListRefUsersRequest struct {
	ctx _context.Context
	ApiService *EducationEducationSchoolApiService
	educationSchoolId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
}

// Show only the first n items
func (r ApiEducationSchoolsListRefUsersRequest) Top(top int32) ApiEducationSchoolsListRefUsersRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiEducationSchoolsListRefUsersRequest) Skip(skip int32) ApiEducationSchoolsListRefUsersRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiEducationSchoolsListRefUsersRequest) Search(search string) ApiEducationSchoolsListRefUsersRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiEducationSchoolsListRefUsersRequest) Filter(filter string) ApiEducationSchoolsListRefUsersRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiEducationSchoolsListRefUsersRequest) Count(count bool) ApiEducationSchoolsListRefUsersRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiEducationSchoolsListRefUsersRequest) Orderby(orderby []string) ApiEducationSchoolsListRefUsersRequest {
	r.orderby = &orderby
	return r
}

func (r ApiEducationSchoolsListRefUsersRequest) Execute() (CollectionOfLinksOfEducationUser, *_nethttp.Response, error) {
	return r.ApiService.EducationSchoolsListRefUsersExecute(r)
}

/*
EducationSchoolsListRefUsers Get ref of users from education

Users in the school. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param educationSchoolId key: id of educationSchool
 @return ApiEducationSchoolsListRefUsersRequest
*/
func (a *EducationEducationSchoolApiService) EducationSchoolsListRefUsers(ctx _context.Context, educationSchoolId string) ApiEducationSchoolsListRefUsersRequest {
	return ApiEducationSchoolsListRefUsersRequest{
		ApiService: a,
		ctx: ctx,
		educationSchoolId: educationSchoolId,
	}
}

// Execute executes the request
//  @return CollectionOfLinksOfEducationUser
func (a *EducationEducationSchoolApiService) EducationSchoolsListRefUsersExecute(r ApiEducationSchoolsListRefUsersRequest) (CollectionOfLinksOfEducationUser, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfLinksOfEducationUser
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationSchoolApiService.EducationSchoolsListRefUsers")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/schools/{educationSchool-id}/users/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"educationSchool-id"+"}", _neturl.PathEscape(parameterToString(r.educationSchoolId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEducationSchoolsListUsersRequest struct {
	ctx _context.Context
	ApiService *EducationEducationSchoolApiService
	educationSchoolId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiEducationSchoolsListUsersRequest) Top(top int32) ApiEducationSchoolsListUsersRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiEducationSchoolsListUsersRequest) Skip(skip int32) ApiEducationSchoolsListUsersRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiEducationSchoolsListUsersRequest) Search(search string) ApiEducationSchoolsListUsersRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiEducationSchoolsListUsersRequest) Filter(filter string) ApiEducationSchoolsListUsersRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiEducationSchoolsListUsersRequest) Count(count bool) ApiEducationSchoolsListUsersRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiEducationSchoolsListUsersRequest) Orderby(orderby []string) ApiEducationSchoolsListUsersRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiEducationSchoolsListUsersRequest) Select_(select_ []string) ApiEducationSchoolsListUsersRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiEducationSchoolsListUsersRequest) Expand(expand []string) ApiEducationSchoolsListUsersRequest {
	r.expand = &expand
	return r
}

func (r ApiEducationSchoolsListUsersRequest) Execute() (CollectionOfEducationUser, *_nethttp.Response, error) {
	return r.ApiService.EducationSchoolsListUsersExecute(r)
}

/*
EducationSchoolsListUsers Get users from education

Users in the school. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param educationSchoolId key: id of educationSchool
 @return ApiEducationSchoolsListUsersRequest
*/
func (a *EducationEducationSchoolApiService) EducationSchoolsListUsers(ctx _context.Context, educationSchoolId string) ApiEducationSchoolsListUsersRequest {
	return ApiEducationSchoolsListUsersRequest{
		ApiService: a,
		ctx: ctx,
		educationSchoolId: educationSchoolId,
	}
}

// Execute executes the request
//  @return CollectionOfEducationUser
func (a *EducationEducationSchoolApiService) EducationSchoolsListUsersExecute(r ApiEducationSchoolsListUsersRequest) (CollectionOfEducationUser, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfEducationUser
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationSchoolApiService.EducationSchoolsListUsers")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/schools/{educationSchool-id}/users"
	localVarPath = strings.Replace(localVarPath, "{"+"educationSchool-id"+"}", _neturl.PathEscape(parameterToString(r.educationSchoolId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEducationSchoolsUpdateRefAdministrativeUnitRequest struct {
	ctx _context.Context
	ApiService *EducationEducationSchoolApiService
	educationSchoolId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiEducationSchoolsUpdateRefAdministrativeUnitRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiEducationSchoolsUpdateRefAdministrativeUnitRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiEducationSchoolsUpdateRefAdministrativeUnitRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.EducationSchoolsUpdateRefAdministrativeUnitExecute(r)
}

/*
EducationSchoolsUpdateRefAdministrativeUnit Update the ref of navigation property administrativeUnit in education

The underlying administrativeUnit for this school.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param educationSchoolId key: id of educationSchool
 @return ApiEducationSchoolsUpdateRefAdministrativeUnitRequest
*/
func (a *EducationEducationSchoolApiService) EducationSchoolsUpdateRefAdministrativeUnit(ctx _context.Context, educationSchoolId string) ApiEducationSchoolsUpdateRefAdministrativeUnitRequest {
	return ApiEducationSchoolsUpdateRefAdministrativeUnitRequest{
		ApiService: a,
		ctx: ctx,
		educationSchoolId: educationSchoolId,
	}
}

// Execute executes the request
func (a *EducationEducationSchoolApiService) EducationSchoolsUpdateRefAdministrativeUnitExecute(r ApiEducationSchoolsUpdateRefAdministrativeUnitRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationSchoolApiService.EducationSchoolsUpdateRefAdministrativeUnit")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/schools/{educationSchool-id}/administrativeUnit/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"educationSchool-id"+"}", _neturl.PathEscape(parameterToString(r.educationSchoolId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEducationUpdateSchoolsRequest struct {
	ctx _context.Context
	ApiService *EducationEducationSchoolApiService
	educationSchoolId string
	microsoftGraphEducationSchool *MicrosoftGraphEducationSchool
}

// New navigation property values
func (r ApiEducationUpdateSchoolsRequest) MicrosoftGraphEducationSchool(microsoftGraphEducationSchool MicrosoftGraphEducationSchool) ApiEducationUpdateSchoolsRequest {
	r.microsoftGraphEducationSchool = &microsoftGraphEducationSchool
	return r
}

func (r ApiEducationUpdateSchoolsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.EducationUpdateSchoolsExecute(r)
}

/*
EducationUpdateSchools Update the navigation property schools in education

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param educationSchoolId key: id of educationSchool
 @return ApiEducationUpdateSchoolsRequest
*/
func (a *EducationEducationSchoolApiService) EducationUpdateSchools(ctx _context.Context, educationSchoolId string) ApiEducationUpdateSchoolsRequest {
	return ApiEducationUpdateSchoolsRequest{
		ApiService: a,
		ctx: ctx,
		educationSchoolId: educationSchoolId,
	}
}

// Execute executes the request
func (a *EducationEducationSchoolApiService) EducationUpdateSchoolsExecute(r ApiEducationUpdateSchoolsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationSchoolApiService.EducationUpdateSchools")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/schools/{educationSchool-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"educationSchool-id"+"}", _neturl.PathEscape(parameterToString(r.educationSchoolId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphEducationSchool == nil {
		return nil, reportError("microsoftGraphEducationSchool is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphEducationSchool
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
