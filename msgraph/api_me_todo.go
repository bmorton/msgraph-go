/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// MeTodoApiService MeTodoApi service
type MeTodoApiService service

type ApiMeDeleteTodoRequest struct {
	ctx _context.Context
	ApiService *MeTodoApiService
	ifMatch *string
}

// ETag
func (r ApiMeDeleteTodoRequest) IfMatch(ifMatch string) ApiMeDeleteTodoRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMeDeleteTodoRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeDeleteTodoExecute(r)
}

/*
MeDeleteTodo Delete navigation property todo for me

Represents the To Do services available to a user.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMeDeleteTodoRequest
*/
func (a *MeTodoApiService) MeDeleteTodo(ctx _context.Context) ApiMeDeleteTodoRequest {
	return ApiMeDeleteTodoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MeTodoApiService) MeDeleteTodoExecute(r ApiMeDeleteTodoRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeTodoApiService.MeDeleteTodo")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/todo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeGetTodoRequest struct {
	ctx _context.Context
	ApiService *MeTodoApiService
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiMeGetTodoRequest) Select_(select_ []string) ApiMeGetTodoRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeGetTodoRequest) Expand(expand []string) ApiMeGetTodoRequest {
	r.expand = &expand
	return r
}

func (r ApiMeGetTodoRequest) Execute() (MicrosoftGraphTodo, *_nethttp.Response, error) {
	return r.ApiService.MeGetTodoExecute(r)
}

/*
MeGetTodo Get todo from me

Represents the To Do services available to a user.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMeGetTodoRequest
*/
func (a *MeTodoApiService) MeGetTodo(ctx _context.Context) ApiMeGetTodoRequest {
	return ApiMeGetTodoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTodo
func (a *MeTodoApiService) MeGetTodoExecute(r ApiMeGetTodoRequest) (MicrosoftGraphTodo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTodo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeTodoApiService.MeGetTodo")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/todo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeTodoCreateListsRequest struct {
	ctx _context.Context
	ApiService *MeTodoApiService
	microsoftGraphTodoTaskList *MicrosoftGraphTodoTaskList
}

// New navigation property
func (r ApiMeTodoCreateListsRequest) MicrosoftGraphTodoTaskList(microsoftGraphTodoTaskList MicrosoftGraphTodoTaskList) ApiMeTodoCreateListsRequest {
	r.microsoftGraphTodoTaskList = &microsoftGraphTodoTaskList
	return r
}

func (r ApiMeTodoCreateListsRequest) Execute() (MicrosoftGraphTodoTaskList, *_nethttp.Response, error) {
	return r.ApiService.MeTodoCreateListsExecute(r)
}

/*
MeTodoCreateLists Create new navigation property to lists for me

The task lists in the users mailbox.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMeTodoCreateListsRequest
*/
func (a *MeTodoApiService) MeTodoCreateLists(ctx _context.Context) ApiMeTodoCreateListsRequest {
	return ApiMeTodoCreateListsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTodoTaskList
func (a *MeTodoApiService) MeTodoCreateListsExecute(r ApiMeTodoCreateListsRequest) (MicrosoftGraphTodoTaskList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTodoTaskList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeTodoApiService.MeTodoCreateLists")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/todo/lists"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTodoTaskList == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphTodoTaskList is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTodoTaskList
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeTodoDeleteListsRequest struct {
	ctx _context.Context
	ApiService *MeTodoApiService
	todoTaskListId string
	ifMatch *string
}

// ETag
func (r ApiMeTodoDeleteListsRequest) IfMatch(ifMatch string) ApiMeTodoDeleteListsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMeTodoDeleteListsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeTodoDeleteListsExecute(r)
}

/*
MeTodoDeleteLists Delete navigation property lists for me

The task lists in the users mailbox.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param todoTaskListId key: id of todoTaskList
 @return ApiMeTodoDeleteListsRequest
*/
func (a *MeTodoApiService) MeTodoDeleteLists(ctx _context.Context, todoTaskListId string) ApiMeTodoDeleteListsRequest {
	return ApiMeTodoDeleteListsRequest{
		ApiService: a,
		ctx: ctx,
		todoTaskListId: todoTaskListId,
	}
}

// Execute executes the request
func (a *MeTodoApiService) MeTodoDeleteListsExecute(r ApiMeTodoDeleteListsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeTodoApiService.MeTodoDeleteLists")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/todo/lists/{todoTaskList-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"todoTaskList-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskListId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeTodoGetListsRequest struct {
	ctx _context.Context
	ApiService *MeTodoApiService
	todoTaskListId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiMeTodoGetListsRequest) Select_(select_ []string) ApiMeTodoGetListsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeTodoGetListsRequest) Expand(expand []string) ApiMeTodoGetListsRequest {
	r.expand = &expand
	return r
}

func (r ApiMeTodoGetListsRequest) Execute() (MicrosoftGraphTodoTaskList, *_nethttp.Response, error) {
	return r.ApiService.MeTodoGetListsExecute(r)
}

/*
MeTodoGetLists Get lists from me

The task lists in the users mailbox.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param todoTaskListId key: id of todoTaskList
 @return ApiMeTodoGetListsRequest
*/
func (a *MeTodoApiService) MeTodoGetLists(ctx _context.Context, todoTaskListId string) ApiMeTodoGetListsRequest {
	return ApiMeTodoGetListsRequest{
		ApiService: a,
		ctx: ctx,
		todoTaskListId: todoTaskListId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTodoTaskList
func (a *MeTodoApiService) MeTodoGetListsExecute(r ApiMeTodoGetListsRequest) (MicrosoftGraphTodoTaskList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTodoTaskList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeTodoApiService.MeTodoGetLists")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/todo/lists/{todoTaskList-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"todoTaskList-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskListId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeTodoListListsRequest struct {
	ctx _context.Context
	ApiService *MeTodoApiService
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiMeTodoListListsRequest) Top(top int32) ApiMeTodoListListsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiMeTodoListListsRequest) Skip(skip int32) ApiMeTodoListListsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiMeTodoListListsRequest) Search(search string) ApiMeTodoListListsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiMeTodoListListsRequest) Filter(filter string) ApiMeTodoListListsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiMeTodoListListsRequest) Count(count bool) ApiMeTodoListListsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiMeTodoListListsRequest) Orderby(orderby []string) ApiMeTodoListListsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiMeTodoListListsRequest) Select_(select_ []string) ApiMeTodoListListsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeTodoListListsRequest) Expand(expand []string) ApiMeTodoListListsRequest {
	r.expand = &expand
	return r
}

func (r ApiMeTodoListListsRequest) Execute() (CollectionOfTodoTaskList, *_nethttp.Response, error) {
	return r.ApiService.MeTodoListListsExecute(r)
}

/*
MeTodoListLists Get lists from me

The task lists in the users mailbox.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMeTodoListListsRequest
*/
func (a *MeTodoApiService) MeTodoListLists(ctx _context.Context) ApiMeTodoListListsRequest {
	return ApiMeTodoListListsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionOfTodoTaskList
func (a *MeTodoApiService) MeTodoListListsExecute(r ApiMeTodoListListsRequest) (CollectionOfTodoTaskList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfTodoTaskList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeTodoApiService.MeTodoListLists")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/todo/lists"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeTodoListsCreateExtensionsRequest struct {
	ctx _context.Context
	ApiService *MeTodoApiService
	todoTaskListId string
	microsoftGraphExtension *MicrosoftGraphExtension
}

// New navigation property
func (r ApiMeTodoListsCreateExtensionsRequest) MicrosoftGraphExtension(microsoftGraphExtension MicrosoftGraphExtension) ApiMeTodoListsCreateExtensionsRequest {
	r.microsoftGraphExtension = &microsoftGraphExtension
	return r
}

func (r ApiMeTodoListsCreateExtensionsRequest) Execute() (MicrosoftGraphExtension, *_nethttp.Response, error) {
	return r.ApiService.MeTodoListsCreateExtensionsExecute(r)
}

/*
MeTodoListsCreateExtensions Create new navigation property to extensions for me

The collection of open extensions defined for the task list. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param todoTaskListId key: id of todoTaskList
 @return ApiMeTodoListsCreateExtensionsRequest
*/
func (a *MeTodoApiService) MeTodoListsCreateExtensions(ctx _context.Context, todoTaskListId string) ApiMeTodoListsCreateExtensionsRequest {
	return ApiMeTodoListsCreateExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		todoTaskListId: todoTaskListId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphExtension
func (a *MeTodoApiService) MeTodoListsCreateExtensionsExecute(r ApiMeTodoListsCreateExtensionsRequest) (MicrosoftGraphExtension, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphExtension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeTodoApiService.MeTodoListsCreateExtensions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/todo/lists/{todoTaskList-id}/extensions"
	localVarPath = strings.Replace(localVarPath, "{"+"todoTaskList-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskListId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphExtension == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphExtension is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphExtension
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeTodoListsCreateTasksRequest struct {
	ctx _context.Context
	ApiService *MeTodoApiService
	todoTaskListId string
	microsoftGraphTodoTask *MicrosoftGraphTodoTask
}

// New navigation property
func (r ApiMeTodoListsCreateTasksRequest) MicrosoftGraphTodoTask(microsoftGraphTodoTask MicrosoftGraphTodoTask) ApiMeTodoListsCreateTasksRequest {
	r.microsoftGraphTodoTask = &microsoftGraphTodoTask
	return r
}

func (r ApiMeTodoListsCreateTasksRequest) Execute() (MicrosoftGraphTodoTask, *_nethttp.Response, error) {
	return r.ApiService.MeTodoListsCreateTasksExecute(r)
}

/*
MeTodoListsCreateTasks Create new navigation property to tasks for me

The tasks in this task list. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param todoTaskListId key: id of todoTaskList
 @return ApiMeTodoListsCreateTasksRequest
*/
func (a *MeTodoApiService) MeTodoListsCreateTasks(ctx _context.Context, todoTaskListId string) ApiMeTodoListsCreateTasksRequest {
	return ApiMeTodoListsCreateTasksRequest{
		ApiService: a,
		ctx: ctx,
		todoTaskListId: todoTaskListId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTodoTask
func (a *MeTodoApiService) MeTodoListsCreateTasksExecute(r ApiMeTodoListsCreateTasksRequest) (MicrosoftGraphTodoTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTodoTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeTodoApiService.MeTodoListsCreateTasks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/todo/lists/{todoTaskList-id}/tasks"
	localVarPath = strings.Replace(localVarPath, "{"+"todoTaskList-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskListId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTodoTask == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphTodoTask is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTodoTask
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeTodoListsDeleteExtensionsRequest struct {
	ctx _context.Context
	ApiService *MeTodoApiService
	todoTaskListId string
	extensionId string
	ifMatch *string
}

// ETag
func (r ApiMeTodoListsDeleteExtensionsRequest) IfMatch(ifMatch string) ApiMeTodoListsDeleteExtensionsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMeTodoListsDeleteExtensionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeTodoListsDeleteExtensionsExecute(r)
}

/*
MeTodoListsDeleteExtensions Delete navigation property extensions for me

The collection of open extensions defined for the task list. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param todoTaskListId key: id of todoTaskList
 @param extensionId key: id of extension
 @return ApiMeTodoListsDeleteExtensionsRequest
*/
func (a *MeTodoApiService) MeTodoListsDeleteExtensions(ctx _context.Context, todoTaskListId string, extensionId string) ApiMeTodoListsDeleteExtensionsRequest {
	return ApiMeTodoListsDeleteExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		todoTaskListId: todoTaskListId,
		extensionId: extensionId,
	}
}

// Execute executes the request
func (a *MeTodoApiService) MeTodoListsDeleteExtensionsExecute(r ApiMeTodoListsDeleteExtensionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeTodoApiService.MeTodoListsDeleteExtensions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/todo/lists/{todoTaskList-id}/extensions/{extension-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"todoTaskList-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskListId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension-id"+"}", _neturl.PathEscape(parameterToString(r.extensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeTodoListsDeleteTasksRequest struct {
	ctx _context.Context
	ApiService *MeTodoApiService
	todoTaskListId string
	todoTaskId string
	ifMatch *string
}

// ETag
func (r ApiMeTodoListsDeleteTasksRequest) IfMatch(ifMatch string) ApiMeTodoListsDeleteTasksRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMeTodoListsDeleteTasksRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeTodoListsDeleteTasksExecute(r)
}

/*
MeTodoListsDeleteTasks Delete navigation property tasks for me

The tasks in this task list. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param todoTaskListId key: id of todoTaskList
 @param todoTaskId key: id of todoTask
 @return ApiMeTodoListsDeleteTasksRequest
*/
func (a *MeTodoApiService) MeTodoListsDeleteTasks(ctx _context.Context, todoTaskListId string, todoTaskId string) ApiMeTodoListsDeleteTasksRequest {
	return ApiMeTodoListsDeleteTasksRequest{
		ApiService: a,
		ctx: ctx,
		todoTaskListId: todoTaskListId,
		todoTaskId: todoTaskId,
	}
}

// Execute executes the request
func (a *MeTodoApiService) MeTodoListsDeleteTasksExecute(r ApiMeTodoListsDeleteTasksRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeTodoApiService.MeTodoListsDeleteTasks")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/todo/lists/{todoTaskList-id}/tasks/{todoTask-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"todoTaskList-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskListId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"todoTask-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeTodoListsGetExtensionsRequest struct {
	ctx _context.Context
	ApiService *MeTodoApiService
	todoTaskListId string
	extensionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiMeTodoListsGetExtensionsRequest) Select_(select_ []string) ApiMeTodoListsGetExtensionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeTodoListsGetExtensionsRequest) Expand(expand []string) ApiMeTodoListsGetExtensionsRequest {
	r.expand = &expand
	return r
}

func (r ApiMeTodoListsGetExtensionsRequest) Execute() (MicrosoftGraphExtension, *_nethttp.Response, error) {
	return r.ApiService.MeTodoListsGetExtensionsExecute(r)
}

/*
MeTodoListsGetExtensions Get extensions from me

The collection of open extensions defined for the task list. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param todoTaskListId key: id of todoTaskList
 @param extensionId key: id of extension
 @return ApiMeTodoListsGetExtensionsRequest
*/
func (a *MeTodoApiService) MeTodoListsGetExtensions(ctx _context.Context, todoTaskListId string, extensionId string) ApiMeTodoListsGetExtensionsRequest {
	return ApiMeTodoListsGetExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		todoTaskListId: todoTaskListId,
		extensionId: extensionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphExtension
func (a *MeTodoApiService) MeTodoListsGetExtensionsExecute(r ApiMeTodoListsGetExtensionsRequest) (MicrosoftGraphExtension, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphExtension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeTodoApiService.MeTodoListsGetExtensions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/todo/lists/{todoTaskList-id}/extensions/{extension-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"todoTaskList-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskListId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension-id"+"}", _neturl.PathEscape(parameterToString(r.extensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeTodoListsGetTasksRequest struct {
	ctx _context.Context
	ApiService *MeTodoApiService
	todoTaskListId string
	todoTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiMeTodoListsGetTasksRequest) Select_(select_ []string) ApiMeTodoListsGetTasksRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeTodoListsGetTasksRequest) Expand(expand []string) ApiMeTodoListsGetTasksRequest {
	r.expand = &expand
	return r
}

func (r ApiMeTodoListsGetTasksRequest) Execute() (MicrosoftGraphTodoTask, *_nethttp.Response, error) {
	return r.ApiService.MeTodoListsGetTasksExecute(r)
}

/*
MeTodoListsGetTasks Get tasks from me

The tasks in this task list. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param todoTaskListId key: id of todoTaskList
 @param todoTaskId key: id of todoTask
 @return ApiMeTodoListsGetTasksRequest
*/
func (a *MeTodoApiService) MeTodoListsGetTasks(ctx _context.Context, todoTaskListId string, todoTaskId string) ApiMeTodoListsGetTasksRequest {
	return ApiMeTodoListsGetTasksRequest{
		ApiService: a,
		ctx: ctx,
		todoTaskListId: todoTaskListId,
		todoTaskId: todoTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTodoTask
func (a *MeTodoApiService) MeTodoListsGetTasksExecute(r ApiMeTodoListsGetTasksRequest) (MicrosoftGraphTodoTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTodoTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeTodoApiService.MeTodoListsGetTasks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/todo/lists/{todoTaskList-id}/tasks/{todoTask-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"todoTaskList-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskListId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"todoTask-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeTodoListsListExtensionsRequest struct {
	ctx _context.Context
	ApiService *MeTodoApiService
	todoTaskListId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiMeTodoListsListExtensionsRequest) Top(top int32) ApiMeTodoListsListExtensionsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiMeTodoListsListExtensionsRequest) Skip(skip int32) ApiMeTodoListsListExtensionsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiMeTodoListsListExtensionsRequest) Search(search string) ApiMeTodoListsListExtensionsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiMeTodoListsListExtensionsRequest) Filter(filter string) ApiMeTodoListsListExtensionsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiMeTodoListsListExtensionsRequest) Count(count bool) ApiMeTodoListsListExtensionsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiMeTodoListsListExtensionsRequest) Orderby(orderby []string) ApiMeTodoListsListExtensionsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiMeTodoListsListExtensionsRequest) Select_(select_ []string) ApiMeTodoListsListExtensionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeTodoListsListExtensionsRequest) Expand(expand []string) ApiMeTodoListsListExtensionsRequest {
	r.expand = &expand
	return r
}

func (r ApiMeTodoListsListExtensionsRequest) Execute() (CollectionOfExtension, *_nethttp.Response, error) {
	return r.ApiService.MeTodoListsListExtensionsExecute(r)
}

/*
MeTodoListsListExtensions Get extensions from me

The collection of open extensions defined for the task list. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param todoTaskListId key: id of todoTaskList
 @return ApiMeTodoListsListExtensionsRequest
*/
func (a *MeTodoApiService) MeTodoListsListExtensions(ctx _context.Context, todoTaskListId string) ApiMeTodoListsListExtensionsRequest {
	return ApiMeTodoListsListExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		todoTaskListId: todoTaskListId,
	}
}

// Execute executes the request
//  @return CollectionOfExtension
func (a *MeTodoApiService) MeTodoListsListExtensionsExecute(r ApiMeTodoListsListExtensionsRequest) (CollectionOfExtension, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfExtension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeTodoApiService.MeTodoListsListExtensions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/todo/lists/{todoTaskList-id}/extensions"
	localVarPath = strings.Replace(localVarPath, "{"+"todoTaskList-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskListId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeTodoListsListTasksRequest struct {
	ctx _context.Context
	ApiService *MeTodoApiService
	todoTaskListId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiMeTodoListsListTasksRequest) Top(top int32) ApiMeTodoListsListTasksRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiMeTodoListsListTasksRequest) Skip(skip int32) ApiMeTodoListsListTasksRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiMeTodoListsListTasksRequest) Search(search string) ApiMeTodoListsListTasksRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiMeTodoListsListTasksRequest) Filter(filter string) ApiMeTodoListsListTasksRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiMeTodoListsListTasksRequest) Count(count bool) ApiMeTodoListsListTasksRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiMeTodoListsListTasksRequest) Orderby(orderby []string) ApiMeTodoListsListTasksRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiMeTodoListsListTasksRequest) Select_(select_ []string) ApiMeTodoListsListTasksRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeTodoListsListTasksRequest) Expand(expand []string) ApiMeTodoListsListTasksRequest {
	r.expand = &expand
	return r
}

func (r ApiMeTodoListsListTasksRequest) Execute() (CollectionOfTodoTask, *_nethttp.Response, error) {
	return r.ApiService.MeTodoListsListTasksExecute(r)
}

/*
MeTodoListsListTasks Get tasks from me

The tasks in this task list. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param todoTaskListId key: id of todoTaskList
 @return ApiMeTodoListsListTasksRequest
*/
func (a *MeTodoApiService) MeTodoListsListTasks(ctx _context.Context, todoTaskListId string) ApiMeTodoListsListTasksRequest {
	return ApiMeTodoListsListTasksRequest{
		ApiService: a,
		ctx: ctx,
		todoTaskListId: todoTaskListId,
	}
}

// Execute executes the request
//  @return CollectionOfTodoTask
func (a *MeTodoApiService) MeTodoListsListTasksExecute(r ApiMeTodoListsListTasksRequest) (CollectionOfTodoTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfTodoTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeTodoApiService.MeTodoListsListTasks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/todo/lists/{todoTaskList-id}/tasks"
	localVarPath = strings.Replace(localVarPath, "{"+"todoTaskList-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskListId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeTodoListsTasksCreateExtensionsRequest struct {
	ctx _context.Context
	ApiService *MeTodoApiService
	todoTaskListId string
	todoTaskId string
	microsoftGraphExtension *MicrosoftGraphExtension
}

// New navigation property
func (r ApiMeTodoListsTasksCreateExtensionsRequest) MicrosoftGraphExtension(microsoftGraphExtension MicrosoftGraphExtension) ApiMeTodoListsTasksCreateExtensionsRequest {
	r.microsoftGraphExtension = &microsoftGraphExtension
	return r
}

func (r ApiMeTodoListsTasksCreateExtensionsRequest) Execute() (MicrosoftGraphExtension, *_nethttp.Response, error) {
	return r.ApiService.MeTodoListsTasksCreateExtensionsExecute(r)
}

/*
MeTodoListsTasksCreateExtensions Create new navigation property to extensions for me

The collection of open extensions defined for the task. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param todoTaskListId key: id of todoTaskList
 @param todoTaskId key: id of todoTask
 @return ApiMeTodoListsTasksCreateExtensionsRequest
*/
func (a *MeTodoApiService) MeTodoListsTasksCreateExtensions(ctx _context.Context, todoTaskListId string, todoTaskId string) ApiMeTodoListsTasksCreateExtensionsRequest {
	return ApiMeTodoListsTasksCreateExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		todoTaskListId: todoTaskListId,
		todoTaskId: todoTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphExtension
func (a *MeTodoApiService) MeTodoListsTasksCreateExtensionsExecute(r ApiMeTodoListsTasksCreateExtensionsRequest) (MicrosoftGraphExtension, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphExtension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeTodoApiService.MeTodoListsTasksCreateExtensions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/todo/lists/{todoTaskList-id}/tasks/{todoTask-id}/extensions"
	localVarPath = strings.Replace(localVarPath, "{"+"todoTaskList-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskListId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"todoTask-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphExtension == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphExtension is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphExtension
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeTodoListsTasksCreateLinkedResourcesRequest struct {
	ctx _context.Context
	ApiService *MeTodoApiService
	todoTaskListId string
	todoTaskId string
	microsoftGraphLinkedResource *MicrosoftGraphLinkedResource
}

// New navigation property
func (r ApiMeTodoListsTasksCreateLinkedResourcesRequest) MicrosoftGraphLinkedResource(microsoftGraphLinkedResource MicrosoftGraphLinkedResource) ApiMeTodoListsTasksCreateLinkedResourcesRequest {
	r.microsoftGraphLinkedResource = &microsoftGraphLinkedResource
	return r
}

func (r ApiMeTodoListsTasksCreateLinkedResourcesRequest) Execute() (MicrosoftGraphLinkedResource, *_nethttp.Response, error) {
	return r.ApiService.MeTodoListsTasksCreateLinkedResourcesExecute(r)
}

/*
MeTodoListsTasksCreateLinkedResources Create new navigation property to linkedResources for me

A collection of resources linked to the task.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param todoTaskListId key: id of todoTaskList
 @param todoTaskId key: id of todoTask
 @return ApiMeTodoListsTasksCreateLinkedResourcesRequest
*/
func (a *MeTodoApiService) MeTodoListsTasksCreateLinkedResources(ctx _context.Context, todoTaskListId string, todoTaskId string) ApiMeTodoListsTasksCreateLinkedResourcesRequest {
	return ApiMeTodoListsTasksCreateLinkedResourcesRequest{
		ApiService: a,
		ctx: ctx,
		todoTaskListId: todoTaskListId,
		todoTaskId: todoTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphLinkedResource
func (a *MeTodoApiService) MeTodoListsTasksCreateLinkedResourcesExecute(r ApiMeTodoListsTasksCreateLinkedResourcesRequest) (MicrosoftGraphLinkedResource, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphLinkedResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeTodoApiService.MeTodoListsTasksCreateLinkedResources")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/todo/lists/{todoTaskList-id}/tasks/{todoTask-id}/linkedResources"
	localVarPath = strings.Replace(localVarPath, "{"+"todoTaskList-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskListId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"todoTask-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphLinkedResource == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphLinkedResource is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphLinkedResource
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeTodoListsTasksDeleteExtensionsRequest struct {
	ctx _context.Context
	ApiService *MeTodoApiService
	todoTaskListId string
	todoTaskId string
	extensionId string
	ifMatch *string
}

// ETag
func (r ApiMeTodoListsTasksDeleteExtensionsRequest) IfMatch(ifMatch string) ApiMeTodoListsTasksDeleteExtensionsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMeTodoListsTasksDeleteExtensionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeTodoListsTasksDeleteExtensionsExecute(r)
}

/*
MeTodoListsTasksDeleteExtensions Delete navigation property extensions for me

The collection of open extensions defined for the task. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param todoTaskListId key: id of todoTaskList
 @param todoTaskId key: id of todoTask
 @param extensionId key: id of extension
 @return ApiMeTodoListsTasksDeleteExtensionsRequest
*/
func (a *MeTodoApiService) MeTodoListsTasksDeleteExtensions(ctx _context.Context, todoTaskListId string, todoTaskId string, extensionId string) ApiMeTodoListsTasksDeleteExtensionsRequest {
	return ApiMeTodoListsTasksDeleteExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		todoTaskListId: todoTaskListId,
		todoTaskId: todoTaskId,
		extensionId: extensionId,
	}
}

// Execute executes the request
func (a *MeTodoApiService) MeTodoListsTasksDeleteExtensionsExecute(r ApiMeTodoListsTasksDeleteExtensionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeTodoApiService.MeTodoListsTasksDeleteExtensions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/todo/lists/{todoTaskList-id}/tasks/{todoTask-id}/extensions/{extension-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"todoTaskList-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskListId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"todoTask-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension-id"+"}", _neturl.PathEscape(parameterToString(r.extensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeTodoListsTasksDeleteLinkedResourcesRequest struct {
	ctx _context.Context
	ApiService *MeTodoApiService
	todoTaskListId string
	todoTaskId string
	linkedResourceId string
	ifMatch *string
}

// ETag
func (r ApiMeTodoListsTasksDeleteLinkedResourcesRequest) IfMatch(ifMatch string) ApiMeTodoListsTasksDeleteLinkedResourcesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMeTodoListsTasksDeleteLinkedResourcesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeTodoListsTasksDeleteLinkedResourcesExecute(r)
}

/*
MeTodoListsTasksDeleteLinkedResources Delete navigation property linkedResources for me

A collection of resources linked to the task.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param todoTaskListId key: id of todoTaskList
 @param todoTaskId key: id of todoTask
 @param linkedResourceId key: id of linkedResource
 @return ApiMeTodoListsTasksDeleteLinkedResourcesRequest
*/
func (a *MeTodoApiService) MeTodoListsTasksDeleteLinkedResources(ctx _context.Context, todoTaskListId string, todoTaskId string, linkedResourceId string) ApiMeTodoListsTasksDeleteLinkedResourcesRequest {
	return ApiMeTodoListsTasksDeleteLinkedResourcesRequest{
		ApiService: a,
		ctx: ctx,
		todoTaskListId: todoTaskListId,
		todoTaskId: todoTaskId,
		linkedResourceId: linkedResourceId,
	}
}

// Execute executes the request
func (a *MeTodoApiService) MeTodoListsTasksDeleteLinkedResourcesExecute(r ApiMeTodoListsTasksDeleteLinkedResourcesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeTodoApiService.MeTodoListsTasksDeleteLinkedResources")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/todo/lists/{todoTaskList-id}/tasks/{todoTask-id}/linkedResources/{linkedResource-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"todoTaskList-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskListId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"todoTask-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"linkedResource-id"+"}", _neturl.PathEscape(parameterToString(r.linkedResourceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeTodoListsTasksGetExtensionsRequest struct {
	ctx _context.Context
	ApiService *MeTodoApiService
	todoTaskListId string
	todoTaskId string
	extensionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiMeTodoListsTasksGetExtensionsRequest) Select_(select_ []string) ApiMeTodoListsTasksGetExtensionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeTodoListsTasksGetExtensionsRequest) Expand(expand []string) ApiMeTodoListsTasksGetExtensionsRequest {
	r.expand = &expand
	return r
}

func (r ApiMeTodoListsTasksGetExtensionsRequest) Execute() (MicrosoftGraphExtension, *_nethttp.Response, error) {
	return r.ApiService.MeTodoListsTasksGetExtensionsExecute(r)
}

/*
MeTodoListsTasksGetExtensions Get extensions from me

The collection of open extensions defined for the task. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param todoTaskListId key: id of todoTaskList
 @param todoTaskId key: id of todoTask
 @param extensionId key: id of extension
 @return ApiMeTodoListsTasksGetExtensionsRequest
*/
func (a *MeTodoApiService) MeTodoListsTasksGetExtensions(ctx _context.Context, todoTaskListId string, todoTaskId string, extensionId string) ApiMeTodoListsTasksGetExtensionsRequest {
	return ApiMeTodoListsTasksGetExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		todoTaskListId: todoTaskListId,
		todoTaskId: todoTaskId,
		extensionId: extensionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphExtension
func (a *MeTodoApiService) MeTodoListsTasksGetExtensionsExecute(r ApiMeTodoListsTasksGetExtensionsRequest) (MicrosoftGraphExtension, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphExtension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeTodoApiService.MeTodoListsTasksGetExtensions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/todo/lists/{todoTaskList-id}/tasks/{todoTask-id}/extensions/{extension-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"todoTaskList-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskListId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"todoTask-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension-id"+"}", _neturl.PathEscape(parameterToString(r.extensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeTodoListsTasksGetLinkedResourcesRequest struct {
	ctx _context.Context
	ApiService *MeTodoApiService
	todoTaskListId string
	todoTaskId string
	linkedResourceId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiMeTodoListsTasksGetLinkedResourcesRequest) Select_(select_ []string) ApiMeTodoListsTasksGetLinkedResourcesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeTodoListsTasksGetLinkedResourcesRequest) Expand(expand []string) ApiMeTodoListsTasksGetLinkedResourcesRequest {
	r.expand = &expand
	return r
}

func (r ApiMeTodoListsTasksGetLinkedResourcesRequest) Execute() (MicrosoftGraphLinkedResource, *_nethttp.Response, error) {
	return r.ApiService.MeTodoListsTasksGetLinkedResourcesExecute(r)
}

/*
MeTodoListsTasksGetLinkedResources Get linkedResources from me

A collection of resources linked to the task.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param todoTaskListId key: id of todoTaskList
 @param todoTaskId key: id of todoTask
 @param linkedResourceId key: id of linkedResource
 @return ApiMeTodoListsTasksGetLinkedResourcesRequest
*/
func (a *MeTodoApiService) MeTodoListsTasksGetLinkedResources(ctx _context.Context, todoTaskListId string, todoTaskId string, linkedResourceId string) ApiMeTodoListsTasksGetLinkedResourcesRequest {
	return ApiMeTodoListsTasksGetLinkedResourcesRequest{
		ApiService: a,
		ctx: ctx,
		todoTaskListId: todoTaskListId,
		todoTaskId: todoTaskId,
		linkedResourceId: linkedResourceId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphLinkedResource
func (a *MeTodoApiService) MeTodoListsTasksGetLinkedResourcesExecute(r ApiMeTodoListsTasksGetLinkedResourcesRequest) (MicrosoftGraphLinkedResource, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphLinkedResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeTodoApiService.MeTodoListsTasksGetLinkedResources")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/todo/lists/{todoTaskList-id}/tasks/{todoTask-id}/linkedResources/{linkedResource-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"todoTaskList-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskListId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"todoTask-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"linkedResource-id"+"}", _neturl.PathEscape(parameterToString(r.linkedResourceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeTodoListsTasksListExtensionsRequest struct {
	ctx _context.Context
	ApiService *MeTodoApiService
	todoTaskListId string
	todoTaskId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiMeTodoListsTasksListExtensionsRequest) Top(top int32) ApiMeTodoListsTasksListExtensionsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiMeTodoListsTasksListExtensionsRequest) Skip(skip int32) ApiMeTodoListsTasksListExtensionsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiMeTodoListsTasksListExtensionsRequest) Search(search string) ApiMeTodoListsTasksListExtensionsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiMeTodoListsTasksListExtensionsRequest) Filter(filter string) ApiMeTodoListsTasksListExtensionsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiMeTodoListsTasksListExtensionsRequest) Count(count bool) ApiMeTodoListsTasksListExtensionsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiMeTodoListsTasksListExtensionsRequest) Orderby(orderby []string) ApiMeTodoListsTasksListExtensionsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiMeTodoListsTasksListExtensionsRequest) Select_(select_ []string) ApiMeTodoListsTasksListExtensionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeTodoListsTasksListExtensionsRequest) Expand(expand []string) ApiMeTodoListsTasksListExtensionsRequest {
	r.expand = &expand
	return r
}

func (r ApiMeTodoListsTasksListExtensionsRequest) Execute() (CollectionOfExtension, *_nethttp.Response, error) {
	return r.ApiService.MeTodoListsTasksListExtensionsExecute(r)
}

/*
MeTodoListsTasksListExtensions Get extensions from me

The collection of open extensions defined for the task. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param todoTaskListId key: id of todoTaskList
 @param todoTaskId key: id of todoTask
 @return ApiMeTodoListsTasksListExtensionsRequest
*/
func (a *MeTodoApiService) MeTodoListsTasksListExtensions(ctx _context.Context, todoTaskListId string, todoTaskId string) ApiMeTodoListsTasksListExtensionsRequest {
	return ApiMeTodoListsTasksListExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		todoTaskListId: todoTaskListId,
		todoTaskId: todoTaskId,
	}
}

// Execute executes the request
//  @return CollectionOfExtension
func (a *MeTodoApiService) MeTodoListsTasksListExtensionsExecute(r ApiMeTodoListsTasksListExtensionsRequest) (CollectionOfExtension, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfExtension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeTodoApiService.MeTodoListsTasksListExtensions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/todo/lists/{todoTaskList-id}/tasks/{todoTask-id}/extensions"
	localVarPath = strings.Replace(localVarPath, "{"+"todoTaskList-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskListId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"todoTask-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeTodoListsTasksListLinkedResourcesRequest struct {
	ctx _context.Context
	ApiService *MeTodoApiService
	todoTaskListId string
	todoTaskId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiMeTodoListsTasksListLinkedResourcesRequest) Top(top int32) ApiMeTodoListsTasksListLinkedResourcesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiMeTodoListsTasksListLinkedResourcesRequest) Skip(skip int32) ApiMeTodoListsTasksListLinkedResourcesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiMeTodoListsTasksListLinkedResourcesRequest) Search(search string) ApiMeTodoListsTasksListLinkedResourcesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiMeTodoListsTasksListLinkedResourcesRequest) Filter(filter string) ApiMeTodoListsTasksListLinkedResourcesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiMeTodoListsTasksListLinkedResourcesRequest) Count(count bool) ApiMeTodoListsTasksListLinkedResourcesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiMeTodoListsTasksListLinkedResourcesRequest) Orderby(orderby []string) ApiMeTodoListsTasksListLinkedResourcesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiMeTodoListsTasksListLinkedResourcesRequest) Select_(select_ []string) ApiMeTodoListsTasksListLinkedResourcesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeTodoListsTasksListLinkedResourcesRequest) Expand(expand []string) ApiMeTodoListsTasksListLinkedResourcesRequest {
	r.expand = &expand
	return r
}

func (r ApiMeTodoListsTasksListLinkedResourcesRequest) Execute() (CollectionOfLinkedResource, *_nethttp.Response, error) {
	return r.ApiService.MeTodoListsTasksListLinkedResourcesExecute(r)
}

/*
MeTodoListsTasksListLinkedResources Get linkedResources from me

A collection of resources linked to the task.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param todoTaskListId key: id of todoTaskList
 @param todoTaskId key: id of todoTask
 @return ApiMeTodoListsTasksListLinkedResourcesRequest
*/
func (a *MeTodoApiService) MeTodoListsTasksListLinkedResources(ctx _context.Context, todoTaskListId string, todoTaskId string) ApiMeTodoListsTasksListLinkedResourcesRequest {
	return ApiMeTodoListsTasksListLinkedResourcesRequest{
		ApiService: a,
		ctx: ctx,
		todoTaskListId: todoTaskListId,
		todoTaskId: todoTaskId,
	}
}

// Execute executes the request
//  @return CollectionOfLinkedResource
func (a *MeTodoApiService) MeTodoListsTasksListLinkedResourcesExecute(r ApiMeTodoListsTasksListLinkedResourcesRequest) (CollectionOfLinkedResource, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfLinkedResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeTodoApiService.MeTodoListsTasksListLinkedResources")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/todo/lists/{todoTaskList-id}/tasks/{todoTask-id}/linkedResources"
	localVarPath = strings.Replace(localVarPath, "{"+"todoTaskList-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskListId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"todoTask-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeTodoListsTasksUpdateExtensionsRequest struct {
	ctx _context.Context
	ApiService *MeTodoApiService
	todoTaskListId string
	todoTaskId string
	extensionId string
	microsoftGraphExtension *MicrosoftGraphExtension
}

// New navigation property values
func (r ApiMeTodoListsTasksUpdateExtensionsRequest) MicrosoftGraphExtension(microsoftGraphExtension MicrosoftGraphExtension) ApiMeTodoListsTasksUpdateExtensionsRequest {
	r.microsoftGraphExtension = &microsoftGraphExtension
	return r
}

func (r ApiMeTodoListsTasksUpdateExtensionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeTodoListsTasksUpdateExtensionsExecute(r)
}

/*
MeTodoListsTasksUpdateExtensions Update the navigation property extensions in me

The collection of open extensions defined for the task. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param todoTaskListId key: id of todoTaskList
 @param todoTaskId key: id of todoTask
 @param extensionId key: id of extension
 @return ApiMeTodoListsTasksUpdateExtensionsRequest
*/
func (a *MeTodoApiService) MeTodoListsTasksUpdateExtensions(ctx _context.Context, todoTaskListId string, todoTaskId string, extensionId string) ApiMeTodoListsTasksUpdateExtensionsRequest {
	return ApiMeTodoListsTasksUpdateExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		todoTaskListId: todoTaskListId,
		todoTaskId: todoTaskId,
		extensionId: extensionId,
	}
}

// Execute executes the request
func (a *MeTodoApiService) MeTodoListsTasksUpdateExtensionsExecute(r ApiMeTodoListsTasksUpdateExtensionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeTodoApiService.MeTodoListsTasksUpdateExtensions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/todo/lists/{todoTaskList-id}/tasks/{todoTask-id}/extensions/{extension-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"todoTaskList-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskListId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"todoTask-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension-id"+"}", _neturl.PathEscape(parameterToString(r.extensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphExtension == nil {
		return nil, reportError("microsoftGraphExtension is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphExtension
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeTodoListsTasksUpdateLinkedResourcesRequest struct {
	ctx _context.Context
	ApiService *MeTodoApiService
	todoTaskListId string
	todoTaskId string
	linkedResourceId string
	microsoftGraphLinkedResource *MicrosoftGraphLinkedResource
}

// New navigation property values
func (r ApiMeTodoListsTasksUpdateLinkedResourcesRequest) MicrosoftGraphLinkedResource(microsoftGraphLinkedResource MicrosoftGraphLinkedResource) ApiMeTodoListsTasksUpdateLinkedResourcesRequest {
	r.microsoftGraphLinkedResource = &microsoftGraphLinkedResource
	return r
}

func (r ApiMeTodoListsTasksUpdateLinkedResourcesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeTodoListsTasksUpdateLinkedResourcesExecute(r)
}

/*
MeTodoListsTasksUpdateLinkedResources Update the navigation property linkedResources in me

A collection of resources linked to the task.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param todoTaskListId key: id of todoTaskList
 @param todoTaskId key: id of todoTask
 @param linkedResourceId key: id of linkedResource
 @return ApiMeTodoListsTasksUpdateLinkedResourcesRequest
*/
func (a *MeTodoApiService) MeTodoListsTasksUpdateLinkedResources(ctx _context.Context, todoTaskListId string, todoTaskId string, linkedResourceId string) ApiMeTodoListsTasksUpdateLinkedResourcesRequest {
	return ApiMeTodoListsTasksUpdateLinkedResourcesRequest{
		ApiService: a,
		ctx: ctx,
		todoTaskListId: todoTaskListId,
		todoTaskId: todoTaskId,
		linkedResourceId: linkedResourceId,
	}
}

// Execute executes the request
func (a *MeTodoApiService) MeTodoListsTasksUpdateLinkedResourcesExecute(r ApiMeTodoListsTasksUpdateLinkedResourcesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeTodoApiService.MeTodoListsTasksUpdateLinkedResources")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/todo/lists/{todoTaskList-id}/tasks/{todoTask-id}/linkedResources/{linkedResource-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"todoTaskList-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskListId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"todoTask-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"linkedResource-id"+"}", _neturl.PathEscape(parameterToString(r.linkedResourceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphLinkedResource == nil {
		return nil, reportError("microsoftGraphLinkedResource is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphLinkedResource
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeTodoListsUpdateExtensionsRequest struct {
	ctx _context.Context
	ApiService *MeTodoApiService
	todoTaskListId string
	extensionId string
	microsoftGraphExtension *MicrosoftGraphExtension
}

// New navigation property values
func (r ApiMeTodoListsUpdateExtensionsRequest) MicrosoftGraphExtension(microsoftGraphExtension MicrosoftGraphExtension) ApiMeTodoListsUpdateExtensionsRequest {
	r.microsoftGraphExtension = &microsoftGraphExtension
	return r
}

func (r ApiMeTodoListsUpdateExtensionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeTodoListsUpdateExtensionsExecute(r)
}

/*
MeTodoListsUpdateExtensions Update the navigation property extensions in me

The collection of open extensions defined for the task list. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param todoTaskListId key: id of todoTaskList
 @param extensionId key: id of extension
 @return ApiMeTodoListsUpdateExtensionsRequest
*/
func (a *MeTodoApiService) MeTodoListsUpdateExtensions(ctx _context.Context, todoTaskListId string, extensionId string) ApiMeTodoListsUpdateExtensionsRequest {
	return ApiMeTodoListsUpdateExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		todoTaskListId: todoTaskListId,
		extensionId: extensionId,
	}
}

// Execute executes the request
func (a *MeTodoApiService) MeTodoListsUpdateExtensionsExecute(r ApiMeTodoListsUpdateExtensionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeTodoApiService.MeTodoListsUpdateExtensions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/todo/lists/{todoTaskList-id}/extensions/{extension-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"todoTaskList-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskListId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension-id"+"}", _neturl.PathEscape(parameterToString(r.extensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphExtension == nil {
		return nil, reportError("microsoftGraphExtension is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphExtension
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeTodoListsUpdateTasksRequest struct {
	ctx _context.Context
	ApiService *MeTodoApiService
	todoTaskListId string
	todoTaskId string
	microsoftGraphTodoTask *MicrosoftGraphTodoTask
}

// New navigation property values
func (r ApiMeTodoListsUpdateTasksRequest) MicrosoftGraphTodoTask(microsoftGraphTodoTask MicrosoftGraphTodoTask) ApiMeTodoListsUpdateTasksRequest {
	r.microsoftGraphTodoTask = &microsoftGraphTodoTask
	return r
}

func (r ApiMeTodoListsUpdateTasksRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeTodoListsUpdateTasksExecute(r)
}

/*
MeTodoListsUpdateTasks Update the navigation property tasks in me

The tasks in this task list. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param todoTaskListId key: id of todoTaskList
 @param todoTaskId key: id of todoTask
 @return ApiMeTodoListsUpdateTasksRequest
*/
func (a *MeTodoApiService) MeTodoListsUpdateTasks(ctx _context.Context, todoTaskListId string, todoTaskId string) ApiMeTodoListsUpdateTasksRequest {
	return ApiMeTodoListsUpdateTasksRequest{
		ApiService: a,
		ctx: ctx,
		todoTaskListId: todoTaskListId,
		todoTaskId: todoTaskId,
	}
}

// Execute executes the request
func (a *MeTodoApiService) MeTodoListsUpdateTasksExecute(r ApiMeTodoListsUpdateTasksRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeTodoApiService.MeTodoListsUpdateTasks")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/todo/lists/{todoTaskList-id}/tasks/{todoTask-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"todoTaskList-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskListId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"todoTask-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTodoTask == nil {
		return nil, reportError("microsoftGraphTodoTask is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTodoTask
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeTodoUpdateListsRequest struct {
	ctx _context.Context
	ApiService *MeTodoApiService
	todoTaskListId string
	microsoftGraphTodoTaskList *MicrosoftGraphTodoTaskList
}

// New navigation property values
func (r ApiMeTodoUpdateListsRequest) MicrosoftGraphTodoTaskList(microsoftGraphTodoTaskList MicrosoftGraphTodoTaskList) ApiMeTodoUpdateListsRequest {
	r.microsoftGraphTodoTaskList = &microsoftGraphTodoTaskList
	return r
}

func (r ApiMeTodoUpdateListsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeTodoUpdateListsExecute(r)
}

/*
MeTodoUpdateLists Update the navigation property lists in me

The task lists in the users mailbox.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param todoTaskListId key: id of todoTaskList
 @return ApiMeTodoUpdateListsRequest
*/
func (a *MeTodoApiService) MeTodoUpdateLists(ctx _context.Context, todoTaskListId string) ApiMeTodoUpdateListsRequest {
	return ApiMeTodoUpdateListsRequest{
		ApiService: a,
		ctx: ctx,
		todoTaskListId: todoTaskListId,
	}
}

// Execute executes the request
func (a *MeTodoApiService) MeTodoUpdateListsExecute(r ApiMeTodoUpdateListsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeTodoApiService.MeTodoUpdateLists")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/todo/lists/{todoTaskList-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"todoTaskList-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskListId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTodoTaskList == nil {
		return nil, reportError("microsoftGraphTodoTaskList is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTodoTaskList
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeUpdateTodoRequest struct {
	ctx _context.Context
	ApiService *MeTodoApiService
	microsoftGraphTodo *MicrosoftGraphTodo
}

// New navigation property values
func (r ApiMeUpdateTodoRequest) MicrosoftGraphTodo(microsoftGraphTodo MicrosoftGraphTodo) ApiMeUpdateTodoRequest {
	r.microsoftGraphTodo = &microsoftGraphTodo
	return r
}

func (r ApiMeUpdateTodoRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeUpdateTodoExecute(r)
}

/*
MeUpdateTodo Update the navigation property todo in me

Represents the To Do services available to a user.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMeUpdateTodoRequest
*/
func (a *MeTodoApiService) MeUpdateTodo(ctx _context.Context) ApiMeUpdateTodoRequest {
	return ApiMeUpdateTodoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MeTodoApiService) MeUpdateTodoExecute(r ApiMeUpdateTodoRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeTodoApiService.MeUpdateTodo")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/todo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTodo == nil {
		return nil, reportError("microsoftGraphTodo is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTodo
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
