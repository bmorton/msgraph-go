/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// DeviceManagementTermsAndConditionsApiService DeviceManagementTermsAndConditionsApi service
type DeviceManagementTermsAndConditionsApiService service

type ApiDeviceManagementCreateTermsAndConditionsRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementTermsAndConditionsApiService
	microsoftGraphTermsAndConditions *MicrosoftGraphTermsAndConditions
}

// New navigation property
func (r ApiDeviceManagementCreateTermsAndConditionsRequest) MicrosoftGraphTermsAndConditions(microsoftGraphTermsAndConditions MicrosoftGraphTermsAndConditions) ApiDeviceManagementCreateTermsAndConditionsRequest {
	r.microsoftGraphTermsAndConditions = &microsoftGraphTermsAndConditions
	return r
}

func (r ApiDeviceManagementCreateTermsAndConditionsRequest) Execute() (MicrosoftGraphTermsAndConditions, *_nethttp.Response, error) {
	return r.ApiService.DeviceManagementCreateTermsAndConditionsExecute(r)
}

/*
DeviceManagementCreateTermsAndConditions Create new navigation property to termsAndConditions for deviceManagement

The terms and conditions associated with device management of the company.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeviceManagementCreateTermsAndConditionsRequest
*/
func (a *DeviceManagementTermsAndConditionsApiService) DeviceManagementCreateTermsAndConditions(ctx _context.Context) ApiDeviceManagementCreateTermsAndConditionsRequest {
	return ApiDeviceManagementCreateTermsAndConditionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermsAndConditions
func (a *DeviceManagementTermsAndConditionsApiService) DeviceManagementCreateTermsAndConditionsExecute(r ApiDeviceManagementCreateTermsAndConditionsRequest) (MicrosoftGraphTermsAndConditions, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermsAndConditions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementTermsAndConditionsApiService.DeviceManagementCreateTermsAndConditions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/termsAndConditions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermsAndConditions == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphTermsAndConditions is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermsAndConditions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceManagementDeleteTermsAndConditionsRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementTermsAndConditionsApiService
	termsAndConditionsId string
	ifMatch *string
}

// ETag
func (r ApiDeviceManagementDeleteTermsAndConditionsRequest) IfMatch(ifMatch string) ApiDeviceManagementDeleteTermsAndConditionsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDeviceManagementDeleteTermsAndConditionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeviceManagementDeleteTermsAndConditionsExecute(r)
}

/*
DeviceManagementDeleteTermsAndConditions Delete navigation property termsAndConditions for deviceManagement

The terms and conditions associated with device management of the company.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param termsAndConditionsId key: id of termsAndConditions
 @return ApiDeviceManagementDeleteTermsAndConditionsRequest
*/
func (a *DeviceManagementTermsAndConditionsApiService) DeviceManagementDeleteTermsAndConditions(ctx _context.Context, termsAndConditionsId string) ApiDeviceManagementDeleteTermsAndConditionsRequest {
	return ApiDeviceManagementDeleteTermsAndConditionsRequest{
		ApiService: a,
		ctx: ctx,
		termsAndConditionsId: termsAndConditionsId,
	}
}

// Execute executes the request
func (a *DeviceManagementTermsAndConditionsApiService) DeviceManagementDeleteTermsAndConditionsExecute(r ApiDeviceManagementDeleteTermsAndConditionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementTermsAndConditionsApiService.DeviceManagementDeleteTermsAndConditions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/termsAndConditions/{termsAndConditions-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"termsAndConditions-id"+"}", _neturl.PathEscape(parameterToString(r.termsAndConditionsId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceManagementGetTermsAndConditionsRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementTermsAndConditionsApiService
	termsAndConditionsId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDeviceManagementGetTermsAndConditionsRequest) Select_(select_ []string) ApiDeviceManagementGetTermsAndConditionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDeviceManagementGetTermsAndConditionsRequest) Expand(expand []string) ApiDeviceManagementGetTermsAndConditionsRequest {
	r.expand = &expand
	return r
}

func (r ApiDeviceManagementGetTermsAndConditionsRequest) Execute() (MicrosoftGraphTermsAndConditions, *_nethttp.Response, error) {
	return r.ApiService.DeviceManagementGetTermsAndConditionsExecute(r)
}

/*
DeviceManagementGetTermsAndConditions Get termsAndConditions from deviceManagement

The terms and conditions associated with device management of the company.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param termsAndConditionsId key: id of termsAndConditions
 @return ApiDeviceManagementGetTermsAndConditionsRequest
*/
func (a *DeviceManagementTermsAndConditionsApiService) DeviceManagementGetTermsAndConditions(ctx _context.Context, termsAndConditionsId string) ApiDeviceManagementGetTermsAndConditionsRequest {
	return ApiDeviceManagementGetTermsAndConditionsRequest{
		ApiService: a,
		ctx: ctx,
		termsAndConditionsId: termsAndConditionsId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermsAndConditions
func (a *DeviceManagementTermsAndConditionsApiService) DeviceManagementGetTermsAndConditionsExecute(r ApiDeviceManagementGetTermsAndConditionsRequest) (MicrosoftGraphTermsAndConditions, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermsAndConditions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementTermsAndConditionsApiService.DeviceManagementGetTermsAndConditions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/termsAndConditions/{termsAndConditions-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"termsAndConditions-id"+"}", _neturl.PathEscape(parameterToString(r.termsAndConditionsId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceManagementListTermsAndConditionsRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementTermsAndConditionsApiService
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiDeviceManagementListTermsAndConditionsRequest) Top(top int32) ApiDeviceManagementListTermsAndConditionsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiDeviceManagementListTermsAndConditionsRequest) Skip(skip int32) ApiDeviceManagementListTermsAndConditionsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiDeviceManagementListTermsAndConditionsRequest) Search(search string) ApiDeviceManagementListTermsAndConditionsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiDeviceManagementListTermsAndConditionsRequest) Filter(filter string) ApiDeviceManagementListTermsAndConditionsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiDeviceManagementListTermsAndConditionsRequest) Count(count bool) ApiDeviceManagementListTermsAndConditionsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiDeviceManagementListTermsAndConditionsRequest) Orderby(orderby []string) ApiDeviceManagementListTermsAndConditionsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiDeviceManagementListTermsAndConditionsRequest) Select_(select_ []string) ApiDeviceManagementListTermsAndConditionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDeviceManagementListTermsAndConditionsRequest) Expand(expand []string) ApiDeviceManagementListTermsAndConditionsRequest {
	r.expand = &expand
	return r
}

func (r ApiDeviceManagementListTermsAndConditionsRequest) Execute() (CollectionOfTermsAndConditions, *_nethttp.Response, error) {
	return r.ApiService.DeviceManagementListTermsAndConditionsExecute(r)
}

/*
DeviceManagementListTermsAndConditions Get termsAndConditions from deviceManagement

The terms and conditions associated with device management of the company.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeviceManagementListTermsAndConditionsRequest
*/
func (a *DeviceManagementTermsAndConditionsApiService) DeviceManagementListTermsAndConditions(ctx _context.Context) ApiDeviceManagementListTermsAndConditionsRequest {
	return ApiDeviceManagementListTermsAndConditionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionOfTermsAndConditions
func (a *DeviceManagementTermsAndConditionsApiService) DeviceManagementListTermsAndConditionsExecute(r ApiDeviceManagementListTermsAndConditionsRequest) (CollectionOfTermsAndConditions, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfTermsAndConditions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementTermsAndConditionsApiService.DeviceManagementListTermsAndConditions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/termsAndConditions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceManagementTermsAndConditionsAcceptanceStatusesDeleteRefTermsAndConditionsRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementTermsAndConditionsApiService
	termsAndConditionsId string
	termsAndConditionsAcceptanceStatusId string
	ifMatch *string
}

// ETag
func (r ApiDeviceManagementTermsAndConditionsAcceptanceStatusesDeleteRefTermsAndConditionsRequest) IfMatch(ifMatch string) ApiDeviceManagementTermsAndConditionsAcceptanceStatusesDeleteRefTermsAndConditionsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDeviceManagementTermsAndConditionsAcceptanceStatusesDeleteRefTermsAndConditionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeviceManagementTermsAndConditionsAcceptanceStatusesDeleteRefTermsAndConditionsExecute(r)
}

/*
DeviceManagementTermsAndConditionsAcceptanceStatusesDeleteRefTermsAndConditions Delete ref of navigation property termsAndConditions for deviceManagement

Navigation link to the terms and conditions that are assigned.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param termsAndConditionsId key: id of termsAndConditions
 @param termsAndConditionsAcceptanceStatusId key: id of termsAndConditionsAcceptanceStatus
 @return ApiDeviceManagementTermsAndConditionsAcceptanceStatusesDeleteRefTermsAndConditionsRequest
*/
func (a *DeviceManagementTermsAndConditionsApiService) DeviceManagementTermsAndConditionsAcceptanceStatusesDeleteRefTermsAndConditions(ctx _context.Context, termsAndConditionsId string, termsAndConditionsAcceptanceStatusId string) ApiDeviceManagementTermsAndConditionsAcceptanceStatusesDeleteRefTermsAndConditionsRequest {
	return ApiDeviceManagementTermsAndConditionsAcceptanceStatusesDeleteRefTermsAndConditionsRequest{
		ApiService: a,
		ctx: ctx,
		termsAndConditionsId: termsAndConditionsId,
		termsAndConditionsAcceptanceStatusId: termsAndConditionsAcceptanceStatusId,
	}
}

// Execute executes the request
func (a *DeviceManagementTermsAndConditionsApiService) DeviceManagementTermsAndConditionsAcceptanceStatusesDeleteRefTermsAndConditionsExecute(r ApiDeviceManagementTermsAndConditionsAcceptanceStatusesDeleteRefTermsAndConditionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementTermsAndConditionsApiService.DeviceManagementTermsAndConditionsAcceptanceStatusesDeleteRefTermsAndConditions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/termsAndConditions/{termsAndConditions-id}/acceptanceStatuses/{termsAndConditionsAcceptanceStatus-id}/termsAndConditions/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"termsAndConditions-id"+"}", _neturl.PathEscape(parameterToString(r.termsAndConditionsId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"termsAndConditionsAcceptanceStatus-id"+"}", _neturl.PathEscape(parameterToString(r.termsAndConditionsAcceptanceStatusId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceManagementTermsAndConditionsAcceptanceStatusesGetRefTermsAndConditionsRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementTermsAndConditionsApiService
	termsAndConditionsId string
	termsAndConditionsAcceptanceStatusId string
}


func (r ApiDeviceManagementTermsAndConditionsAcceptanceStatusesGetRefTermsAndConditionsRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.DeviceManagementTermsAndConditionsAcceptanceStatusesGetRefTermsAndConditionsExecute(r)
}

/*
DeviceManagementTermsAndConditionsAcceptanceStatusesGetRefTermsAndConditions Get ref of termsAndConditions from deviceManagement

Navigation link to the terms and conditions that are assigned.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param termsAndConditionsId key: id of termsAndConditions
 @param termsAndConditionsAcceptanceStatusId key: id of termsAndConditionsAcceptanceStatus
 @return ApiDeviceManagementTermsAndConditionsAcceptanceStatusesGetRefTermsAndConditionsRequest
*/
func (a *DeviceManagementTermsAndConditionsApiService) DeviceManagementTermsAndConditionsAcceptanceStatusesGetRefTermsAndConditions(ctx _context.Context, termsAndConditionsId string, termsAndConditionsAcceptanceStatusId string) ApiDeviceManagementTermsAndConditionsAcceptanceStatusesGetRefTermsAndConditionsRequest {
	return ApiDeviceManagementTermsAndConditionsAcceptanceStatusesGetRefTermsAndConditionsRequest{
		ApiService: a,
		ctx: ctx,
		termsAndConditionsId: termsAndConditionsId,
		termsAndConditionsAcceptanceStatusId: termsAndConditionsAcceptanceStatusId,
	}
}

// Execute executes the request
//  @return string
func (a *DeviceManagementTermsAndConditionsApiService) DeviceManagementTermsAndConditionsAcceptanceStatusesGetRefTermsAndConditionsExecute(r ApiDeviceManagementTermsAndConditionsAcceptanceStatusesGetRefTermsAndConditionsRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementTermsAndConditionsApiService.DeviceManagementTermsAndConditionsAcceptanceStatusesGetRefTermsAndConditions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/termsAndConditions/{termsAndConditions-id}/acceptanceStatuses/{termsAndConditionsAcceptanceStatus-id}/termsAndConditions/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"termsAndConditions-id"+"}", _neturl.PathEscape(parameterToString(r.termsAndConditionsId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"termsAndConditionsAcceptanceStatus-id"+"}", _neturl.PathEscape(parameterToString(r.termsAndConditionsAcceptanceStatusId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceManagementTermsAndConditionsAcceptanceStatusesGetTermsAndConditionsRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementTermsAndConditionsApiService
	termsAndConditionsId string
	termsAndConditionsAcceptanceStatusId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDeviceManagementTermsAndConditionsAcceptanceStatusesGetTermsAndConditionsRequest) Select_(select_ []string) ApiDeviceManagementTermsAndConditionsAcceptanceStatusesGetTermsAndConditionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDeviceManagementTermsAndConditionsAcceptanceStatusesGetTermsAndConditionsRequest) Expand(expand []string) ApiDeviceManagementTermsAndConditionsAcceptanceStatusesGetTermsAndConditionsRequest {
	r.expand = &expand
	return r
}

func (r ApiDeviceManagementTermsAndConditionsAcceptanceStatusesGetTermsAndConditionsRequest) Execute() (MicrosoftGraphTermsAndConditions, *_nethttp.Response, error) {
	return r.ApiService.DeviceManagementTermsAndConditionsAcceptanceStatusesGetTermsAndConditionsExecute(r)
}

/*
DeviceManagementTermsAndConditionsAcceptanceStatusesGetTermsAndConditions Get termsAndConditions from deviceManagement

Navigation link to the terms and conditions that are assigned.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param termsAndConditionsId key: id of termsAndConditions
 @param termsAndConditionsAcceptanceStatusId key: id of termsAndConditionsAcceptanceStatus
 @return ApiDeviceManagementTermsAndConditionsAcceptanceStatusesGetTermsAndConditionsRequest
*/
func (a *DeviceManagementTermsAndConditionsApiService) DeviceManagementTermsAndConditionsAcceptanceStatusesGetTermsAndConditions(ctx _context.Context, termsAndConditionsId string, termsAndConditionsAcceptanceStatusId string) ApiDeviceManagementTermsAndConditionsAcceptanceStatusesGetTermsAndConditionsRequest {
	return ApiDeviceManagementTermsAndConditionsAcceptanceStatusesGetTermsAndConditionsRequest{
		ApiService: a,
		ctx: ctx,
		termsAndConditionsId: termsAndConditionsId,
		termsAndConditionsAcceptanceStatusId: termsAndConditionsAcceptanceStatusId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermsAndConditions
func (a *DeviceManagementTermsAndConditionsApiService) DeviceManagementTermsAndConditionsAcceptanceStatusesGetTermsAndConditionsExecute(r ApiDeviceManagementTermsAndConditionsAcceptanceStatusesGetTermsAndConditionsRequest) (MicrosoftGraphTermsAndConditions, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermsAndConditions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementTermsAndConditionsApiService.DeviceManagementTermsAndConditionsAcceptanceStatusesGetTermsAndConditions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/termsAndConditions/{termsAndConditions-id}/acceptanceStatuses/{termsAndConditionsAcceptanceStatus-id}/termsAndConditions"
	localVarPath = strings.Replace(localVarPath, "{"+"termsAndConditions-id"+"}", _neturl.PathEscape(parameterToString(r.termsAndConditionsId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"termsAndConditionsAcceptanceStatus-id"+"}", _neturl.PathEscape(parameterToString(r.termsAndConditionsAcceptanceStatusId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceManagementTermsAndConditionsAcceptanceStatusesUpdateRefTermsAndConditionsRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementTermsAndConditionsApiService
	termsAndConditionsId string
	termsAndConditionsAcceptanceStatusId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiDeviceManagementTermsAndConditionsAcceptanceStatusesUpdateRefTermsAndConditionsRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiDeviceManagementTermsAndConditionsAcceptanceStatusesUpdateRefTermsAndConditionsRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiDeviceManagementTermsAndConditionsAcceptanceStatusesUpdateRefTermsAndConditionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeviceManagementTermsAndConditionsAcceptanceStatusesUpdateRefTermsAndConditionsExecute(r)
}

/*
DeviceManagementTermsAndConditionsAcceptanceStatusesUpdateRefTermsAndConditions Update the ref of navigation property termsAndConditions in deviceManagement

Navigation link to the terms and conditions that are assigned.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param termsAndConditionsId key: id of termsAndConditions
 @param termsAndConditionsAcceptanceStatusId key: id of termsAndConditionsAcceptanceStatus
 @return ApiDeviceManagementTermsAndConditionsAcceptanceStatusesUpdateRefTermsAndConditionsRequest
*/
func (a *DeviceManagementTermsAndConditionsApiService) DeviceManagementTermsAndConditionsAcceptanceStatusesUpdateRefTermsAndConditions(ctx _context.Context, termsAndConditionsId string, termsAndConditionsAcceptanceStatusId string) ApiDeviceManagementTermsAndConditionsAcceptanceStatusesUpdateRefTermsAndConditionsRequest {
	return ApiDeviceManagementTermsAndConditionsAcceptanceStatusesUpdateRefTermsAndConditionsRequest{
		ApiService: a,
		ctx: ctx,
		termsAndConditionsId: termsAndConditionsId,
		termsAndConditionsAcceptanceStatusId: termsAndConditionsAcceptanceStatusId,
	}
}

// Execute executes the request
func (a *DeviceManagementTermsAndConditionsApiService) DeviceManagementTermsAndConditionsAcceptanceStatusesUpdateRefTermsAndConditionsExecute(r ApiDeviceManagementTermsAndConditionsAcceptanceStatusesUpdateRefTermsAndConditionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementTermsAndConditionsApiService.DeviceManagementTermsAndConditionsAcceptanceStatusesUpdateRefTermsAndConditions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/termsAndConditions/{termsAndConditions-id}/acceptanceStatuses/{termsAndConditionsAcceptanceStatus-id}/termsAndConditions/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"termsAndConditions-id"+"}", _neturl.PathEscape(parameterToString(r.termsAndConditionsId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"termsAndConditionsAcceptanceStatus-id"+"}", _neturl.PathEscape(parameterToString(r.termsAndConditionsAcceptanceStatusId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceManagementTermsAndConditionsCreateAcceptanceStatusesRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementTermsAndConditionsApiService
	termsAndConditionsId string
	microsoftGraphTermsAndConditionsAcceptanceStatus *MicrosoftGraphTermsAndConditionsAcceptanceStatus
}

// New navigation property
func (r ApiDeviceManagementTermsAndConditionsCreateAcceptanceStatusesRequest) MicrosoftGraphTermsAndConditionsAcceptanceStatus(microsoftGraphTermsAndConditionsAcceptanceStatus MicrosoftGraphTermsAndConditionsAcceptanceStatus) ApiDeviceManagementTermsAndConditionsCreateAcceptanceStatusesRequest {
	r.microsoftGraphTermsAndConditionsAcceptanceStatus = &microsoftGraphTermsAndConditionsAcceptanceStatus
	return r
}

func (r ApiDeviceManagementTermsAndConditionsCreateAcceptanceStatusesRequest) Execute() (MicrosoftGraphTermsAndConditionsAcceptanceStatus, *_nethttp.Response, error) {
	return r.ApiService.DeviceManagementTermsAndConditionsCreateAcceptanceStatusesExecute(r)
}

/*
DeviceManagementTermsAndConditionsCreateAcceptanceStatuses Create new navigation property to acceptanceStatuses for deviceManagement

The list of acceptance statuses for this T&C policy.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param termsAndConditionsId key: id of termsAndConditions
 @return ApiDeviceManagementTermsAndConditionsCreateAcceptanceStatusesRequest
*/
func (a *DeviceManagementTermsAndConditionsApiService) DeviceManagementTermsAndConditionsCreateAcceptanceStatuses(ctx _context.Context, termsAndConditionsId string) ApiDeviceManagementTermsAndConditionsCreateAcceptanceStatusesRequest {
	return ApiDeviceManagementTermsAndConditionsCreateAcceptanceStatusesRequest{
		ApiService: a,
		ctx: ctx,
		termsAndConditionsId: termsAndConditionsId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermsAndConditionsAcceptanceStatus
func (a *DeviceManagementTermsAndConditionsApiService) DeviceManagementTermsAndConditionsCreateAcceptanceStatusesExecute(r ApiDeviceManagementTermsAndConditionsCreateAcceptanceStatusesRequest) (MicrosoftGraphTermsAndConditionsAcceptanceStatus, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermsAndConditionsAcceptanceStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementTermsAndConditionsApiService.DeviceManagementTermsAndConditionsCreateAcceptanceStatuses")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/termsAndConditions/{termsAndConditions-id}/acceptanceStatuses"
	localVarPath = strings.Replace(localVarPath, "{"+"termsAndConditions-id"+"}", _neturl.PathEscape(parameterToString(r.termsAndConditionsId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermsAndConditionsAcceptanceStatus == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphTermsAndConditionsAcceptanceStatus is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermsAndConditionsAcceptanceStatus
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceManagementTermsAndConditionsCreateAssignmentsRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementTermsAndConditionsApiService
	termsAndConditionsId string
	microsoftGraphTermsAndConditionsAssignment *MicrosoftGraphTermsAndConditionsAssignment
}

// New navigation property
func (r ApiDeviceManagementTermsAndConditionsCreateAssignmentsRequest) MicrosoftGraphTermsAndConditionsAssignment(microsoftGraphTermsAndConditionsAssignment MicrosoftGraphTermsAndConditionsAssignment) ApiDeviceManagementTermsAndConditionsCreateAssignmentsRequest {
	r.microsoftGraphTermsAndConditionsAssignment = &microsoftGraphTermsAndConditionsAssignment
	return r
}

func (r ApiDeviceManagementTermsAndConditionsCreateAssignmentsRequest) Execute() (MicrosoftGraphTermsAndConditionsAssignment, *_nethttp.Response, error) {
	return r.ApiService.DeviceManagementTermsAndConditionsCreateAssignmentsExecute(r)
}

/*
DeviceManagementTermsAndConditionsCreateAssignments Create new navigation property to assignments for deviceManagement

The list of assignments for this T&C policy.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param termsAndConditionsId key: id of termsAndConditions
 @return ApiDeviceManagementTermsAndConditionsCreateAssignmentsRequest
*/
func (a *DeviceManagementTermsAndConditionsApiService) DeviceManagementTermsAndConditionsCreateAssignments(ctx _context.Context, termsAndConditionsId string) ApiDeviceManagementTermsAndConditionsCreateAssignmentsRequest {
	return ApiDeviceManagementTermsAndConditionsCreateAssignmentsRequest{
		ApiService: a,
		ctx: ctx,
		termsAndConditionsId: termsAndConditionsId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermsAndConditionsAssignment
func (a *DeviceManagementTermsAndConditionsApiService) DeviceManagementTermsAndConditionsCreateAssignmentsExecute(r ApiDeviceManagementTermsAndConditionsCreateAssignmentsRequest) (MicrosoftGraphTermsAndConditionsAssignment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermsAndConditionsAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementTermsAndConditionsApiService.DeviceManagementTermsAndConditionsCreateAssignments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/termsAndConditions/{termsAndConditions-id}/assignments"
	localVarPath = strings.Replace(localVarPath, "{"+"termsAndConditions-id"+"}", _neturl.PathEscape(parameterToString(r.termsAndConditionsId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermsAndConditionsAssignment == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphTermsAndConditionsAssignment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermsAndConditionsAssignment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceManagementTermsAndConditionsDeleteAcceptanceStatusesRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementTermsAndConditionsApiService
	termsAndConditionsId string
	termsAndConditionsAcceptanceStatusId string
	ifMatch *string
}

// ETag
func (r ApiDeviceManagementTermsAndConditionsDeleteAcceptanceStatusesRequest) IfMatch(ifMatch string) ApiDeviceManagementTermsAndConditionsDeleteAcceptanceStatusesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDeviceManagementTermsAndConditionsDeleteAcceptanceStatusesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeviceManagementTermsAndConditionsDeleteAcceptanceStatusesExecute(r)
}

/*
DeviceManagementTermsAndConditionsDeleteAcceptanceStatuses Delete navigation property acceptanceStatuses for deviceManagement

The list of acceptance statuses for this T&C policy.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param termsAndConditionsId key: id of termsAndConditions
 @param termsAndConditionsAcceptanceStatusId key: id of termsAndConditionsAcceptanceStatus
 @return ApiDeviceManagementTermsAndConditionsDeleteAcceptanceStatusesRequest
*/
func (a *DeviceManagementTermsAndConditionsApiService) DeviceManagementTermsAndConditionsDeleteAcceptanceStatuses(ctx _context.Context, termsAndConditionsId string, termsAndConditionsAcceptanceStatusId string) ApiDeviceManagementTermsAndConditionsDeleteAcceptanceStatusesRequest {
	return ApiDeviceManagementTermsAndConditionsDeleteAcceptanceStatusesRequest{
		ApiService: a,
		ctx: ctx,
		termsAndConditionsId: termsAndConditionsId,
		termsAndConditionsAcceptanceStatusId: termsAndConditionsAcceptanceStatusId,
	}
}

// Execute executes the request
func (a *DeviceManagementTermsAndConditionsApiService) DeviceManagementTermsAndConditionsDeleteAcceptanceStatusesExecute(r ApiDeviceManagementTermsAndConditionsDeleteAcceptanceStatusesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementTermsAndConditionsApiService.DeviceManagementTermsAndConditionsDeleteAcceptanceStatuses")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/termsAndConditions/{termsAndConditions-id}/acceptanceStatuses/{termsAndConditionsAcceptanceStatus-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"termsAndConditions-id"+"}", _neturl.PathEscape(parameterToString(r.termsAndConditionsId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"termsAndConditionsAcceptanceStatus-id"+"}", _neturl.PathEscape(parameterToString(r.termsAndConditionsAcceptanceStatusId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceManagementTermsAndConditionsDeleteAssignmentsRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementTermsAndConditionsApiService
	termsAndConditionsId string
	termsAndConditionsAssignmentId string
	ifMatch *string
}

// ETag
func (r ApiDeviceManagementTermsAndConditionsDeleteAssignmentsRequest) IfMatch(ifMatch string) ApiDeviceManagementTermsAndConditionsDeleteAssignmentsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDeviceManagementTermsAndConditionsDeleteAssignmentsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeviceManagementTermsAndConditionsDeleteAssignmentsExecute(r)
}

/*
DeviceManagementTermsAndConditionsDeleteAssignments Delete navigation property assignments for deviceManagement

The list of assignments for this T&C policy.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param termsAndConditionsId key: id of termsAndConditions
 @param termsAndConditionsAssignmentId key: id of termsAndConditionsAssignment
 @return ApiDeviceManagementTermsAndConditionsDeleteAssignmentsRequest
*/
func (a *DeviceManagementTermsAndConditionsApiService) DeviceManagementTermsAndConditionsDeleteAssignments(ctx _context.Context, termsAndConditionsId string, termsAndConditionsAssignmentId string) ApiDeviceManagementTermsAndConditionsDeleteAssignmentsRequest {
	return ApiDeviceManagementTermsAndConditionsDeleteAssignmentsRequest{
		ApiService: a,
		ctx: ctx,
		termsAndConditionsId: termsAndConditionsId,
		termsAndConditionsAssignmentId: termsAndConditionsAssignmentId,
	}
}

// Execute executes the request
func (a *DeviceManagementTermsAndConditionsApiService) DeviceManagementTermsAndConditionsDeleteAssignmentsExecute(r ApiDeviceManagementTermsAndConditionsDeleteAssignmentsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementTermsAndConditionsApiService.DeviceManagementTermsAndConditionsDeleteAssignments")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/termsAndConditions/{termsAndConditions-id}/assignments/{termsAndConditionsAssignment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"termsAndConditions-id"+"}", _neturl.PathEscape(parameterToString(r.termsAndConditionsId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"termsAndConditionsAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.termsAndConditionsAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceManagementTermsAndConditionsGetAcceptanceStatusesRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementTermsAndConditionsApiService
	termsAndConditionsId string
	termsAndConditionsAcceptanceStatusId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDeviceManagementTermsAndConditionsGetAcceptanceStatusesRequest) Select_(select_ []string) ApiDeviceManagementTermsAndConditionsGetAcceptanceStatusesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDeviceManagementTermsAndConditionsGetAcceptanceStatusesRequest) Expand(expand []string) ApiDeviceManagementTermsAndConditionsGetAcceptanceStatusesRequest {
	r.expand = &expand
	return r
}

func (r ApiDeviceManagementTermsAndConditionsGetAcceptanceStatusesRequest) Execute() (MicrosoftGraphTermsAndConditionsAcceptanceStatus, *_nethttp.Response, error) {
	return r.ApiService.DeviceManagementTermsAndConditionsGetAcceptanceStatusesExecute(r)
}

/*
DeviceManagementTermsAndConditionsGetAcceptanceStatuses Get acceptanceStatuses from deviceManagement

The list of acceptance statuses for this T&C policy.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param termsAndConditionsId key: id of termsAndConditions
 @param termsAndConditionsAcceptanceStatusId key: id of termsAndConditionsAcceptanceStatus
 @return ApiDeviceManagementTermsAndConditionsGetAcceptanceStatusesRequest
*/
func (a *DeviceManagementTermsAndConditionsApiService) DeviceManagementTermsAndConditionsGetAcceptanceStatuses(ctx _context.Context, termsAndConditionsId string, termsAndConditionsAcceptanceStatusId string) ApiDeviceManagementTermsAndConditionsGetAcceptanceStatusesRequest {
	return ApiDeviceManagementTermsAndConditionsGetAcceptanceStatusesRequest{
		ApiService: a,
		ctx: ctx,
		termsAndConditionsId: termsAndConditionsId,
		termsAndConditionsAcceptanceStatusId: termsAndConditionsAcceptanceStatusId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermsAndConditionsAcceptanceStatus
func (a *DeviceManagementTermsAndConditionsApiService) DeviceManagementTermsAndConditionsGetAcceptanceStatusesExecute(r ApiDeviceManagementTermsAndConditionsGetAcceptanceStatusesRequest) (MicrosoftGraphTermsAndConditionsAcceptanceStatus, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermsAndConditionsAcceptanceStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementTermsAndConditionsApiService.DeviceManagementTermsAndConditionsGetAcceptanceStatuses")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/termsAndConditions/{termsAndConditions-id}/acceptanceStatuses/{termsAndConditionsAcceptanceStatus-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"termsAndConditions-id"+"}", _neturl.PathEscape(parameterToString(r.termsAndConditionsId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"termsAndConditionsAcceptanceStatus-id"+"}", _neturl.PathEscape(parameterToString(r.termsAndConditionsAcceptanceStatusId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceManagementTermsAndConditionsGetAssignmentsRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementTermsAndConditionsApiService
	termsAndConditionsId string
	termsAndConditionsAssignmentId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDeviceManagementTermsAndConditionsGetAssignmentsRequest) Select_(select_ []string) ApiDeviceManagementTermsAndConditionsGetAssignmentsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDeviceManagementTermsAndConditionsGetAssignmentsRequest) Expand(expand []string) ApiDeviceManagementTermsAndConditionsGetAssignmentsRequest {
	r.expand = &expand
	return r
}

func (r ApiDeviceManagementTermsAndConditionsGetAssignmentsRequest) Execute() (MicrosoftGraphTermsAndConditionsAssignment, *_nethttp.Response, error) {
	return r.ApiService.DeviceManagementTermsAndConditionsGetAssignmentsExecute(r)
}

/*
DeviceManagementTermsAndConditionsGetAssignments Get assignments from deviceManagement

The list of assignments for this T&C policy.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param termsAndConditionsId key: id of termsAndConditions
 @param termsAndConditionsAssignmentId key: id of termsAndConditionsAssignment
 @return ApiDeviceManagementTermsAndConditionsGetAssignmentsRequest
*/
func (a *DeviceManagementTermsAndConditionsApiService) DeviceManagementTermsAndConditionsGetAssignments(ctx _context.Context, termsAndConditionsId string, termsAndConditionsAssignmentId string) ApiDeviceManagementTermsAndConditionsGetAssignmentsRequest {
	return ApiDeviceManagementTermsAndConditionsGetAssignmentsRequest{
		ApiService: a,
		ctx: ctx,
		termsAndConditionsId: termsAndConditionsId,
		termsAndConditionsAssignmentId: termsAndConditionsAssignmentId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTermsAndConditionsAssignment
func (a *DeviceManagementTermsAndConditionsApiService) DeviceManagementTermsAndConditionsGetAssignmentsExecute(r ApiDeviceManagementTermsAndConditionsGetAssignmentsRequest) (MicrosoftGraphTermsAndConditionsAssignment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTermsAndConditionsAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementTermsAndConditionsApiService.DeviceManagementTermsAndConditionsGetAssignments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/termsAndConditions/{termsAndConditions-id}/assignments/{termsAndConditionsAssignment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"termsAndConditions-id"+"}", _neturl.PathEscape(parameterToString(r.termsAndConditionsId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"termsAndConditionsAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.termsAndConditionsAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceManagementTermsAndConditionsListAcceptanceStatusesRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementTermsAndConditionsApiService
	termsAndConditionsId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiDeviceManagementTermsAndConditionsListAcceptanceStatusesRequest) Top(top int32) ApiDeviceManagementTermsAndConditionsListAcceptanceStatusesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiDeviceManagementTermsAndConditionsListAcceptanceStatusesRequest) Skip(skip int32) ApiDeviceManagementTermsAndConditionsListAcceptanceStatusesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiDeviceManagementTermsAndConditionsListAcceptanceStatusesRequest) Search(search string) ApiDeviceManagementTermsAndConditionsListAcceptanceStatusesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiDeviceManagementTermsAndConditionsListAcceptanceStatusesRequest) Filter(filter string) ApiDeviceManagementTermsAndConditionsListAcceptanceStatusesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiDeviceManagementTermsAndConditionsListAcceptanceStatusesRequest) Count(count bool) ApiDeviceManagementTermsAndConditionsListAcceptanceStatusesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiDeviceManagementTermsAndConditionsListAcceptanceStatusesRequest) Orderby(orderby []string) ApiDeviceManagementTermsAndConditionsListAcceptanceStatusesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiDeviceManagementTermsAndConditionsListAcceptanceStatusesRequest) Select_(select_ []string) ApiDeviceManagementTermsAndConditionsListAcceptanceStatusesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDeviceManagementTermsAndConditionsListAcceptanceStatusesRequest) Expand(expand []string) ApiDeviceManagementTermsAndConditionsListAcceptanceStatusesRequest {
	r.expand = &expand
	return r
}

func (r ApiDeviceManagementTermsAndConditionsListAcceptanceStatusesRequest) Execute() (CollectionOfTermsAndConditionsAcceptanceStatus, *_nethttp.Response, error) {
	return r.ApiService.DeviceManagementTermsAndConditionsListAcceptanceStatusesExecute(r)
}

/*
DeviceManagementTermsAndConditionsListAcceptanceStatuses Get acceptanceStatuses from deviceManagement

The list of acceptance statuses for this T&C policy.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param termsAndConditionsId key: id of termsAndConditions
 @return ApiDeviceManagementTermsAndConditionsListAcceptanceStatusesRequest
*/
func (a *DeviceManagementTermsAndConditionsApiService) DeviceManagementTermsAndConditionsListAcceptanceStatuses(ctx _context.Context, termsAndConditionsId string) ApiDeviceManagementTermsAndConditionsListAcceptanceStatusesRequest {
	return ApiDeviceManagementTermsAndConditionsListAcceptanceStatusesRequest{
		ApiService: a,
		ctx: ctx,
		termsAndConditionsId: termsAndConditionsId,
	}
}

// Execute executes the request
//  @return CollectionOfTermsAndConditionsAcceptanceStatus
func (a *DeviceManagementTermsAndConditionsApiService) DeviceManagementTermsAndConditionsListAcceptanceStatusesExecute(r ApiDeviceManagementTermsAndConditionsListAcceptanceStatusesRequest) (CollectionOfTermsAndConditionsAcceptanceStatus, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfTermsAndConditionsAcceptanceStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementTermsAndConditionsApiService.DeviceManagementTermsAndConditionsListAcceptanceStatuses")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/termsAndConditions/{termsAndConditions-id}/acceptanceStatuses"
	localVarPath = strings.Replace(localVarPath, "{"+"termsAndConditions-id"+"}", _neturl.PathEscape(parameterToString(r.termsAndConditionsId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceManagementTermsAndConditionsListAssignmentsRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementTermsAndConditionsApiService
	termsAndConditionsId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiDeviceManagementTermsAndConditionsListAssignmentsRequest) Top(top int32) ApiDeviceManagementTermsAndConditionsListAssignmentsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiDeviceManagementTermsAndConditionsListAssignmentsRequest) Skip(skip int32) ApiDeviceManagementTermsAndConditionsListAssignmentsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiDeviceManagementTermsAndConditionsListAssignmentsRequest) Search(search string) ApiDeviceManagementTermsAndConditionsListAssignmentsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiDeviceManagementTermsAndConditionsListAssignmentsRequest) Filter(filter string) ApiDeviceManagementTermsAndConditionsListAssignmentsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiDeviceManagementTermsAndConditionsListAssignmentsRequest) Count(count bool) ApiDeviceManagementTermsAndConditionsListAssignmentsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiDeviceManagementTermsAndConditionsListAssignmentsRequest) Orderby(orderby []string) ApiDeviceManagementTermsAndConditionsListAssignmentsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiDeviceManagementTermsAndConditionsListAssignmentsRequest) Select_(select_ []string) ApiDeviceManagementTermsAndConditionsListAssignmentsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDeviceManagementTermsAndConditionsListAssignmentsRequest) Expand(expand []string) ApiDeviceManagementTermsAndConditionsListAssignmentsRequest {
	r.expand = &expand
	return r
}

func (r ApiDeviceManagementTermsAndConditionsListAssignmentsRequest) Execute() (CollectionOfTermsAndConditionsAssignment, *_nethttp.Response, error) {
	return r.ApiService.DeviceManagementTermsAndConditionsListAssignmentsExecute(r)
}

/*
DeviceManagementTermsAndConditionsListAssignments Get assignments from deviceManagement

The list of assignments for this T&C policy.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param termsAndConditionsId key: id of termsAndConditions
 @return ApiDeviceManagementTermsAndConditionsListAssignmentsRequest
*/
func (a *DeviceManagementTermsAndConditionsApiService) DeviceManagementTermsAndConditionsListAssignments(ctx _context.Context, termsAndConditionsId string) ApiDeviceManagementTermsAndConditionsListAssignmentsRequest {
	return ApiDeviceManagementTermsAndConditionsListAssignmentsRequest{
		ApiService: a,
		ctx: ctx,
		termsAndConditionsId: termsAndConditionsId,
	}
}

// Execute executes the request
//  @return CollectionOfTermsAndConditionsAssignment
func (a *DeviceManagementTermsAndConditionsApiService) DeviceManagementTermsAndConditionsListAssignmentsExecute(r ApiDeviceManagementTermsAndConditionsListAssignmentsRequest) (CollectionOfTermsAndConditionsAssignment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfTermsAndConditionsAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementTermsAndConditionsApiService.DeviceManagementTermsAndConditionsListAssignments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/termsAndConditions/{termsAndConditions-id}/assignments"
	localVarPath = strings.Replace(localVarPath, "{"+"termsAndConditions-id"+"}", _neturl.PathEscape(parameterToString(r.termsAndConditionsId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceManagementTermsAndConditionsUpdateAcceptanceStatusesRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementTermsAndConditionsApiService
	termsAndConditionsId string
	termsAndConditionsAcceptanceStatusId string
	microsoftGraphTermsAndConditionsAcceptanceStatus *MicrosoftGraphTermsAndConditionsAcceptanceStatus
}

// New navigation property values
func (r ApiDeviceManagementTermsAndConditionsUpdateAcceptanceStatusesRequest) MicrosoftGraphTermsAndConditionsAcceptanceStatus(microsoftGraphTermsAndConditionsAcceptanceStatus MicrosoftGraphTermsAndConditionsAcceptanceStatus) ApiDeviceManagementTermsAndConditionsUpdateAcceptanceStatusesRequest {
	r.microsoftGraphTermsAndConditionsAcceptanceStatus = &microsoftGraphTermsAndConditionsAcceptanceStatus
	return r
}

func (r ApiDeviceManagementTermsAndConditionsUpdateAcceptanceStatusesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeviceManagementTermsAndConditionsUpdateAcceptanceStatusesExecute(r)
}

/*
DeviceManagementTermsAndConditionsUpdateAcceptanceStatuses Update the navigation property acceptanceStatuses in deviceManagement

The list of acceptance statuses for this T&C policy.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param termsAndConditionsId key: id of termsAndConditions
 @param termsAndConditionsAcceptanceStatusId key: id of termsAndConditionsAcceptanceStatus
 @return ApiDeviceManagementTermsAndConditionsUpdateAcceptanceStatusesRequest
*/
func (a *DeviceManagementTermsAndConditionsApiService) DeviceManagementTermsAndConditionsUpdateAcceptanceStatuses(ctx _context.Context, termsAndConditionsId string, termsAndConditionsAcceptanceStatusId string) ApiDeviceManagementTermsAndConditionsUpdateAcceptanceStatusesRequest {
	return ApiDeviceManagementTermsAndConditionsUpdateAcceptanceStatusesRequest{
		ApiService: a,
		ctx: ctx,
		termsAndConditionsId: termsAndConditionsId,
		termsAndConditionsAcceptanceStatusId: termsAndConditionsAcceptanceStatusId,
	}
}

// Execute executes the request
func (a *DeviceManagementTermsAndConditionsApiService) DeviceManagementTermsAndConditionsUpdateAcceptanceStatusesExecute(r ApiDeviceManagementTermsAndConditionsUpdateAcceptanceStatusesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementTermsAndConditionsApiService.DeviceManagementTermsAndConditionsUpdateAcceptanceStatuses")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/termsAndConditions/{termsAndConditions-id}/acceptanceStatuses/{termsAndConditionsAcceptanceStatus-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"termsAndConditions-id"+"}", _neturl.PathEscape(parameterToString(r.termsAndConditionsId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"termsAndConditionsAcceptanceStatus-id"+"}", _neturl.PathEscape(parameterToString(r.termsAndConditionsAcceptanceStatusId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermsAndConditionsAcceptanceStatus == nil {
		return nil, reportError("microsoftGraphTermsAndConditionsAcceptanceStatus is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermsAndConditionsAcceptanceStatus
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceManagementTermsAndConditionsUpdateAssignmentsRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementTermsAndConditionsApiService
	termsAndConditionsId string
	termsAndConditionsAssignmentId string
	microsoftGraphTermsAndConditionsAssignment *MicrosoftGraphTermsAndConditionsAssignment
}

// New navigation property values
func (r ApiDeviceManagementTermsAndConditionsUpdateAssignmentsRequest) MicrosoftGraphTermsAndConditionsAssignment(microsoftGraphTermsAndConditionsAssignment MicrosoftGraphTermsAndConditionsAssignment) ApiDeviceManagementTermsAndConditionsUpdateAssignmentsRequest {
	r.microsoftGraphTermsAndConditionsAssignment = &microsoftGraphTermsAndConditionsAssignment
	return r
}

func (r ApiDeviceManagementTermsAndConditionsUpdateAssignmentsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeviceManagementTermsAndConditionsUpdateAssignmentsExecute(r)
}

/*
DeviceManagementTermsAndConditionsUpdateAssignments Update the navigation property assignments in deviceManagement

The list of assignments for this T&C policy.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param termsAndConditionsId key: id of termsAndConditions
 @param termsAndConditionsAssignmentId key: id of termsAndConditionsAssignment
 @return ApiDeviceManagementTermsAndConditionsUpdateAssignmentsRequest
*/
func (a *DeviceManagementTermsAndConditionsApiService) DeviceManagementTermsAndConditionsUpdateAssignments(ctx _context.Context, termsAndConditionsId string, termsAndConditionsAssignmentId string) ApiDeviceManagementTermsAndConditionsUpdateAssignmentsRequest {
	return ApiDeviceManagementTermsAndConditionsUpdateAssignmentsRequest{
		ApiService: a,
		ctx: ctx,
		termsAndConditionsId: termsAndConditionsId,
		termsAndConditionsAssignmentId: termsAndConditionsAssignmentId,
	}
}

// Execute executes the request
func (a *DeviceManagementTermsAndConditionsApiService) DeviceManagementTermsAndConditionsUpdateAssignmentsExecute(r ApiDeviceManagementTermsAndConditionsUpdateAssignmentsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementTermsAndConditionsApiService.DeviceManagementTermsAndConditionsUpdateAssignments")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/termsAndConditions/{termsAndConditions-id}/assignments/{termsAndConditionsAssignment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"termsAndConditions-id"+"}", _neturl.PathEscape(parameterToString(r.termsAndConditionsId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"termsAndConditionsAssignment-id"+"}", _neturl.PathEscape(parameterToString(r.termsAndConditionsAssignmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermsAndConditionsAssignment == nil {
		return nil, reportError("microsoftGraphTermsAndConditionsAssignment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermsAndConditionsAssignment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceManagementUpdateTermsAndConditionsRequest struct {
	ctx _context.Context
	ApiService *DeviceManagementTermsAndConditionsApiService
	termsAndConditionsId string
	microsoftGraphTermsAndConditions *MicrosoftGraphTermsAndConditions
}

// New navigation property values
func (r ApiDeviceManagementUpdateTermsAndConditionsRequest) MicrosoftGraphTermsAndConditions(microsoftGraphTermsAndConditions MicrosoftGraphTermsAndConditions) ApiDeviceManagementUpdateTermsAndConditionsRequest {
	r.microsoftGraphTermsAndConditions = &microsoftGraphTermsAndConditions
	return r
}

func (r ApiDeviceManagementUpdateTermsAndConditionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeviceManagementUpdateTermsAndConditionsExecute(r)
}

/*
DeviceManagementUpdateTermsAndConditions Update the navigation property termsAndConditions in deviceManagement

The terms and conditions associated with device management of the company.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param termsAndConditionsId key: id of termsAndConditions
 @return ApiDeviceManagementUpdateTermsAndConditionsRequest
*/
func (a *DeviceManagementTermsAndConditionsApiService) DeviceManagementUpdateTermsAndConditions(ctx _context.Context, termsAndConditionsId string) ApiDeviceManagementUpdateTermsAndConditionsRequest {
	return ApiDeviceManagementUpdateTermsAndConditionsRequest{
		ApiService: a,
		ctx: ctx,
		termsAndConditionsId: termsAndConditionsId,
	}
}

// Execute executes the request
func (a *DeviceManagementTermsAndConditionsApiService) DeviceManagementUpdateTermsAndConditionsExecute(r ApiDeviceManagementUpdateTermsAndConditionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceManagementTermsAndConditionsApiService.DeviceManagementUpdateTermsAndConditions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deviceManagement/termsAndConditions/{termsAndConditions-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"termsAndConditions-id"+"}", _neturl.PathEscape(parameterToString(r.termsAndConditionsId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTermsAndConditions == nil {
		return nil, reportError("microsoftGraphTermsAndConditions is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTermsAndConditions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
