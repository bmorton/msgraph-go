/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// SitesContentTypeApiService SitesContentTypeApi service
type SitesContentTypeApiService service

type ApiSitesContentTypesColumnsDeleteRefSourceColumnRequest struct {
	ctx _context.Context
	ApiService *SitesContentTypeApiService
	siteId string
	contentTypeId string
	columnDefinitionId string
	ifMatch *string
}

// ETag
func (r ApiSitesContentTypesColumnsDeleteRefSourceColumnRequest) IfMatch(ifMatch string) ApiSitesContentTypesColumnsDeleteRefSourceColumnRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesContentTypesColumnsDeleteRefSourceColumnRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesContentTypesColumnsDeleteRefSourceColumnExecute(r)
}

/*
SitesContentTypesColumnsDeleteRefSourceColumn Delete ref of navigation property sourceColumn for sites

The source column for the content type column.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param contentTypeId key: id of contentType
 @param columnDefinitionId key: id of columnDefinition
 @return ApiSitesContentTypesColumnsDeleteRefSourceColumnRequest
*/
func (a *SitesContentTypeApiService) SitesContentTypesColumnsDeleteRefSourceColumn(ctx _context.Context, siteId string, contentTypeId string, columnDefinitionId string) ApiSitesContentTypesColumnsDeleteRefSourceColumnRequest {
	return ApiSitesContentTypesColumnsDeleteRefSourceColumnRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		contentTypeId: contentTypeId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
func (a *SitesContentTypeApiService) SitesContentTypesColumnsDeleteRefSourceColumnExecute(r ApiSitesContentTypesColumnsDeleteRefSourceColumnRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesContentTypeApiService.SitesContentTypesColumnsDeleteRefSourceColumn")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/contentTypes/{contentType-id}/columns/{columnDefinition-id}/sourceColumn/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesContentTypesColumnsGetRefSourceColumnRequest struct {
	ctx _context.Context
	ApiService *SitesContentTypeApiService
	siteId string
	contentTypeId string
	columnDefinitionId string
}


func (r ApiSitesContentTypesColumnsGetRefSourceColumnRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SitesContentTypesColumnsGetRefSourceColumnExecute(r)
}

/*
SitesContentTypesColumnsGetRefSourceColumn Get ref of sourceColumn from sites

The source column for the content type column.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param contentTypeId key: id of contentType
 @param columnDefinitionId key: id of columnDefinition
 @return ApiSitesContentTypesColumnsGetRefSourceColumnRequest
*/
func (a *SitesContentTypeApiService) SitesContentTypesColumnsGetRefSourceColumn(ctx _context.Context, siteId string, contentTypeId string, columnDefinitionId string) ApiSitesContentTypesColumnsGetRefSourceColumnRequest {
	return ApiSitesContentTypesColumnsGetRefSourceColumnRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		contentTypeId: contentTypeId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
//  @return string
func (a *SitesContentTypeApiService) SitesContentTypesColumnsGetRefSourceColumnExecute(r ApiSitesContentTypesColumnsGetRefSourceColumnRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesContentTypeApiService.SitesContentTypesColumnsGetRefSourceColumn")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/contentTypes/{contentType-id}/columns/{columnDefinition-id}/sourceColumn/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesContentTypesColumnsGetSourceColumnRequest struct {
	ctx _context.Context
	ApiService *SitesContentTypeApiService
	siteId string
	contentTypeId string
	columnDefinitionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesContentTypesColumnsGetSourceColumnRequest) Select_(select_ []string) ApiSitesContentTypesColumnsGetSourceColumnRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesContentTypesColumnsGetSourceColumnRequest) Expand(expand []string) ApiSitesContentTypesColumnsGetSourceColumnRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesContentTypesColumnsGetSourceColumnRequest) Execute() (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.SitesContentTypesColumnsGetSourceColumnExecute(r)
}

/*
SitesContentTypesColumnsGetSourceColumn Get sourceColumn from sites

The source column for the content type column.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param contentTypeId key: id of contentType
 @param columnDefinitionId key: id of columnDefinition
 @return ApiSitesContentTypesColumnsGetSourceColumnRequest
*/
func (a *SitesContentTypeApiService) SitesContentTypesColumnsGetSourceColumn(ctx _context.Context, siteId string, contentTypeId string, columnDefinitionId string) ApiSitesContentTypesColumnsGetSourceColumnRequest {
	return ApiSitesContentTypesColumnsGetSourceColumnRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		contentTypeId: contentTypeId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphColumnDefinition
func (a *SitesContentTypeApiService) SitesContentTypesColumnsGetSourceColumnExecute(r ApiSitesContentTypesColumnsGetSourceColumnRequest) (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesContentTypeApiService.SitesContentTypesColumnsGetSourceColumn")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/contentTypes/{contentType-id}/columns/{columnDefinition-id}/sourceColumn"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesContentTypesColumnsUpdateRefSourceColumnRequest struct {
	ctx _context.Context
	ApiService *SitesContentTypeApiService
	siteId string
	contentTypeId string
	columnDefinitionId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSitesContentTypesColumnsUpdateRefSourceColumnRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesContentTypesColumnsUpdateRefSourceColumnRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesContentTypesColumnsUpdateRefSourceColumnRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesContentTypesColumnsUpdateRefSourceColumnExecute(r)
}

/*
SitesContentTypesColumnsUpdateRefSourceColumn Update the ref of navigation property sourceColumn in sites

The source column for the content type column.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param contentTypeId key: id of contentType
 @param columnDefinitionId key: id of columnDefinition
 @return ApiSitesContentTypesColumnsUpdateRefSourceColumnRequest
*/
func (a *SitesContentTypeApiService) SitesContentTypesColumnsUpdateRefSourceColumn(ctx _context.Context, siteId string, contentTypeId string, columnDefinitionId string) ApiSitesContentTypesColumnsUpdateRefSourceColumnRequest {
	return ApiSitesContentTypesColumnsUpdateRefSourceColumnRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		contentTypeId: contentTypeId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
func (a *SitesContentTypeApiService) SitesContentTypesColumnsUpdateRefSourceColumnExecute(r ApiSitesContentTypesColumnsUpdateRefSourceColumnRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesContentTypeApiService.SitesContentTypesColumnsUpdateRefSourceColumn")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/contentTypes/{contentType-id}/columns/{columnDefinition-id}/sourceColumn/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesContentTypesCreateColumnLinksRequest struct {
	ctx _context.Context
	ApiService *SitesContentTypeApiService
	siteId string
	contentTypeId string
	microsoftGraphColumnLink *MicrosoftGraphColumnLink
}

// New navigation property
func (r ApiSitesContentTypesCreateColumnLinksRequest) MicrosoftGraphColumnLink(microsoftGraphColumnLink MicrosoftGraphColumnLink) ApiSitesContentTypesCreateColumnLinksRequest {
	r.microsoftGraphColumnLink = &microsoftGraphColumnLink
	return r
}

func (r ApiSitesContentTypesCreateColumnLinksRequest) Execute() (MicrosoftGraphColumnLink, *_nethttp.Response, error) {
	return r.ApiService.SitesContentTypesCreateColumnLinksExecute(r)
}

/*
SitesContentTypesCreateColumnLinks Create new navigation property to columnLinks for sites

The collection of columns that are required by this content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param contentTypeId key: id of contentType
 @return ApiSitesContentTypesCreateColumnLinksRequest
*/
func (a *SitesContentTypeApiService) SitesContentTypesCreateColumnLinks(ctx _context.Context, siteId string, contentTypeId string) ApiSitesContentTypesCreateColumnLinksRequest {
	return ApiSitesContentTypesCreateColumnLinksRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphColumnLink
func (a *SitesContentTypeApiService) SitesContentTypesCreateColumnLinksExecute(r ApiSitesContentTypesCreateColumnLinksRequest) (MicrosoftGraphColumnLink, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphColumnLink
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesContentTypeApiService.SitesContentTypesCreateColumnLinks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/contentTypes/{contentType-id}/columnLinks"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphColumnLink == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphColumnLink is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphColumnLink
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesContentTypesCreateColumnsRequest struct {
	ctx _context.Context
	ApiService *SitesContentTypeApiService
	siteId string
	contentTypeId string
	microsoftGraphColumnDefinition *MicrosoftGraphColumnDefinition
}

// New navigation property
func (r ApiSitesContentTypesCreateColumnsRequest) MicrosoftGraphColumnDefinition(microsoftGraphColumnDefinition MicrosoftGraphColumnDefinition) ApiSitesContentTypesCreateColumnsRequest {
	r.microsoftGraphColumnDefinition = &microsoftGraphColumnDefinition
	return r
}

func (r ApiSitesContentTypesCreateColumnsRequest) Execute() (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.SitesContentTypesCreateColumnsExecute(r)
}

/*
SitesContentTypesCreateColumns Create new navigation property to columns for sites

The collection of column definitions for this contentType.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param contentTypeId key: id of contentType
 @return ApiSitesContentTypesCreateColumnsRequest
*/
func (a *SitesContentTypeApiService) SitesContentTypesCreateColumns(ctx _context.Context, siteId string, contentTypeId string) ApiSitesContentTypesCreateColumnsRequest {
	return ApiSitesContentTypesCreateColumnsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphColumnDefinition
func (a *SitesContentTypeApiService) SitesContentTypesCreateColumnsExecute(r ApiSitesContentTypesCreateColumnsRequest) (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesContentTypeApiService.SitesContentTypesCreateColumns")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/contentTypes/{contentType-id}/columns"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphColumnDefinition == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphColumnDefinition is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphColumnDefinition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesContentTypesCreateRefBaseTypesRequest struct {
	ctx _context.Context
	ApiService *SitesContentTypeApiService
	siteId string
	contentTypeId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref value
func (r ApiSitesContentTypesCreateRefBaseTypesRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesContentTypesCreateRefBaseTypesRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesContentTypesCreateRefBaseTypesRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.SitesContentTypesCreateRefBaseTypesExecute(r)
}

/*
SitesContentTypesCreateRefBaseTypes Create new navigation property ref to baseTypes for sites

The collection of content types that are ancestors of this content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param contentTypeId key: id of contentType
 @return ApiSitesContentTypesCreateRefBaseTypesRequest
*/
func (a *SitesContentTypeApiService) SitesContentTypesCreateRefBaseTypes(ctx _context.Context, siteId string, contentTypeId string) ApiSitesContentTypesCreateRefBaseTypesRequest {
	return ApiSitesContentTypesCreateRefBaseTypesRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *SitesContentTypeApiService) SitesContentTypesCreateRefBaseTypesExecute(r ApiSitesContentTypesCreateRefBaseTypesRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesContentTypeApiService.SitesContentTypesCreateRefBaseTypes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/contentTypes/{contentType-id}/baseTypes/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesContentTypesCreateRefColumnPositionsRequest struct {
	ctx _context.Context
	ApiService *SitesContentTypeApiService
	siteId string
	contentTypeId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref value
func (r ApiSitesContentTypesCreateRefColumnPositionsRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesContentTypesCreateRefColumnPositionsRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesContentTypesCreateRefColumnPositionsRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.SitesContentTypesCreateRefColumnPositionsExecute(r)
}

/*
SitesContentTypesCreateRefColumnPositions Create new navigation property ref to columnPositions for sites

Column order information in a content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param contentTypeId key: id of contentType
 @return ApiSitesContentTypesCreateRefColumnPositionsRequest
*/
func (a *SitesContentTypeApiService) SitesContentTypesCreateRefColumnPositions(ctx _context.Context, siteId string, contentTypeId string) ApiSitesContentTypesCreateRefColumnPositionsRequest {
	return ApiSitesContentTypesCreateRefColumnPositionsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *SitesContentTypeApiService) SitesContentTypesCreateRefColumnPositionsExecute(r ApiSitesContentTypesCreateRefColumnPositionsRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesContentTypeApiService.SitesContentTypesCreateRefColumnPositions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/contentTypes/{contentType-id}/columnPositions/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesContentTypesDeleteColumnLinksRequest struct {
	ctx _context.Context
	ApiService *SitesContentTypeApiService
	siteId string
	contentTypeId string
	columnLinkId string
	ifMatch *string
}

// ETag
func (r ApiSitesContentTypesDeleteColumnLinksRequest) IfMatch(ifMatch string) ApiSitesContentTypesDeleteColumnLinksRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesContentTypesDeleteColumnLinksRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesContentTypesDeleteColumnLinksExecute(r)
}

/*
SitesContentTypesDeleteColumnLinks Delete navigation property columnLinks for sites

The collection of columns that are required by this content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param contentTypeId key: id of contentType
 @param columnLinkId key: id of columnLink
 @return ApiSitesContentTypesDeleteColumnLinksRequest
*/
func (a *SitesContentTypeApiService) SitesContentTypesDeleteColumnLinks(ctx _context.Context, siteId string, contentTypeId string, columnLinkId string) ApiSitesContentTypesDeleteColumnLinksRequest {
	return ApiSitesContentTypesDeleteColumnLinksRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		contentTypeId: contentTypeId,
		columnLinkId: columnLinkId,
	}
}

// Execute executes the request
func (a *SitesContentTypeApiService) SitesContentTypesDeleteColumnLinksExecute(r ApiSitesContentTypesDeleteColumnLinksRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesContentTypeApiService.SitesContentTypesDeleteColumnLinks")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/contentTypes/{contentType-id}/columnLinks/{columnLink-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnLink-id"+"}", _neturl.PathEscape(parameterToString(r.columnLinkId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesContentTypesDeleteColumnsRequest struct {
	ctx _context.Context
	ApiService *SitesContentTypeApiService
	siteId string
	contentTypeId string
	columnDefinitionId string
	ifMatch *string
}

// ETag
func (r ApiSitesContentTypesDeleteColumnsRequest) IfMatch(ifMatch string) ApiSitesContentTypesDeleteColumnsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesContentTypesDeleteColumnsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesContentTypesDeleteColumnsExecute(r)
}

/*
SitesContentTypesDeleteColumns Delete navigation property columns for sites

The collection of column definitions for this contentType.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param contentTypeId key: id of contentType
 @param columnDefinitionId key: id of columnDefinition
 @return ApiSitesContentTypesDeleteColumnsRequest
*/
func (a *SitesContentTypeApiService) SitesContentTypesDeleteColumns(ctx _context.Context, siteId string, contentTypeId string, columnDefinitionId string) ApiSitesContentTypesDeleteColumnsRequest {
	return ApiSitesContentTypesDeleteColumnsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		contentTypeId: contentTypeId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
func (a *SitesContentTypeApiService) SitesContentTypesDeleteColumnsExecute(r ApiSitesContentTypesDeleteColumnsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesContentTypeApiService.SitesContentTypesDeleteColumns")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/contentTypes/{contentType-id}/columns/{columnDefinition-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesContentTypesDeleteRefBaseRequest struct {
	ctx _context.Context
	ApiService *SitesContentTypeApiService
	siteId string
	contentTypeId string
	ifMatch *string
}

// ETag
func (r ApiSitesContentTypesDeleteRefBaseRequest) IfMatch(ifMatch string) ApiSitesContentTypesDeleteRefBaseRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesContentTypesDeleteRefBaseRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesContentTypesDeleteRefBaseExecute(r)
}

/*
SitesContentTypesDeleteRefBase Delete ref of navigation property base for sites

Parent contentType from which this content type is derived.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param contentTypeId key: id of contentType
 @return ApiSitesContentTypesDeleteRefBaseRequest
*/
func (a *SitesContentTypeApiService) SitesContentTypesDeleteRefBase(ctx _context.Context, siteId string, contentTypeId string) ApiSitesContentTypesDeleteRefBaseRequest {
	return ApiSitesContentTypesDeleteRefBaseRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
func (a *SitesContentTypeApiService) SitesContentTypesDeleteRefBaseExecute(r ApiSitesContentTypesDeleteRefBaseRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesContentTypeApiService.SitesContentTypesDeleteRefBase")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/contentTypes/{contentType-id}/base/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesContentTypesGetBaseRequest struct {
	ctx _context.Context
	ApiService *SitesContentTypeApiService
	siteId string
	contentTypeId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesContentTypesGetBaseRequest) Select_(select_ []string) ApiSitesContentTypesGetBaseRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesContentTypesGetBaseRequest) Expand(expand []string) ApiSitesContentTypesGetBaseRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesContentTypesGetBaseRequest) Execute() (MicrosoftGraphContentType, *_nethttp.Response, error) {
	return r.ApiService.SitesContentTypesGetBaseExecute(r)
}

/*
SitesContentTypesGetBase Get base from sites

Parent contentType from which this content type is derived.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param contentTypeId key: id of contentType
 @return ApiSitesContentTypesGetBaseRequest
*/
func (a *SitesContentTypeApiService) SitesContentTypesGetBase(ctx _context.Context, siteId string, contentTypeId string) ApiSitesContentTypesGetBaseRequest {
	return ApiSitesContentTypesGetBaseRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphContentType
func (a *SitesContentTypeApiService) SitesContentTypesGetBaseExecute(r ApiSitesContentTypesGetBaseRequest) (MicrosoftGraphContentType, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphContentType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesContentTypeApiService.SitesContentTypesGetBase")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/contentTypes/{contentType-id}/base"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesContentTypesGetColumnLinksRequest struct {
	ctx _context.Context
	ApiService *SitesContentTypeApiService
	siteId string
	contentTypeId string
	columnLinkId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesContentTypesGetColumnLinksRequest) Select_(select_ []string) ApiSitesContentTypesGetColumnLinksRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesContentTypesGetColumnLinksRequest) Expand(expand []string) ApiSitesContentTypesGetColumnLinksRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesContentTypesGetColumnLinksRequest) Execute() (MicrosoftGraphColumnLink, *_nethttp.Response, error) {
	return r.ApiService.SitesContentTypesGetColumnLinksExecute(r)
}

/*
SitesContentTypesGetColumnLinks Get columnLinks from sites

The collection of columns that are required by this content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param contentTypeId key: id of contentType
 @param columnLinkId key: id of columnLink
 @return ApiSitesContentTypesGetColumnLinksRequest
*/
func (a *SitesContentTypeApiService) SitesContentTypesGetColumnLinks(ctx _context.Context, siteId string, contentTypeId string, columnLinkId string) ApiSitesContentTypesGetColumnLinksRequest {
	return ApiSitesContentTypesGetColumnLinksRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		contentTypeId: contentTypeId,
		columnLinkId: columnLinkId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphColumnLink
func (a *SitesContentTypeApiService) SitesContentTypesGetColumnLinksExecute(r ApiSitesContentTypesGetColumnLinksRequest) (MicrosoftGraphColumnLink, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphColumnLink
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesContentTypeApiService.SitesContentTypesGetColumnLinks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/contentTypes/{contentType-id}/columnLinks/{columnLink-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnLink-id"+"}", _neturl.PathEscape(parameterToString(r.columnLinkId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesContentTypesGetColumnsRequest struct {
	ctx _context.Context
	ApiService *SitesContentTypeApiService
	siteId string
	contentTypeId string
	columnDefinitionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesContentTypesGetColumnsRequest) Select_(select_ []string) ApiSitesContentTypesGetColumnsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesContentTypesGetColumnsRequest) Expand(expand []string) ApiSitesContentTypesGetColumnsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesContentTypesGetColumnsRequest) Execute() (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.SitesContentTypesGetColumnsExecute(r)
}

/*
SitesContentTypesGetColumns Get columns from sites

The collection of column definitions for this contentType.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param contentTypeId key: id of contentType
 @param columnDefinitionId key: id of columnDefinition
 @return ApiSitesContentTypesGetColumnsRequest
*/
func (a *SitesContentTypeApiService) SitesContentTypesGetColumns(ctx _context.Context, siteId string, contentTypeId string, columnDefinitionId string) ApiSitesContentTypesGetColumnsRequest {
	return ApiSitesContentTypesGetColumnsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		contentTypeId: contentTypeId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphColumnDefinition
func (a *SitesContentTypeApiService) SitesContentTypesGetColumnsExecute(r ApiSitesContentTypesGetColumnsRequest) (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesContentTypeApiService.SitesContentTypesGetColumns")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/contentTypes/{contentType-id}/columns/{columnDefinition-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesContentTypesGetRefBaseRequest struct {
	ctx _context.Context
	ApiService *SitesContentTypeApiService
	siteId string
	contentTypeId string
}


func (r ApiSitesContentTypesGetRefBaseRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SitesContentTypesGetRefBaseExecute(r)
}

/*
SitesContentTypesGetRefBase Get ref of base from sites

Parent contentType from which this content type is derived.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param contentTypeId key: id of contentType
 @return ApiSitesContentTypesGetRefBaseRequest
*/
func (a *SitesContentTypeApiService) SitesContentTypesGetRefBase(ctx _context.Context, siteId string, contentTypeId string) ApiSitesContentTypesGetRefBaseRequest {
	return ApiSitesContentTypesGetRefBaseRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return string
func (a *SitesContentTypeApiService) SitesContentTypesGetRefBaseExecute(r ApiSitesContentTypesGetRefBaseRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesContentTypeApiService.SitesContentTypesGetRefBase")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/contentTypes/{contentType-id}/base/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesContentTypesListBaseTypesRequest struct {
	ctx _context.Context
	ApiService *SitesContentTypeApiService
	siteId string
	contentTypeId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesContentTypesListBaseTypesRequest) Top(top int32) ApiSitesContentTypesListBaseTypesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesContentTypesListBaseTypesRequest) Skip(skip int32) ApiSitesContentTypesListBaseTypesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesContentTypesListBaseTypesRequest) Search(search string) ApiSitesContentTypesListBaseTypesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesContentTypesListBaseTypesRequest) Filter(filter string) ApiSitesContentTypesListBaseTypesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesContentTypesListBaseTypesRequest) Count(count bool) ApiSitesContentTypesListBaseTypesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesContentTypesListBaseTypesRequest) Orderby(orderby []string) ApiSitesContentTypesListBaseTypesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesContentTypesListBaseTypesRequest) Select_(select_ []string) ApiSitesContentTypesListBaseTypesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesContentTypesListBaseTypesRequest) Expand(expand []string) ApiSitesContentTypesListBaseTypesRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesContentTypesListBaseTypesRequest) Execute() (CollectionOfContentType, *_nethttp.Response, error) {
	return r.ApiService.SitesContentTypesListBaseTypesExecute(r)
}

/*
SitesContentTypesListBaseTypes Get baseTypes from sites

The collection of content types that are ancestors of this content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param contentTypeId key: id of contentType
 @return ApiSitesContentTypesListBaseTypesRequest
*/
func (a *SitesContentTypeApiService) SitesContentTypesListBaseTypes(ctx _context.Context, siteId string, contentTypeId string) ApiSitesContentTypesListBaseTypesRequest {
	return ApiSitesContentTypesListBaseTypesRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return CollectionOfContentType
func (a *SitesContentTypeApiService) SitesContentTypesListBaseTypesExecute(r ApiSitesContentTypesListBaseTypesRequest) (CollectionOfContentType, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfContentType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesContentTypeApiService.SitesContentTypesListBaseTypes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/contentTypes/{contentType-id}/baseTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesContentTypesListColumnLinksRequest struct {
	ctx _context.Context
	ApiService *SitesContentTypeApiService
	siteId string
	contentTypeId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesContentTypesListColumnLinksRequest) Top(top int32) ApiSitesContentTypesListColumnLinksRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesContentTypesListColumnLinksRequest) Skip(skip int32) ApiSitesContentTypesListColumnLinksRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesContentTypesListColumnLinksRequest) Search(search string) ApiSitesContentTypesListColumnLinksRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesContentTypesListColumnLinksRequest) Filter(filter string) ApiSitesContentTypesListColumnLinksRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesContentTypesListColumnLinksRequest) Count(count bool) ApiSitesContentTypesListColumnLinksRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesContentTypesListColumnLinksRequest) Orderby(orderby []string) ApiSitesContentTypesListColumnLinksRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesContentTypesListColumnLinksRequest) Select_(select_ []string) ApiSitesContentTypesListColumnLinksRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesContentTypesListColumnLinksRequest) Expand(expand []string) ApiSitesContentTypesListColumnLinksRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesContentTypesListColumnLinksRequest) Execute() (CollectionOfColumnLink, *_nethttp.Response, error) {
	return r.ApiService.SitesContentTypesListColumnLinksExecute(r)
}

/*
SitesContentTypesListColumnLinks Get columnLinks from sites

The collection of columns that are required by this content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param contentTypeId key: id of contentType
 @return ApiSitesContentTypesListColumnLinksRequest
*/
func (a *SitesContentTypeApiService) SitesContentTypesListColumnLinks(ctx _context.Context, siteId string, contentTypeId string) ApiSitesContentTypesListColumnLinksRequest {
	return ApiSitesContentTypesListColumnLinksRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return CollectionOfColumnLink
func (a *SitesContentTypeApiService) SitesContentTypesListColumnLinksExecute(r ApiSitesContentTypesListColumnLinksRequest) (CollectionOfColumnLink, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfColumnLink
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesContentTypeApiService.SitesContentTypesListColumnLinks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/contentTypes/{contentType-id}/columnLinks"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesContentTypesListColumnPositionsRequest struct {
	ctx _context.Context
	ApiService *SitesContentTypeApiService
	siteId string
	contentTypeId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesContentTypesListColumnPositionsRequest) Top(top int32) ApiSitesContentTypesListColumnPositionsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesContentTypesListColumnPositionsRequest) Skip(skip int32) ApiSitesContentTypesListColumnPositionsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesContentTypesListColumnPositionsRequest) Search(search string) ApiSitesContentTypesListColumnPositionsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesContentTypesListColumnPositionsRequest) Filter(filter string) ApiSitesContentTypesListColumnPositionsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesContentTypesListColumnPositionsRequest) Count(count bool) ApiSitesContentTypesListColumnPositionsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesContentTypesListColumnPositionsRequest) Orderby(orderby []string) ApiSitesContentTypesListColumnPositionsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesContentTypesListColumnPositionsRequest) Select_(select_ []string) ApiSitesContentTypesListColumnPositionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesContentTypesListColumnPositionsRequest) Expand(expand []string) ApiSitesContentTypesListColumnPositionsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesContentTypesListColumnPositionsRequest) Execute() (CollectionOfColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.SitesContentTypesListColumnPositionsExecute(r)
}

/*
SitesContentTypesListColumnPositions Get columnPositions from sites

Column order information in a content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param contentTypeId key: id of contentType
 @return ApiSitesContentTypesListColumnPositionsRequest
*/
func (a *SitesContentTypeApiService) SitesContentTypesListColumnPositions(ctx _context.Context, siteId string, contentTypeId string) ApiSitesContentTypesListColumnPositionsRequest {
	return ApiSitesContentTypesListColumnPositionsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return CollectionOfColumnDefinition
func (a *SitesContentTypeApiService) SitesContentTypesListColumnPositionsExecute(r ApiSitesContentTypesListColumnPositionsRequest) (CollectionOfColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesContentTypeApiService.SitesContentTypesListColumnPositions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/contentTypes/{contentType-id}/columnPositions"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesContentTypesListColumnsRequest struct {
	ctx _context.Context
	ApiService *SitesContentTypeApiService
	siteId string
	contentTypeId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesContentTypesListColumnsRequest) Top(top int32) ApiSitesContentTypesListColumnsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesContentTypesListColumnsRequest) Skip(skip int32) ApiSitesContentTypesListColumnsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesContentTypesListColumnsRequest) Search(search string) ApiSitesContentTypesListColumnsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesContentTypesListColumnsRequest) Filter(filter string) ApiSitesContentTypesListColumnsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesContentTypesListColumnsRequest) Count(count bool) ApiSitesContentTypesListColumnsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesContentTypesListColumnsRequest) Orderby(orderby []string) ApiSitesContentTypesListColumnsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesContentTypesListColumnsRequest) Select_(select_ []string) ApiSitesContentTypesListColumnsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesContentTypesListColumnsRequest) Expand(expand []string) ApiSitesContentTypesListColumnsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesContentTypesListColumnsRequest) Execute() (CollectionOfColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.SitesContentTypesListColumnsExecute(r)
}

/*
SitesContentTypesListColumns Get columns from sites

The collection of column definitions for this contentType.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param contentTypeId key: id of contentType
 @return ApiSitesContentTypesListColumnsRequest
*/
func (a *SitesContentTypeApiService) SitesContentTypesListColumns(ctx _context.Context, siteId string, contentTypeId string) ApiSitesContentTypesListColumnsRequest {
	return ApiSitesContentTypesListColumnsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return CollectionOfColumnDefinition
func (a *SitesContentTypeApiService) SitesContentTypesListColumnsExecute(r ApiSitesContentTypesListColumnsRequest) (CollectionOfColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesContentTypeApiService.SitesContentTypesListColumns")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/contentTypes/{contentType-id}/columns"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesContentTypesListRefBaseTypesRequest struct {
	ctx _context.Context
	ApiService *SitesContentTypeApiService
	siteId string
	contentTypeId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
}

// Show only the first n items
func (r ApiSitesContentTypesListRefBaseTypesRequest) Top(top int32) ApiSitesContentTypesListRefBaseTypesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesContentTypesListRefBaseTypesRequest) Skip(skip int32) ApiSitesContentTypesListRefBaseTypesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesContentTypesListRefBaseTypesRequest) Search(search string) ApiSitesContentTypesListRefBaseTypesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesContentTypesListRefBaseTypesRequest) Filter(filter string) ApiSitesContentTypesListRefBaseTypesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesContentTypesListRefBaseTypesRequest) Count(count bool) ApiSitesContentTypesListRefBaseTypesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesContentTypesListRefBaseTypesRequest) Orderby(orderby []string) ApiSitesContentTypesListRefBaseTypesRequest {
	r.orderby = &orderby
	return r
}

func (r ApiSitesContentTypesListRefBaseTypesRequest) Execute() (CollectionOfLinksOfContentType, *_nethttp.Response, error) {
	return r.ApiService.SitesContentTypesListRefBaseTypesExecute(r)
}

/*
SitesContentTypesListRefBaseTypes Get ref of baseTypes from sites

The collection of content types that are ancestors of this content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param contentTypeId key: id of contentType
 @return ApiSitesContentTypesListRefBaseTypesRequest
*/
func (a *SitesContentTypeApiService) SitesContentTypesListRefBaseTypes(ctx _context.Context, siteId string, contentTypeId string) ApiSitesContentTypesListRefBaseTypesRequest {
	return ApiSitesContentTypesListRefBaseTypesRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return CollectionOfLinksOfContentType
func (a *SitesContentTypeApiService) SitesContentTypesListRefBaseTypesExecute(r ApiSitesContentTypesListRefBaseTypesRequest) (CollectionOfLinksOfContentType, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfLinksOfContentType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesContentTypeApiService.SitesContentTypesListRefBaseTypes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/contentTypes/{contentType-id}/baseTypes/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesContentTypesListRefColumnPositionsRequest struct {
	ctx _context.Context
	ApiService *SitesContentTypeApiService
	siteId string
	contentTypeId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
}

// Show only the first n items
func (r ApiSitesContentTypesListRefColumnPositionsRequest) Top(top int32) ApiSitesContentTypesListRefColumnPositionsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesContentTypesListRefColumnPositionsRequest) Skip(skip int32) ApiSitesContentTypesListRefColumnPositionsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesContentTypesListRefColumnPositionsRequest) Search(search string) ApiSitesContentTypesListRefColumnPositionsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesContentTypesListRefColumnPositionsRequest) Filter(filter string) ApiSitesContentTypesListRefColumnPositionsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesContentTypesListRefColumnPositionsRequest) Count(count bool) ApiSitesContentTypesListRefColumnPositionsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesContentTypesListRefColumnPositionsRequest) Orderby(orderby []string) ApiSitesContentTypesListRefColumnPositionsRequest {
	r.orderby = &orderby
	return r
}

func (r ApiSitesContentTypesListRefColumnPositionsRequest) Execute() (CollectionOfLinksOfColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.SitesContentTypesListRefColumnPositionsExecute(r)
}

/*
SitesContentTypesListRefColumnPositions Get ref of columnPositions from sites

Column order information in a content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param contentTypeId key: id of contentType
 @return ApiSitesContentTypesListRefColumnPositionsRequest
*/
func (a *SitesContentTypeApiService) SitesContentTypesListRefColumnPositions(ctx _context.Context, siteId string, contentTypeId string) ApiSitesContentTypesListRefColumnPositionsRequest {
	return ApiSitesContentTypesListRefColumnPositionsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return CollectionOfLinksOfColumnDefinition
func (a *SitesContentTypeApiService) SitesContentTypesListRefColumnPositionsExecute(r ApiSitesContentTypesListRefColumnPositionsRequest) (CollectionOfLinksOfColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfLinksOfColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesContentTypeApiService.SitesContentTypesListRefColumnPositions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/contentTypes/{contentType-id}/columnPositions/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesContentTypesUpdateColumnLinksRequest struct {
	ctx _context.Context
	ApiService *SitesContentTypeApiService
	siteId string
	contentTypeId string
	columnLinkId string
	microsoftGraphColumnLink *MicrosoftGraphColumnLink
}

// New navigation property values
func (r ApiSitesContentTypesUpdateColumnLinksRequest) MicrosoftGraphColumnLink(microsoftGraphColumnLink MicrosoftGraphColumnLink) ApiSitesContentTypesUpdateColumnLinksRequest {
	r.microsoftGraphColumnLink = &microsoftGraphColumnLink
	return r
}

func (r ApiSitesContentTypesUpdateColumnLinksRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesContentTypesUpdateColumnLinksExecute(r)
}

/*
SitesContentTypesUpdateColumnLinks Update the navigation property columnLinks in sites

The collection of columns that are required by this content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param contentTypeId key: id of contentType
 @param columnLinkId key: id of columnLink
 @return ApiSitesContentTypesUpdateColumnLinksRequest
*/
func (a *SitesContentTypeApiService) SitesContentTypesUpdateColumnLinks(ctx _context.Context, siteId string, contentTypeId string, columnLinkId string) ApiSitesContentTypesUpdateColumnLinksRequest {
	return ApiSitesContentTypesUpdateColumnLinksRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		contentTypeId: contentTypeId,
		columnLinkId: columnLinkId,
	}
}

// Execute executes the request
func (a *SitesContentTypeApiService) SitesContentTypesUpdateColumnLinksExecute(r ApiSitesContentTypesUpdateColumnLinksRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesContentTypeApiService.SitesContentTypesUpdateColumnLinks")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/contentTypes/{contentType-id}/columnLinks/{columnLink-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnLink-id"+"}", _neturl.PathEscape(parameterToString(r.columnLinkId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphColumnLink == nil {
		return nil, reportError("microsoftGraphColumnLink is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphColumnLink
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesContentTypesUpdateColumnsRequest struct {
	ctx _context.Context
	ApiService *SitesContentTypeApiService
	siteId string
	contentTypeId string
	columnDefinitionId string
	microsoftGraphColumnDefinition *MicrosoftGraphColumnDefinition
}

// New navigation property values
func (r ApiSitesContentTypesUpdateColumnsRequest) MicrosoftGraphColumnDefinition(microsoftGraphColumnDefinition MicrosoftGraphColumnDefinition) ApiSitesContentTypesUpdateColumnsRequest {
	r.microsoftGraphColumnDefinition = &microsoftGraphColumnDefinition
	return r
}

func (r ApiSitesContentTypesUpdateColumnsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesContentTypesUpdateColumnsExecute(r)
}

/*
SitesContentTypesUpdateColumns Update the navigation property columns in sites

The collection of column definitions for this contentType.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param contentTypeId key: id of contentType
 @param columnDefinitionId key: id of columnDefinition
 @return ApiSitesContentTypesUpdateColumnsRequest
*/
func (a *SitesContentTypeApiService) SitesContentTypesUpdateColumns(ctx _context.Context, siteId string, contentTypeId string, columnDefinitionId string) ApiSitesContentTypesUpdateColumnsRequest {
	return ApiSitesContentTypesUpdateColumnsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		contentTypeId: contentTypeId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
func (a *SitesContentTypeApiService) SitesContentTypesUpdateColumnsExecute(r ApiSitesContentTypesUpdateColumnsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesContentTypeApiService.SitesContentTypesUpdateColumns")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/contentTypes/{contentType-id}/columns/{columnDefinition-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphColumnDefinition == nil {
		return nil, reportError("microsoftGraphColumnDefinition is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphColumnDefinition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesContentTypesUpdateRefBaseRequest struct {
	ctx _context.Context
	ApiService *SitesContentTypeApiService
	siteId string
	contentTypeId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSitesContentTypesUpdateRefBaseRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesContentTypesUpdateRefBaseRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesContentTypesUpdateRefBaseRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesContentTypesUpdateRefBaseExecute(r)
}

/*
SitesContentTypesUpdateRefBase Update the ref of navigation property base in sites

Parent contentType from which this content type is derived.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param contentTypeId key: id of contentType
 @return ApiSitesContentTypesUpdateRefBaseRequest
*/
func (a *SitesContentTypeApiService) SitesContentTypesUpdateRefBase(ctx _context.Context, siteId string, contentTypeId string) ApiSitesContentTypesUpdateRefBaseRequest {
	return ApiSitesContentTypesUpdateRefBaseRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
func (a *SitesContentTypeApiService) SitesContentTypesUpdateRefBaseExecute(r ApiSitesContentTypesUpdateRefBaseRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesContentTypeApiService.SitesContentTypesUpdateRefBase")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/contentTypes/{contentType-id}/base/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesCreateContentTypesRequest struct {
	ctx _context.Context
	ApiService *SitesContentTypeApiService
	siteId string
	microsoftGraphContentType *MicrosoftGraphContentType
}

// New navigation property
func (r ApiSitesCreateContentTypesRequest) MicrosoftGraphContentType(microsoftGraphContentType MicrosoftGraphContentType) ApiSitesCreateContentTypesRequest {
	r.microsoftGraphContentType = &microsoftGraphContentType
	return r
}

func (r ApiSitesCreateContentTypesRequest) Execute() (MicrosoftGraphContentType, *_nethttp.Response, error) {
	return r.ApiService.SitesCreateContentTypesExecute(r)
}

/*
SitesCreateContentTypes Create new navigation property to contentTypes for sites

The collection of content types defined for this site.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @return ApiSitesCreateContentTypesRequest
*/
func (a *SitesContentTypeApiService) SitesCreateContentTypes(ctx _context.Context, siteId string) ApiSitesCreateContentTypesRequest {
	return ApiSitesCreateContentTypesRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphContentType
func (a *SitesContentTypeApiService) SitesCreateContentTypesExecute(r ApiSitesCreateContentTypesRequest) (MicrosoftGraphContentType, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphContentType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesContentTypeApiService.SitesCreateContentTypes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/contentTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphContentType == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphContentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphContentType
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesDeleteContentTypesRequest struct {
	ctx _context.Context
	ApiService *SitesContentTypeApiService
	siteId string
	contentTypeId string
	ifMatch *string
}

// ETag
func (r ApiSitesDeleteContentTypesRequest) IfMatch(ifMatch string) ApiSitesDeleteContentTypesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesDeleteContentTypesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesDeleteContentTypesExecute(r)
}

/*
SitesDeleteContentTypes Delete navigation property contentTypes for sites

The collection of content types defined for this site.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param contentTypeId key: id of contentType
 @return ApiSitesDeleteContentTypesRequest
*/
func (a *SitesContentTypeApiService) SitesDeleteContentTypes(ctx _context.Context, siteId string, contentTypeId string) ApiSitesDeleteContentTypesRequest {
	return ApiSitesDeleteContentTypesRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
func (a *SitesContentTypeApiService) SitesDeleteContentTypesExecute(r ApiSitesDeleteContentTypesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesContentTypeApiService.SitesDeleteContentTypes")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/contentTypes/{contentType-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesGetContentTypesRequest struct {
	ctx _context.Context
	ApiService *SitesContentTypeApiService
	siteId string
	contentTypeId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesGetContentTypesRequest) Select_(select_ []string) ApiSitesGetContentTypesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesGetContentTypesRequest) Expand(expand []string) ApiSitesGetContentTypesRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesGetContentTypesRequest) Execute() (MicrosoftGraphContentType, *_nethttp.Response, error) {
	return r.ApiService.SitesGetContentTypesExecute(r)
}

/*
SitesGetContentTypes Get contentTypes from sites

The collection of content types defined for this site.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param contentTypeId key: id of contentType
 @return ApiSitesGetContentTypesRequest
*/
func (a *SitesContentTypeApiService) SitesGetContentTypes(ctx _context.Context, siteId string, contentTypeId string) ApiSitesGetContentTypesRequest {
	return ApiSitesGetContentTypesRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphContentType
func (a *SitesContentTypeApiService) SitesGetContentTypesExecute(r ApiSitesGetContentTypesRequest) (MicrosoftGraphContentType, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphContentType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesContentTypeApiService.SitesGetContentTypes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/contentTypes/{contentType-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesListContentTypesRequest struct {
	ctx _context.Context
	ApiService *SitesContentTypeApiService
	siteId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesListContentTypesRequest) Top(top int32) ApiSitesListContentTypesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesListContentTypesRequest) Skip(skip int32) ApiSitesListContentTypesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesListContentTypesRequest) Search(search string) ApiSitesListContentTypesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesListContentTypesRequest) Filter(filter string) ApiSitesListContentTypesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesListContentTypesRequest) Count(count bool) ApiSitesListContentTypesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesListContentTypesRequest) Orderby(orderby []string) ApiSitesListContentTypesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesListContentTypesRequest) Select_(select_ []string) ApiSitesListContentTypesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesListContentTypesRequest) Expand(expand []string) ApiSitesListContentTypesRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesListContentTypesRequest) Execute() (CollectionOfContentType, *_nethttp.Response, error) {
	return r.ApiService.SitesListContentTypesExecute(r)
}

/*
SitesListContentTypes Get contentTypes from sites

The collection of content types defined for this site.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @return ApiSitesListContentTypesRequest
*/
func (a *SitesContentTypeApiService) SitesListContentTypes(ctx _context.Context, siteId string) ApiSitesListContentTypesRequest {
	return ApiSitesListContentTypesRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return CollectionOfContentType
func (a *SitesContentTypeApiService) SitesListContentTypesExecute(r ApiSitesListContentTypesRequest) (CollectionOfContentType, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfContentType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesContentTypeApiService.SitesListContentTypes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/contentTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesUpdateContentTypesRequest struct {
	ctx _context.Context
	ApiService *SitesContentTypeApiService
	siteId string
	contentTypeId string
	microsoftGraphContentType *MicrosoftGraphContentType
}

// New navigation property values
func (r ApiSitesUpdateContentTypesRequest) MicrosoftGraphContentType(microsoftGraphContentType MicrosoftGraphContentType) ApiSitesUpdateContentTypesRequest {
	r.microsoftGraphContentType = &microsoftGraphContentType
	return r
}

func (r ApiSitesUpdateContentTypesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesUpdateContentTypesExecute(r)
}

/*
SitesUpdateContentTypes Update the navigation property contentTypes in sites

The collection of content types defined for this site.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param contentTypeId key: id of contentType
 @return ApiSitesUpdateContentTypesRequest
*/
func (a *SitesContentTypeApiService) SitesUpdateContentTypes(ctx _context.Context, siteId string, contentTypeId string) ApiSitesUpdateContentTypesRequest {
	return ApiSitesUpdateContentTypesRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
func (a *SitesContentTypeApiService) SitesUpdateContentTypesExecute(r ApiSitesUpdateContentTypesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesContentTypeApiService.SitesUpdateContentTypes")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/contentTypes/{contentType-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphContentType == nil {
		return nil, reportError("microsoftGraphContentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphContentType
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
