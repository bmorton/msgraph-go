/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// CommunicationsCallApiService CommunicationsCallApi service
type CommunicationsCallApiService service

type ApiCommunicationsCallsCreateAudioRoutingGroupsRequest struct {
	ctx _context.Context
	ApiService *CommunicationsCallApiService
	callId string
	microsoftGraphAudioRoutingGroup *MicrosoftGraphAudioRoutingGroup
}

// New navigation property
func (r ApiCommunicationsCallsCreateAudioRoutingGroupsRequest) MicrosoftGraphAudioRoutingGroup(microsoftGraphAudioRoutingGroup MicrosoftGraphAudioRoutingGroup) ApiCommunicationsCallsCreateAudioRoutingGroupsRequest {
	r.microsoftGraphAudioRoutingGroup = &microsoftGraphAudioRoutingGroup
	return r
}

func (r ApiCommunicationsCallsCreateAudioRoutingGroupsRequest) Execute() (MicrosoftGraphAudioRoutingGroup, *_nethttp.Response, error) {
	return r.ApiService.CommunicationsCallsCreateAudioRoutingGroupsExecute(r)
}

/*
CommunicationsCallsCreateAudioRoutingGroups Create new navigation property to audioRoutingGroups for communications

Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callId key: id of call
 @return ApiCommunicationsCallsCreateAudioRoutingGroupsRequest
*/
func (a *CommunicationsCallApiService) CommunicationsCallsCreateAudioRoutingGroups(ctx _context.Context, callId string) ApiCommunicationsCallsCreateAudioRoutingGroupsRequest {
	return ApiCommunicationsCallsCreateAudioRoutingGroupsRequest{
		ApiService: a,
		ctx: ctx,
		callId: callId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphAudioRoutingGroup
func (a *CommunicationsCallApiService) CommunicationsCallsCreateAudioRoutingGroupsExecute(r ApiCommunicationsCallsCreateAudioRoutingGroupsRequest) (MicrosoftGraphAudioRoutingGroup, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphAudioRoutingGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsCallApiService.CommunicationsCallsCreateAudioRoutingGroups")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/calls/{call-id}/audioRoutingGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"call-id"+"}", _neturl.PathEscape(parameterToString(r.callId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphAudioRoutingGroup == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphAudioRoutingGroup is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphAudioRoutingGroup
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCommunicationsCallsCreateOperationsRequest struct {
	ctx _context.Context
	ApiService *CommunicationsCallApiService
	callId string
	microsoftGraphCommsOperation *MicrosoftGraphCommsOperation
}

// New navigation property
func (r ApiCommunicationsCallsCreateOperationsRequest) MicrosoftGraphCommsOperation(microsoftGraphCommsOperation MicrosoftGraphCommsOperation) ApiCommunicationsCallsCreateOperationsRequest {
	r.microsoftGraphCommsOperation = &microsoftGraphCommsOperation
	return r
}

func (r ApiCommunicationsCallsCreateOperationsRequest) Execute() (MicrosoftGraphCommsOperation, *_nethttp.Response, error) {
	return r.ApiService.CommunicationsCallsCreateOperationsExecute(r)
}

/*
CommunicationsCallsCreateOperations Create new navigation property to operations for communications

Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callId key: id of call
 @return ApiCommunicationsCallsCreateOperationsRequest
*/
func (a *CommunicationsCallApiService) CommunicationsCallsCreateOperations(ctx _context.Context, callId string) ApiCommunicationsCallsCreateOperationsRequest {
	return ApiCommunicationsCallsCreateOperationsRequest{
		ApiService: a,
		ctx: ctx,
		callId: callId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphCommsOperation
func (a *CommunicationsCallApiService) CommunicationsCallsCreateOperationsExecute(r ApiCommunicationsCallsCreateOperationsRequest) (MicrosoftGraphCommsOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphCommsOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsCallApiService.CommunicationsCallsCreateOperations")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/calls/{call-id}/operations"
	localVarPath = strings.Replace(localVarPath, "{"+"call-id"+"}", _neturl.PathEscape(parameterToString(r.callId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphCommsOperation == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphCommsOperation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphCommsOperation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCommunicationsCallsCreateParticipantsRequest struct {
	ctx _context.Context
	ApiService *CommunicationsCallApiService
	callId string
	microsoftGraphParticipant *MicrosoftGraphParticipant
}

// New navigation property
func (r ApiCommunicationsCallsCreateParticipantsRequest) MicrosoftGraphParticipant(microsoftGraphParticipant MicrosoftGraphParticipant) ApiCommunicationsCallsCreateParticipantsRequest {
	r.microsoftGraphParticipant = &microsoftGraphParticipant
	return r
}

func (r ApiCommunicationsCallsCreateParticipantsRequest) Execute() (MicrosoftGraphParticipant, *_nethttp.Response, error) {
	return r.ApiService.CommunicationsCallsCreateParticipantsExecute(r)
}

/*
CommunicationsCallsCreateParticipants Create new navigation property to participants for communications

Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callId key: id of call
 @return ApiCommunicationsCallsCreateParticipantsRequest
*/
func (a *CommunicationsCallApiService) CommunicationsCallsCreateParticipants(ctx _context.Context, callId string) ApiCommunicationsCallsCreateParticipantsRequest {
	return ApiCommunicationsCallsCreateParticipantsRequest{
		ApiService: a,
		ctx: ctx,
		callId: callId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphParticipant
func (a *CommunicationsCallApiService) CommunicationsCallsCreateParticipantsExecute(r ApiCommunicationsCallsCreateParticipantsRequest) (MicrosoftGraphParticipant, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphParticipant
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsCallApiService.CommunicationsCallsCreateParticipants")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/calls/{call-id}/participants"
	localVarPath = strings.Replace(localVarPath, "{"+"call-id"+"}", _neturl.PathEscape(parameterToString(r.callId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphParticipant == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphParticipant is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphParticipant
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCommunicationsCallsDeleteAudioRoutingGroupsRequest struct {
	ctx _context.Context
	ApiService *CommunicationsCallApiService
	callId string
	audioRoutingGroupId string
	ifMatch *string
}

// ETag
func (r ApiCommunicationsCallsDeleteAudioRoutingGroupsRequest) IfMatch(ifMatch string) ApiCommunicationsCallsDeleteAudioRoutingGroupsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiCommunicationsCallsDeleteAudioRoutingGroupsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CommunicationsCallsDeleteAudioRoutingGroupsExecute(r)
}

/*
CommunicationsCallsDeleteAudioRoutingGroups Delete navigation property audioRoutingGroups for communications

Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callId key: id of call
 @param audioRoutingGroupId key: id of audioRoutingGroup
 @return ApiCommunicationsCallsDeleteAudioRoutingGroupsRequest
*/
func (a *CommunicationsCallApiService) CommunicationsCallsDeleteAudioRoutingGroups(ctx _context.Context, callId string, audioRoutingGroupId string) ApiCommunicationsCallsDeleteAudioRoutingGroupsRequest {
	return ApiCommunicationsCallsDeleteAudioRoutingGroupsRequest{
		ApiService: a,
		ctx: ctx,
		callId: callId,
		audioRoutingGroupId: audioRoutingGroupId,
	}
}

// Execute executes the request
func (a *CommunicationsCallApiService) CommunicationsCallsDeleteAudioRoutingGroupsExecute(r ApiCommunicationsCallsDeleteAudioRoutingGroupsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsCallApiService.CommunicationsCallsDeleteAudioRoutingGroups")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/calls/{call-id}/audioRoutingGroups/{audioRoutingGroup-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"call-id"+"}", _neturl.PathEscape(parameterToString(r.callId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"audioRoutingGroup-id"+"}", _neturl.PathEscape(parameterToString(r.audioRoutingGroupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCommunicationsCallsDeleteOperationsRequest struct {
	ctx _context.Context
	ApiService *CommunicationsCallApiService
	callId string
	commsOperationId string
	ifMatch *string
}

// ETag
func (r ApiCommunicationsCallsDeleteOperationsRequest) IfMatch(ifMatch string) ApiCommunicationsCallsDeleteOperationsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiCommunicationsCallsDeleteOperationsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CommunicationsCallsDeleteOperationsExecute(r)
}

/*
CommunicationsCallsDeleteOperations Delete navigation property operations for communications

Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callId key: id of call
 @param commsOperationId key: id of commsOperation
 @return ApiCommunicationsCallsDeleteOperationsRequest
*/
func (a *CommunicationsCallApiService) CommunicationsCallsDeleteOperations(ctx _context.Context, callId string, commsOperationId string) ApiCommunicationsCallsDeleteOperationsRequest {
	return ApiCommunicationsCallsDeleteOperationsRequest{
		ApiService: a,
		ctx: ctx,
		callId: callId,
		commsOperationId: commsOperationId,
	}
}

// Execute executes the request
func (a *CommunicationsCallApiService) CommunicationsCallsDeleteOperationsExecute(r ApiCommunicationsCallsDeleteOperationsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsCallApiService.CommunicationsCallsDeleteOperations")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/calls/{call-id}/operations/{commsOperation-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"call-id"+"}", _neturl.PathEscape(parameterToString(r.callId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commsOperation-id"+"}", _neturl.PathEscape(parameterToString(r.commsOperationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCommunicationsCallsDeleteParticipantsRequest struct {
	ctx _context.Context
	ApiService *CommunicationsCallApiService
	callId string
	participantId string
	ifMatch *string
}

// ETag
func (r ApiCommunicationsCallsDeleteParticipantsRequest) IfMatch(ifMatch string) ApiCommunicationsCallsDeleteParticipantsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiCommunicationsCallsDeleteParticipantsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CommunicationsCallsDeleteParticipantsExecute(r)
}

/*
CommunicationsCallsDeleteParticipants Delete navigation property participants for communications

Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callId key: id of call
 @param participantId key: id of participant
 @return ApiCommunicationsCallsDeleteParticipantsRequest
*/
func (a *CommunicationsCallApiService) CommunicationsCallsDeleteParticipants(ctx _context.Context, callId string, participantId string) ApiCommunicationsCallsDeleteParticipantsRequest {
	return ApiCommunicationsCallsDeleteParticipantsRequest{
		ApiService: a,
		ctx: ctx,
		callId: callId,
		participantId: participantId,
	}
}

// Execute executes the request
func (a *CommunicationsCallApiService) CommunicationsCallsDeleteParticipantsExecute(r ApiCommunicationsCallsDeleteParticipantsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsCallApiService.CommunicationsCallsDeleteParticipants")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/calls/{call-id}/participants/{participant-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"call-id"+"}", _neturl.PathEscape(parameterToString(r.callId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"participant-id"+"}", _neturl.PathEscape(parameterToString(r.participantId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCommunicationsCallsGetAudioRoutingGroupsRequest struct {
	ctx _context.Context
	ApiService *CommunicationsCallApiService
	callId string
	audioRoutingGroupId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiCommunicationsCallsGetAudioRoutingGroupsRequest) Select_(select_ []string) ApiCommunicationsCallsGetAudioRoutingGroupsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiCommunicationsCallsGetAudioRoutingGroupsRequest) Expand(expand []string) ApiCommunicationsCallsGetAudioRoutingGroupsRequest {
	r.expand = &expand
	return r
}

func (r ApiCommunicationsCallsGetAudioRoutingGroupsRequest) Execute() (MicrosoftGraphAudioRoutingGroup, *_nethttp.Response, error) {
	return r.ApiService.CommunicationsCallsGetAudioRoutingGroupsExecute(r)
}

/*
CommunicationsCallsGetAudioRoutingGroups Get audioRoutingGroups from communications

Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callId key: id of call
 @param audioRoutingGroupId key: id of audioRoutingGroup
 @return ApiCommunicationsCallsGetAudioRoutingGroupsRequest
*/
func (a *CommunicationsCallApiService) CommunicationsCallsGetAudioRoutingGroups(ctx _context.Context, callId string, audioRoutingGroupId string) ApiCommunicationsCallsGetAudioRoutingGroupsRequest {
	return ApiCommunicationsCallsGetAudioRoutingGroupsRequest{
		ApiService: a,
		ctx: ctx,
		callId: callId,
		audioRoutingGroupId: audioRoutingGroupId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphAudioRoutingGroup
func (a *CommunicationsCallApiService) CommunicationsCallsGetAudioRoutingGroupsExecute(r ApiCommunicationsCallsGetAudioRoutingGroupsRequest) (MicrosoftGraphAudioRoutingGroup, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphAudioRoutingGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsCallApiService.CommunicationsCallsGetAudioRoutingGroups")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/calls/{call-id}/audioRoutingGroups/{audioRoutingGroup-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"call-id"+"}", _neturl.PathEscape(parameterToString(r.callId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"audioRoutingGroup-id"+"}", _neturl.PathEscape(parameterToString(r.audioRoutingGroupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCommunicationsCallsGetOperationsRequest struct {
	ctx _context.Context
	ApiService *CommunicationsCallApiService
	callId string
	commsOperationId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiCommunicationsCallsGetOperationsRequest) Select_(select_ []string) ApiCommunicationsCallsGetOperationsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiCommunicationsCallsGetOperationsRequest) Expand(expand []string) ApiCommunicationsCallsGetOperationsRequest {
	r.expand = &expand
	return r
}

func (r ApiCommunicationsCallsGetOperationsRequest) Execute() (MicrosoftGraphCommsOperation, *_nethttp.Response, error) {
	return r.ApiService.CommunicationsCallsGetOperationsExecute(r)
}

/*
CommunicationsCallsGetOperations Get operations from communications

Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callId key: id of call
 @param commsOperationId key: id of commsOperation
 @return ApiCommunicationsCallsGetOperationsRequest
*/
func (a *CommunicationsCallApiService) CommunicationsCallsGetOperations(ctx _context.Context, callId string, commsOperationId string) ApiCommunicationsCallsGetOperationsRequest {
	return ApiCommunicationsCallsGetOperationsRequest{
		ApiService: a,
		ctx: ctx,
		callId: callId,
		commsOperationId: commsOperationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphCommsOperation
func (a *CommunicationsCallApiService) CommunicationsCallsGetOperationsExecute(r ApiCommunicationsCallsGetOperationsRequest) (MicrosoftGraphCommsOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphCommsOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsCallApiService.CommunicationsCallsGetOperations")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/calls/{call-id}/operations/{commsOperation-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"call-id"+"}", _neturl.PathEscape(parameterToString(r.callId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commsOperation-id"+"}", _neturl.PathEscape(parameterToString(r.commsOperationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCommunicationsCallsGetParticipantsRequest struct {
	ctx _context.Context
	ApiService *CommunicationsCallApiService
	callId string
	participantId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiCommunicationsCallsGetParticipantsRequest) Select_(select_ []string) ApiCommunicationsCallsGetParticipantsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiCommunicationsCallsGetParticipantsRequest) Expand(expand []string) ApiCommunicationsCallsGetParticipantsRequest {
	r.expand = &expand
	return r
}

func (r ApiCommunicationsCallsGetParticipantsRequest) Execute() (MicrosoftGraphParticipant, *_nethttp.Response, error) {
	return r.ApiService.CommunicationsCallsGetParticipantsExecute(r)
}

/*
CommunicationsCallsGetParticipants Get participants from communications

Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callId key: id of call
 @param participantId key: id of participant
 @return ApiCommunicationsCallsGetParticipantsRequest
*/
func (a *CommunicationsCallApiService) CommunicationsCallsGetParticipants(ctx _context.Context, callId string, participantId string) ApiCommunicationsCallsGetParticipantsRequest {
	return ApiCommunicationsCallsGetParticipantsRequest{
		ApiService: a,
		ctx: ctx,
		callId: callId,
		participantId: participantId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphParticipant
func (a *CommunicationsCallApiService) CommunicationsCallsGetParticipantsExecute(r ApiCommunicationsCallsGetParticipantsRequest) (MicrosoftGraphParticipant, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphParticipant
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsCallApiService.CommunicationsCallsGetParticipants")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/calls/{call-id}/participants/{participant-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"call-id"+"}", _neturl.PathEscape(parameterToString(r.callId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"participant-id"+"}", _neturl.PathEscape(parameterToString(r.participantId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCommunicationsCallsListAudioRoutingGroupsRequest struct {
	ctx _context.Context
	ApiService *CommunicationsCallApiService
	callId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiCommunicationsCallsListAudioRoutingGroupsRequest) Top(top int32) ApiCommunicationsCallsListAudioRoutingGroupsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiCommunicationsCallsListAudioRoutingGroupsRequest) Skip(skip int32) ApiCommunicationsCallsListAudioRoutingGroupsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiCommunicationsCallsListAudioRoutingGroupsRequest) Search(search string) ApiCommunicationsCallsListAudioRoutingGroupsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiCommunicationsCallsListAudioRoutingGroupsRequest) Filter(filter string) ApiCommunicationsCallsListAudioRoutingGroupsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiCommunicationsCallsListAudioRoutingGroupsRequest) Count(count bool) ApiCommunicationsCallsListAudioRoutingGroupsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiCommunicationsCallsListAudioRoutingGroupsRequest) Orderby(orderby []string) ApiCommunicationsCallsListAudioRoutingGroupsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiCommunicationsCallsListAudioRoutingGroupsRequest) Select_(select_ []string) ApiCommunicationsCallsListAudioRoutingGroupsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiCommunicationsCallsListAudioRoutingGroupsRequest) Expand(expand []string) ApiCommunicationsCallsListAudioRoutingGroupsRequest {
	r.expand = &expand
	return r
}

func (r ApiCommunicationsCallsListAudioRoutingGroupsRequest) Execute() (CollectionOfAudioRoutingGroup, *_nethttp.Response, error) {
	return r.ApiService.CommunicationsCallsListAudioRoutingGroupsExecute(r)
}

/*
CommunicationsCallsListAudioRoutingGroups Get audioRoutingGroups from communications

Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callId key: id of call
 @return ApiCommunicationsCallsListAudioRoutingGroupsRequest
*/
func (a *CommunicationsCallApiService) CommunicationsCallsListAudioRoutingGroups(ctx _context.Context, callId string) ApiCommunicationsCallsListAudioRoutingGroupsRequest {
	return ApiCommunicationsCallsListAudioRoutingGroupsRequest{
		ApiService: a,
		ctx: ctx,
		callId: callId,
	}
}

// Execute executes the request
//  @return CollectionOfAudioRoutingGroup
func (a *CommunicationsCallApiService) CommunicationsCallsListAudioRoutingGroupsExecute(r ApiCommunicationsCallsListAudioRoutingGroupsRequest) (CollectionOfAudioRoutingGroup, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfAudioRoutingGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsCallApiService.CommunicationsCallsListAudioRoutingGroups")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/calls/{call-id}/audioRoutingGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"call-id"+"}", _neturl.PathEscape(parameterToString(r.callId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCommunicationsCallsListOperationsRequest struct {
	ctx _context.Context
	ApiService *CommunicationsCallApiService
	callId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiCommunicationsCallsListOperationsRequest) Top(top int32) ApiCommunicationsCallsListOperationsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiCommunicationsCallsListOperationsRequest) Skip(skip int32) ApiCommunicationsCallsListOperationsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiCommunicationsCallsListOperationsRequest) Search(search string) ApiCommunicationsCallsListOperationsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiCommunicationsCallsListOperationsRequest) Filter(filter string) ApiCommunicationsCallsListOperationsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiCommunicationsCallsListOperationsRequest) Count(count bool) ApiCommunicationsCallsListOperationsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiCommunicationsCallsListOperationsRequest) Orderby(orderby []string) ApiCommunicationsCallsListOperationsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiCommunicationsCallsListOperationsRequest) Select_(select_ []string) ApiCommunicationsCallsListOperationsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiCommunicationsCallsListOperationsRequest) Expand(expand []string) ApiCommunicationsCallsListOperationsRequest {
	r.expand = &expand
	return r
}

func (r ApiCommunicationsCallsListOperationsRequest) Execute() (CollectionOfCommsOperation, *_nethttp.Response, error) {
	return r.ApiService.CommunicationsCallsListOperationsExecute(r)
}

/*
CommunicationsCallsListOperations Get operations from communications

Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callId key: id of call
 @return ApiCommunicationsCallsListOperationsRequest
*/
func (a *CommunicationsCallApiService) CommunicationsCallsListOperations(ctx _context.Context, callId string) ApiCommunicationsCallsListOperationsRequest {
	return ApiCommunicationsCallsListOperationsRequest{
		ApiService: a,
		ctx: ctx,
		callId: callId,
	}
}

// Execute executes the request
//  @return CollectionOfCommsOperation
func (a *CommunicationsCallApiService) CommunicationsCallsListOperationsExecute(r ApiCommunicationsCallsListOperationsRequest) (CollectionOfCommsOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfCommsOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsCallApiService.CommunicationsCallsListOperations")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/calls/{call-id}/operations"
	localVarPath = strings.Replace(localVarPath, "{"+"call-id"+"}", _neturl.PathEscape(parameterToString(r.callId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCommunicationsCallsListParticipantsRequest struct {
	ctx _context.Context
	ApiService *CommunicationsCallApiService
	callId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiCommunicationsCallsListParticipantsRequest) Top(top int32) ApiCommunicationsCallsListParticipantsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiCommunicationsCallsListParticipantsRequest) Skip(skip int32) ApiCommunicationsCallsListParticipantsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiCommunicationsCallsListParticipantsRequest) Search(search string) ApiCommunicationsCallsListParticipantsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiCommunicationsCallsListParticipantsRequest) Filter(filter string) ApiCommunicationsCallsListParticipantsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiCommunicationsCallsListParticipantsRequest) Count(count bool) ApiCommunicationsCallsListParticipantsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiCommunicationsCallsListParticipantsRequest) Orderby(orderby []string) ApiCommunicationsCallsListParticipantsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiCommunicationsCallsListParticipantsRequest) Select_(select_ []string) ApiCommunicationsCallsListParticipantsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiCommunicationsCallsListParticipantsRequest) Expand(expand []string) ApiCommunicationsCallsListParticipantsRequest {
	r.expand = &expand
	return r
}

func (r ApiCommunicationsCallsListParticipantsRequest) Execute() (CollectionOfParticipant, *_nethttp.Response, error) {
	return r.ApiService.CommunicationsCallsListParticipantsExecute(r)
}

/*
CommunicationsCallsListParticipants Get participants from communications

Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callId key: id of call
 @return ApiCommunicationsCallsListParticipantsRequest
*/
func (a *CommunicationsCallApiService) CommunicationsCallsListParticipants(ctx _context.Context, callId string) ApiCommunicationsCallsListParticipantsRequest {
	return ApiCommunicationsCallsListParticipantsRequest{
		ApiService: a,
		ctx: ctx,
		callId: callId,
	}
}

// Execute executes the request
//  @return CollectionOfParticipant
func (a *CommunicationsCallApiService) CommunicationsCallsListParticipantsExecute(r ApiCommunicationsCallsListParticipantsRequest) (CollectionOfParticipant, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfParticipant
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsCallApiService.CommunicationsCallsListParticipants")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/calls/{call-id}/participants"
	localVarPath = strings.Replace(localVarPath, "{"+"call-id"+"}", _neturl.PathEscape(parameterToString(r.callId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCommunicationsCallsUpdateAudioRoutingGroupsRequest struct {
	ctx _context.Context
	ApiService *CommunicationsCallApiService
	callId string
	audioRoutingGroupId string
	microsoftGraphAudioRoutingGroup *MicrosoftGraphAudioRoutingGroup
}

// New navigation property values
func (r ApiCommunicationsCallsUpdateAudioRoutingGroupsRequest) MicrosoftGraphAudioRoutingGroup(microsoftGraphAudioRoutingGroup MicrosoftGraphAudioRoutingGroup) ApiCommunicationsCallsUpdateAudioRoutingGroupsRequest {
	r.microsoftGraphAudioRoutingGroup = &microsoftGraphAudioRoutingGroup
	return r
}

func (r ApiCommunicationsCallsUpdateAudioRoutingGroupsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CommunicationsCallsUpdateAudioRoutingGroupsExecute(r)
}

/*
CommunicationsCallsUpdateAudioRoutingGroups Update the navigation property audioRoutingGroups in communications

Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callId key: id of call
 @param audioRoutingGroupId key: id of audioRoutingGroup
 @return ApiCommunicationsCallsUpdateAudioRoutingGroupsRequest
*/
func (a *CommunicationsCallApiService) CommunicationsCallsUpdateAudioRoutingGroups(ctx _context.Context, callId string, audioRoutingGroupId string) ApiCommunicationsCallsUpdateAudioRoutingGroupsRequest {
	return ApiCommunicationsCallsUpdateAudioRoutingGroupsRequest{
		ApiService: a,
		ctx: ctx,
		callId: callId,
		audioRoutingGroupId: audioRoutingGroupId,
	}
}

// Execute executes the request
func (a *CommunicationsCallApiService) CommunicationsCallsUpdateAudioRoutingGroupsExecute(r ApiCommunicationsCallsUpdateAudioRoutingGroupsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsCallApiService.CommunicationsCallsUpdateAudioRoutingGroups")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/calls/{call-id}/audioRoutingGroups/{audioRoutingGroup-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"call-id"+"}", _neturl.PathEscape(parameterToString(r.callId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"audioRoutingGroup-id"+"}", _neturl.PathEscape(parameterToString(r.audioRoutingGroupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphAudioRoutingGroup == nil {
		return nil, reportError("microsoftGraphAudioRoutingGroup is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphAudioRoutingGroup
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCommunicationsCallsUpdateOperationsRequest struct {
	ctx _context.Context
	ApiService *CommunicationsCallApiService
	callId string
	commsOperationId string
	microsoftGraphCommsOperation *MicrosoftGraphCommsOperation
}

// New navigation property values
func (r ApiCommunicationsCallsUpdateOperationsRequest) MicrosoftGraphCommsOperation(microsoftGraphCommsOperation MicrosoftGraphCommsOperation) ApiCommunicationsCallsUpdateOperationsRequest {
	r.microsoftGraphCommsOperation = &microsoftGraphCommsOperation
	return r
}

func (r ApiCommunicationsCallsUpdateOperationsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CommunicationsCallsUpdateOperationsExecute(r)
}

/*
CommunicationsCallsUpdateOperations Update the navigation property operations in communications

Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callId key: id of call
 @param commsOperationId key: id of commsOperation
 @return ApiCommunicationsCallsUpdateOperationsRequest
*/
func (a *CommunicationsCallApiService) CommunicationsCallsUpdateOperations(ctx _context.Context, callId string, commsOperationId string) ApiCommunicationsCallsUpdateOperationsRequest {
	return ApiCommunicationsCallsUpdateOperationsRequest{
		ApiService: a,
		ctx: ctx,
		callId: callId,
		commsOperationId: commsOperationId,
	}
}

// Execute executes the request
func (a *CommunicationsCallApiService) CommunicationsCallsUpdateOperationsExecute(r ApiCommunicationsCallsUpdateOperationsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsCallApiService.CommunicationsCallsUpdateOperations")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/calls/{call-id}/operations/{commsOperation-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"call-id"+"}", _neturl.PathEscape(parameterToString(r.callId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commsOperation-id"+"}", _neturl.PathEscape(parameterToString(r.commsOperationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphCommsOperation == nil {
		return nil, reportError("microsoftGraphCommsOperation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphCommsOperation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCommunicationsCallsUpdateParticipantsRequest struct {
	ctx _context.Context
	ApiService *CommunicationsCallApiService
	callId string
	participantId string
	microsoftGraphParticipant *MicrosoftGraphParticipant
}

// New navigation property values
func (r ApiCommunicationsCallsUpdateParticipantsRequest) MicrosoftGraphParticipant(microsoftGraphParticipant MicrosoftGraphParticipant) ApiCommunicationsCallsUpdateParticipantsRequest {
	r.microsoftGraphParticipant = &microsoftGraphParticipant
	return r
}

func (r ApiCommunicationsCallsUpdateParticipantsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CommunicationsCallsUpdateParticipantsExecute(r)
}

/*
CommunicationsCallsUpdateParticipants Update the navigation property participants in communications

Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callId key: id of call
 @param participantId key: id of participant
 @return ApiCommunicationsCallsUpdateParticipantsRequest
*/
func (a *CommunicationsCallApiService) CommunicationsCallsUpdateParticipants(ctx _context.Context, callId string, participantId string) ApiCommunicationsCallsUpdateParticipantsRequest {
	return ApiCommunicationsCallsUpdateParticipantsRequest{
		ApiService: a,
		ctx: ctx,
		callId: callId,
		participantId: participantId,
	}
}

// Execute executes the request
func (a *CommunicationsCallApiService) CommunicationsCallsUpdateParticipantsExecute(r ApiCommunicationsCallsUpdateParticipantsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsCallApiService.CommunicationsCallsUpdateParticipants")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/calls/{call-id}/participants/{participant-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"call-id"+"}", _neturl.PathEscape(parameterToString(r.callId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"participant-id"+"}", _neturl.PathEscape(parameterToString(r.participantId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphParticipant == nil {
		return nil, reportError("microsoftGraphParticipant is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphParticipant
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCommunicationsCreateCallsRequest struct {
	ctx _context.Context
	ApiService *CommunicationsCallApiService
	microsoftGraphCall *MicrosoftGraphCall
}

// New navigation property
func (r ApiCommunicationsCreateCallsRequest) MicrosoftGraphCall(microsoftGraphCall MicrosoftGraphCall) ApiCommunicationsCreateCallsRequest {
	r.microsoftGraphCall = &microsoftGraphCall
	return r
}

func (r ApiCommunicationsCreateCallsRequest) Execute() (MicrosoftGraphCall, *_nethttp.Response, error) {
	return r.ApiService.CommunicationsCreateCallsExecute(r)
}

/*
CommunicationsCreateCalls Create new navigation property to calls for communications

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCommunicationsCreateCallsRequest
*/
func (a *CommunicationsCallApiService) CommunicationsCreateCalls(ctx _context.Context) ApiCommunicationsCreateCallsRequest {
	return ApiCommunicationsCreateCallsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphCall
func (a *CommunicationsCallApiService) CommunicationsCreateCallsExecute(r ApiCommunicationsCreateCallsRequest) (MicrosoftGraphCall, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphCall
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsCallApiService.CommunicationsCreateCalls")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/calls"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphCall == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphCall is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphCall
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCommunicationsDeleteCallsRequest struct {
	ctx _context.Context
	ApiService *CommunicationsCallApiService
	callId string
	ifMatch *string
}

// ETag
func (r ApiCommunicationsDeleteCallsRequest) IfMatch(ifMatch string) ApiCommunicationsDeleteCallsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiCommunicationsDeleteCallsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CommunicationsDeleteCallsExecute(r)
}

/*
CommunicationsDeleteCalls Delete navigation property calls for communications

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callId key: id of call
 @return ApiCommunicationsDeleteCallsRequest
*/
func (a *CommunicationsCallApiService) CommunicationsDeleteCalls(ctx _context.Context, callId string) ApiCommunicationsDeleteCallsRequest {
	return ApiCommunicationsDeleteCallsRequest{
		ApiService: a,
		ctx: ctx,
		callId: callId,
	}
}

// Execute executes the request
func (a *CommunicationsCallApiService) CommunicationsDeleteCallsExecute(r ApiCommunicationsDeleteCallsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsCallApiService.CommunicationsDeleteCalls")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/calls/{call-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"call-id"+"}", _neturl.PathEscape(parameterToString(r.callId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCommunicationsGetCallsRequest struct {
	ctx _context.Context
	ApiService *CommunicationsCallApiService
	callId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiCommunicationsGetCallsRequest) Select_(select_ []string) ApiCommunicationsGetCallsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiCommunicationsGetCallsRequest) Expand(expand []string) ApiCommunicationsGetCallsRequest {
	r.expand = &expand
	return r
}

func (r ApiCommunicationsGetCallsRequest) Execute() (MicrosoftGraphCall, *_nethttp.Response, error) {
	return r.ApiService.CommunicationsGetCallsExecute(r)
}

/*
CommunicationsGetCalls Get calls from communications

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callId key: id of call
 @return ApiCommunicationsGetCallsRequest
*/
func (a *CommunicationsCallApiService) CommunicationsGetCalls(ctx _context.Context, callId string) ApiCommunicationsGetCallsRequest {
	return ApiCommunicationsGetCallsRequest{
		ApiService: a,
		ctx: ctx,
		callId: callId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphCall
func (a *CommunicationsCallApiService) CommunicationsGetCallsExecute(r ApiCommunicationsGetCallsRequest) (MicrosoftGraphCall, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphCall
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsCallApiService.CommunicationsGetCalls")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/calls/{call-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"call-id"+"}", _neturl.PathEscape(parameterToString(r.callId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCommunicationsListCallsRequest struct {
	ctx _context.Context
	ApiService *CommunicationsCallApiService
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiCommunicationsListCallsRequest) Top(top int32) ApiCommunicationsListCallsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiCommunicationsListCallsRequest) Skip(skip int32) ApiCommunicationsListCallsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiCommunicationsListCallsRequest) Search(search string) ApiCommunicationsListCallsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiCommunicationsListCallsRequest) Filter(filter string) ApiCommunicationsListCallsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiCommunicationsListCallsRequest) Count(count bool) ApiCommunicationsListCallsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiCommunicationsListCallsRequest) Orderby(orderby []string) ApiCommunicationsListCallsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiCommunicationsListCallsRequest) Select_(select_ []string) ApiCommunicationsListCallsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiCommunicationsListCallsRequest) Expand(expand []string) ApiCommunicationsListCallsRequest {
	r.expand = &expand
	return r
}

func (r ApiCommunicationsListCallsRequest) Execute() (CollectionOfCall, *_nethttp.Response, error) {
	return r.ApiService.CommunicationsListCallsExecute(r)
}

/*
CommunicationsListCalls Get calls from communications

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCommunicationsListCallsRequest
*/
func (a *CommunicationsCallApiService) CommunicationsListCalls(ctx _context.Context) ApiCommunicationsListCallsRequest {
	return ApiCommunicationsListCallsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionOfCall
func (a *CommunicationsCallApiService) CommunicationsListCallsExecute(r ApiCommunicationsListCallsRequest) (CollectionOfCall, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfCall
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsCallApiService.CommunicationsListCalls")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/calls"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCommunicationsUpdateCallsRequest struct {
	ctx _context.Context
	ApiService *CommunicationsCallApiService
	callId string
	microsoftGraphCall *MicrosoftGraphCall
}

// New navigation property values
func (r ApiCommunicationsUpdateCallsRequest) MicrosoftGraphCall(microsoftGraphCall MicrosoftGraphCall) ApiCommunicationsUpdateCallsRequest {
	r.microsoftGraphCall = &microsoftGraphCall
	return r
}

func (r ApiCommunicationsUpdateCallsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CommunicationsUpdateCallsExecute(r)
}

/*
CommunicationsUpdateCalls Update the navigation property calls in communications

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param callId key: id of call
 @return ApiCommunicationsUpdateCallsRequest
*/
func (a *CommunicationsCallApiService) CommunicationsUpdateCalls(ctx _context.Context, callId string) ApiCommunicationsUpdateCallsRequest {
	return ApiCommunicationsUpdateCallsRequest{
		ApiService: a,
		ctx: ctx,
		callId: callId,
	}
}

// Execute executes the request
func (a *CommunicationsCallApiService) CommunicationsUpdateCallsExecute(r ApiCommunicationsUpdateCallsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommunicationsCallApiService.CommunicationsUpdateCalls")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communications/calls/{call-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"call-id"+"}", _neturl.PathEscape(parameterToString(r.callId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphCall == nil {
		return nil, reportError("microsoftGraphCall is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphCall
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
