/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package msgraph

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// UsersPlannerUserApiService UsersPlannerUserApi service
type UsersPlannerUserApiService service

type ApiUsersDeletePlannerRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	ifMatch *string
}

// ETag
func (r ApiUsersDeletePlannerRequest) IfMatch(ifMatch string) ApiUsersDeletePlannerRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersDeletePlannerRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersDeletePlannerExecute(r)
}

/*
UsersDeletePlanner Delete navigation property planner for users

Entry-point to the Planner resource that might exist for a user. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @return ApiUsersDeletePlannerRequest
*/
func (a *UsersPlannerUserApiService) UsersDeletePlanner(ctx _context.Context, userId string) ApiUsersDeletePlannerRequest {
	return ApiUsersDeletePlannerRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
func (a *UsersPlannerUserApiService) UsersDeletePlannerExecute(r ApiUsersDeletePlannerRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersDeletePlanner")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersGetPlannerRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiUsersGetPlannerRequest) Select_(select_ []string) ApiUsersGetPlannerRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersGetPlannerRequest) Expand(expand []string) ApiUsersGetPlannerRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersGetPlannerRequest) Execute() (MicrosoftGraphPlannerUser, *_nethttp.Response, error) {
	return r.ApiService.UsersGetPlannerExecute(r)
}

/*
UsersGetPlanner Get planner from users

Entry-point to the Planner resource that might exist for a user. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @return ApiUsersGetPlannerRequest
*/
func (a *UsersPlannerUserApiService) UsersGetPlanner(ctx _context.Context, userId string) ApiUsersGetPlannerRequest {
	return ApiUsersGetPlannerRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerUser
func (a *UsersPlannerUserApiService) UsersGetPlannerExecute(r ApiUsersGetPlannerRequest) (MicrosoftGraphPlannerUser, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerUser
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersGetPlanner")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPlannerCreatePlansRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	microsoftGraphPlannerPlan *MicrosoftGraphPlannerPlan
}

// New navigation property
func (r ApiUsersPlannerCreatePlansRequest) MicrosoftGraphPlannerPlan(microsoftGraphPlannerPlan MicrosoftGraphPlannerPlan) ApiUsersPlannerCreatePlansRequest {
	r.microsoftGraphPlannerPlan = &microsoftGraphPlannerPlan
	return r
}

func (r ApiUsersPlannerCreatePlansRequest) Execute() (MicrosoftGraphPlannerPlan, *_nethttp.Response, error) {
	return r.ApiService.UsersPlannerCreatePlansExecute(r)
}

/*
UsersPlannerCreatePlans Create new navigation property to plans for users

Read-only. Nullable. Returns the plannerTasks assigned to the user.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @return ApiUsersPlannerCreatePlansRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerCreatePlans(ctx _context.Context, userId string) ApiUsersPlannerCreatePlansRequest {
	return ApiUsersPlannerCreatePlansRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerPlan
func (a *UsersPlannerUserApiService) UsersPlannerCreatePlansExecute(r ApiUsersPlannerCreatePlansRequest) (MicrosoftGraphPlannerPlan, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerPlan
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerCreatePlans")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/plans"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerPlan == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphPlannerPlan is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerPlan
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPlannerCreateTasksRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	microsoftGraphPlannerTask *MicrosoftGraphPlannerTask
}

// New navigation property
func (r ApiUsersPlannerCreateTasksRequest) MicrosoftGraphPlannerTask(microsoftGraphPlannerTask MicrosoftGraphPlannerTask) ApiUsersPlannerCreateTasksRequest {
	r.microsoftGraphPlannerTask = &microsoftGraphPlannerTask
	return r
}

func (r ApiUsersPlannerCreateTasksRequest) Execute() (MicrosoftGraphPlannerTask, *_nethttp.Response, error) {
	return r.ApiService.UsersPlannerCreateTasksExecute(r)
}

/*
UsersPlannerCreateTasks Create new navigation property to tasks for users

Read-only. Nullable. Returns the plannerPlans shared with the user.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @return ApiUsersPlannerCreateTasksRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerCreateTasks(ctx _context.Context, userId string) ApiUsersPlannerCreateTasksRequest {
	return ApiUsersPlannerCreateTasksRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerTask
func (a *UsersPlannerUserApiService) UsersPlannerCreateTasksExecute(r ApiUsersPlannerCreateTasksRequest) (MicrosoftGraphPlannerTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerCreateTasks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/tasks"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerTask == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphPlannerTask is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerTask
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPlannerDeletePlansRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerPlanId string
	ifMatch *string
}

// ETag
func (r ApiUsersPlannerDeletePlansRequest) IfMatch(ifMatch string) ApiUsersPlannerDeletePlansRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersPlannerDeletePlansRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersPlannerDeletePlansExecute(r)
}

/*
UsersPlannerDeletePlans Delete navigation property plans for users

Read-only. Nullable. Returns the plannerTasks assigned to the user.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerPlanId key: id of plannerPlan
 @return ApiUsersPlannerDeletePlansRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerDeletePlans(ctx _context.Context, userId string, plannerPlanId string) ApiUsersPlannerDeletePlansRequest {
	return ApiUsersPlannerDeletePlansRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerPlanId: plannerPlanId,
	}
}

// Execute executes the request
func (a *UsersPlannerUserApiService) UsersPlannerDeletePlansExecute(r ApiUsersPlannerDeletePlansRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerDeletePlans")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/plans/{plannerPlan-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersPlannerDeleteTasksRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiUsersPlannerDeleteTasksRequest) IfMatch(ifMatch string) ApiUsersPlannerDeleteTasksRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersPlannerDeleteTasksRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersPlannerDeleteTasksExecute(r)
}

/*
UsersPlannerDeleteTasks Delete navigation property tasks for users

Read-only. Nullable. Returns the plannerPlans shared with the user.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerTaskId key: id of plannerTask
 @return ApiUsersPlannerDeleteTasksRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerDeleteTasks(ctx _context.Context, userId string, plannerTaskId string) ApiUsersPlannerDeleteTasksRequest {
	return ApiUsersPlannerDeleteTasksRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *UsersPlannerUserApiService) UsersPlannerDeleteTasksExecute(r ApiUsersPlannerDeleteTasksRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerDeleteTasks")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/tasks/{plannerTask-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersPlannerGetPlansRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerPlanId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiUsersPlannerGetPlansRequest) Select_(select_ []string) ApiUsersPlannerGetPlansRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersPlannerGetPlansRequest) Expand(expand []string) ApiUsersPlannerGetPlansRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersPlannerGetPlansRequest) Execute() (MicrosoftGraphPlannerPlan, *_nethttp.Response, error) {
	return r.ApiService.UsersPlannerGetPlansExecute(r)
}

/*
UsersPlannerGetPlans Get plans from users

Read-only. Nullable. Returns the plannerTasks assigned to the user.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerPlanId key: id of plannerPlan
 @return ApiUsersPlannerGetPlansRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerGetPlans(ctx _context.Context, userId string, plannerPlanId string) ApiUsersPlannerGetPlansRequest {
	return ApiUsersPlannerGetPlansRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerPlanId: plannerPlanId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerPlan
func (a *UsersPlannerUserApiService) UsersPlannerGetPlansExecute(r ApiUsersPlannerGetPlansRequest) (MicrosoftGraphPlannerPlan, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerPlan
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerGetPlans")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/plans/{plannerPlan-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPlannerGetTasksRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiUsersPlannerGetTasksRequest) Select_(select_ []string) ApiUsersPlannerGetTasksRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersPlannerGetTasksRequest) Expand(expand []string) ApiUsersPlannerGetTasksRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersPlannerGetTasksRequest) Execute() (MicrosoftGraphPlannerTask, *_nethttp.Response, error) {
	return r.ApiService.UsersPlannerGetTasksExecute(r)
}

/*
UsersPlannerGetTasks Get tasks from users

Read-only. Nullable. Returns the plannerPlans shared with the user.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerTaskId key: id of plannerTask
 @return ApiUsersPlannerGetTasksRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerGetTasks(ctx _context.Context, userId string, plannerTaskId string) ApiUsersPlannerGetTasksRequest {
	return ApiUsersPlannerGetTasksRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerTask
func (a *UsersPlannerUserApiService) UsersPlannerGetTasksExecute(r ApiUsersPlannerGetTasksRequest) (MicrosoftGraphPlannerTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerGetTasks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/tasks/{plannerTask-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPlannerListPlansRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiUsersPlannerListPlansRequest) Top(top int32) ApiUsersPlannerListPlansRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiUsersPlannerListPlansRequest) Skip(skip int32) ApiUsersPlannerListPlansRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiUsersPlannerListPlansRequest) Search(search string) ApiUsersPlannerListPlansRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiUsersPlannerListPlansRequest) Filter(filter string) ApiUsersPlannerListPlansRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiUsersPlannerListPlansRequest) Count(count bool) ApiUsersPlannerListPlansRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiUsersPlannerListPlansRequest) Orderby(orderby []string) ApiUsersPlannerListPlansRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiUsersPlannerListPlansRequest) Select_(select_ []string) ApiUsersPlannerListPlansRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersPlannerListPlansRequest) Expand(expand []string) ApiUsersPlannerListPlansRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersPlannerListPlansRequest) Execute() (CollectionOfPlannerPlan, *_nethttp.Response, error) {
	return r.ApiService.UsersPlannerListPlansExecute(r)
}

/*
UsersPlannerListPlans Get plans from users

Read-only. Nullable. Returns the plannerTasks assigned to the user.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @return ApiUsersPlannerListPlansRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerListPlans(ctx _context.Context, userId string) ApiUsersPlannerListPlansRequest {
	return ApiUsersPlannerListPlansRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return CollectionOfPlannerPlan
func (a *UsersPlannerUserApiService) UsersPlannerListPlansExecute(r ApiUsersPlannerListPlansRequest) (CollectionOfPlannerPlan, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfPlannerPlan
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerListPlans")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/plans"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPlannerListTasksRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiUsersPlannerListTasksRequest) Top(top int32) ApiUsersPlannerListTasksRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiUsersPlannerListTasksRequest) Skip(skip int32) ApiUsersPlannerListTasksRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiUsersPlannerListTasksRequest) Search(search string) ApiUsersPlannerListTasksRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiUsersPlannerListTasksRequest) Filter(filter string) ApiUsersPlannerListTasksRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiUsersPlannerListTasksRequest) Count(count bool) ApiUsersPlannerListTasksRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiUsersPlannerListTasksRequest) Orderby(orderby []string) ApiUsersPlannerListTasksRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiUsersPlannerListTasksRequest) Select_(select_ []string) ApiUsersPlannerListTasksRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersPlannerListTasksRequest) Expand(expand []string) ApiUsersPlannerListTasksRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersPlannerListTasksRequest) Execute() (CollectionOfPlannerTask, *_nethttp.Response, error) {
	return r.ApiService.UsersPlannerListTasksExecute(r)
}

/*
UsersPlannerListTasks Get tasks from users

Read-only. Nullable. Returns the plannerPlans shared with the user.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @return ApiUsersPlannerListTasksRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerListTasks(ctx _context.Context, userId string) ApiUsersPlannerListTasksRequest {
	return ApiUsersPlannerListTasksRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return CollectionOfPlannerTask
func (a *UsersPlannerUserApiService) UsersPlannerListTasksExecute(r ApiUsersPlannerListTasksRequest) (CollectionOfPlannerTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfPlannerTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerListTasks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/tasks"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPlannerPlansBucketsCreateTasksRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerPlanId string
	plannerBucketId string
	microsoftGraphPlannerTask *MicrosoftGraphPlannerTask
}

// New navigation property
func (r ApiUsersPlannerPlansBucketsCreateTasksRequest) MicrosoftGraphPlannerTask(microsoftGraphPlannerTask MicrosoftGraphPlannerTask) ApiUsersPlannerPlansBucketsCreateTasksRequest {
	r.microsoftGraphPlannerTask = &microsoftGraphPlannerTask
	return r
}

func (r ApiUsersPlannerPlansBucketsCreateTasksRequest) Execute() (MicrosoftGraphPlannerTask, *_nethttp.Response, error) {
	return r.ApiService.UsersPlannerPlansBucketsCreateTasksExecute(r)
}

/*
UsersPlannerPlansBucketsCreateTasks Create new navigation property to tasks for users

Read-only. Nullable. The collection of tasks in the bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @return ApiUsersPlannerPlansBucketsCreateTasksRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerPlansBucketsCreateTasks(ctx _context.Context, userId string, plannerPlanId string, plannerBucketId string) ApiUsersPlannerPlansBucketsCreateTasksRequest {
	return ApiUsersPlannerPlansBucketsCreateTasksRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerTask
func (a *UsersPlannerUserApiService) UsersPlannerPlansBucketsCreateTasksExecute(r ApiUsersPlannerPlansBucketsCreateTasksRequest) (MicrosoftGraphPlannerTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerPlansBucketsCreateTasks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerTask == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphPlannerTask is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerTask
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPlannerPlansBucketsDeleteTasksRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiUsersPlannerPlansBucketsDeleteTasksRequest) IfMatch(ifMatch string) ApiUsersPlannerPlansBucketsDeleteTasksRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersPlannerPlansBucketsDeleteTasksRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersPlannerPlansBucketsDeleteTasksExecute(r)
}

/*
UsersPlannerPlansBucketsDeleteTasks Delete navigation property tasks for users

Read-only. Nullable. The collection of tasks in the bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiUsersPlannerPlansBucketsDeleteTasksRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerPlansBucketsDeleteTasks(ctx _context.Context, userId string, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiUsersPlannerPlansBucketsDeleteTasksRequest {
	return ApiUsersPlannerPlansBucketsDeleteTasksRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *UsersPlannerUserApiService) UsersPlannerPlansBucketsDeleteTasksExecute(r ApiUsersPlannerPlansBucketsDeleteTasksRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerPlansBucketsDeleteTasks")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersPlannerPlansBucketsGetTasksRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiUsersPlannerPlansBucketsGetTasksRequest) Select_(select_ []string) ApiUsersPlannerPlansBucketsGetTasksRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersPlannerPlansBucketsGetTasksRequest) Expand(expand []string) ApiUsersPlannerPlansBucketsGetTasksRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersPlannerPlansBucketsGetTasksRequest) Execute() (MicrosoftGraphPlannerTask, *_nethttp.Response, error) {
	return r.ApiService.UsersPlannerPlansBucketsGetTasksExecute(r)
}

/*
UsersPlannerPlansBucketsGetTasks Get tasks from users

Read-only. Nullable. The collection of tasks in the bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiUsersPlannerPlansBucketsGetTasksRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerPlansBucketsGetTasks(ctx _context.Context, userId string, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiUsersPlannerPlansBucketsGetTasksRequest {
	return ApiUsersPlannerPlansBucketsGetTasksRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerTask
func (a *UsersPlannerUserApiService) UsersPlannerPlansBucketsGetTasksExecute(r ApiUsersPlannerPlansBucketsGetTasksRequest) (MicrosoftGraphPlannerTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerPlansBucketsGetTasks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPlannerPlansBucketsListTasksRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerPlanId string
	plannerBucketId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiUsersPlannerPlansBucketsListTasksRequest) Top(top int32) ApiUsersPlannerPlansBucketsListTasksRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiUsersPlannerPlansBucketsListTasksRequest) Skip(skip int32) ApiUsersPlannerPlansBucketsListTasksRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiUsersPlannerPlansBucketsListTasksRequest) Search(search string) ApiUsersPlannerPlansBucketsListTasksRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiUsersPlannerPlansBucketsListTasksRequest) Filter(filter string) ApiUsersPlannerPlansBucketsListTasksRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiUsersPlannerPlansBucketsListTasksRequest) Count(count bool) ApiUsersPlannerPlansBucketsListTasksRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiUsersPlannerPlansBucketsListTasksRequest) Orderby(orderby []string) ApiUsersPlannerPlansBucketsListTasksRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiUsersPlannerPlansBucketsListTasksRequest) Select_(select_ []string) ApiUsersPlannerPlansBucketsListTasksRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersPlannerPlansBucketsListTasksRequest) Expand(expand []string) ApiUsersPlannerPlansBucketsListTasksRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersPlannerPlansBucketsListTasksRequest) Execute() (CollectionOfPlannerTask, *_nethttp.Response, error) {
	return r.ApiService.UsersPlannerPlansBucketsListTasksExecute(r)
}

/*
UsersPlannerPlansBucketsListTasks Get tasks from users

Read-only. Nullable. The collection of tasks in the bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @return ApiUsersPlannerPlansBucketsListTasksRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerPlansBucketsListTasks(ctx _context.Context, userId string, plannerPlanId string, plannerBucketId string) ApiUsersPlannerPlansBucketsListTasksRequest {
	return ApiUsersPlannerPlansBucketsListTasksRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
	}
}

// Execute executes the request
//  @return CollectionOfPlannerTask
func (a *UsersPlannerUserApiService) UsersPlannerPlansBucketsListTasksExecute(r ApiUsersPlannerPlansBucketsListTasksRequest) (CollectionOfPlannerTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfPlannerTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerPlansBucketsListTasks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiUsersPlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormatRequest) IfMatch(ifMatch string) ApiUsersPlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormatRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersPlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersPlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormatExecute(r)
}

/*
UsersPlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormat Delete navigation property assignedToTaskBoardFormat for users

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by assignedTo.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiUsersPlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormatRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormat(ctx _context.Context, userId string, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiUsersPlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormatRequest {
	return ApiUsersPlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *UsersPlannerUserApiService) UsersPlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormatExecute(r ApiUsersPlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersPlannerPlansBucketsTasksDeleteBucketTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiUsersPlannerPlansBucketsTasksDeleteBucketTaskBoardFormatRequest) IfMatch(ifMatch string) ApiUsersPlannerPlansBucketsTasksDeleteBucketTaskBoardFormatRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersPlannerPlansBucketsTasksDeleteBucketTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersPlannerPlansBucketsTasksDeleteBucketTaskBoardFormatExecute(r)
}

/*
UsersPlannerPlansBucketsTasksDeleteBucketTaskBoardFormat Delete navigation property bucketTaskBoardFormat for users

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiUsersPlannerPlansBucketsTasksDeleteBucketTaskBoardFormatRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerPlansBucketsTasksDeleteBucketTaskBoardFormat(ctx _context.Context, userId string, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiUsersPlannerPlansBucketsTasksDeleteBucketTaskBoardFormatRequest {
	return ApiUsersPlannerPlansBucketsTasksDeleteBucketTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *UsersPlannerUserApiService) UsersPlannerPlansBucketsTasksDeleteBucketTaskBoardFormatExecute(r ApiUsersPlannerPlansBucketsTasksDeleteBucketTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerPlansBucketsTasksDeleteBucketTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersPlannerPlansBucketsTasksDeleteDetailsRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiUsersPlannerPlansBucketsTasksDeleteDetailsRequest) IfMatch(ifMatch string) ApiUsersPlannerPlansBucketsTasksDeleteDetailsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersPlannerPlansBucketsTasksDeleteDetailsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersPlannerPlansBucketsTasksDeleteDetailsExecute(r)
}

/*
UsersPlannerPlansBucketsTasksDeleteDetails Delete navigation property details for users

Read-only. Nullable. Additional details about the task.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiUsersPlannerPlansBucketsTasksDeleteDetailsRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerPlansBucketsTasksDeleteDetails(ctx _context.Context, userId string, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiUsersPlannerPlansBucketsTasksDeleteDetailsRequest {
	return ApiUsersPlannerPlansBucketsTasksDeleteDetailsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *UsersPlannerUserApiService) UsersPlannerPlansBucketsTasksDeleteDetailsExecute(r ApiUsersPlannerPlansBucketsTasksDeleteDetailsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerPlansBucketsTasksDeleteDetails")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersPlannerPlansBucketsTasksDeleteProgressTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiUsersPlannerPlansBucketsTasksDeleteProgressTaskBoardFormatRequest) IfMatch(ifMatch string) ApiUsersPlannerPlansBucketsTasksDeleteProgressTaskBoardFormatRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersPlannerPlansBucketsTasksDeleteProgressTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersPlannerPlansBucketsTasksDeleteProgressTaskBoardFormatExecute(r)
}

/*
UsersPlannerPlansBucketsTasksDeleteProgressTaskBoardFormat Delete navigation property progressTaskBoardFormat for users

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by progress.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiUsersPlannerPlansBucketsTasksDeleteProgressTaskBoardFormatRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerPlansBucketsTasksDeleteProgressTaskBoardFormat(ctx _context.Context, userId string, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiUsersPlannerPlansBucketsTasksDeleteProgressTaskBoardFormatRequest {
	return ApiUsersPlannerPlansBucketsTasksDeleteProgressTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *UsersPlannerUserApiService) UsersPlannerPlansBucketsTasksDeleteProgressTaskBoardFormatExecute(r ApiUsersPlannerPlansBucketsTasksDeleteProgressTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerPlansBucketsTasksDeleteProgressTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/progressTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersPlannerPlansBucketsTasksGetAssignedToTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiUsersPlannerPlansBucketsTasksGetAssignedToTaskBoardFormatRequest) Select_(select_ []string) ApiUsersPlannerPlansBucketsTasksGetAssignedToTaskBoardFormatRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersPlannerPlansBucketsTasksGetAssignedToTaskBoardFormatRequest) Expand(expand []string) ApiUsersPlannerPlansBucketsTasksGetAssignedToTaskBoardFormatRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersPlannerPlansBucketsTasksGetAssignedToTaskBoardFormatRequest) Execute() (MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat, *_nethttp.Response, error) {
	return r.ApiService.UsersPlannerPlansBucketsTasksGetAssignedToTaskBoardFormatExecute(r)
}

/*
UsersPlannerPlansBucketsTasksGetAssignedToTaskBoardFormat Get assignedToTaskBoardFormat from users

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by assignedTo.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiUsersPlannerPlansBucketsTasksGetAssignedToTaskBoardFormatRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerPlansBucketsTasksGetAssignedToTaskBoardFormat(ctx _context.Context, userId string, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiUsersPlannerPlansBucketsTasksGetAssignedToTaskBoardFormatRequest {
	return ApiUsersPlannerPlansBucketsTasksGetAssignedToTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat
func (a *UsersPlannerUserApiService) UsersPlannerPlansBucketsTasksGetAssignedToTaskBoardFormatExecute(r ApiUsersPlannerPlansBucketsTasksGetAssignedToTaskBoardFormatRequest) (MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerPlansBucketsTasksGetAssignedToTaskBoardFormat")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPlannerPlansBucketsTasksGetBucketTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiUsersPlannerPlansBucketsTasksGetBucketTaskBoardFormatRequest) Select_(select_ []string) ApiUsersPlannerPlansBucketsTasksGetBucketTaskBoardFormatRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersPlannerPlansBucketsTasksGetBucketTaskBoardFormatRequest) Expand(expand []string) ApiUsersPlannerPlansBucketsTasksGetBucketTaskBoardFormatRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersPlannerPlansBucketsTasksGetBucketTaskBoardFormatRequest) Execute() (MicrosoftGraphPlannerBucketTaskBoardTaskFormat, *_nethttp.Response, error) {
	return r.ApiService.UsersPlannerPlansBucketsTasksGetBucketTaskBoardFormatExecute(r)
}

/*
UsersPlannerPlansBucketsTasksGetBucketTaskBoardFormat Get bucketTaskBoardFormat from users

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiUsersPlannerPlansBucketsTasksGetBucketTaskBoardFormatRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerPlansBucketsTasksGetBucketTaskBoardFormat(ctx _context.Context, userId string, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiUsersPlannerPlansBucketsTasksGetBucketTaskBoardFormatRequest {
	return ApiUsersPlannerPlansBucketsTasksGetBucketTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerBucketTaskBoardTaskFormat
func (a *UsersPlannerUserApiService) UsersPlannerPlansBucketsTasksGetBucketTaskBoardFormatExecute(r ApiUsersPlannerPlansBucketsTasksGetBucketTaskBoardFormatRequest) (MicrosoftGraphPlannerBucketTaskBoardTaskFormat, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerBucketTaskBoardTaskFormat
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerPlansBucketsTasksGetBucketTaskBoardFormat")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPlannerPlansBucketsTasksGetDetailsRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiUsersPlannerPlansBucketsTasksGetDetailsRequest) Select_(select_ []string) ApiUsersPlannerPlansBucketsTasksGetDetailsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersPlannerPlansBucketsTasksGetDetailsRequest) Expand(expand []string) ApiUsersPlannerPlansBucketsTasksGetDetailsRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersPlannerPlansBucketsTasksGetDetailsRequest) Execute() (MicrosoftGraphPlannerTaskDetails, *_nethttp.Response, error) {
	return r.ApiService.UsersPlannerPlansBucketsTasksGetDetailsExecute(r)
}

/*
UsersPlannerPlansBucketsTasksGetDetails Get details from users

Read-only. Nullable. Additional details about the task.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiUsersPlannerPlansBucketsTasksGetDetailsRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerPlansBucketsTasksGetDetails(ctx _context.Context, userId string, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiUsersPlannerPlansBucketsTasksGetDetailsRequest {
	return ApiUsersPlannerPlansBucketsTasksGetDetailsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerTaskDetails
func (a *UsersPlannerUserApiService) UsersPlannerPlansBucketsTasksGetDetailsExecute(r ApiUsersPlannerPlansBucketsTasksGetDetailsRequest) (MicrosoftGraphPlannerTaskDetails, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerTaskDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerPlansBucketsTasksGetDetails")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPlannerPlansBucketsTasksGetProgressTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiUsersPlannerPlansBucketsTasksGetProgressTaskBoardFormatRequest) Select_(select_ []string) ApiUsersPlannerPlansBucketsTasksGetProgressTaskBoardFormatRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersPlannerPlansBucketsTasksGetProgressTaskBoardFormatRequest) Expand(expand []string) ApiUsersPlannerPlansBucketsTasksGetProgressTaskBoardFormatRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersPlannerPlansBucketsTasksGetProgressTaskBoardFormatRequest) Execute() (MicrosoftGraphPlannerProgressTaskBoardTaskFormat, *_nethttp.Response, error) {
	return r.ApiService.UsersPlannerPlansBucketsTasksGetProgressTaskBoardFormatExecute(r)
}

/*
UsersPlannerPlansBucketsTasksGetProgressTaskBoardFormat Get progressTaskBoardFormat from users

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by progress.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiUsersPlannerPlansBucketsTasksGetProgressTaskBoardFormatRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerPlansBucketsTasksGetProgressTaskBoardFormat(ctx _context.Context, userId string, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiUsersPlannerPlansBucketsTasksGetProgressTaskBoardFormatRequest {
	return ApiUsersPlannerPlansBucketsTasksGetProgressTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerProgressTaskBoardTaskFormat
func (a *UsersPlannerUserApiService) UsersPlannerPlansBucketsTasksGetProgressTaskBoardFormatExecute(r ApiUsersPlannerPlansBucketsTasksGetProgressTaskBoardFormatRequest) (MicrosoftGraphPlannerProgressTaskBoardTaskFormat, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerProgressTaskBoardTaskFormat
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerPlansBucketsTasksGetProgressTaskBoardFormat")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/progressTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	microsoftGraphPlannerAssignedToTaskBoardTaskFormat *MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat
}

// New navigation property values
func (r ApiUsersPlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormatRequest) MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat(microsoftGraphPlannerAssignedToTaskBoardTaskFormat MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat) ApiUsersPlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormatRequest {
	r.microsoftGraphPlannerAssignedToTaskBoardTaskFormat = &microsoftGraphPlannerAssignedToTaskBoardTaskFormat
	return r
}

func (r ApiUsersPlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersPlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormatExecute(r)
}

/*
UsersPlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormat Update the navigation property assignedToTaskBoardFormat in users

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by assignedTo.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiUsersPlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormatRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormat(ctx _context.Context, userId string, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiUsersPlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormatRequest {
	return ApiUsersPlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *UsersPlannerUserApiService) UsersPlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormatExecute(r ApiUsersPlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerAssignedToTaskBoardTaskFormat == nil {
		return nil, reportError("microsoftGraphPlannerAssignedToTaskBoardTaskFormat is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerAssignedToTaskBoardTaskFormat
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersPlannerPlansBucketsTasksUpdateBucketTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	microsoftGraphPlannerBucketTaskBoardTaskFormat *MicrosoftGraphPlannerBucketTaskBoardTaskFormat
}

// New navigation property values
func (r ApiUsersPlannerPlansBucketsTasksUpdateBucketTaskBoardFormatRequest) MicrosoftGraphPlannerBucketTaskBoardTaskFormat(microsoftGraphPlannerBucketTaskBoardTaskFormat MicrosoftGraphPlannerBucketTaskBoardTaskFormat) ApiUsersPlannerPlansBucketsTasksUpdateBucketTaskBoardFormatRequest {
	r.microsoftGraphPlannerBucketTaskBoardTaskFormat = &microsoftGraphPlannerBucketTaskBoardTaskFormat
	return r
}

func (r ApiUsersPlannerPlansBucketsTasksUpdateBucketTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersPlannerPlansBucketsTasksUpdateBucketTaskBoardFormatExecute(r)
}

/*
UsersPlannerPlansBucketsTasksUpdateBucketTaskBoardFormat Update the navigation property bucketTaskBoardFormat in users

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiUsersPlannerPlansBucketsTasksUpdateBucketTaskBoardFormatRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerPlansBucketsTasksUpdateBucketTaskBoardFormat(ctx _context.Context, userId string, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiUsersPlannerPlansBucketsTasksUpdateBucketTaskBoardFormatRequest {
	return ApiUsersPlannerPlansBucketsTasksUpdateBucketTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *UsersPlannerUserApiService) UsersPlannerPlansBucketsTasksUpdateBucketTaskBoardFormatExecute(r ApiUsersPlannerPlansBucketsTasksUpdateBucketTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerPlansBucketsTasksUpdateBucketTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerBucketTaskBoardTaskFormat == nil {
		return nil, reportError("microsoftGraphPlannerBucketTaskBoardTaskFormat is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerBucketTaskBoardTaskFormat
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersPlannerPlansBucketsTasksUpdateDetailsRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	microsoftGraphPlannerTaskDetails *MicrosoftGraphPlannerTaskDetails
}

// New navigation property values
func (r ApiUsersPlannerPlansBucketsTasksUpdateDetailsRequest) MicrosoftGraphPlannerTaskDetails(microsoftGraphPlannerTaskDetails MicrosoftGraphPlannerTaskDetails) ApiUsersPlannerPlansBucketsTasksUpdateDetailsRequest {
	r.microsoftGraphPlannerTaskDetails = &microsoftGraphPlannerTaskDetails
	return r
}

func (r ApiUsersPlannerPlansBucketsTasksUpdateDetailsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersPlannerPlansBucketsTasksUpdateDetailsExecute(r)
}

/*
UsersPlannerPlansBucketsTasksUpdateDetails Update the navigation property details in users

Read-only. Nullable. Additional details about the task.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiUsersPlannerPlansBucketsTasksUpdateDetailsRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerPlansBucketsTasksUpdateDetails(ctx _context.Context, userId string, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiUsersPlannerPlansBucketsTasksUpdateDetailsRequest {
	return ApiUsersPlannerPlansBucketsTasksUpdateDetailsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *UsersPlannerUserApiService) UsersPlannerPlansBucketsTasksUpdateDetailsExecute(r ApiUsersPlannerPlansBucketsTasksUpdateDetailsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerPlansBucketsTasksUpdateDetails")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerTaskDetails == nil {
		return nil, reportError("microsoftGraphPlannerTaskDetails is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerTaskDetails
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersPlannerPlansBucketsTasksUpdateProgressTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	microsoftGraphPlannerProgressTaskBoardTaskFormat *MicrosoftGraphPlannerProgressTaskBoardTaskFormat
}

// New navigation property values
func (r ApiUsersPlannerPlansBucketsTasksUpdateProgressTaskBoardFormatRequest) MicrosoftGraphPlannerProgressTaskBoardTaskFormat(microsoftGraphPlannerProgressTaskBoardTaskFormat MicrosoftGraphPlannerProgressTaskBoardTaskFormat) ApiUsersPlannerPlansBucketsTasksUpdateProgressTaskBoardFormatRequest {
	r.microsoftGraphPlannerProgressTaskBoardTaskFormat = &microsoftGraphPlannerProgressTaskBoardTaskFormat
	return r
}

func (r ApiUsersPlannerPlansBucketsTasksUpdateProgressTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersPlannerPlansBucketsTasksUpdateProgressTaskBoardFormatExecute(r)
}

/*
UsersPlannerPlansBucketsTasksUpdateProgressTaskBoardFormat Update the navigation property progressTaskBoardFormat in users

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by progress.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiUsersPlannerPlansBucketsTasksUpdateProgressTaskBoardFormatRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerPlansBucketsTasksUpdateProgressTaskBoardFormat(ctx _context.Context, userId string, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiUsersPlannerPlansBucketsTasksUpdateProgressTaskBoardFormatRequest {
	return ApiUsersPlannerPlansBucketsTasksUpdateProgressTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *UsersPlannerUserApiService) UsersPlannerPlansBucketsTasksUpdateProgressTaskBoardFormatExecute(r ApiUsersPlannerPlansBucketsTasksUpdateProgressTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerPlansBucketsTasksUpdateProgressTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/progressTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerProgressTaskBoardTaskFormat == nil {
		return nil, reportError("microsoftGraphPlannerProgressTaskBoardTaskFormat is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerProgressTaskBoardTaskFormat
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersPlannerPlansBucketsUpdateTasksRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	microsoftGraphPlannerTask *MicrosoftGraphPlannerTask
}

// New navigation property values
func (r ApiUsersPlannerPlansBucketsUpdateTasksRequest) MicrosoftGraphPlannerTask(microsoftGraphPlannerTask MicrosoftGraphPlannerTask) ApiUsersPlannerPlansBucketsUpdateTasksRequest {
	r.microsoftGraphPlannerTask = &microsoftGraphPlannerTask
	return r
}

func (r ApiUsersPlannerPlansBucketsUpdateTasksRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersPlannerPlansBucketsUpdateTasksExecute(r)
}

/*
UsersPlannerPlansBucketsUpdateTasks Update the navigation property tasks in users

Read-only. Nullable. The collection of tasks in the bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiUsersPlannerPlansBucketsUpdateTasksRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerPlansBucketsUpdateTasks(ctx _context.Context, userId string, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiUsersPlannerPlansBucketsUpdateTasksRequest {
	return ApiUsersPlannerPlansBucketsUpdateTasksRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *UsersPlannerUserApiService) UsersPlannerPlansBucketsUpdateTasksExecute(r ApiUsersPlannerPlansBucketsUpdateTasksRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerPlansBucketsUpdateTasks")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerTask == nil {
		return nil, reportError("microsoftGraphPlannerTask is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerTask
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersPlannerPlansCreateBucketsRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerPlanId string
	microsoftGraphPlannerBucket *MicrosoftGraphPlannerBucket
}

// New navigation property
func (r ApiUsersPlannerPlansCreateBucketsRequest) MicrosoftGraphPlannerBucket(microsoftGraphPlannerBucket MicrosoftGraphPlannerBucket) ApiUsersPlannerPlansCreateBucketsRequest {
	r.microsoftGraphPlannerBucket = &microsoftGraphPlannerBucket
	return r
}

func (r ApiUsersPlannerPlansCreateBucketsRequest) Execute() (MicrosoftGraphPlannerBucket, *_nethttp.Response, error) {
	return r.ApiService.UsersPlannerPlansCreateBucketsExecute(r)
}

/*
UsersPlannerPlansCreateBuckets Create new navigation property to buckets for users

Read-only. Nullable. Collection of buckets in the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerPlanId key: id of plannerPlan
 @return ApiUsersPlannerPlansCreateBucketsRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerPlansCreateBuckets(ctx _context.Context, userId string, plannerPlanId string) ApiUsersPlannerPlansCreateBucketsRequest {
	return ApiUsersPlannerPlansCreateBucketsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerPlanId: plannerPlanId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerBucket
func (a *UsersPlannerUserApiService) UsersPlannerPlansCreateBucketsExecute(r ApiUsersPlannerPlansCreateBucketsRequest) (MicrosoftGraphPlannerBucket, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerBucket
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerPlansCreateBuckets")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/plans/{plannerPlan-id}/buckets"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerBucket == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphPlannerBucket is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerBucket
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPlannerPlansCreateTasksRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerPlanId string
	microsoftGraphPlannerTask *MicrosoftGraphPlannerTask
}

// New navigation property
func (r ApiUsersPlannerPlansCreateTasksRequest) MicrosoftGraphPlannerTask(microsoftGraphPlannerTask MicrosoftGraphPlannerTask) ApiUsersPlannerPlansCreateTasksRequest {
	r.microsoftGraphPlannerTask = &microsoftGraphPlannerTask
	return r
}

func (r ApiUsersPlannerPlansCreateTasksRequest) Execute() (MicrosoftGraphPlannerTask, *_nethttp.Response, error) {
	return r.ApiService.UsersPlannerPlansCreateTasksExecute(r)
}

/*
UsersPlannerPlansCreateTasks Create new navigation property to tasks for users

Read-only. Nullable. Collection of tasks in the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerPlanId key: id of plannerPlan
 @return ApiUsersPlannerPlansCreateTasksRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerPlansCreateTasks(ctx _context.Context, userId string, plannerPlanId string) ApiUsersPlannerPlansCreateTasksRequest {
	return ApiUsersPlannerPlansCreateTasksRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerPlanId: plannerPlanId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerTask
func (a *UsersPlannerUserApiService) UsersPlannerPlansCreateTasksExecute(r ApiUsersPlannerPlansCreateTasksRequest) (MicrosoftGraphPlannerTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerPlansCreateTasks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/plans/{plannerPlan-id}/tasks"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerTask == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphPlannerTask is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerTask
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPlannerPlansDeleteBucketsRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerPlanId string
	plannerBucketId string
	ifMatch *string
}

// ETag
func (r ApiUsersPlannerPlansDeleteBucketsRequest) IfMatch(ifMatch string) ApiUsersPlannerPlansDeleteBucketsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersPlannerPlansDeleteBucketsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersPlannerPlansDeleteBucketsExecute(r)
}

/*
UsersPlannerPlansDeleteBuckets Delete navigation property buckets for users

Read-only. Nullable. Collection of buckets in the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @return ApiUsersPlannerPlansDeleteBucketsRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerPlansDeleteBuckets(ctx _context.Context, userId string, plannerPlanId string, plannerBucketId string) ApiUsersPlannerPlansDeleteBucketsRequest {
	return ApiUsersPlannerPlansDeleteBucketsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
	}
}

// Execute executes the request
func (a *UsersPlannerUserApiService) UsersPlannerPlansDeleteBucketsExecute(r ApiUsersPlannerPlansDeleteBucketsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerPlansDeleteBuckets")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersPlannerPlansDeleteDetailsRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerPlanId string
	ifMatch *string
}

// ETag
func (r ApiUsersPlannerPlansDeleteDetailsRequest) IfMatch(ifMatch string) ApiUsersPlannerPlansDeleteDetailsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersPlannerPlansDeleteDetailsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersPlannerPlansDeleteDetailsExecute(r)
}

/*
UsersPlannerPlansDeleteDetails Delete navigation property details for users

Read-only. Nullable. Additional details about the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerPlanId key: id of plannerPlan
 @return ApiUsersPlannerPlansDeleteDetailsRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerPlansDeleteDetails(ctx _context.Context, userId string, plannerPlanId string) ApiUsersPlannerPlansDeleteDetailsRequest {
	return ApiUsersPlannerPlansDeleteDetailsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerPlanId: plannerPlanId,
	}
}

// Execute executes the request
func (a *UsersPlannerUserApiService) UsersPlannerPlansDeleteDetailsExecute(r ApiUsersPlannerPlansDeleteDetailsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerPlansDeleteDetails")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/plans/{plannerPlan-id}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersPlannerPlansDeleteTasksRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerPlanId string
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiUsersPlannerPlansDeleteTasksRequest) IfMatch(ifMatch string) ApiUsersPlannerPlansDeleteTasksRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersPlannerPlansDeleteTasksRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersPlannerPlansDeleteTasksExecute(r)
}

/*
UsersPlannerPlansDeleteTasks Delete navigation property tasks for users

Read-only. Nullable. Collection of tasks in the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiUsersPlannerPlansDeleteTasksRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerPlansDeleteTasks(ctx _context.Context, userId string, plannerPlanId string, plannerTaskId string) ApiUsersPlannerPlansDeleteTasksRequest {
	return ApiUsersPlannerPlansDeleteTasksRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *UsersPlannerUserApiService) UsersPlannerPlansDeleteTasksExecute(r ApiUsersPlannerPlansDeleteTasksRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerPlansDeleteTasks")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersPlannerPlansGetBucketsRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerPlanId string
	plannerBucketId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiUsersPlannerPlansGetBucketsRequest) Select_(select_ []string) ApiUsersPlannerPlansGetBucketsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersPlannerPlansGetBucketsRequest) Expand(expand []string) ApiUsersPlannerPlansGetBucketsRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersPlannerPlansGetBucketsRequest) Execute() (MicrosoftGraphPlannerBucket, *_nethttp.Response, error) {
	return r.ApiService.UsersPlannerPlansGetBucketsExecute(r)
}

/*
UsersPlannerPlansGetBuckets Get buckets from users

Read-only. Nullable. Collection of buckets in the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @return ApiUsersPlannerPlansGetBucketsRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerPlansGetBuckets(ctx _context.Context, userId string, plannerPlanId string, plannerBucketId string) ApiUsersPlannerPlansGetBucketsRequest {
	return ApiUsersPlannerPlansGetBucketsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerBucket
func (a *UsersPlannerUserApiService) UsersPlannerPlansGetBucketsExecute(r ApiUsersPlannerPlansGetBucketsRequest) (MicrosoftGraphPlannerBucket, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerBucket
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerPlansGetBuckets")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPlannerPlansGetDetailsRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerPlanId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiUsersPlannerPlansGetDetailsRequest) Select_(select_ []string) ApiUsersPlannerPlansGetDetailsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersPlannerPlansGetDetailsRequest) Expand(expand []string) ApiUsersPlannerPlansGetDetailsRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersPlannerPlansGetDetailsRequest) Execute() (MicrosoftGraphPlannerPlanDetails, *_nethttp.Response, error) {
	return r.ApiService.UsersPlannerPlansGetDetailsExecute(r)
}

/*
UsersPlannerPlansGetDetails Get details from users

Read-only. Nullable. Additional details about the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerPlanId key: id of plannerPlan
 @return ApiUsersPlannerPlansGetDetailsRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerPlansGetDetails(ctx _context.Context, userId string, plannerPlanId string) ApiUsersPlannerPlansGetDetailsRequest {
	return ApiUsersPlannerPlansGetDetailsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerPlanId: plannerPlanId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerPlanDetails
func (a *UsersPlannerUserApiService) UsersPlannerPlansGetDetailsExecute(r ApiUsersPlannerPlansGetDetailsRequest) (MicrosoftGraphPlannerPlanDetails, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerPlanDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerPlansGetDetails")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/plans/{plannerPlan-id}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPlannerPlansGetTasksRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerPlanId string
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiUsersPlannerPlansGetTasksRequest) Select_(select_ []string) ApiUsersPlannerPlansGetTasksRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersPlannerPlansGetTasksRequest) Expand(expand []string) ApiUsersPlannerPlansGetTasksRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersPlannerPlansGetTasksRequest) Execute() (MicrosoftGraphPlannerTask, *_nethttp.Response, error) {
	return r.ApiService.UsersPlannerPlansGetTasksExecute(r)
}

/*
UsersPlannerPlansGetTasks Get tasks from users

Read-only. Nullable. Collection of tasks in the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiUsersPlannerPlansGetTasksRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerPlansGetTasks(ctx _context.Context, userId string, plannerPlanId string, plannerTaskId string) ApiUsersPlannerPlansGetTasksRequest {
	return ApiUsersPlannerPlansGetTasksRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerTask
func (a *UsersPlannerUserApiService) UsersPlannerPlansGetTasksExecute(r ApiUsersPlannerPlansGetTasksRequest) (MicrosoftGraphPlannerTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerPlansGetTasks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPlannerPlansListBucketsRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerPlanId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiUsersPlannerPlansListBucketsRequest) Top(top int32) ApiUsersPlannerPlansListBucketsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiUsersPlannerPlansListBucketsRequest) Skip(skip int32) ApiUsersPlannerPlansListBucketsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiUsersPlannerPlansListBucketsRequest) Search(search string) ApiUsersPlannerPlansListBucketsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiUsersPlannerPlansListBucketsRequest) Filter(filter string) ApiUsersPlannerPlansListBucketsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiUsersPlannerPlansListBucketsRequest) Count(count bool) ApiUsersPlannerPlansListBucketsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiUsersPlannerPlansListBucketsRequest) Orderby(orderby []string) ApiUsersPlannerPlansListBucketsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiUsersPlannerPlansListBucketsRequest) Select_(select_ []string) ApiUsersPlannerPlansListBucketsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersPlannerPlansListBucketsRequest) Expand(expand []string) ApiUsersPlannerPlansListBucketsRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersPlannerPlansListBucketsRequest) Execute() (CollectionOfPlannerBucket, *_nethttp.Response, error) {
	return r.ApiService.UsersPlannerPlansListBucketsExecute(r)
}

/*
UsersPlannerPlansListBuckets Get buckets from users

Read-only. Nullable. Collection of buckets in the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerPlanId key: id of plannerPlan
 @return ApiUsersPlannerPlansListBucketsRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerPlansListBuckets(ctx _context.Context, userId string, plannerPlanId string) ApiUsersPlannerPlansListBucketsRequest {
	return ApiUsersPlannerPlansListBucketsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerPlanId: plannerPlanId,
	}
}

// Execute executes the request
//  @return CollectionOfPlannerBucket
func (a *UsersPlannerUserApiService) UsersPlannerPlansListBucketsExecute(r ApiUsersPlannerPlansListBucketsRequest) (CollectionOfPlannerBucket, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfPlannerBucket
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerPlansListBuckets")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/plans/{plannerPlan-id}/buckets"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPlannerPlansListTasksRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerPlanId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiUsersPlannerPlansListTasksRequest) Top(top int32) ApiUsersPlannerPlansListTasksRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiUsersPlannerPlansListTasksRequest) Skip(skip int32) ApiUsersPlannerPlansListTasksRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiUsersPlannerPlansListTasksRequest) Search(search string) ApiUsersPlannerPlansListTasksRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiUsersPlannerPlansListTasksRequest) Filter(filter string) ApiUsersPlannerPlansListTasksRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiUsersPlannerPlansListTasksRequest) Count(count bool) ApiUsersPlannerPlansListTasksRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiUsersPlannerPlansListTasksRequest) Orderby(orderby []string) ApiUsersPlannerPlansListTasksRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiUsersPlannerPlansListTasksRequest) Select_(select_ []string) ApiUsersPlannerPlansListTasksRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersPlannerPlansListTasksRequest) Expand(expand []string) ApiUsersPlannerPlansListTasksRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersPlannerPlansListTasksRequest) Execute() (CollectionOfPlannerTask, *_nethttp.Response, error) {
	return r.ApiService.UsersPlannerPlansListTasksExecute(r)
}

/*
UsersPlannerPlansListTasks Get tasks from users

Read-only. Nullable. Collection of tasks in the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerPlanId key: id of plannerPlan
 @return ApiUsersPlannerPlansListTasksRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerPlansListTasks(ctx _context.Context, userId string, plannerPlanId string) ApiUsersPlannerPlansListTasksRequest {
	return ApiUsersPlannerPlansListTasksRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerPlanId: plannerPlanId,
	}
}

// Execute executes the request
//  @return CollectionOfPlannerTask
func (a *UsersPlannerUserApiService) UsersPlannerPlansListTasksExecute(r ApiUsersPlannerPlansListTasksRequest) (CollectionOfPlannerTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfPlannerTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerPlansListTasks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/plans/{plannerPlan-id}/tasks"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPlannerPlansTasksDeleteAssignedToTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerPlanId string
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiUsersPlannerPlansTasksDeleteAssignedToTaskBoardFormatRequest) IfMatch(ifMatch string) ApiUsersPlannerPlansTasksDeleteAssignedToTaskBoardFormatRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersPlannerPlansTasksDeleteAssignedToTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersPlannerPlansTasksDeleteAssignedToTaskBoardFormatExecute(r)
}

/*
UsersPlannerPlansTasksDeleteAssignedToTaskBoardFormat Delete navigation property assignedToTaskBoardFormat for users

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by assignedTo.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiUsersPlannerPlansTasksDeleteAssignedToTaskBoardFormatRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerPlansTasksDeleteAssignedToTaskBoardFormat(ctx _context.Context, userId string, plannerPlanId string, plannerTaskId string) ApiUsersPlannerPlansTasksDeleteAssignedToTaskBoardFormatRequest {
	return ApiUsersPlannerPlansTasksDeleteAssignedToTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *UsersPlannerUserApiService) UsersPlannerPlansTasksDeleteAssignedToTaskBoardFormatExecute(r ApiUsersPlannerPlansTasksDeleteAssignedToTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerPlansTasksDeleteAssignedToTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersPlannerPlansTasksDeleteBucketTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerPlanId string
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiUsersPlannerPlansTasksDeleteBucketTaskBoardFormatRequest) IfMatch(ifMatch string) ApiUsersPlannerPlansTasksDeleteBucketTaskBoardFormatRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersPlannerPlansTasksDeleteBucketTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersPlannerPlansTasksDeleteBucketTaskBoardFormatExecute(r)
}

/*
UsersPlannerPlansTasksDeleteBucketTaskBoardFormat Delete navigation property bucketTaskBoardFormat for users

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiUsersPlannerPlansTasksDeleteBucketTaskBoardFormatRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerPlansTasksDeleteBucketTaskBoardFormat(ctx _context.Context, userId string, plannerPlanId string, plannerTaskId string) ApiUsersPlannerPlansTasksDeleteBucketTaskBoardFormatRequest {
	return ApiUsersPlannerPlansTasksDeleteBucketTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *UsersPlannerUserApiService) UsersPlannerPlansTasksDeleteBucketTaskBoardFormatExecute(r ApiUsersPlannerPlansTasksDeleteBucketTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerPlansTasksDeleteBucketTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersPlannerPlansTasksDeleteDetailsRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerPlanId string
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiUsersPlannerPlansTasksDeleteDetailsRequest) IfMatch(ifMatch string) ApiUsersPlannerPlansTasksDeleteDetailsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersPlannerPlansTasksDeleteDetailsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersPlannerPlansTasksDeleteDetailsExecute(r)
}

/*
UsersPlannerPlansTasksDeleteDetails Delete navigation property details for users

Read-only. Nullable. Additional details about the task.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiUsersPlannerPlansTasksDeleteDetailsRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerPlansTasksDeleteDetails(ctx _context.Context, userId string, plannerPlanId string, plannerTaskId string) ApiUsersPlannerPlansTasksDeleteDetailsRequest {
	return ApiUsersPlannerPlansTasksDeleteDetailsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *UsersPlannerUserApiService) UsersPlannerPlansTasksDeleteDetailsExecute(r ApiUsersPlannerPlansTasksDeleteDetailsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerPlansTasksDeleteDetails")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersPlannerPlansTasksDeleteProgressTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerPlanId string
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiUsersPlannerPlansTasksDeleteProgressTaskBoardFormatRequest) IfMatch(ifMatch string) ApiUsersPlannerPlansTasksDeleteProgressTaskBoardFormatRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersPlannerPlansTasksDeleteProgressTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersPlannerPlansTasksDeleteProgressTaskBoardFormatExecute(r)
}

/*
UsersPlannerPlansTasksDeleteProgressTaskBoardFormat Delete navigation property progressTaskBoardFormat for users

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by progress.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiUsersPlannerPlansTasksDeleteProgressTaskBoardFormatRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerPlansTasksDeleteProgressTaskBoardFormat(ctx _context.Context, userId string, plannerPlanId string, plannerTaskId string) ApiUsersPlannerPlansTasksDeleteProgressTaskBoardFormatRequest {
	return ApiUsersPlannerPlansTasksDeleteProgressTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *UsersPlannerUserApiService) UsersPlannerPlansTasksDeleteProgressTaskBoardFormatExecute(r ApiUsersPlannerPlansTasksDeleteProgressTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerPlansTasksDeleteProgressTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/progressTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersPlannerPlansTasksGetAssignedToTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerPlanId string
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiUsersPlannerPlansTasksGetAssignedToTaskBoardFormatRequest) Select_(select_ []string) ApiUsersPlannerPlansTasksGetAssignedToTaskBoardFormatRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersPlannerPlansTasksGetAssignedToTaskBoardFormatRequest) Expand(expand []string) ApiUsersPlannerPlansTasksGetAssignedToTaskBoardFormatRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersPlannerPlansTasksGetAssignedToTaskBoardFormatRequest) Execute() (MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat, *_nethttp.Response, error) {
	return r.ApiService.UsersPlannerPlansTasksGetAssignedToTaskBoardFormatExecute(r)
}

/*
UsersPlannerPlansTasksGetAssignedToTaskBoardFormat Get assignedToTaskBoardFormat from users

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by assignedTo.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiUsersPlannerPlansTasksGetAssignedToTaskBoardFormatRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerPlansTasksGetAssignedToTaskBoardFormat(ctx _context.Context, userId string, plannerPlanId string, plannerTaskId string) ApiUsersPlannerPlansTasksGetAssignedToTaskBoardFormatRequest {
	return ApiUsersPlannerPlansTasksGetAssignedToTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat
func (a *UsersPlannerUserApiService) UsersPlannerPlansTasksGetAssignedToTaskBoardFormatExecute(r ApiUsersPlannerPlansTasksGetAssignedToTaskBoardFormatRequest) (MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerPlansTasksGetAssignedToTaskBoardFormat")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPlannerPlansTasksGetBucketTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerPlanId string
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiUsersPlannerPlansTasksGetBucketTaskBoardFormatRequest) Select_(select_ []string) ApiUsersPlannerPlansTasksGetBucketTaskBoardFormatRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersPlannerPlansTasksGetBucketTaskBoardFormatRequest) Expand(expand []string) ApiUsersPlannerPlansTasksGetBucketTaskBoardFormatRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersPlannerPlansTasksGetBucketTaskBoardFormatRequest) Execute() (MicrosoftGraphPlannerBucketTaskBoardTaskFormat, *_nethttp.Response, error) {
	return r.ApiService.UsersPlannerPlansTasksGetBucketTaskBoardFormatExecute(r)
}

/*
UsersPlannerPlansTasksGetBucketTaskBoardFormat Get bucketTaskBoardFormat from users

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiUsersPlannerPlansTasksGetBucketTaskBoardFormatRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerPlansTasksGetBucketTaskBoardFormat(ctx _context.Context, userId string, plannerPlanId string, plannerTaskId string) ApiUsersPlannerPlansTasksGetBucketTaskBoardFormatRequest {
	return ApiUsersPlannerPlansTasksGetBucketTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerBucketTaskBoardTaskFormat
func (a *UsersPlannerUserApiService) UsersPlannerPlansTasksGetBucketTaskBoardFormatExecute(r ApiUsersPlannerPlansTasksGetBucketTaskBoardFormatRequest) (MicrosoftGraphPlannerBucketTaskBoardTaskFormat, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerBucketTaskBoardTaskFormat
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerPlansTasksGetBucketTaskBoardFormat")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPlannerPlansTasksGetDetailsRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerPlanId string
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiUsersPlannerPlansTasksGetDetailsRequest) Select_(select_ []string) ApiUsersPlannerPlansTasksGetDetailsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersPlannerPlansTasksGetDetailsRequest) Expand(expand []string) ApiUsersPlannerPlansTasksGetDetailsRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersPlannerPlansTasksGetDetailsRequest) Execute() (MicrosoftGraphPlannerTaskDetails, *_nethttp.Response, error) {
	return r.ApiService.UsersPlannerPlansTasksGetDetailsExecute(r)
}

/*
UsersPlannerPlansTasksGetDetails Get details from users

Read-only. Nullable. Additional details about the task.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiUsersPlannerPlansTasksGetDetailsRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerPlansTasksGetDetails(ctx _context.Context, userId string, plannerPlanId string, plannerTaskId string) ApiUsersPlannerPlansTasksGetDetailsRequest {
	return ApiUsersPlannerPlansTasksGetDetailsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerTaskDetails
func (a *UsersPlannerUserApiService) UsersPlannerPlansTasksGetDetailsExecute(r ApiUsersPlannerPlansTasksGetDetailsRequest) (MicrosoftGraphPlannerTaskDetails, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerTaskDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerPlansTasksGetDetails")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPlannerPlansTasksGetProgressTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerPlanId string
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiUsersPlannerPlansTasksGetProgressTaskBoardFormatRequest) Select_(select_ []string) ApiUsersPlannerPlansTasksGetProgressTaskBoardFormatRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersPlannerPlansTasksGetProgressTaskBoardFormatRequest) Expand(expand []string) ApiUsersPlannerPlansTasksGetProgressTaskBoardFormatRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersPlannerPlansTasksGetProgressTaskBoardFormatRequest) Execute() (MicrosoftGraphPlannerProgressTaskBoardTaskFormat, *_nethttp.Response, error) {
	return r.ApiService.UsersPlannerPlansTasksGetProgressTaskBoardFormatExecute(r)
}

/*
UsersPlannerPlansTasksGetProgressTaskBoardFormat Get progressTaskBoardFormat from users

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by progress.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiUsersPlannerPlansTasksGetProgressTaskBoardFormatRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerPlansTasksGetProgressTaskBoardFormat(ctx _context.Context, userId string, plannerPlanId string, plannerTaskId string) ApiUsersPlannerPlansTasksGetProgressTaskBoardFormatRequest {
	return ApiUsersPlannerPlansTasksGetProgressTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerProgressTaskBoardTaskFormat
func (a *UsersPlannerUserApiService) UsersPlannerPlansTasksGetProgressTaskBoardFormatExecute(r ApiUsersPlannerPlansTasksGetProgressTaskBoardFormatRequest) (MicrosoftGraphPlannerProgressTaskBoardTaskFormat, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerProgressTaskBoardTaskFormat
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerPlansTasksGetProgressTaskBoardFormat")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/progressTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPlannerPlansTasksUpdateAssignedToTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerPlanId string
	plannerTaskId string
	microsoftGraphPlannerAssignedToTaskBoardTaskFormat *MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat
}

// New navigation property values
func (r ApiUsersPlannerPlansTasksUpdateAssignedToTaskBoardFormatRequest) MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat(microsoftGraphPlannerAssignedToTaskBoardTaskFormat MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat) ApiUsersPlannerPlansTasksUpdateAssignedToTaskBoardFormatRequest {
	r.microsoftGraphPlannerAssignedToTaskBoardTaskFormat = &microsoftGraphPlannerAssignedToTaskBoardTaskFormat
	return r
}

func (r ApiUsersPlannerPlansTasksUpdateAssignedToTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersPlannerPlansTasksUpdateAssignedToTaskBoardFormatExecute(r)
}

/*
UsersPlannerPlansTasksUpdateAssignedToTaskBoardFormat Update the navigation property assignedToTaskBoardFormat in users

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by assignedTo.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiUsersPlannerPlansTasksUpdateAssignedToTaskBoardFormatRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerPlansTasksUpdateAssignedToTaskBoardFormat(ctx _context.Context, userId string, plannerPlanId string, plannerTaskId string) ApiUsersPlannerPlansTasksUpdateAssignedToTaskBoardFormatRequest {
	return ApiUsersPlannerPlansTasksUpdateAssignedToTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *UsersPlannerUserApiService) UsersPlannerPlansTasksUpdateAssignedToTaskBoardFormatExecute(r ApiUsersPlannerPlansTasksUpdateAssignedToTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerPlansTasksUpdateAssignedToTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerAssignedToTaskBoardTaskFormat == nil {
		return nil, reportError("microsoftGraphPlannerAssignedToTaskBoardTaskFormat is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerAssignedToTaskBoardTaskFormat
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersPlannerPlansTasksUpdateBucketTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerPlanId string
	plannerTaskId string
	microsoftGraphPlannerBucketTaskBoardTaskFormat *MicrosoftGraphPlannerBucketTaskBoardTaskFormat
}

// New navigation property values
func (r ApiUsersPlannerPlansTasksUpdateBucketTaskBoardFormatRequest) MicrosoftGraphPlannerBucketTaskBoardTaskFormat(microsoftGraphPlannerBucketTaskBoardTaskFormat MicrosoftGraphPlannerBucketTaskBoardTaskFormat) ApiUsersPlannerPlansTasksUpdateBucketTaskBoardFormatRequest {
	r.microsoftGraphPlannerBucketTaskBoardTaskFormat = &microsoftGraphPlannerBucketTaskBoardTaskFormat
	return r
}

func (r ApiUsersPlannerPlansTasksUpdateBucketTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersPlannerPlansTasksUpdateBucketTaskBoardFormatExecute(r)
}

/*
UsersPlannerPlansTasksUpdateBucketTaskBoardFormat Update the navigation property bucketTaskBoardFormat in users

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiUsersPlannerPlansTasksUpdateBucketTaskBoardFormatRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerPlansTasksUpdateBucketTaskBoardFormat(ctx _context.Context, userId string, plannerPlanId string, plannerTaskId string) ApiUsersPlannerPlansTasksUpdateBucketTaskBoardFormatRequest {
	return ApiUsersPlannerPlansTasksUpdateBucketTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *UsersPlannerUserApiService) UsersPlannerPlansTasksUpdateBucketTaskBoardFormatExecute(r ApiUsersPlannerPlansTasksUpdateBucketTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerPlansTasksUpdateBucketTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerBucketTaskBoardTaskFormat == nil {
		return nil, reportError("microsoftGraphPlannerBucketTaskBoardTaskFormat is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerBucketTaskBoardTaskFormat
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersPlannerPlansTasksUpdateDetailsRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerPlanId string
	plannerTaskId string
	microsoftGraphPlannerTaskDetails *MicrosoftGraphPlannerTaskDetails
}

// New navigation property values
func (r ApiUsersPlannerPlansTasksUpdateDetailsRequest) MicrosoftGraphPlannerTaskDetails(microsoftGraphPlannerTaskDetails MicrosoftGraphPlannerTaskDetails) ApiUsersPlannerPlansTasksUpdateDetailsRequest {
	r.microsoftGraphPlannerTaskDetails = &microsoftGraphPlannerTaskDetails
	return r
}

func (r ApiUsersPlannerPlansTasksUpdateDetailsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersPlannerPlansTasksUpdateDetailsExecute(r)
}

/*
UsersPlannerPlansTasksUpdateDetails Update the navigation property details in users

Read-only. Nullable. Additional details about the task.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiUsersPlannerPlansTasksUpdateDetailsRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerPlansTasksUpdateDetails(ctx _context.Context, userId string, plannerPlanId string, plannerTaskId string) ApiUsersPlannerPlansTasksUpdateDetailsRequest {
	return ApiUsersPlannerPlansTasksUpdateDetailsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *UsersPlannerUserApiService) UsersPlannerPlansTasksUpdateDetailsExecute(r ApiUsersPlannerPlansTasksUpdateDetailsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerPlansTasksUpdateDetails")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerTaskDetails == nil {
		return nil, reportError("microsoftGraphPlannerTaskDetails is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerTaskDetails
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersPlannerPlansTasksUpdateProgressTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerPlanId string
	plannerTaskId string
	microsoftGraphPlannerProgressTaskBoardTaskFormat *MicrosoftGraphPlannerProgressTaskBoardTaskFormat
}

// New navigation property values
func (r ApiUsersPlannerPlansTasksUpdateProgressTaskBoardFormatRequest) MicrosoftGraphPlannerProgressTaskBoardTaskFormat(microsoftGraphPlannerProgressTaskBoardTaskFormat MicrosoftGraphPlannerProgressTaskBoardTaskFormat) ApiUsersPlannerPlansTasksUpdateProgressTaskBoardFormatRequest {
	r.microsoftGraphPlannerProgressTaskBoardTaskFormat = &microsoftGraphPlannerProgressTaskBoardTaskFormat
	return r
}

func (r ApiUsersPlannerPlansTasksUpdateProgressTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersPlannerPlansTasksUpdateProgressTaskBoardFormatExecute(r)
}

/*
UsersPlannerPlansTasksUpdateProgressTaskBoardFormat Update the navigation property progressTaskBoardFormat in users

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by progress.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiUsersPlannerPlansTasksUpdateProgressTaskBoardFormatRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerPlansTasksUpdateProgressTaskBoardFormat(ctx _context.Context, userId string, plannerPlanId string, plannerTaskId string) ApiUsersPlannerPlansTasksUpdateProgressTaskBoardFormatRequest {
	return ApiUsersPlannerPlansTasksUpdateProgressTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *UsersPlannerUserApiService) UsersPlannerPlansTasksUpdateProgressTaskBoardFormatExecute(r ApiUsersPlannerPlansTasksUpdateProgressTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerPlansTasksUpdateProgressTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/progressTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerProgressTaskBoardTaskFormat == nil {
		return nil, reportError("microsoftGraphPlannerProgressTaskBoardTaskFormat is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerProgressTaskBoardTaskFormat
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersPlannerPlansUpdateBucketsRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerPlanId string
	plannerBucketId string
	microsoftGraphPlannerBucket *MicrosoftGraphPlannerBucket
}

// New navigation property values
func (r ApiUsersPlannerPlansUpdateBucketsRequest) MicrosoftGraphPlannerBucket(microsoftGraphPlannerBucket MicrosoftGraphPlannerBucket) ApiUsersPlannerPlansUpdateBucketsRequest {
	r.microsoftGraphPlannerBucket = &microsoftGraphPlannerBucket
	return r
}

func (r ApiUsersPlannerPlansUpdateBucketsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersPlannerPlansUpdateBucketsExecute(r)
}

/*
UsersPlannerPlansUpdateBuckets Update the navigation property buckets in users

Read-only. Nullable. Collection of buckets in the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @return ApiUsersPlannerPlansUpdateBucketsRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerPlansUpdateBuckets(ctx _context.Context, userId string, plannerPlanId string, plannerBucketId string) ApiUsersPlannerPlansUpdateBucketsRequest {
	return ApiUsersPlannerPlansUpdateBucketsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
	}
}

// Execute executes the request
func (a *UsersPlannerUserApiService) UsersPlannerPlansUpdateBucketsExecute(r ApiUsersPlannerPlansUpdateBucketsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerPlansUpdateBuckets")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerBucket == nil {
		return nil, reportError("microsoftGraphPlannerBucket is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerBucket
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersPlannerPlansUpdateDetailsRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerPlanId string
	microsoftGraphPlannerPlanDetails *MicrosoftGraphPlannerPlanDetails
}

// New navigation property values
func (r ApiUsersPlannerPlansUpdateDetailsRequest) MicrosoftGraphPlannerPlanDetails(microsoftGraphPlannerPlanDetails MicrosoftGraphPlannerPlanDetails) ApiUsersPlannerPlansUpdateDetailsRequest {
	r.microsoftGraphPlannerPlanDetails = &microsoftGraphPlannerPlanDetails
	return r
}

func (r ApiUsersPlannerPlansUpdateDetailsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersPlannerPlansUpdateDetailsExecute(r)
}

/*
UsersPlannerPlansUpdateDetails Update the navigation property details in users

Read-only. Nullable. Additional details about the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerPlanId key: id of plannerPlan
 @return ApiUsersPlannerPlansUpdateDetailsRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerPlansUpdateDetails(ctx _context.Context, userId string, plannerPlanId string) ApiUsersPlannerPlansUpdateDetailsRequest {
	return ApiUsersPlannerPlansUpdateDetailsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerPlanId: plannerPlanId,
	}
}

// Execute executes the request
func (a *UsersPlannerUserApiService) UsersPlannerPlansUpdateDetailsExecute(r ApiUsersPlannerPlansUpdateDetailsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerPlansUpdateDetails")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/plans/{plannerPlan-id}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerPlanDetails == nil {
		return nil, reportError("microsoftGraphPlannerPlanDetails is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerPlanDetails
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersPlannerPlansUpdateTasksRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerPlanId string
	plannerTaskId string
	microsoftGraphPlannerTask *MicrosoftGraphPlannerTask
}

// New navigation property values
func (r ApiUsersPlannerPlansUpdateTasksRequest) MicrosoftGraphPlannerTask(microsoftGraphPlannerTask MicrosoftGraphPlannerTask) ApiUsersPlannerPlansUpdateTasksRequest {
	r.microsoftGraphPlannerTask = &microsoftGraphPlannerTask
	return r
}

func (r ApiUsersPlannerPlansUpdateTasksRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersPlannerPlansUpdateTasksExecute(r)
}

/*
UsersPlannerPlansUpdateTasks Update the navigation property tasks in users

Read-only. Nullable. Collection of tasks in the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiUsersPlannerPlansUpdateTasksRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerPlansUpdateTasks(ctx _context.Context, userId string, plannerPlanId string, plannerTaskId string) ApiUsersPlannerPlansUpdateTasksRequest {
	return ApiUsersPlannerPlansUpdateTasksRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *UsersPlannerUserApiService) UsersPlannerPlansUpdateTasksExecute(r ApiUsersPlannerPlansUpdateTasksRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerPlansUpdateTasks")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerTask == nil {
		return nil, reportError("microsoftGraphPlannerTask is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerTask
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersPlannerTasksDeleteAssignedToTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiUsersPlannerTasksDeleteAssignedToTaskBoardFormatRequest) IfMatch(ifMatch string) ApiUsersPlannerTasksDeleteAssignedToTaskBoardFormatRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersPlannerTasksDeleteAssignedToTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersPlannerTasksDeleteAssignedToTaskBoardFormatExecute(r)
}

/*
UsersPlannerTasksDeleteAssignedToTaskBoardFormat Delete navigation property assignedToTaskBoardFormat for users

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by assignedTo.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerTaskId key: id of plannerTask
 @return ApiUsersPlannerTasksDeleteAssignedToTaskBoardFormatRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerTasksDeleteAssignedToTaskBoardFormat(ctx _context.Context, userId string, plannerTaskId string) ApiUsersPlannerTasksDeleteAssignedToTaskBoardFormatRequest {
	return ApiUsersPlannerTasksDeleteAssignedToTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *UsersPlannerUserApiService) UsersPlannerTasksDeleteAssignedToTaskBoardFormatExecute(r ApiUsersPlannerTasksDeleteAssignedToTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerTasksDeleteAssignedToTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/tasks/{plannerTask-id}/assignedToTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersPlannerTasksDeleteBucketTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiUsersPlannerTasksDeleteBucketTaskBoardFormatRequest) IfMatch(ifMatch string) ApiUsersPlannerTasksDeleteBucketTaskBoardFormatRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersPlannerTasksDeleteBucketTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersPlannerTasksDeleteBucketTaskBoardFormatExecute(r)
}

/*
UsersPlannerTasksDeleteBucketTaskBoardFormat Delete navigation property bucketTaskBoardFormat for users

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerTaskId key: id of plannerTask
 @return ApiUsersPlannerTasksDeleteBucketTaskBoardFormatRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerTasksDeleteBucketTaskBoardFormat(ctx _context.Context, userId string, plannerTaskId string) ApiUsersPlannerTasksDeleteBucketTaskBoardFormatRequest {
	return ApiUsersPlannerTasksDeleteBucketTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *UsersPlannerUserApiService) UsersPlannerTasksDeleteBucketTaskBoardFormatExecute(r ApiUsersPlannerTasksDeleteBucketTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerTasksDeleteBucketTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/tasks/{plannerTask-id}/bucketTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersPlannerTasksDeleteDetailsRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiUsersPlannerTasksDeleteDetailsRequest) IfMatch(ifMatch string) ApiUsersPlannerTasksDeleteDetailsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersPlannerTasksDeleteDetailsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersPlannerTasksDeleteDetailsExecute(r)
}

/*
UsersPlannerTasksDeleteDetails Delete navigation property details for users

Read-only. Nullable. Additional details about the task.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerTaskId key: id of plannerTask
 @return ApiUsersPlannerTasksDeleteDetailsRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerTasksDeleteDetails(ctx _context.Context, userId string, plannerTaskId string) ApiUsersPlannerTasksDeleteDetailsRequest {
	return ApiUsersPlannerTasksDeleteDetailsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *UsersPlannerUserApiService) UsersPlannerTasksDeleteDetailsExecute(r ApiUsersPlannerTasksDeleteDetailsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerTasksDeleteDetails")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/tasks/{plannerTask-id}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersPlannerTasksDeleteProgressTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiUsersPlannerTasksDeleteProgressTaskBoardFormatRequest) IfMatch(ifMatch string) ApiUsersPlannerTasksDeleteProgressTaskBoardFormatRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersPlannerTasksDeleteProgressTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersPlannerTasksDeleteProgressTaskBoardFormatExecute(r)
}

/*
UsersPlannerTasksDeleteProgressTaskBoardFormat Delete navigation property progressTaskBoardFormat for users

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by progress.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerTaskId key: id of plannerTask
 @return ApiUsersPlannerTasksDeleteProgressTaskBoardFormatRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerTasksDeleteProgressTaskBoardFormat(ctx _context.Context, userId string, plannerTaskId string) ApiUsersPlannerTasksDeleteProgressTaskBoardFormatRequest {
	return ApiUsersPlannerTasksDeleteProgressTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *UsersPlannerUserApiService) UsersPlannerTasksDeleteProgressTaskBoardFormatExecute(r ApiUsersPlannerTasksDeleteProgressTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerTasksDeleteProgressTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/tasks/{plannerTask-id}/progressTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersPlannerTasksGetAssignedToTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiUsersPlannerTasksGetAssignedToTaskBoardFormatRequest) Select_(select_ []string) ApiUsersPlannerTasksGetAssignedToTaskBoardFormatRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersPlannerTasksGetAssignedToTaskBoardFormatRequest) Expand(expand []string) ApiUsersPlannerTasksGetAssignedToTaskBoardFormatRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersPlannerTasksGetAssignedToTaskBoardFormatRequest) Execute() (MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat, *_nethttp.Response, error) {
	return r.ApiService.UsersPlannerTasksGetAssignedToTaskBoardFormatExecute(r)
}

/*
UsersPlannerTasksGetAssignedToTaskBoardFormat Get assignedToTaskBoardFormat from users

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by assignedTo.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerTaskId key: id of plannerTask
 @return ApiUsersPlannerTasksGetAssignedToTaskBoardFormatRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerTasksGetAssignedToTaskBoardFormat(ctx _context.Context, userId string, plannerTaskId string) ApiUsersPlannerTasksGetAssignedToTaskBoardFormatRequest {
	return ApiUsersPlannerTasksGetAssignedToTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat
func (a *UsersPlannerUserApiService) UsersPlannerTasksGetAssignedToTaskBoardFormatExecute(r ApiUsersPlannerTasksGetAssignedToTaskBoardFormatRequest) (MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerTasksGetAssignedToTaskBoardFormat")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/tasks/{plannerTask-id}/assignedToTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPlannerTasksGetBucketTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiUsersPlannerTasksGetBucketTaskBoardFormatRequest) Select_(select_ []string) ApiUsersPlannerTasksGetBucketTaskBoardFormatRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersPlannerTasksGetBucketTaskBoardFormatRequest) Expand(expand []string) ApiUsersPlannerTasksGetBucketTaskBoardFormatRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersPlannerTasksGetBucketTaskBoardFormatRequest) Execute() (MicrosoftGraphPlannerBucketTaskBoardTaskFormat, *_nethttp.Response, error) {
	return r.ApiService.UsersPlannerTasksGetBucketTaskBoardFormatExecute(r)
}

/*
UsersPlannerTasksGetBucketTaskBoardFormat Get bucketTaskBoardFormat from users

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerTaskId key: id of plannerTask
 @return ApiUsersPlannerTasksGetBucketTaskBoardFormatRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerTasksGetBucketTaskBoardFormat(ctx _context.Context, userId string, plannerTaskId string) ApiUsersPlannerTasksGetBucketTaskBoardFormatRequest {
	return ApiUsersPlannerTasksGetBucketTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerBucketTaskBoardTaskFormat
func (a *UsersPlannerUserApiService) UsersPlannerTasksGetBucketTaskBoardFormatExecute(r ApiUsersPlannerTasksGetBucketTaskBoardFormatRequest) (MicrosoftGraphPlannerBucketTaskBoardTaskFormat, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerBucketTaskBoardTaskFormat
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerTasksGetBucketTaskBoardFormat")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/tasks/{plannerTask-id}/bucketTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPlannerTasksGetDetailsRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiUsersPlannerTasksGetDetailsRequest) Select_(select_ []string) ApiUsersPlannerTasksGetDetailsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersPlannerTasksGetDetailsRequest) Expand(expand []string) ApiUsersPlannerTasksGetDetailsRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersPlannerTasksGetDetailsRequest) Execute() (MicrosoftGraphPlannerTaskDetails, *_nethttp.Response, error) {
	return r.ApiService.UsersPlannerTasksGetDetailsExecute(r)
}

/*
UsersPlannerTasksGetDetails Get details from users

Read-only. Nullable. Additional details about the task.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerTaskId key: id of plannerTask
 @return ApiUsersPlannerTasksGetDetailsRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerTasksGetDetails(ctx _context.Context, userId string, plannerTaskId string) ApiUsersPlannerTasksGetDetailsRequest {
	return ApiUsersPlannerTasksGetDetailsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerTaskDetails
func (a *UsersPlannerUserApiService) UsersPlannerTasksGetDetailsExecute(r ApiUsersPlannerTasksGetDetailsRequest) (MicrosoftGraphPlannerTaskDetails, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerTaskDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerTasksGetDetails")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/tasks/{plannerTask-id}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPlannerTasksGetProgressTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiUsersPlannerTasksGetProgressTaskBoardFormatRequest) Select_(select_ []string) ApiUsersPlannerTasksGetProgressTaskBoardFormatRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersPlannerTasksGetProgressTaskBoardFormatRequest) Expand(expand []string) ApiUsersPlannerTasksGetProgressTaskBoardFormatRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersPlannerTasksGetProgressTaskBoardFormatRequest) Execute() (MicrosoftGraphPlannerProgressTaskBoardTaskFormat, *_nethttp.Response, error) {
	return r.ApiService.UsersPlannerTasksGetProgressTaskBoardFormatExecute(r)
}

/*
UsersPlannerTasksGetProgressTaskBoardFormat Get progressTaskBoardFormat from users

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by progress.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerTaskId key: id of plannerTask
 @return ApiUsersPlannerTasksGetProgressTaskBoardFormatRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerTasksGetProgressTaskBoardFormat(ctx _context.Context, userId string, plannerTaskId string) ApiUsersPlannerTasksGetProgressTaskBoardFormatRequest {
	return ApiUsersPlannerTasksGetProgressTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerProgressTaskBoardTaskFormat
func (a *UsersPlannerUserApiService) UsersPlannerTasksGetProgressTaskBoardFormatExecute(r ApiUsersPlannerTasksGetProgressTaskBoardFormatRequest) (MicrosoftGraphPlannerProgressTaskBoardTaskFormat, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerProgressTaskBoardTaskFormat
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerTasksGetProgressTaskBoardFormat")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/tasks/{plannerTask-id}/progressTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPlannerTasksUpdateAssignedToTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerTaskId string
	microsoftGraphPlannerAssignedToTaskBoardTaskFormat *MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat
}

// New navigation property values
func (r ApiUsersPlannerTasksUpdateAssignedToTaskBoardFormatRequest) MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat(microsoftGraphPlannerAssignedToTaskBoardTaskFormat MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat) ApiUsersPlannerTasksUpdateAssignedToTaskBoardFormatRequest {
	r.microsoftGraphPlannerAssignedToTaskBoardTaskFormat = &microsoftGraphPlannerAssignedToTaskBoardTaskFormat
	return r
}

func (r ApiUsersPlannerTasksUpdateAssignedToTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersPlannerTasksUpdateAssignedToTaskBoardFormatExecute(r)
}

/*
UsersPlannerTasksUpdateAssignedToTaskBoardFormat Update the navigation property assignedToTaskBoardFormat in users

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by assignedTo.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerTaskId key: id of plannerTask
 @return ApiUsersPlannerTasksUpdateAssignedToTaskBoardFormatRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerTasksUpdateAssignedToTaskBoardFormat(ctx _context.Context, userId string, plannerTaskId string) ApiUsersPlannerTasksUpdateAssignedToTaskBoardFormatRequest {
	return ApiUsersPlannerTasksUpdateAssignedToTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *UsersPlannerUserApiService) UsersPlannerTasksUpdateAssignedToTaskBoardFormatExecute(r ApiUsersPlannerTasksUpdateAssignedToTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerTasksUpdateAssignedToTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/tasks/{plannerTask-id}/assignedToTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerAssignedToTaskBoardTaskFormat == nil {
		return nil, reportError("microsoftGraphPlannerAssignedToTaskBoardTaskFormat is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerAssignedToTaskBoardTaskFormat
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersPlannerTasksUpdateBucketTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerTaskId string
	microsoftGraphPlannerBucketTaskBoardTaskFormat *MicrosoftGraphPlannerBucketTaskBoardTaskFormat
}

// New navigation property values
func (r ApiUsersPlannerTasksUpdateBucketTaskBoardFormatRequest) MicrosoftGraphPlannerBucketTaskBoardTaskFormat(microsoftGraphPlannerBucketTaskBoardTaskFormat MicrosoftGraphPlannerBucketTaskBoardTaskFormat) ApiUsersPlannerTasksUpdateBucketTaskBoardFormatRequest {
	r.microsoftGraphPlannerBucketTaskBoardTaskFormat = &microsoftGraphPlannerBucketTaskBoardTaskFormat
	return r
}

func (r ApiUsersPlannerTasksUpdateBucketTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersPlannerTasksUpdateBucketTaskBoardFormatExecute(r)
}

/*
UsersPlannerTasksUpdateBucketTaskBoardFormat Update the navigation property bucketTaskBoardFormat in users

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerTaskId key: id of plannerTask
 @return ApiUsersPlannerTasksUpdateBucketTaskBoardFormatRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerTasksUpdateBucketTaskBoardFormat(ctx _context.Context, userId string, plannerTaskId string) ApiUsersPlannerTasksUpdateBucketTaskBoardFormatRequest {
	return ApiUsersPlannerTasksUpdateBucketTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *UsersPlannerUserApiService) UsersPlannerTasksUpdateBucketTaskBoardFormatExecute(r ApiUsersPlannerTasksUpdateBucketTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerTasksUpdateBucketTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/tasks/{plannerTask-id}/bucketTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerBucketTaskBoardTaskFormat == nil {
		return nil, reportError("microsoftGraphPlannerBucketTaskBoardTaskFormat is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerBucketTaskBoardTaskFormat
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersPlannerTasksUpdateDetailsRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerTaskId string
	microsoftGraphPlannerTaskDetails *MicrosoftGraphPlannerTaskDetails
}

// New navigation property values
func (r ApiUsersPlannerTasksUpdateDetailsRequest) MicrosoftGraphPlannerTaskDetails(microsoftGraphPlannerTaskDetails MicrosoftGraphPlannerTaskDetails) ApiUsersPlannerTasksUpdateDetailsRequest {
	r.microsoftGraphPlannerTaskDetails = &microsoftGraphPlannerTaskDetails
	return r
}

func (r ApiUsersPlannerTasksUpdateDetailsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersPlannerTasksUpdateDetailsExecute(r)
}

/*
UsersPlannerTasksUpdateDetails Update the navigation property details in users

Read-only. Nullable. Additional details about the task.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerTaskId key: id of plannerTask
 @return ApiUsersPlannerTasksUpdateDetailsRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerTasksUpdateDetails(ctx _context.Context, userId string, plannerTaskId string) ApiUsersPlannerTasksUpdateDetailsRequest {
	return ApiUsersPlannerTasksUpdateDetailsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *UsersPlannerUserApiService) UsersPlannerTasksUpdateDetailsExecute(r ApiUsersPlannerTasksUpdateDetailsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerTasksUpdateDetails")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/tasks/{plannerTask-id}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerTaskDetails == nil {
		return nil, reportError("microsoftGraphPlannerTaskDetails is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerTaskDetails
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersPlannerTasksUpdateProgressTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerTaskId string
	microsoftGraphPlannerProgressTaskBoardTaskFormat *MicrosoftGraphPlannerProgressTaskBoardTaskFormat
}

// New navigation property values
func (r ApiUsersPlannerTasksUpdateProgressTaskBoardFormatRequest) MicrosoftGraphPlannerProgressTaskBoardTaskFormat(microsoftGraphPlannerProgressTaskBoardTaskFormat MicrosoftGraphPlannerProgressTaskBoardTaskFormat) ApiUsersPlannerTasksUpdateProgressTaskBoardFormatRequest {
	r.microsoftGraphPlannerProgressTaskBoardTaskFormat = &microsoftGraphPlannerProgressTaskBoardTaskFormat
	return r
}

func (r ApiUsersPlannerTasksUpdateProgressTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersPlannerTasksUpdateProgressTaskBoardFormatExecute(r)
}

/*
UsersPlannerTasksUpdateProgressTaskBoardFormat Update the navigation property progressTaskBoardFormat in users

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by progress.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerTaskId key: id of plannerTask
 @return ApiUsersPlannerTasksUpdateProgressTaskBoardFormatRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerTasksUpdateProgressTaskBoardFormat(ctx _context.Context, userId string, plannerTaskId string) ApiUsersPlannerTasksUpdateProgressTaskBoardFormatRequest {
	return ApiUsersPlannerTasksUpdateProgressTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *UsersPlannerUserApiService) UsersPlannerTasksUpdateProgressTaskBoardFormatExecute(r ApiUsersPlannerTasksUpdateProgressTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerTasksUpdateProgressTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/tasks/{plannerTask-id}/progressTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerProgressTaskBoardTaskFormat == nil {
		return nil, reportError("microsoftGraphPlannerProgressTaskBoardTaskFormat is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerProgressTaskBoardTaskFormat
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersPlannerUpdatePlansRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerPlanId string
	microsoftGraphPlannerPlan *MicrosoftGraphPlannerPlan
}

// New navigation property values
func (r ApiUsersPlannerUpdatePlansRequest) MicrosoftGraphPlannerPlan(microsoftGraphPlannerPlan MicrosoftGraphPlannerPlan) ApiUsersPlannerUpdatePlansRequest {
	r.microsoftGraphPlannerPlan = &microsoftGraphPlannerPlan
	return r
}

func (r ApiUsersPlannerUpdatePlansRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersPlannerUpdatePlansExecute(r)
}

/*
UsersPlannerUpdatePlans Update the navigation property plans in users

Read-only. Nullable. Returns the plannerTasks assigned to the user.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerPlanId key: id of plannerPlan
 @return ApiUsersPlannerUpdatePlansRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerUpdatePlans(ctx _context.Context, userId string, plannerPlanId string) ApiUsersPlannerUpdatePlansRequest {
	return ApiUsersPlannerUpdatePlansRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerPlanId: plannerPlanId,
	}
}

// Execute executes the request
func (a *UsersPlannerUserApiService) UsersPlannerUpdatePlansExecute(r ApiUsersPlannerUpdatePlansRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerUpdatePlans")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/plans/{plannerPlan-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerPlan == nil {
		return nil, reportError("microsoftGraphPlannerPlan is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerPlan
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersPlannerUpdateTasksRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	plannerTaskId string
	microsoftGraphPlannerTask *MicrosoftGraphPlannerTask
}

// New navigation property values
func (r ApiUsersPlannerUpdateTasksRequest) MicrosoftGraphPlannerTask(microsoftGraphPlannerTask MicrosoftGraphPlannerTask) ApiUsersPlannerUpdateTasksRequest {
	r.microsoftGraphPlannerTask = &microsoftGraphPlannerTask
	return r
}

func (r ApiUsersPlannerUpdateTasksRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersPlannerUpdateTasksExecute(r)
}

/*
UsersPlannerUpdateTasks Update the navigation property tasks in users

Read-only. Nullable. Returns the plannerPlans shared with the user.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param plannerTaskId key: id of plannerTask
 @return ApiUsersPlannerUpdateTasksRequest
*/
func (a *UsersPlannerUserApiService) UsersPlannerUpdateTasks(ctx _context.Context, userId string, plannerTaskId string) ApiUsersPlannerUpdateTasksRequest {
	return ApiUsersPlannerUpdateTasksRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *UsersPlannerUserApiService) UsersPlannerUpdateTasksExecute(r ApiUsersPlannerUpdateTasksRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersPlannerUpdateTasks")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner/tasks/{plannerTask-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerTask == nil {
		return nil, reportError("microsoftGraphPlannerTask is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerTask
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUpdatePlannerRequest struct {
	ctx _context.Context
	ApiService *UsersPlannerUserApiService
	userId string
	microsoftGraphPlannerUser *MicrosoftGraphPlannerUser
}

// New navigation property values
func (r ApiUsersUpdatePlannerRequest) MicrosoftGraphPlannerUser(microsoftGraphPlannerUser MicrosoftGraphPlannerUser) ApiUsersUpdatePlannerRequest {
	r.microsoftGraphPlannerUser = &microsoftGraphPlannerUser
	return r
}

func (r ApiUsersUpdatePlannerRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUpdatePlannerExecute(r)
}

/*
UsersUpdatePlanner Update the navigation property planner in users

Entry-point to the Planner resource that might exist for a user. Read-only.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @return ApiUsersUpdatePlannerRequest
*/
func (a *UsersPlannerUserApiService) UsersUpdatePlanner(ctx _context.Context, userId string) ApiUsersUpdatePlannerRequest {
	return ApiUsersUpdatePlannerRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
func (a *UsersPlannerUserApiService) UsersUpdatePlannerExecute(r ApiUsersUpdatePlannerRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersPlannerUserApiService.UsersUpdatePlanner")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/planner"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerUser == nil {
		return nil, reportError("microsoftGraphPlannerUser is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerUser
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
