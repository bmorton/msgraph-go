/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"os"
)

// Linger please
var (
	_ _context.Context
)

// DriveListApiService DriveListApi service
type DriveListApiService service

type ApiDriveDeleteListRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	ifMatch *string
}

// ETag
func (r ApiDriveDeleteListRequest) IfMatch(ifMatch string) ApiDriveDeleteListRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDriveDeleteListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DriveDeleteListExecute(r)
}

/*
DriveDeleteList Delete navigation property list for drive

For drives in SharePoint, the underlying document library list. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDriveDeleteListRequest
*/
func (a *DriveListApiService) DriveDeleteList(ctx _context.Context) ApiDriveDeleteListRequest {
	return ApiDriveDeleteListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DriveListApiService) DriveDeleteListExecute(r ApiDriveDeleteListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveDeleteList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDriveGetListRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDriveGetListRequest) Select_(select_ []string) ApiDriveGetListRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDriveGetListRequest) Expand(expand []string) ApiDriveGetListRequest {
	r.expand = &expand
	return r
}

func (r ApiDriveGetListRequest) Execute() (MicrosoftGraphList, *_nethttp.Response, error) {
	return r.ApiService.DriveGetListExecute(r)
}

/*
DriveGetList Get list from drive

For drives in SharePoint, the underlying document library list. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDriveGetListRequest
*/
func (a *DriveListApiService) DriveGetList(ctx _context.Context) ApiDriveGetListRequest {
	return ApiDriveGetListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphList
func (a *DriveListApiService) DriveGetListExecute(r ApiDriveGetListRequest) (MicrosoftGraphList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveGetList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDriveListColumnsDeleteRefSourceColumnRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	columnDefinitionId string
	ifMatch *string
}

// ETag
func (r ApiDriveListColumnsDeleteRefSourceColumnRequest) IfMatch(ifMatch string) ApiDriveListColumnsDeleteRefSourceColumnRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDriveListColumnsDeleteRefSourceColumnRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DriveListColumnsDeleteRefSourceColumnExecute(r)
}

/*
DriveListColumnsDeleteRefSourceColumn Delete ref of navigation property sourceColumn for drive

The source column for the content type column.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param columnDefinitionId key: id of columnDefinition
 @return ApiDriveListColumnsDeleteRefSourceColumnRequest
*/
func (a *DriveListApiService) DriveListColumnsDeleteRefSourceColumn(ctx _context.Context, columnDefinitionId string) ApiDriveListColumnsDeleteRefSourceColumnRequest {
	return ApiDriveListColumnsDeleteRefSourceColumnRequest{
		ApiService: a,
		ctx: ctx,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
func (a *DriveListApiService) DriveListColumnsDeleteRefSourceColumnExecute(r ApiDriveListColumnsDeleteRefSourceColumnRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListColumnsDeleteRefSourceColumn")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/columns/{columnDefinition-id}/sourceColumn/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDriveListColumnsGetRefSourceColumnRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	columnDefinitionId string
}


func (r ApiDriveListColumnsGetRefSourceColumnRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.DriveListColumnsGetRefSourceColumnExecute(r)
}

/*
DriveListColumnsGetRefSourceColumn Get ref of sourceColumn from drive

The source column for the content type column.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param columnDefinitionId key: id of columnDefinition
 @return ApiDriveListColumnsGetRefSourceColumnRequest
*/
func (a *DriveListApiService) DriveListColumnsGetRefSourceColumn(ctx _context.Context, columnDefinitionId string) ApiDriveListColumnsGetRefSourceColumnRequest {
	return ApiDriveListColumnsGetRefSourceColumnRequest{
		ApiService: a,
		ctx: ctx,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
//  @return string
func (a *DriveListApiService) DriveListColumnsGetRefSourceColumnExecute(r ApiDriveListColumnsGetRefSourceColumnRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListColumnsGetRefSourceColumn")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/columns/{columnDefinition-id}/sourceColumn/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDriveListColumnsGetSourceColumnRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	columnDefinitionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDriveListColumnsGetSourceColumnRequest) Select_(select_ []string) ApiDriveListColumnsGetSourceColumnRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDriveListColumnsGetSourceColumnRequest) Expand(expand []string) ApiDriveListColumnsGetSourceColumnRequest {
	r.expand = &expand
	return r
}

func (r ApiDriveListColumnsGetSourceColumnRequest) Execute() (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.DriveListColumnsGetSourceColumnExecute(r)
}

/*
DriveListColumnsGetSourceColumn Get sourceColumn from drive

The source column for the content type column.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param columnDefinitionId key: id of columnDefinition
 @return ApiDriveListColumnsGetSourceColumnRequest
*/
func (a *DriveListApiService) DriveListColumnsGetSourceColumn(ctx _context.Context, columnDefinitionId string) ApiDriveListColumnsGetSourceColumnRequest {
	return ApiDriveListColumnsGetSourceColumnRequest{
		ApiService: a,
		ctx: ctx,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphColumnDefinition
func (a *DriveListApiService) DriveListColumnsGetSourceColumnExecute(r ApiDriveListColumnsGetSourceColumnRequest) (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListColumnsGetSourceColumn")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/columns/{columnDefinition-id}/sourceColumn"
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDriveListColumnsUpdateRefSourceColumnRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	columnDefinitionId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiDriveListColumnsUpdateRefSourceColumnRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiDriveListColumnsUpdateRefSourceColumnRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiDriveListColumnsUpdateRefSourceColumnRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DriveListColumnsUpdateRefSourceColumnExecute(r)
}

/*
DriveListColumnsUpdateRefSourceColumn Update the ref of navigation property sourceColumn in drive

The source column for the content type column.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param columnDefinitionId key: id of columnDefinition
 @return ApiDriveListColumnsUpdateRefSourceColumnRequest
*/
func (a *DriveListApiService) DriveListColumnsUpdateRefSourceColumn(ctx _context.Context, columnDefinitionId string) ApiDriveListColumnsUpdateRefSourceColumnRequest {
	return ApiDriveListColumnsUpdateRefSourceColumnRequest{
		ApiService: a,
		ctx: ctx,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
func (a *DriveListApiService) DriveListColumnsUpdateRefSourceColumnExecute(r ApiDriveListColumnsUpdateRefSourceColumnRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListColumnsUpdateRefSourceColumn")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/columns/{columnDefinition-id}/sourceColumn/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDriveListContentTypesColumnsDeleteRefSourceColumnRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	contentTypeId string
	columnDefinitionId string
	ifMatch *string
}

// ETag
func (r ApiDriveListContentTypesColumnsDeleteRefSourceColumnRequest) IfMatch(ifMatch string) ApiDriveListContentTypesColumnsDeleteRefSourceColumnRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDriveListContentTypesColumnsDeleteRefSourceColumnRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DriveListContentTypesColumnsDeleteRefSourceColumnExecute(r)
}

/*
DriveListContentTypesColumnsDeleteRefSourceColumn Delete ref of navigation property sourceColumn for drive

The source column for the content type column.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentTypeId key: id of contentType
 @param columnDefinitionId key: id of columnDefinition
 @return ApiDriveListContentTypesColumnsDeleteRefSourceColumnRequest
*/
func (a *DriveListApiService) DriveListContentTypesColumnsDeleteRefSourceColumn(ctx _context.Context, contentTypeId string, columnDefinitionId string) ApiDriveListContentTypesColumnsDeleteRefSourceColumnRequest {
	return ApiDriveListContentTypesColumnsDeleteRefSourceColumnRequest{
		ApiService: a,
		ctx: ctx,
		contentTypeId: contentTypeId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
func (a *DriveListApiService) DriveListContentTypesColumnsDeleteRefSourceColumnExecute(r ApiDriveListContentTypesColumnsDeleteRefSourceColumnRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListContentTypesColumnsDeleteRefSourceColumn")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/contentTypes/{contentType-id}/columns/{columnDefinition-id}/sourceColumn/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDriveListContentTypesColumnsGetRefSourceColumnRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	contentTypeId string
	columnDefinitionId string
}


func (r ApiDriveListContentTypesColumnsGetRefSourceColumnRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.DriveListContentTypesColumnsGetRefSourceColumnExecute(r)
}

/*
DriveListContentTypesColumnsGetRefSourceColumn Get ref of sourceColumn from drive

The source column for the content type column.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentTypeId key: id of contentType
 @param columnDefinitionId key: id of columnDefinition
 @return ApiDriveListContentTypesColumnsGetRefSourceColumnRequest
*/
func (a *DriveListApiService) DriveListContentTypesColumnsGetRefSourceColumn(ctx _context.Context, contentTypeId string, columnDefinitionId string) ApiDriveListContentTypesColumnsGetRefSourceColumnRequest {
	return ApiDriveListContentTypesColumnsGetRefSourceColumnRequest{
		ApiService: a,
		ctx: ctx,
		contentTypeId: contentTypeId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
//  @return string
func (a *DriveListApiService) DriveListContentTypesColumnsGetRefSourceColumnExecute(r ApiDriveListContentTypesColumnsGetRefSourceColumnRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListContentTypesColumnsGetRefSourceColumn")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/contentTypes/{contentType-id}/columns/{columnDefinition-id}/sourceColumn/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDriveListContentTypesColumnsGetSourceColumnRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	contentTypeId string
	columnDefinitionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDriveListContentTypesColumnsGetSourceColumnRequest) Select_(select_ []string) ApiDriveListContentTypesColumnsGetSourceColumnRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDriveListContentTypesColumnsGetSourceColumnRequest) Expand(expand []string) ApiDriveListContentTypesColumnsGetSourceColumnRequest {
	r.expand = &expand
	return r
}

func (r ApiDriveListContentTypesColumnsGetSourceColumnRequest) Execute() (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.DriveListContentTypesColumnsGetSourceColumnExecute(r)
}

/*
DriveListContentTypesColumnsGetSourceColumn Get sourceColumn from drive

The source column for the content type column.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentTypeId key: id of contentType
 @param columnDefinitionId key: id of columnDefinition
 @return ApiDriveListContentTypesColumnsGetSourceColumnRequest
*/
func (a *DriveListApiService) DriveListContentTypesColumnsGetSourceColumn(ctx _context.Context, contentTypeId string, columnDefinitionId string) ApiDriveListContentTypesColumnsGetSourceColumnRequest {
	return ApiDriveListContentTypesColumnsGetSourceColumnRequest{
		ApiService: a,
		ctx: ctx,
		contentTypeId: contentTypeId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphColumnDefinition
func (a *DriveListApiService) DriveListContentTypesColumnsGetSourceColumnExecute(r ApiDriveListContentTypesColumnsGetSourceColumnRequest) (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListContentTypesColumnsGetSourceColumn")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/contentTypes/{contentType-id}/columns/{columnDefinition-id}/sourceColumn"
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDriveListContentTypesColumnsUpdateRefSourceColumnRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	contentTypeId string
	columnDefinitionId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiDriveListContentTypesColumnsUpdateRefSourceColumnRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiDriveListContentTypesColumnsUpdateRefSourceColumnRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiDriveListContentTypesColumnsUpdateRefSourceColumnRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DriveListContentTypesColumnsUpdateRefSourceColumnExecute(r)
}

/*
DriveListContentTypesColumnsUpdateRefSourceColumn Update the ref of navigation property sourceColumn in drive

The source column for the content type column.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentTypeId key: id of contentType
 @param columnDefinitionId key: id of columnDefinition
 @return ApiDriveListContentTypesColumnsUpdateRefSourceColumnRequest
*/
func (a *DriveListApiService) DriveListContentTypesColumnsUpdateRefSourceColumn(ctx _context.Context, contentTypeId string, columnDefinitionId string) ApiDriveListContentTypesColumnsUpdateRefSourceColumnRequest {
	return ApiDriveListContentTypesColumnsUpdateRefSourceColumnRequest{
		ApiService: a,
		ctx: ctx,
		contentTypeId: contentTypeId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
func (a *DriveListApiService) DriveListContentTypesColumnsUpdateRefSourceColumnExecute(r ApiDriveListContentTypesColumnsUpdateRefSourceColumnRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListContentTypesColumnsUpdateRefSourceColumn")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/contentTypes/{contentType-id}/columns/{columnDefinition-id}/sourceColumn/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDriveListContentTypesCreateColumnLinksRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	contentTypeId string
	microsoftGraphColumnLink *MicrosoftGraphColumnLink
}

// New navigation property
func (r ApiDriveListContentTypesCreateColumnLinksRequest) MicrosoftGraphColumnLink(microsoftGraphColumnLink MicrosoftGraphColumnLink) ApiDriveListContentTypesCreateColumnLinksRequest {
	r.microsoftGraphColumnLink = &microsoftGraphColumnLink
	return r
}

func (r ApiDriveListContentTypesCreateColumnLinksRequest) Execute() (MicrosoftGraphColumnLink, *_nethttp.Response, error) {
	return r.ApiService.DriveListContentTypesCreateColumnLinksExecute(r)
}

/*
DriveListContentTypesCreateColumnLinks Create new navigation property to columnLinks for drive

The collection of columns that are required by this content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentTypeId key: id of contentType
 @return ApiDriveListContentTypesCreateColumnLinksRequest
*/
func (a *DriveListApiService) DriveListContentTypesCreateColumnLinks(ctx _context.Context, contentTypeId string) ApiDriveListContentTypesCreateColumnLinksRequest {
	return ApiDriveListContentTypesCreateColumnLinksRequest{
		ApiService: a,
		ctx: ctx,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphColumnLink
func (a *DriveListApiService) DriveListContentTypesCreateColumnLinksExecute(r ApiDriveListContentTypesCreateColumnLinksRequest) (MicrosoftGraphColumnLink, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphColumnLink
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListContentTypesCreateColumnLinks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/contentTypes/{contentType-id}/columnLinks"
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphColumnLink == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphColumnLink is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphColumnLink
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDriveListContentTypesCreateColumnsRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	contentTypeId string
	microsoftGraphColumnDefinition *MicrosoftGraphColumnDefinition
}

// New navigation property
func (r ApiDriveListContentTypesCreateColumnsRequest) MicrosoftGraphColumnDefinition(microsoftGraphColumnDefinition MicrosoftGraphColumnDefinition) ApiDriveListContentTypesCreateColumnsRequest {
	r.microsoftGraphColumnDefinition = &microsoftGraphColumnDefinition
	return r
}

func (r ApiDriveListContentTypesCreateColumnsRequest) Execute() (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.DriveListContentTypesCreateColumnsExecute(r)
}

/*
DriveListContentTypesCreateColumns Create new navigation property to columns for drive

The collection of column definitions for this contentType.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentTypeId key: id of contentType
 @return ApiDriveListContentTypesCreateColumnsRequest
*/
func (a *DriveListApiService) DriveListContentTypesCreateColumns(ctx _context.Context, contentTypeId string) ApiDriveListContentTypesCreateColumnsRequest {
	return ApiDriveListContentTypesCreateColumnsRequest{
		ApiService: a,
		ctx: ctx,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphColumnDefinition
func (a *DriveListApiService) DriveListContentTypesCreateColumnsExecute(r ApiDriveListContentTypesCreateColumnsRequest) (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListContentTypesCreateColumns")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/contentTypes/{contentType-id}/columns"
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphColumnDefinition == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphColumnDefinition is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphColumnDefinition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDriveListContentTypesCreateRefBaseTypesRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	contentTypeId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref value
func (r ApiDriveListContentTypesCreateRefBaseTypesRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiDriveListContentTypesCreateRefBaseTypesRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiDriveListContentTypesCreateRefBaseTypesRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.DriveListContentTypesCreateRefBaseTypesExecute(r)
}

/*
DriveListContentTypesCreateRefBaseTypes Create new navigation property ref to baseTypes for drive

The collection of content types that are ancestors of this content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentTypeId key: id of contentType
 @return ApiDriveListContentTypesCreateRefBaseTypesRequest
*/
func (a *DriveListApiService) DriveListContentTypesCreateRefBaseTypes(ctx _context.Context, contentTypeId string) ApiDriveListContentTypesCreateRefBaseTypesRequest {
	return ApiDriveListContentTypesCreateRefBaseTypesRequest{
		ApiService: a,
		ctx: ctx,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DriveListApiService) DriveListContentTypesCreateRefBaseTypesExecute(r ApiDriveListContentTypesCreateRefBaseTypesRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListContentTypesCreateRefBaseTypes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/contentTypes/{contentType-id}/baseTypes/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDriveListContentTypesCreateRefColumnPositionsRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	contentTypeId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref value
func (r ApiDriveListContentTypesCreateRefColumnPositionsRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiDriveListContentTypesCreateRefColumnPositionsRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiDriveListContentTypesCreateRefColumnPositionsRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.DriveListContentTypesCreateRefColumnPositionsExecute(r)
}

/*
DriveListContentTypesCreateRefColumnPositions Create new navigation property ref to columnPositions for drive

Column order information in a content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentTypeId key: id of contentType
 @return ApiDriveListContentTypesCreateRefColumnPositionsRequest
*/
func (a *DriveListApiService) DriveListContentTypesCreateRefColumnPositions(ctx _context.Context, contentTypeId string) ApiDriveListContentTypesCreateRefColumnPositionsRequest {
	return ApiDriveListContentTypesCreateRefColumnPositionsRequest{
		ApiService: a,
		ctx: ctx,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DriveListApiService) DriveListContentTypesCreateRefColumnPositionsExecute(r ApiDriveListContentTypesCreateRefColumnPositionsRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListContentTypesCreateRefColumnPositions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/contentTypes/{contentType-id}/columnPositions/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDriveListContentTypesDeleteColumnLinksRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	contentTypeId string
	columnLinkId string
	ifMatch *string
}

// ETag
func (r ApiDriveListContentTypesDeleteColumnLinksRequest) IfMatch(ifMatch string) ApiDriveListContentTypesDeleteColumnLinksRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDriveListContentTypesDeleteColumnLinksRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DriveListContentTypesDeleteColumnLinksExecute(r)
}

/*
DriveListContentTypesDeleteColumnLinks Delete navigation property columnLinks for drive

The collection of columns that are required by this content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentTypeId key: id of contentType
 @param columnLinkId key: id of columnLink
 @return ApiDriveListContentTypesDeleteColumnLinksRequest
*/
func (a *DriveListApiService) DriveListContentTypesDeleteColumnLinks(ctx _context.Context, contentTypeId string, columnLinkId string) ApiDriveListContentTypesDeleteColumnLinksRequest {
	return ApiDriveListContentTypesDeleteColumnLinksRequest{
		ApiService: a,
		ctx: ctx,
		contentTypeId: contentTypeId,
		columnLinkId: columnLinkId,
	}
}

// Execute executes the request
func (a *DriveListApiService) DriveListContentTypesDeleteColumnLinksExecute(r ApiDriveListContentTypesDeleteColumnLinksRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListContentTypesDeleteColumnLinks")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/contentTypes/{contentType-id}/columnLinks/{columnLink-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnLink-id"+"}", _neturl.PathEscape(parameterToString(r.columnLinkId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDriveListContentTypesDeleteColumnsRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	contentTypeId string
	columnDefinitionId string
	ifMatch *string
}

// ETag
func (r ApiDriveListContentTypesDeleteColumnsRequest) IfMatch(ifMatch string) ApiDriveListContentTypesDeleteColumnsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDriveListContentTypesDeleteColumnsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DriveListContentTypesDeleteColumnsExecute(r)
}

/*
DriveListContentTypesDeleteColumns Delete navigation property columns for drive

The collection of column definitions for this contentType.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentTypeId key: id of contentType
 @param columnDefinitionId key: id of columnDefinition
 @return ApiDriveListContentTypesDeleteColumnsRequest
*/
func (a *DriveListApiService) DriveListContentTypesDeleteColumns(ctx _context.Context, contentTypeId string, columnDefinitionId string) ApiDriveListContentTypesDeleteColumnsRequest {
	return ApiDriveListContentTypesDeleteColumnsRequest{
		ApiService: a,
		ctx: ctx,
		contentTypeId: contentTypeId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
func (a *DriveListApiService) DriveListContentTypesDeleteColumnsExecute(r ApiDriveListContentTypesDeleteColumnsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListContentTypesDeleteColumns")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/contentTypes/{contentType-id}/columns/{columnDefinition-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDriveListContentTypesDeleteRefBaseRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	contentTypeId string
	ifMatch *string
}

// ETag
func (r ApiDriveListContentTypesDeleteRefBaseRequest) IfMatch(ifMatch string) ApiDriveListContentTypesDeleteRefBaseRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDriveListContentTypesDeleteRefBaseRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DriveListContentTypesDeleteRefBaseExecute(r)
}

/*
DriveListContentTypesDeleteRefBase Delete ref of navigation property base for drive

Parent contentType from which this content type is derived.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentTypeId key: id of contentType
 @return ApiDriveListContentTypesDeleteRefBaseRequest
*/
func (a *DriveListApiService) DriveListContentTypesDeleteRefBase(ctx _context.Context, contentTypeId string) ApiDriveListContentTypesDeleteRefBaseRequest {
	return ApiDriveListContentTypesDeleteRefBaseRequest{
		ApiService: a,
		ctx: ctx,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
func (a *DriveListApiService) DriveListContentTypesDeleteRefBaseExecute(r ApiDriveListContentTypesDeleteRefBaseRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListContentTypesDeleteRefBase")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/contentTypes/{contentType-id}/base/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDriveListContentTypesGetBaseRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	contentTypeId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDriveListContentTypesGetBaseRequest) Select_(select_ []string) ApiDriveListContentTypesGetBaseRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDriveListContentTypesGetBaseRequest) Expand(expand []string) ApiDriveListContentTypesGetBaseRequest {
	r.expand = &expand
	return r
}

func (r ApiDriveListContentTypesGetBaseRequest) Execute() (MicrosoftGraphContentType, *_nethttp.Response, error) {
	return r.ApiService.DriveListContentTypesGetBaseExecute(r)
}

/*
DriveListContentTypesGetBase Get base from drive

Parent contentType from which this content type is derived.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentTypeId key: id of contentType
 @return ApiDriveListContentTypesGetBaseRequest
*/
func (a *DriveListApiService) DriveListContentTypesGetBase(ctx _context.Context, contentTypeId string) ApiDriveListContentTypesGetBaseRequest {
	return ApiDriveListContentTypesGetBaseRequest{
		ApiService: a,
		ctx: ctx,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphContentType
func (a *DriveListApiService) DriveListContentTypesGetBaseExecute(r ApiDriveListContentTypesGetBaseRequest) (MicrosoftGraphContentType, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphContentType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListContentTypesGetBase")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/contentTypes/{contentType-id}/base"
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDriveListContentTypesGetColumnLinksRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	contentTypeId string
	columnLinkId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDriveListContentTypesGetColumnLinksRequest) Select_(select_ []string) ApiDriveListContentTypesGetColumnLinksRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDriveListContentTypesGetColumnLinksRequest) Expand(expand []string) ApiDriveListContentTypesGetColumnLinksRequest {
	r.expand = &expand
	return r
}

func (r ApiDriveListContentTypesGetColumnLinksRequest) Execute() (MicrosoftGraphColumnLink, *_nethttp.Response, error) {
	return r.ApiService.DriveListContentTypesGetColumnLinksExecute(r)
}

/*
DriveListContentTypesGetColumnLinks Get columnLinks from drive

The collection of columns that are required by this content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentTypeId key: id of contentType
 @param columnLinkId key: id of columnLink
 @return ApiDriveListContentTypesGetColumnLinksRequest
*/
func (a *DriveListApiService) DriveListContentTypesGetColumnLinks(ctx _context.Context, contentTypeId string, columnLinkId string) ApiDriveListContentTypesGetColumnLinksRequest {
	return ApiDriveListContentTypesGetColumnLinksRequest{
		ApiService: a,
		ctx: ctx,
		contentTypeId: contentTypeId,
		columnLinkId: columnLinkId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphColumnLink
func (a *DriveListApiService) DriveListContentTypesGetColumnLinksExecute(r ApiDriveListContentTypesGetColumnLinksRequest) (MicrosoftGraphColumnLink, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphColumnLink
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListContentTypesGetColumnLinks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/contentTypes/{contentType-id}/columnLinks/{columnLink-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnLink-id"+"}", _neturl.PathEscape(parameterToString(r.columnLinkId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDriveListContentTypesGetColumnsRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	contentTypeId string
	columnDefinitionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDriveListContentTypesGetColumnsRequest) Select_(select_ []string) ApiDriveListContentTypesGetColumnsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDriveListContentTypesGetColumnsRequest) Expand(expand []string) ApiDriveListContentTypesGetColumnsRequest {
	r.expand = &expand
	return r
}

func (r ApiDriveListContentTypesGetColumnsRequest) Execute() (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.DriveListContentTypesGetColumnsExecute(r)
}

/*
DriveListContentTypesGetColumns Get columns from drive

The collection of column definitions for this contentType.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentTypeId key: id of contentType
 @param columnDefinitionId key: id of columnDefinition
 @return ApiDriveListContentTypesGetColumnsRequest
*/
func (a *DriveListApiService) DriveListContentTypesGetColumns(ctx _context.Context, contentTypeId string, columnDefinitionId string) ApiDriveListContentTypesGetColumnsRequest {
	return ApiDriveListContentTypesGetColumnsRequest{
		ApiService: a,
		ctx: ctx,
		contentTypeId: contentTypeId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphColumnDefinition
func (a *DriveListApiService) DriveListContentTypesGetColumnsExecute(r ApiDriveListContentTypesGetColumnsRequest) (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListContentTypesGetColumns")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/contentTypes/{contentType-id}/columns/{columnDefinition-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDriveListContentTypesGetRefBaseRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	contentTypeId string
}


func (r ApiDriveListContentTypesGetRefBaseRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.DriveListContentTypesGetRefBaseExecute(r)
}

/*
DriveListContentTypesGetRefBase Get ref of base from drive

Parent contentType from which this content type is derived.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentTypeId key: id of contentType
 @return ApiDriveListContentTypesGetRefBaseRequest
*/
func (a *DriveListApiService) DriveListContentTypesGetRefBase(ctx _context.Context, contentTypeId string) ApiDriveListContentTypesGetRefBaseRequest {
	return ApiDriveListContentTypesGetRefBaseRequest{
		ApiService: a,
		ctx: ctx,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return string
func (a *DriveListApiService) DriveListContentTypesGetRefBaseExecute(r ApiDriveListContentTypesGetRefBaseRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListContentTypesGetRefBase")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/contentTypes/{contentType-id}/base/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDriveListContentTypesListBaseTypesRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	contentTypeId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiDriveListContentTypesListBaseTypesRequest) Top(top int32) ApiDriveListContentTypesListBaseTypesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiDriveListContentTypesListBaseTypesRequest) Skip(skip int32) ApiDriveListContentTypesListBaseTypesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiDriveListContentTypesListBaseTypesRequest) Search(search string) ApiDriveListContentTypesListBaseTypesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiDriveListContentTypesListBaseTypesRequest) Filter(filter string) ApiDriveListContentTypesListBaseTypesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiDriveListContentTypesListBaseTypesRequest) Count(count bool) ApiDriveListContentTypesListBaseTypesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiDriveListContentTypesListBaseTypesRequest) Orderby(orderby []string) ApiDriveListContentTypesListBaseTypesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiDriveListContentTypesListBaseTypesRequest) Select_(select_ []string) ApiDriveListContentTypesListBaseTypesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDriveListContentTypesListBaseTypesRequest) Expand(expand []string) ApiDriveListContentTypesListBaseTypesRequest {
	r.expand = &expand
	return r
}

func (r ApiDriveListContentTypesListBaseTypesRequest) Execute() (CollectionOfContentType, *_nethttp.Response, error) {
	return r.ApiService.DriveListContentTypesListBaseTypesExecute(r)
}

/*
DriveListContentTypesListBaseTypes Get baseTypes from drive

The collection of content types that are ancestors of this content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentTypeId key: id of contentType
 @return ApiDriveListContentTypesListBaseTypesRequest
*/
func (a *DriveListApiService) DriveListContentTypesListBaseTypes(ctx _context.Context, contentTypeId string) ApiDriveListContentTypesListBaseTypesRequest {
	return ApiDriveListContentTypesListBaseTypesRequest{
		ApiService: a,
		ctx: ctx,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return CollectionOfContentType
func (a *DriveListApiService) DriveListContentTypesListBaseTypesExecute(r ApiDriveListContentTypesListBaseTypesRequest) (CollectionOfContentType, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfContentType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListContentTypesListBaseTypes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/contentTypes/{contentType-id}/baseTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDriveListContentTypesListColumnLinksRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	contentTypeId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiDriveListContentTypesListColumnLinksRequest) Top(top int32) ApiDriveListContentTypesListColumnLinksRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiDriveListContentTypesListColumnLinksRequest) Skip(skip int32) ApiDriveListContentTypesListColumnLinksRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiDriveListContentTypesListColumnLinksRequest) Search(search string) ApiDriveListContentTypesListColumnLinksRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiDriveListContentTypesListColumnLinksRequest) Filter(filter string) ApiDriveListContentTypesListColumnLinksRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiDriveListContentTypesListColumnLinksRequest) Count(count bool) ApiDriveListContentTypesListColumnLinksRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiDriveListContentTypesListColumnLinksRequest) Orderby(orderby []string) ApiDriveListContentTypesListColumnLinksRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiDriveListContentTypesListColumnLinksRequest) Select_(select_ []string) ApiDriveListContentTypesListColumnLinksRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDriveListContentTypesListColumnLinksRequest) Expand(expand []string) ApiDriveListContentTypesListColumnLinksRequest {
	r.expand = &expand
	return r
}

func (r ApiDriveListContentTypesListColumnLinksRequest) Execute() (CollectionOfColumnLink, *_nethttp.Response, error) {
	return r.ApiService.DriveListContentTypesListColumnLinksExecute(r)
}

/*
DriveListContentTypesListColumnLinks Get columnLinks from drive

The collection of columns that are required by this content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentTypeId key: id of contentType
 @return ApiDriveListContentTypesListColumnLinksRequest
*/
func (a *DriveListApiService) DriveListContentTypesListColumnLinks(ctx _context.Context, contentTypeId string) ApiDriveListContentTypesListColumnLinksRequest {
	return ApiDriveListContentTypesListColumnLinksRequest{
		ApiService: a,
		ctx: ctx,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return CollectionOfColumnLink
func (a *DriveListApiService) DriveListContentTypesListColumnLinksExecute(r ApiDriveListContentTypesListColumnLinksRequest) (CollectionOfColumnLink, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfColumnLink
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListContentTypesListColumnLinks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/contentTypes/{contentType-id}/columnLinks"
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDriveListContentTypesListColumnPositionsRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	contentTypeId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiDriveListContentTypesListColumnPositionsRequest) Top(top int32) ApiDriveListContentTypesListColumnPositionsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiDriveListContentTypesListColumnPositionsRequest) Skip(skip int32) ApiDriveListContentTypesListColumnPositionsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiDriveListContentTypesListColumnPositionsRequest) Search(search string) ApiDriveListContentTypesListColumnPositionsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiDriveListContentTypesListColumnPositionsRequest) Filter(filter string) ApiDriveListContentTypesListColumnPositionsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiDriveListContentTypesListColumnPositionsRequest) Count(count bool) ApiDriveListContentTypesListColumnPositionsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiDriveListContentTypesListColumnPositionsRequest) Orderby(orderby []string) ApiDriveListContentTypesListColumnPositionsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiDriveListContentTypesListColumnPositionsRequest) Select_(select_ []string) ApiDriveListContentTypesListColumnPositionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDriveListContentTypesListColumnPositionsRequest) Expand(expand []string) ApiDriveListContentTypesListColumnPositionsRequest {
	r.expand = &expand
	return r
}

func (r ApiDriveListContentTypesListColumnPositionsRequest) Execute() (CollectionOfColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.DriveListContentTypesListColumnPositionsExecute(r)
}

/*
DriveListContentTypesListColumnPositions Get columnPositions from drive

Column order information in a content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentTypeId key: id of contentType
 @return ApiDriveListContentTypesListColumnPositionsRequest
*/
func (a *DriveListApiService) DriveListContentTypesListColumnPositions(ctx _context.Context, contentTypeId string) ApiDriveListContentTypesListColumnPositionsRequest {
	return ApiDriveListContentTypesListColumnPositionsRequest{
		ApiService: a,
		ctx: ctx,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return CollectionOfColumnDefinition
func (a *DriveListApiService) DriveListContentTypesListColumnPositionsExecute(r ApiDriveListContentTypesListColumnPositionsRequest) (CollectionOfColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListContentTypesListColumnPositions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/contentTypes/{contentType-id}/columnPositions"
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDriveListContentTypesListColumnsRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	contentTypeId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiDriveListContentTypesListColumnsRequest) Top(top int32) ApiDriveListContentTypesListColumnsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiDriveListContentTypesListColumnsRequest) Skip(skip int32) ApiDriveListContentTypesListColumnsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiDriveListContentTypesListColumnsRequest) Search(search string) ApiDriveListContentTypesListColumnsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiDriveListContentTypesListColumnsRequest) Filter(filter string) ApiDriveListContentTypesListColumnsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiDriveListContentTypesListColumnsRequest) Count(count bool) ApiDriveListContentTypesListColumnsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiDriveListContentTypesListColumnsRequest) Orderby(orderby []string) ApiDriveListContentTypesListColumnsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiDriveListContentTypesListColumnsRequest) Select_(select_ []string) ApiDriveListContentTypesListColumnsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDriveListContentTypesListColumnsRequest) Expand(expand []string) ApiDriveListContentTypesListColumnsRequest {
	r.expand = &expand
	return r
}

func (r ApiDriveListContentTypesListColumnsRequest) Execute() (CollectionOfColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.DriveListContentTypesListColumnsExecute(r)
}

/*
DriveListContentTypesListColumns Get columns from drive

The collection of column definitions for this contentType.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentTypeId key: id of contentType
 @return ApiDriveListContentTypesListColumnsRequest
*/
func (a *DriveListApiService) DriveListContentTypesListColumns(ctx _context.Context, contentTypeId string) ApiDriveListContentTypesListColumnsRequest {
	return ApiDriveListContentTypesListColumnsRequest{
		ApiService: a,
		ctx: ctx,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return CollectionOfColumnDefinition
func (a *DriveListApiService) DriveListContentTypesListColumnsExecute(r ApiDriveListContentTypesListColumnsRequest) (CollectionOfColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListContentTypesListColumns")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/contentTypes/{contentType-id}/columns"
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDriveListContentTypesListRefBaseTypesRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	contentTypeId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
}

// Show only the first n items
func (r ApiDriveListContentTypesListRefBaseTypesRequest) Top(top int32) ApiDriveListContentTypesListRefBaseTypesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiDriveListContentTypesListRefBaseTypesRequest) Skip(skip int32) ApiDriveListContentTypesListRefBaseTypesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiDriveListContentTypesListRefBaseTypesRequest) Search(search string) ApiDriveListContentTypesListRefBaseTypesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiDriveListContentTypesListRefBaseTypesRequest) Filter(filter string) ApiDriveListContentTypesListRefBaseTypesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiDriveListContentTypesListRefBaseTypesRequest) Count(count bool) ApiDriveListContentTypesListRefBaseTypesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiDriveListContentTypesListRefBaseTypesRequest) Orderby(orderby []string) ApiDriveListContentTypesListRefBaseTypesRequest {
	r.orderby = &orderby
	return r
}

func (r ApiDriveListContentTypesListRefBaseTypesRequest) Execute() (CollectionOfLinksOfContentType, *_nethttp.Response, error) {
	return r.ApiService.DriveListContentTypesListRefBaseTypesExecute(r)
}

/*
DriveListContentTypesListRefBaseTypes Get ref of baseTypes from drive

The collection of content types that are ancestors of this content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentTypeId key: id of contentType
 @return ApiDriveListContentTypesListRefBaseTypesRequest
*/
func (a *DriveListApiService) DriveListContentTypesListRefBaseTypes(ctx _context.Context, contentTypeId string) ApiDriveListContentTypesListRefBaseTypesRequest {
	return ApiDriveListContentTypesListRefBaseTypesRequest{
		ApiService: a,
		ctx: ctx,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return CollectionOfLinksOfContentType
func (a *DriveListApiService) DriveListContentTypesListRefBaseTypesExecute(r ApiDriveListContentTypesListRefBaseTypesRequest) (CollectionOfLinksOfContentType, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfLinksOfContentType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListContentTypesListRefBaseTypes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/contentTypes/{contentType-id}/baseTypes/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDriveListContentTypesListRefColumnPositionsRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	contentTypeId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
}

// Show only the first n items
func (r ApiDriveListContentTypesListRefColumnPositionsRequest) Top(top int32) ApiDriveListContentTypesListRefColumnPositionsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiDriveListContentTypesListRefColumnPositionsRequest) Skip(skip int32) ApiDriveListContentTypesListRefColumnPositionsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiDriveListContentTypesListRefColumnPositionsRequest) Search(search string) ApiDriveListContentTypesListRefColumnPositionsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiDriveListContentTypesListRefColumnPositionsRequest) Filter(filter string) ApiDriveListContentTypesListRefColumnPositionsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiDriveListContentTypesListRefColumnPositionsRequest) Count(count bool) ApiDriveListContentTypesListRefColumnPositionsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiDriveListContentTypesListRefColumnPositionsRequest) Orderby(orderby []string) ApiDriveListContentTypesListRefColumnPositionsRequest {
	r.orderby = &orderby
	return r
}

func (r ApiDriveListContentTypesListRefColumnPositionsRequest) Execute() (CollectionOfLinksOfColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.DriveListContentTypesListRefColumnPositionsExecute(r)
}

/*
DriveListContentTypesListRefColumnPositions Get ref of columnPositions from drive

Column order information in a content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentTypeId key: id of contentType
 @return ApiDriveListContentTypesListRefColumnPositionsRequest
*/
func (a *DriveListApiService) DriveListContentTypesListRefColumnPositions(ctx _context.Context, contentTypeId string) ApiDriveListContentTypesListRefColumnPositionsRequest {
	return ApiDriveListContentTypesListRefColumnPositionsRequest{
		ApiService: a,
		ctx: ctx,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return CollectionOfLinksOfColumnDefinition
func (a *DriveListApiService) DriveListContentTypesListRefColumnPositionsExecute(r ApiDriveListContentTypesListRefColumnPositionsRequest) (CollectionOfLinksOfColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfLinksOfColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListContentTypesListRefColumnPositions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/contentTypes/{contentType-id}/columnPositions/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDriveListContentTypesUpdateColumnLinksRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	contentTypeId string
	columnLinkId string
	microsoftGraphColumnLink *MicrosoftGraphColumnLink
}

// New navigation property values
func (r ApiDriveListContentTypesUpdateColumnLinksRequest) MicrosoftGraphColumnLink(microsoftGraphColumnLink MicrosoftGraphColumnLink) ApiDriveListContentTypesUpdateColumnLinksRequest {
	r.microsoftGraphColumnLink = &microsoftGraphColumnLink
	return r
}

func (r ApiDriveListContentTypesUpdateColumnLinksRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DriveListContentTypesUpdateColumnLinksExecute(r)
}

/*
DriveListContentTypesUpdateColumnLinks Update the navigation property columnLinks in drive

The collection of columns that are required by this content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentTypeId key: id of contentType
 @param columnLinkId key: id of columnLink
 @return ApiDriveListContentTypesUpdateColumnLinksRequest
*/
func (a *DriveListApiService) DriveListContentTypesUpdateColumnLinks(ctx _context.Context, contentTypeId string, columnLinkId string) ApiDriveListContentTypesUpdateColumnLinksRequest {
	return ApiDriveListContentTypesUpdateColumnLinksRequest{
		ApiService: a,
		ctx: ctx,
		contentTypeId: contentTypeId,
		columnLinkId: columnLinkId,
	}
}

// Execute executes the request
func (a *DriveListApiService) DriveListContentTypesUpdateColumnLinksExecute(r ApiDriveListContentTypesUpdateColumnLinksRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListContentTypesUpdateColumnLinks")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/contentTypes/{contentType-id}/columnLinks/{columnLink-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnLink-id"+"}", _neturl.PathEscape(parameterToString(r.columnLinkId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphColumnLink == nil {
		return nil, reportError("microsoftGraphColumnLink is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphColumnLink
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDriveListContentTypesUpdateColumnsRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	contentTypeId string
	columnDefinitionId string
	microsoftGraphColumnDefinition *MicrosoftGraphColumnDefinition
}

// New navigation property values
func (r ApiDriveListContentTypesUpdateColumnsRequest) MicrosoftGraphColumnDefinition(microsoftGraphColumnDefinition MicrosoftGraphColumnDefinition) ApiDriveListContentTypesUpdateColumnsRequest {
	r.microsoftGraphColumnDefinition = &microsoftGraphColumnDefinition
	return r
}

func (r ApiDriveListContentTypesUpdateColumnsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DriveListContentTypesUpdateColumnsExecute(r)
}

/*
DriveListContentTypesUpdateColumns Update the navigation property columns in drive

The collection of column definitions for this contentType.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentTypeId key: id of contentType
 @param columnDefinitionId key: id of columnDefinition
 @return ApiDriveListContentTypesUpdateColumnsRequest
*/
func (a *DriveListApiService) DriveListContentTypesUpdateColumns(ctx _context.Context, contentTypeId string, columnDefinitionId string) ApiDriveListContentTypesUpdateColumnsRequest {
	return ApiDriveListContentTypesUpdateColumnsRequest{
		ApiService: a,
		ctx: ctx,
		contentTypeId: contentTypeId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
func (a *DriveListApiService) DriveListContentTypesUpdateColumnsExecute(r ApiDriveListContentTypesUpdateColumnsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListContentTypesUpdateColumns")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/contentTypes/{contentType-id}/columns/{columnDefinition-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphColumnDefinition == nil {
		return nil, reportError("microsoftGraphColumnDefinition is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphColumnDefinition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDriveListContentTypesUpdateRefBaseRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	contentTypeId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiDriveListContentTypesUpdateRefBaseRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiDriveListContentTypesUpdateRefBaseRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiDriveListContentTypesUpdateRefBaseRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DriveListContentTypesUpdateRefBaseExecute(r)
}

/*
DriveListContentTypesUpdateRefBase Update the ref of navigation property base in drive

Parent contentType from which this content type is derived.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentTypeId key: id of contentType
 @return ApiDriveListContentTypesUpdateRefBaseRequest
*/
func (a *DriveListApiService) DriveListContentTypesUpdateRefBase(ctx _context.Context, contentTypeId string) ApiDriveListContentTypesUpdateRefBaseRequest {
	return ApiDriveListContentTypesUpdateRefBaseRequest{
		ApiService: a,
		ctx: ctx,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
func (a *DriveListApiService) DriveListContentTypesUpdateRefBaseExecute(r ApiDriveListContentTypesUpdateRefBaseRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListContentTypesUpdateRefBase")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/contentTypes/{contentType-id}/base/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDriveListCreateColumnsRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	microsoftGraphColumnDefinition *MicrosoftGraphColumnDefinition
}

// New navigation property
func (r ApiDriveListCreateColumnsRequest) MicrosoftGraphColumnDefinition(microsoftGraphColumnDefinition MicrosoftGraphColumnDefinition) ApiDriveListCreateColumnsRequest {
	r.microsoftGraphColumnDefinition = &microsoftGraphColumnDefinition
	return r
}

func (r ApiDriveListCreateColumnsRequest) Execute() (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.DriveListCreateColumnsExecute(r)
}

/*
DriveListCreateColumns Create new navigation property to columns for drive

The collection of field definitions for this list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDriveListCreateColumnsRequest
*/
func (a *DriveListApiService) DriveListCreateColumns(ctx _context.Context) ApiDriveListCreateColumnsRequest {
	return ApiDriveListCreateColumnsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphColumnDefinition
func (a *DriveListApiService) DriveListCreateColumnsExecute(r ApiDriveListCreateColumnsRequest) (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListCreateColumns")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/columns"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphColumnDefinition == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphColumnDefinition is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphColumnDefinition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDriveListCreateContentTypesRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	microsoftGraphContentType *MicrosoftGraphContentType
}

// New navigation property
func (r ApiDriveListCreateContentTypesRequest) MicrosoftGraphContentType(microsoftGraphContentType MicrosoftGraphContentType) ApiDriveListCreateContentTypesRequest {
	r.microsoftGraphContentType = &microsoftGraphContentType
	return r
}

func (r ApiDriveListCreateContentTypesRequest) Execute() (MicrosoftGraphContentType, *_nethttp.Response, error) {
	return r.ApiService.DriveListCreateContentTypesExecute(r)
}

/*
DriveListCreateContentTypes Create new navigation property to contentTypes for drive

The collection of content types present in this list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDriveListCreateContentTypesRequest
*/
func (a *DriveListApiService) DriveListCreateContentTypes(ctx _context.Context) ApiDriveListCreateContentTypesRequest {
	return ApiDriveListCreateContentTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphContentType
func (a *DriveListApiService) DriveListCreateContentTypesExecute(r ApiDriveListCreateContentTypesRequest) (MicrosoftGraphContentType, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphContentType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListCreateContentTypes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/contentTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphContentType == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphContentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphContentType
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDriveListCreateItemsRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	microsoftGraphListItem *MicrosoftGraphListItem
}

// New navigation property
func (r ApiDriveListCreateItemsRequest) MicrosoftGraphListItem(microsoftGraphListItem MicrosoftGraphListItem) ApiDriveListCreateItemsRequest {
	r.microsoftGraphListItem = &microsoftGraphListItem
	return r
}

func (r ApiDriveListCreateItemsRequest) Execute() (MicrosoftGraphListItem, *_nethttp.Response, error) {
	return r.ApiService.DriveListCreateItemsExecute(r)
}

/*
DriveListCreateItems Create new navigation property to items for drive

All items contained in the list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDriveListCreateItemsRequest
*/
func (a *DriveListApiService) DriveListCreateItems(ctx _context.Context) ApiDriveListCreateItemsRequest {
	return ApiDriveListCreateItemsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphListItem
func (a *DriveListApiService) DriveListCreateItemsExecute(r ApiDriveListCreateItemsRequest) (MicrosoftGraphListItem, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphListItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListCreateItems")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/items"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphListItem == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphListItem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphListItem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDriveListCreateSubscriptionsRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	microsoftGraphSubscription *MicrosoftGraphSubscription
}

// New navigation property
func (r ApiDriveListCreateSubscriptionsRequest) MicrosoftGraphSubscription(microsoftGraphSubscription MicrosoftGraphSubscription) ApiDriveListCreateSubscriptionsRequest {
	r.microsoftGraphSubscription = &microsoftGraphSubscription
	return r
}

func (r ApiDriveListCreateSubscriptionsRequest) Execute() (MicrosoftGraphSubscription, *_nethttp.Response, error) {
	return r.ApiService.DriveListCreateSubscriptionsExecute(r)
}

/*
DriveListCreateSubscriptions Create new navigation property to subscriptions for drive

The set of subscriptions on the list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDriveListCreateSubscriptionsRequest
*/
func (a *DriveListApiService) DriveListCreateSubscriptions(ctx _context.Context) ApiDriveListCreateSubscriptionsRequest {
	return ApiDriveListCreateSubscriptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphSubscription
func (a *DriveListApiService) DriveListCreateSubscriptionsExecute(r ApiDriveListCreateSubscriptionsRequest) (MicrosoftGraphSubscription, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphSubscription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListCreateSubscriptions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/subscriptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphSubscription == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphSubscription is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphSubscription
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDriveListDeleteColumnsRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	columnDefinitionId string
	ifMatch *string
}

// ETag
func (r ApiDriveListDeleteColumnsRequest) IfMatch(ifMatch string) ApiDriveListDeleteColumnsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDriveListDeleteColumnsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DriveListDeleteColumnsExecute(r)
}

/*
DriveListDeleteColumns Delete navigation property columns for drive

The collection of field definitions for this list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param columnDefinitionId key: id of columnDefinition
 @return ApiDriveListDeleteColumnsRequest
*/
func (a *DriveListApiService) DriveListDeleteColumns(ctx _context.Context, columnDefinitionId string) ApiDriveListDeleteColumnsRequest {
	return ApiDriveListDeleteColumnsRequest{
		ApiService: a,
		ctx: ctx,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
func (a *DriveListApiService) DriveListDeleteColumnsExecute(r ApiDriveListDeleteColumnsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListDeleteColumns")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/columns/{columnDefinition-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDriveListDeleteContentTypesRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	contentTypeId string
	ifMatch *string
}

// ETag
func (r ApiDriveListDeleteContentTypesRequest) IfMatch(ifMatch string) ApiDriveListDeleteContentTypesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDriveListDeleteContentTypesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DriveListDeleteContentTypesExecute(r)
}

/*
DriveListDeleteContentTypes Delete navigation property contentTypes for drive

The collection of content types present in this list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentTypeId key: id of contentType
 @return ApiDriveListDeleteContentTypesRequest
*/
func (a *DriveListApiService) DriveListDeleteContentTypes(ctx _context.Context, contentTypeId string) ApiDriveListDeleteContentTypesRequest {
	return ApiDriveListDeleteContentTypesRequest{
		ApiService: a,
		ctx: ctx,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
func (a *DriveListApiService) DriveListDeleteContentTypesExecute(r ApiDriveListDeleteContentTypesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListDeleteContentTypes")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/contentTypes/{contentType-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDriveListDeleteDriveRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	ifMatch *string
}

// ETag
func (r ApiDriveListDeleteDriveRequest) IfMatch(ifMatch string) ApiDriveListDeleteDriveRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDriveListDeleteDriveRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DriveListDeleteDriveExecute(r)
}

/*
DriveListDeleteDrive Delete navigation property drive for drive

Only present on document libraries. Allows access to the list as a [drive][] resource with [driveItems][driveItem].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDriveListDeleteDriveRequest
*/
func (a *DriveListApiService) DriveListDeleteDrive(ctx _context.Context) ApiDriveListDeleteDriveRequest {
	return ApiDriveListDeleteDriveRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DriveListApiService) DriveListDeleteDriveExecute(r ApiDriveListDeleteDriveRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListDeleteDrive")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/drive"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDriveListDeleteItemsRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	listItemId string
	ifMatch *string
}

// ETag
func (r ApiDriveListDeleteItemsRequest) IfMatch(ifMatch string) ApiDriveListDeleteItemsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDriveListDeleteItemsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DriveListDeleteItemsExecute(r)
}

/*
DriveListDeleteItems Delete navigation property items for drive

All items contained in the list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listItemId key: id of listItem
 @return ApiDriveListDeleteItemsRequest
*/
func (a *DriveListApiService) DriveListDeleteItems(ctx _context.Context, listItemId string) ApiDriveListDeleteItemsRequest {
	return ApiDriveListDeleteItemsRequest{
		ApiService: a,
		ctx: ctx,
		listItemId: listItemId,
	}
}

// Execute executes the request
func (a *DriveListApiService) DriveListDeleteItemsExecute(r ApiDriveListDeleteItemsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListDeleteItems")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/items/{listItem-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDriveListDeleteSubscriptionsRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	subscriptionId string
	ifMatch *string
}

// ETag
func (r ApiDriveListDeleteSubscriptionsRequest) IfMatch(ifMatch string) ApiDriveListDeleteSubscriptionsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDriveListDeleteSubscriptionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DriveListDeleteSubscriptionsExecute(r)
}

/*
DriveListDeleteSubscriptions Delete navigation property subscriptions for drive

The set of subscriptions on the list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param subscriptionId key: id of subscription
 @return ApiDriveListDeleteSubscriptionsRequest
*/
func (a *DriveListApiService) DriveListDeleteSubscriptions(ctx _context.Context, subscriptionId string) ApiDriveListDeleteSubscriptionsRequest {
	return ApiDriveListDeleteSubscriptionsRequest{
		ApiService: a,
		ctx: ctx,
		subscriptionId: subscriptionId,
	}
}

// Execute executes the request
func (a *DriveListApiService) DriveListDeleteSubscriptionsExecute(r ApiDriveListDeleteSubscriptionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListDeleteSubscriptions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/subscriptions/{subscription-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"subscription-id"+"}", _neturl.PathEscape(parameterToString(r.subscriptionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDriveListGetColumnsRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	columnDefinitionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDriveListGetColumnsRequest) Select_(select_ []string) ApiDriveListGetColumnsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDriveListGetColumnsRequest) Expand(expand []string) ApiDriveListGetColumnsRequest {
	r.expand = &expand
	return r
}

func (r ApiDriveListGetColumnsRequest) Execute() (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.DriveListGetColumnsExecute(r)
}

/*
DriveListGetColumns Get columns from drive

The collection of field definitions for this list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param columnDefinitionId key: id of columnDefinition
 @return ApiDriveListGetColumnsRequest
*/
func (a *DriveListApiService) DriveListGetColumns(ctx _context.Context, columnDefinitionId string) ApiDriveListGetColumnsRequest {
	return ApiDriveListGetColumnsRequest{
		ApiService: a,
		ctx: ctx,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphColumnDefinition
func (a *DriveListApiService) DriveListGetColumnsExecute(r ApiDriveListGetColumnsRequest) (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListGetColumns")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/columns/{columnDefinition-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDriveListGetContentTypesRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	contentTypeId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDriveListGetContentTypesRequest) Select_(select_ []string) ApiDriveListGetContentTypesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDriveListGetContentTypesRequest) Expand(expand []string) ApiDriveListGetContentTypesRequest {
	r.expand = &expand
	return r
}

func (r ApiDriveListGetContentTypesRequest) Execute() (MicrosoftGraphContentType, *_nethttp.Response, error) {
	return r.ApiService.DriveListGetContentTypesExecute(r)
}

/*
DriveListGetContentTypes Get contentTypes from drive

The collection of content types present in this list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentTypeId key: id of contentType
 @return ApiDriveListGetContentTypesRequest
*/
func (a *DriveListApiService) DriveListGetContentTypes(ctx _context.Context, contentTypeId string) ApiDriveListGetContentTypesRequest {
	return ApiDriveListGetContentTypesRequest{
		ApiService: a,
		ctx: ctx,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphContentType
func (a *DriveListApiService) DriveListGetContentTypesExecute(r ApiDriveListGetContentTypesRequest) (MicrosoftGraphContentType, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphContentType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListGetContentTypes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/contentTypes/{contentType-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDriveListGetDriveRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDriveListGetDriveRequest) Select_(select_ []string) ApiDriveListGetDriveRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDriveListGetDriveRequest) Expand(expand []string) ApiDriveListGetDriveRequest {
	r.expand = &expand
	return r
}

func (r ApiDriveListGetDriveRequest) Execute() (MicrosoftGraphDrive, *_nethttp.Response, error) {
	return r.ApiService.DriveListGetDriveExecute(r)
}

/*
DriveListGetDrive Get drive from drive

Only present on document libraries. Allows access to the list as a [drive][] resource with [driveItems][driveItem].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDriveListGetDriveRequest
*/
func (a *DriveListApiService) DriveListGetDrive(ctx _context.Context) ApiDriveListGetDriveRequest {
	return ApiDriveListGetDriveRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphDrive
func (a *DriveListApiService) DriveListGetDriveExecute(r ApiDriveListGetDriveRequest) (MicrosoftGraphDrive, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphDrive
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListGetDrive")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/drive"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDriveListGetItemsRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	listItemId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDriveListGetItemsRequest) Select_(select_ []string) ApiDriveListGetItemsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDriveListGetItemsRequest) Expand(expand []string) ApiDriveListGetItemsRequest {
	r.expand = &expand
	return r
}

func (r ApiDriveListGetItemsRequest) Execute() (MicrosoftGraphListItem, *_nethttp.Response, error) {
	return r.ApiService.DriveListGetItemsExecute(r)
}

/*
DriveListGetItems Get items from drive

All items contained in the list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listItemId key: id of listItem
 @return ApiDriveListGetItemsRequest
*/
func (a *DriveListApiService) DriveListGetItems(ctx _context.Context, listItemId string) ApiDriveListGetItemsRequest {
	return ApiDriveListGetItemsRequest{
		ApiService: a,
		ctx: ctx,
		listItemId: listItemId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphListItem
func (a *DriveListApiService) DriveListGetItemsExecute(r ApiDriveListGetItemsRequest) (MicrosoftGraphListItem, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphListItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListGetItems")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/items/{listItem-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDriveListGetSubscriptionsRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	subscriptionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDriveListGetSubscriptionsRequest) Select_(select_ []string) ApiDriveListGetSubscriptionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDriveListGetSubscriptionsRequest) Expand(expand []string) ApiDriveListGetSubscriptionsRequest {
	r.expand = &expand
	return r
}

func (r ApiDriveListGetSubscriptionsRequest) Execute() (MicrosoftGraphSubscription, *_nethttp.Response, error) {
	return r.ApiService.DriveListGetSubscriptionsExecute(r)
}

/*
DriveListGetSubscriptions Get subscriptions from drive

The set of subscriptions on the list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param subscriptionId key: id of subscription
 @return ApiDriveListGetSubscriptionsRequest
*/
func (a *DriveListApiService) DriveListGetSubscriptions(ctx _context.Context, subscriptionId string) ApiDriveListGetSubscriptionsRequest {
	return ApiDriveListGetSubscriptionsRequest{
		ApiService: a,
		ctx: ctx,
		subscriptionId: subscriptionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphSubscription
func (a *DriveListApiService) DriveListGetSubscriptionsExecute(r ApiDriveListGetSubscriptionsRequest) (MicrosoftGraphSubscription, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphSubscription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListGetSubscriptions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/subscriptions/{subscription-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"subscription-id"+"}", _neturl.PathEscape(parameterToString(r.subscriptionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDriveListItemsCreateVersionsRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	listItemId string
	microsoftGraphListItemVersion *MicrosoftGraphListItemVersion
}

// New navigation property
func (r ApiDriveListItemsCreateVersionsRequest) MicrosoftGraphListItemVersion(microsoftGraphListItemVersion MicrosoftGraphListItemVersion) ApiDriveListItemsCreateVersionsRequest {
	r.microsoftGraphListItemVersion = &microsoftGraphListItemVersion
	return r
}

func (r ApiDriveListItemsCreateVersionsRequest) Execute() (MicrosoftGraphListItemVersion, *_nethttp.Response, error) {
	return r.ApiService.DriveListItemsCreateVersionsExecute(r)
}

/*
DriveListItemsCreateVersions Create new navigation property to versions for drive

The list of previous versions of the list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listItemId key: id of listItem
 @return ApiDriveListItemsCreateVersionsRequest
*/
func (a *DriveListApiService) DriveListItemsCreateVersions(ctx _context.Context, listItemId string) ApiDriveListItemsCreateVersionsRequest {
	return ApiDriveListItemsCreateVersionsRequest{
		ApiService: a,
		ctx: ctx,
		listItemId: listItemId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphListItemVersion
func (a *DriveListApiService) DriveListItemsCreateVersionsExecute(r ApiDriveListItemsCreateVersionsRequest) (MicrosoftGraphListItemVersion, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphListItemVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListItemsCreateVersions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/items/{listItem-id}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphListItemVersion == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphListItemVersion is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphListItemVersion
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDriveListItemsDeleteDriveItemRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	listItemId string
	ifMatch *string
}

// ETag
func (r ApiDriveListItemsDeleteDriveItemRequest) IfMatch(ifMatch string) ApiDriveListItemsDeleteDriveItemRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDriveListItemsDeleteDriveItemRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DriveListItemsDeleteDriveItemExecute(r)
}

/*
DriveListItemsDeleteDriveItem Delete navigation property driveItem for drive

For document libraries, the driveItem relationship exposes the listItem as a [driveItem][]

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listItemId key: id of listItem
 @return ApiDriveListItemsDeleteDriveItemRequest
*/
func (a *DriveListApiService) DriveListItemsDeleteDriveItem(ctx _context.Context, listItemId string) ApiDriveListItemsDeleteDriveItemRequest {
	return ApiDriveListItemsDeleteDriveItemRequest{
		ApiService: a,
		ctx: ctx,
		listItemId: listItemId,
	}
}

// Execute executes the request
func (a *DriveListApiService) DriveListItemsDeleteDriveItemExecute(r ApiDriveListItemsDeleteDriveItemRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListItemsDeleteDriveItem")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/items/{listItem-id}/driveItem"
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDriveListItemsDeleteFieldsRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	listItemId string
	ifMatch *string
}

// ETag
func (r ApiDriveListItemsDeleteFieldsRequest) IfMatch(ifMatch string) ApiDriveListItemsDeleteFieldsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDriveListItemsDeleteFieldsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DriveListItemsDeleteFieldsExecute(r)
}

/*
DriveListItemsDeleteFields Delete navigation property fields for drive

The values of the columns set on this list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listItemId key: id of listItem
 @return ApiDriveListItemsDeleteFieldsRequest
*/
func (a *DriveListApiService) DriveListItemsDeleteFields(ctx _context.Context, listItemId string) ApiDriveListItemsDeleteFieldsRequest {
	return ApiDriveListItemsDeleteFieldsRequest{
		ApiService: a,
		ctx: ctx,
		listItemId: listItemId,
	}
}

// Execute executes the request
func (a *DriveListApiService) DriveListItemsDeleteFieldsExecute(r ApiDriveListItemsDeleteFieldsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListItemsDeleteFields")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/items/{listItem-id}/fields"
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDriveListItemsDeleteRefAnalyticsRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	listItemId string
	ifMatch *string
}

// ETag
func (r ApiDriveListItemsDeleteRefAnalyticsRequest) IfMatch(ifMatch string) ApiDriveListItemsDeleteRefAnalyticsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDriveListItemsDeleteRefAnalyticsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DriveListItemsDeleteRefAnalyticsExecute(r)
}

/*
DriveListItemsDeleteRefAnalytics Delete ref of navigation property analytics for drive

Analytics about the view activities that took place on this item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listItemId key: id of listItem
 @return ApiDriveListItemsDeleteRefAnalyticsRequest
*/
func (a *DriveListApiService) DriveListItemsDeleteRefAnalytics(ctx _context.Context, listItemId string) ApiDriveListItemsDeleteRefAnalyticsRequest {
	return ApiDriveListItemsDeleteRefAnalyticsRequest{
		ApiService: a,
		ctx: ctx,
		listItemId: listItemId,
	}
}

// Execute executes the request
func (a *DriveListApiService) DriveListItemsDeleteRefAnalyticsExecute(r ApiDriveListItemsDeleteRefAnalyticsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListItemsDeleteRefAnalytics")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/items/{listItem-id}/analytics/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDriveListItemsDeleteVersionsRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	listItemId string
	listItemVersionId string
	ifMatch *string
}

// ETag
func (r ApiDriveListItemsDeleteVersionsRequest) IfMatch(ifMatch string) ApiDriveListItemsDeleteVersionsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDriveListItemsDeleteVersionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DriveListItemsDeleteVersionsExecute(r)
}

/*
DriveListItemsDeleteVersions Delete navigation property versions for drive

The list of previous versions of the list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listItemId key: id of listItem
 @param listItemVersionId key: id of listItemVersion
 @return ApiDriveListItemsDeleteVersionsRequest
*/
func (a *DriveListApiService) DriveListItemsDeleteVersions(ctx _context.Context, listItemId string, listItemVersionId string) ApiDriveListItemsDeleteVersionsRequest {
	return ApiDriveListItemsDeleteVersionsRequest{
		ApiService: a,
		ctx: ctx,
		listItemId: listItemId,
		listItemVersionId: listItemVersionId,
	}
}

// Execute executes the request
func (a *DriveListApiService) DriveListItemsDeleteVersionsExecute(r ApiDriveListItemsDeleteVersionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListItemsDeleteVersions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/items/{listItem-id}/versions/{listItemVersion-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItemVersion-id"+"}", _neturl.PathEscape(parameterToString(r.listItemVersionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDriveListItemsGetAnalyticsRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	listItemId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDriveListItemsGetAnalyticsRequest) Select_(select_ []string) ApiDriveListItemsGetAnalyticsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDriveListItemsGetAnalyticsRequest) Expand(expand []string) ApiDriveListItemsGetAnalyticsRequest {
	r.expand = &expand
	return r
}

func (r ApiDriveListItemsGetAnalyticsRequest) Execute() (MicrosoftGraphItemAnalytics, *_nethttp.Response, error) {
	return r.ApiService.DriveListItemsGetAnalyticsExecute(r)
}

/*
DriveListItemsGetAnalytics Get analytics from drive

Analytics about the view activities that took place on this item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listItemId key: id of listItem
 @return ApiDriveListItemsGetAnalyticsRequest
*/
func (a *DriveListApiService) DriveListItemsGetAnalytics(ctx _context.Context, listItemId string) ApiDriveListItemsGetAnalyticsRequest {
	return ApiDriveListItemsGetAnalyticsRequest{
		ApiService: a,
		ctx: ctx,
		listItemId: listItemId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphItemAnalytics
func (a *DriveListApiService) DriveListItemsGetAnalyticsExecute(r ApiDriveListItemsGetAnalyticsRequest) (MicrosoftGraphItemAnalytics, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphItemAnalytics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListItemsGetAnalytics")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/items/{listItem-id}/analytics"
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDriveListItemsGetDriveItemRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	listItemId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDriveListItemsGetDriveItemRequest) Select_(select_ []string) ApiDriveListItemsGetDriveItemRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDriveListItemsGetDriveItemRequest) Expand(expand []string) ApiDriveListItemsGetDriveItemRequest {
	r.expand = &expand
	return r
}

func (r ApiDriveListItemsGetDriveItemRequest) Execute() (MicrosoftGraphDriveItem, *_nethttp.Response, error) {
	return r.ApiService.DriveListItemsGetDriveItemExecute(r)
}

/*
DriveListItemsGetDriveItem Get driveItem from drive

For document libraries, the driveItem relationship exposes the listItem as a [driveItem][]

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listItemId key: id of listItem
 @return ApiDriveListItemsGetDriveItemRequest
*/
func (a *DriveListApiService) DriveListItemsGetDriveItem(ctx _context.Context, listItemId string) ApiDriveListItemsGetDriveItemRequest {
	return ApiDriveListItemsGetDriveItemRequest{
		ApiService: a,
		ctx: ctx,
		listItemId: listItemId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphDriveItem
func (a *DriveListApiService) DriveListItemsGetDriveItemExecute(r ApiDriveListItemsGetDriveItemRequest) (MicrosoftGraphDriveItem, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphDriveItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListItemsGetDriveItem")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/items/{listItem-id}/driveItem"
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDriveListItemsGetDriveItemContentRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	listItemId string
}


func (r ApiDriveListItemsGetDriveItemContentRequest) Execute() (*os.File, *_nethttp.Response, error) {
	return r.ApiService.DriveListItemsGetDriveItemContentExecute(r)
}

/*
DriveListItemsGetDriveItemContent Get media content for the navigation property driveItem from drive

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listItemId key: id of listItem
 @return ApiDriveListItemsGetDriveItemContentRequest
*/
func (a *DriveListApiService) DriveListItemsGetDriveItemContent(ctx _context.Context, listItemId string) ApiDriveListItemsGetDriveItemContentRequest {
	return ApiDriveListItemsGetDriveItemContentRequest{
		ApiService: a,
		ctx: ctx,
		listItemId: listItemId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *DriveListApiService) DriveListItemsGetDriveItemContentExecute(r ApiDriveListItemsGetDriveItemContentRequest) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListItemsGetDriveItemContent")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/items/{listItem-id}/driveItem/content"
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDriveListItemsGetFieldsRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	listItemId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDriveListItemsGetFieldsRequest) Select_(select_ []string) ApiDriveListItemsGetFieldsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDriveListItemsGetFieldsRequest) Expand(expand []string) ApiDriveListItemsGetFieldsRequest {
	r.expand = &expand
	return r
}

func (r ApiDriveListItemsGetFieldsRequest) Execute() (MicrosoftGraphFieldValueSet, *_nethttp.Response, error) {
	return r.ApiService.DriveListItemsGetFieldsExecute(r)
}

/*
DriveListItemsGetFields Get fields from drive

The values of the columns set on this list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listItemId key: id of listItem
 @return ApiDriveListItemsGetFieldsRequest
*/
func (a *DriveListApiService) DriveListItemsGetFields(ctx _context.Context, listItemId string) ApiDriveListItemsGetFieldsRequest {
	return ApiDriveListItemsGetFieldsRequest{
		ApiService: a,
		ctx: ctx,
		listItemId: listItemId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphFieldValueSet
func (a *DriveListApiService) DriveListItemsGetFieldsExecute(r ApiDriveListItemsGetFieldsRequest) (MicrosoftGraphFieldValueSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphFieldValueSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListItemsGetFields")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/items/{listItem-id}/fields"
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDriveListItemsGetRefAnalyticsRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	listItemId string
}


func (r ApiDriveListItemsGetRefAnalyticsRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.DriveListItemsGetRefAnalyticsExecute(r)
}

/*
DriveListItemsGetRefAnalytics Get ref of analytics from drive

Analytics about the view activities that took place on this item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listItemId key: id of listItem
 @return ApiDriveListItemsGetRefAnalyticsRequest
*/
func (a *DriveListApiService) DriveListItemsGetRefAnalytics(ctx _context.Context, listItemId string) ApiDriveListItemsGetRefAnalyticsRequest {
	return ApiDriveListItemsGetRefAnalyticsRequest{
		ApiService: a,
		ctx: ctx,
		listItemId: listItemId,
	}
}

// Execute executes the request
//  @return string
func (a *DriveListApiService) DriveListItemsGetRefAnalyticsExecute(r ApiDriveListItemsGetRefAnalyticsRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListItemsGetRefAnalytics")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/items/{listItem-id}/analytics/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDriveListItemsGetVersionsRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	listItemId string
	listItemVersionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDriveListItemsGetVersionsRequest) Select_(select_ []string) ApiDriveListItemsGetVersionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDriveListItemsGetVersionsRequest) Expand(expand []string) ApiDriveListItemsGetVersionsRequest {
	r.expand = &expand
	return r
}

func (r ApiDriveListItemsGetVersionsRequest) Execute() (MicrosoftGraphListItemVersion, *_nethttp.Response, error) {
	return r.ApiService.DriveListItemsGetVersionsExecute(r)
}

/*
DriveListItemsGetVersions Get versions from drive

The list of previous versions of the list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listItemId key: id of listItem
 @param listItemVersionId key: id of listItemVersion
 @return ApiDriveListItemsGetVersionsRequest
*/
func (a *DriveListApiService) DriveListItemsGetVersions(ctx _context.Context, listItemId string, listItemVersionId string) ApiDriveListItemsGetVersionsRequest {
	return ApiDriveListItemsGetVersionsRequest{
		ApiService: a,
		ctx: ctx,
		listItemId: listItemId,
		listItemVersionId: listItemVersionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphListItemVersion
func (a *DriveListApiService) DriveListItemsGetVersionsExecute(r ApiDriveListItemsGetVersionsRequest) (MicrosoftGraphListItemVersion, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphListItemVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListItemsGetVersions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/items/{listItem-id}/versions/{listItemVersion-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItemVersion-id"+"}", _neturl.PathEscape(parameterToString(r.listItemVersionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDriveListItemsListVersionsRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	listItemId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiDriveListItemsListVersionsRequest) Top(top int32) ApiDriveListItemsListVersionsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiDriveListItemsListVersionsRequest) Skip(skip int32) ApiDriveListItemsListVersionsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiDriveListItemsListVersionsRequest) Search(search string) ApiDriveListItemsListVersionsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiDriveListItemsListVersionsRequest) Filter(filter string) ApiDriveListItemsListVersionsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiDriveListItemsListVersionsRequest) Count(count bool) ApiDriveListItemsListVersionsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiDriveListItemsListVersionsRequest) Orderby(orderby []string) ApiDriveListItemsListVersionsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiDriveListItemsListVersionsRequest) Select_(select_ []string) ApiDriveListItemsListVersionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDriveListItemsListVersionsRequest) Expand(expand []string) ApiDriveListItemsListVersionsRequest {
	r.expand = &expand
	return r
}

func (r ApiDriveListItemsListVersionsRequest) Execute() (CollectionOfListItemVersion, *_nethttp.Response, error) {
	return r.ApiService.DriveListItemsListVersionsExecute(r)
}

/*
DriveListItemsListVersions Get versions from drive

The list of previous versions of the list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listItemId key: id of listItem
 @return ApiDriveListItemsListVersionsRequest
*/
func (a *DriveListApiService) DriveListItemsListVersions(ctx _context.Context, listItemId string) ApiDriveListItemsListVersionsRequest {
	return ApiDriveListItemsListVersionsRequest{
		ApiService: a,
		ctx: ctx,
		listItemId: listItemId,
	}
}

// Execute executes the request
//  @return CollectionOfListItemVersion
func (a *DriveListApiService) DriveListItemsListVersionsExecute(r ApiDriveListItemsListVersionsRequest) (CollectionOfListItemVersion, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfListItemVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListItemsListVersions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/items/{listItem-id}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDriveListItemsUpdateDriveItemRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	listItemId string
	microsoftGraphDriveItem *MicrosoftGraphDriveItem
}

// New navigation property values
func (r ApiDriveListItemsUpdateDriveItemRequest) MicrosoftGraphDriveItem(microsoftGraphDriveItem MicrosoftGraphDriveItem) ApiDriveListItemsUpdateDriveItemRequest {
	r.microsoftGraphDriveItem = &microsoftGraphDriveItem
	return r
}

func (r ApiDriveListItemsUpdateDriveItemRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DriveListItemsUpdateDriveItemExecute(r)
}

/*
DriveListItemsUpdateDriveItem Update the navigation property driveItem in drive

For document libraries, the driveItem relationship exposes the listItem as a [driveItem][]

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listItemId key: id of listItem
 @return ApiDriveListItemsUpdateDriveItemRequest
*/
func (a *DriveListApiService) DriveListItemsUpdateDriveItem(ctx _context.Context, listItemId string) ApiDriveListItemsUpdateDriveItemRequest {
	return ApiDriveListItemsUpdateDriveItemRequest{
		ApiService: a,
		ctx: ctx,
		listItemId: listItemId,
	}
}

// Execute executes the request
func (a *DriveListApiService) DriveListItemsUpdateDriveItemExecute(r ApiDriveListItemsUpdateDriveItemRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListItemsUpdateDriveItem")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/items/{listItem-id}/driveItem"
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphDriveItem == nil {
		return nil, reportError("microsoftGraphDriveItem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphDriveItem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDriveListItemsUpdateDriveItemContentRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	listItemId string
	body **os.File
}

// New media content.
func (r ApiDriveListItemsUpdateDriveItemContentRequest) Body(body *os.File) ApiDriveListItemsUpdateDriveItemContentRequest {
	r.body = &body
	return r
}

func (r ApiDriveListItemsUpdateDriveItemContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DriveListItemsUpdateDriveItemContentExecute(r)
}

/*
DriveListItemsUpdateDriveItemContent Update media content for the navigation property driveItem in drive

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listItemId key: id of listItem
 @return ApiDriveListItemsUpdateDriveItemContentRequest
*/
func (a *DriveListApiService) DriveListItemsUpdateDriveItemContent(ctx _context.Context, listItemId string) ApiDriveListItemsUpdateDriveItemContentRequest {
	return ApiDriveListItemsUpdateDriveItemContentRequest{
		ApiService: a,
		ctx: ctx,
		listItemId: listItemId,
	}
}

// Execute executes the request
func (a *DriveListApiService) DriveListItemsUpdateDriveItemContentExecute(r ApiDriveListItemsUpdateDriveItemContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListItemsUpdateDriveItemContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/items/{listItem-id}/driveItem/content"
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDriveListItemsUpdateFieldsRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	listItemId string
	microsoftGraphFieldValueSet *MicrosoftGraphFieldValueSet
}

// New navigation property values
func (r ApiDriveListItemsUpdateFieldsRequest) MicrosoftGraphFieldValueSet(microsoftGraphFieldValueSet MicrosoftGraphFieldValueSet) ApiDriveListItemsUpdateFieldsRequest {
	r.microsoftGraphFieldValueSet = &microsoftGraphFieldValueSet
	return r
}

func (r ApiDriveListItemsUpdateFieldsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DriveListItemsUpdateFieldsExecute(r)
}

/*
DriveListItemsUpdateFields Update the navigation property fields in drive

The values of the columns set on this list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listItemId key: id of listItem
 @return ApiDriveListItemsUpdateFieldsRequest
*/
func (a *DriveListApiService) DriveListItemsUpdateFields(ctx _context.Context, listItemId string) ApiDriveListItemsUpdateFieldsRequest {
	return ApiDriveListItemsUpdateFieldsRequest{
		ApiService: a,
		ctx: ctx,
		listItemId: listItemId,
	}
}

// Execute executes the request
func (a *DriveListApiService) DriveListItemsUpdateFieldsExecute(r ApiDriveListItemsUpdateFieldsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListItemsUpdateFields")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/items/{listItem-id}/fields"
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphFieldValueSet == nil {
		return nil, reportError("microsoftGraphFieldValueSet is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphFieldValueSet
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDriveListItemsUpdateRefAnalyticsRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	listItemId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiDriveListItemsUpdateRefAnalyticsRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiDriveListItemsUpdateRefAnalyticsRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiDriveListItemsUpdateRefAnalyticsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DriveListItemsUpdateRefAnalyticsExecute(r)
}

/*
DriveListItemsUpdateRefAnalytics Update the ref of navigation property analytics in drive

Analytics about the view activities that took place on this item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listItemId key: id of listItem
 @return ApiDriveListItemsUpdateRefAnalyticsRequest
*/
func (a *DriveListApiService) DriveListItemsUpdateRefAnalytics(ctx _context.Context, listItemId string) ApiDriveListItemsUpdateRefAnalyticsRequest {
	return ApiDriveListItemsUpdateRefAnalyticsRequest{
		ApiService: a,
		ctx: ctx,
		listItemId: listItemId,
	}
}

// Execute executes the request
func (a *DriveListApiService) DriveListItemsUpdateRefAnalyticsExecute(r ApiDriveListItemsUpdateRefAnalyticsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListItemsUpdateRefAnalytics")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/items/{listItem-id}/analytics/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDriveListItemsUpdateVersionsRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	listItemId string
	listItemVersionId string
	microsoftGraphListItemVersion *MicrosoftGraphListItemVersion
}

// New navigation property values
func (r ApiDriveListItemsUpdateVersionsRequest) MicrosoftGraphListItemVersion(microsoftGraphListItemVersion MicrosoftGraphListItemVersion) ApiDriveListItemsUpdateVersionsRequest {
	r.microsoftGraphListItemVersion = &microsoftGraphListItemVersion
	return r
}

func (r ApiDriveListItemsUpdateVersionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DriveListItemsUpdateVersionsExecute(r)
}

/*
DriveListItemsUpdateVersions Update the navigation property versions in drive

The list of previous versions of the list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listItemId key: id of listItem
 @param listItemVersionId key: id of listItemVersion
 @return ApiDriveListItemsUpdateVersionsRequest
*/
func (a *DriveListApiService) DriveListItemsUpdateVersions(ctx _context.Context, listItemId string, listItemVersionId string) ApiDriveListItemsUpdateVersionsRequest {
	return ApiDriveListItemsUpdateVersionsRequest{
		ApiService: a,
		ctx: ctx,
		listItemId: listItemId,
		listItemVersionId: listItemVersionId,
	}
}

// Execute executes the request
func (a *DriveListApiService) DriveListItemsUpdateVersionsExecute(r ApiDriveListItemsUpdateVersionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListItemsUpdateVersions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/items/{listItem-id}/versions/{listItemVersion-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItemVersion-id"+"}", _neturl.PathEscape(parameterToString(r.listItemVersionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphListItemVersion == nil {
		return nil, reportError("microsoftGraphListItemVersion is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphListItemVersion
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDriveListItemsVersionsDeleteFieldsRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	listItemId string
	listItemVersionId string
	ifMatch *string
}

// ETag
func (r ApiDriveListItemsVersionsDeleteFieldsRequest) IfMatch(ifMatch string) ApiDriveListItemsVersionsDeleteFieldsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDriveListItemsVersionsDeleteFieldsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DriveListItemsVersionsDeleteFieldsExecute(r)
}

/*
DriveListItemsVersionsDeleteFields Delete navigation property fields for drive

A collection of the fields and values for this version of the list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listItemId key: id of listItem
 @param listItemVersionId key: id of listItemVersion
 @return ApiDriveListItemsVersionsDeleteFieldsRequest
*/
func (a *DriveListApiService) DriveListItemsVersionsDeleteFields(ctx _context.Context, listItemId string, listItemVersionId string) ApiDriveListItemsVersionsDeleteFieldsRequest {
	return ApiDriveListItemsVersionsDeleteFieldsRequest{
		ApiService: a,
		ctx: ctx,
		listItemId: listItemId,
		listItemVersionId: listItemVersionId,
	}
}

// Execute executes the request
func (a *DriveListApiService) DriveListItemsVersionsDeleteFieldsExecute(r ApiDriveListItemsVersionsDeleteFieldsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListItemsVersionsDeleteFields")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/items/{listItem-id}/versions/{listItemVersion-id}/fields"
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItemVersion-id"+"}", _neturl.PathEscape(parameterToString(r.listItemVersionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDriveListItemsVersionsGetFieldsRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	listItemId string
	listItemVersionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDriveListItemsVersionsGetFieldsRequest) Select_(select_ []string) ApiDriveListItemsVersionsGetFieldsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDriveListItemsVersionsGetFieldsRequest) Expand(expand []string) ApiDriveListItemsVersionsGetFieldsRequest {
	r.expand = &expand
	return r
}

func (r ApiDriveListItemsVersionsGetFieldsRequest) Execute() (MicrosoftGraphFieldValueSet, *_nethttp.Response, error) {
	return r.ApiService.DriveListItemsVersionsGetFieldsExecute(r)
}

/*
DriveListItemsVersionsGetFields Get fields from drive

A collection of the fields and values for this version of the list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listItemId key: id of listItem
 @param listItemVersionId key: id of listItemVersion
 @return ApiDriveListItemsVersionsGetFieldsRequest
*/
func (a *DriveListApiService) DriveListItemsVersionsGetFields(ctx _context.Context, listItemId string, listItemVersionId string) ApiDriveListItemsVersionsGetFieldsRequest {
	return ApiDriveListItemsVersionsGetFieldsRequest{
		ApiService: a,
		ctx: ctx,
		listItemId: listItemId,
		listItemVersionId: listItemVersionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphFieldValueSet
func (a *DriveListApiService) DriveListItemsVersionsGetFieldsExecute(r ApiDriveListItemsVersionsGetFieldsRequest) (MicrosoftGraphFieldValueSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphFieldValueSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListItemsVersionsGetFields")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/items/{listItem-id}/versions/{listItemVersion-id}/fields"
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItemVersion-id"+"}", _neturl.PathEscape(parameterToString(r.listItemVersionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDriveListItemsVersionsUpdateFieldsRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	listItemId string
	listItemVersionId string
	microsoftGraphFieldValueSet *MicrosoftGraphFieldValueSet
}

// New navigation property values
func (r ApiDriveListItemsVersionsUpdateFieldsRequest) MicrosoftGraphFieldValueSet(microsoftGraphFieldValueSet MicrosoftGraphFieldValueSet) ApiDriveListItemsVersionsUpdateFieldsRequest {
	r.microsoftGraphFieldValueSet = &microsoftGraphFieldValueSet
	return r
}

func (r ApiDriveListItemsVersionsUpdateFieldsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DriveListItemsVersionsUpdateFieldsExecute(r)
}

/*
DriveListItemsVersionsUpdateFields Update the navigation property fields in drive

A collection of the fields and values for this version of the list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listItemId key: id of listItem
 @param listItemVersionId key: id of listItemVersion
 @return ApiDriveListItemsVersionsUpdateFieldsRequest
*/
func (a *DriveListApiService) DriveListItemsVersionsUpdateFields(ctx _context.Context, listItemId string, listItemVersionId string) ApiDriveListItemsVersionsUpdateFieldsRequest {
	return ApiDriveListItemsVersionsUpdateFieldsRequest{
		ApiService: a,
		ctx: ctx,
		listItemId: listItemId,
		listItemVersionId: listItemVersionId,
	}
}

// Execute executes the request
func (a *DriveListApiService) DriveListItemsVersionsUpdateFieldsExecute(r ApiDriveListItemsVersionsUpdateFieldsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListItemsVersionsUpdateFields")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/items/{listItem-id}/versions/{listItemVersion-id}/fields"
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItemVersion-id"+"}", _neturl.PathEscape(parameterToString(r.listItemVersionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphFieldValueSet == nil {
		return nil, reportError("microsoftGraphFieldValueSet is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphFieldValueSet
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDriveListListColumnsRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiDriveListListColumnsRequest) Top(top int32) ApiDriveListListColumnsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiDriveListListColumnsRequest) Skip(skip int32) ApiDriveListListColumnsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiDriveListListColumnsRequest) Search(search string) ApiDriveListListColumnsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiDriveListListColumnsRequest) Filter(filter string) ApiDriveListListColumnsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiDriveListListColumnsRequest) Count(count bool) ApiDriveListListColumnsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiDriveListListColumnsRequest) Orderby(orderby []string) ApiDriveListListColumnsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiDriveListListColumnsRequest) Select_(select_ []string) ApiDriveListListColumnsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDriveListListColumnsRequest) Expand(expand []string) ApiDriveListListColumnsRequest {
	r.expand = &expand
	return r
}

func (r ApiDriveListListColumnsRequest) Execute() (CollectionOfColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.DriveListListColumnsExecute(r)
}

/*
DriveListListColumns Get columns from drive

The collection of field definitions for this list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDriveListListColumnsRequest
*/
func (a *DriveListApiService) DriveListListColumns(ctx _context.Context) ApiDriveListListColumnsRequest {
	return ApiDriveListListColumnsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionOfColumnDefinition
func (a *DriveListApiService) DriveListListColumnsExecute(r ApiDriveListListColumnsRequest) (CollectionOfColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListListColumns")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/columns"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDriveListListContentTypesRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiDriveListListContentTypesRequest) Top(top int32) ApiDriveListListContentTypesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiDriveListListContentTypesRequest) Skip(skip int32) ApiDriveListListContentTypesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiDriveListListContentTypesRequest) Search(search string) ApiDriveListListContentTypesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiDriveListListContentTypesRequest) Filter(filter string) ApiDriveListListContentTypesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiDriveListListContentTypesRequest) Count(count bool) ApiDriveListListContentTypesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiDriveListListContentTypesRequest) Orderby(orderby []string) ApiDriveListListContentTypesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiDriveListListContentTypesRequest) Select_(select_ []string) ApiDriveListListContentTypesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDriveListListContentTypesRequest) Expand(expand []string) ApiDriveListListContentTypesRequest {
	r.expand = &expand
	return r
}

func (r ApiDriveListListContentTypesRequest) Execute() (CollectionOfContentType, *_nethttp.Response, error) {
	return r.ApiService.DriveListListContentTypesExecute(r)
}

/*
DriveListListContentTypes Get contentTypes from drive

The collection of content types present in this list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDriveListListContentTypesRequest
*/
func (a *DriveListApiService) DriveListListContentTypes(ctx _context.Context) ApiDriveListListContentTypesRequest {
	return ApiDriveListListContentTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionOfContentType
func (a *DriveListApiService) DriveListListContentTypesExecute(r ApiDriveListListContentTypesRequest) (CollectionOfContentType, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfContentType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListListContentTypes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/contentTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDriveListListItemsRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiDriveListListItemsRequest) Top(top int32) ApiDriveListListItemsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiDriveListListItemsRequest) Skip(skip int32) ApiDriveListListItemsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiDriveListListItemsRequest) Search(search string) ApiDriveListListItemsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiDriveListListItemsRequest) Filter(filter string) ApiDriveListListItemsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiDriveListListItemsRequest) Count(count bool) ApiDriveListListItemsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiDriveListListItemsRequest) Orderby(orderby []string) ApiDriveListListItemsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiDriveListListItemsRequest) Select_(select_ []string) ApiDriveListListItemsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDriveListListItemsRequest) Expand(expand []string) ApiDriveListListItemsRequest {
	r.expand = &expand
	return r
}

func (r ApiDriveListListItemsRequest) Execute() (CollectionOfListItem, *_nethttp.Response, error) {
	return r.ApiService.DriveListListItemsExecute(r)
}

/*
DriveListListItems Get items from drive

All items contained in the list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDriveListListItemsRequest
*/
func (a *DriveListApiService) DriveListListItems(ctx _context.Context) ApiDriveListListItemsRequest {
	return ApiDriveListListItemsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionOfListItem
func (a *DriveListApiService) DriveListListItemsExecute(r ApiDriveListListItemsRequest) (CollectionOfListItem, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfListItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListListItems")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/items"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDriveListListSubscriptionsRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiDriveListListSubscriptionsRequest) Top(top int32) ApiDriveListListSubscriptionsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiDriveListListSubscriptionsRequest) Skip(skip int32) ApiDriveListListSubscriptionsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiDriveListListSubscriptionsRequest) Search(search string) ApiDriveListListSubscriptionsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiDriveListListSubscriptionsRequest) Filter(filter string) ApiDriveListListSubscriptionsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiDriveListListSubscriptionsRequest) Count(count bool) ApiDriveListListSubscriptionsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiDriveListListSubscriptionsRequest) Orderby(orderby []string) ApiDriveListListSubscriptionsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiDriveListListSubscriptionsRequest) Select_(select_ []string) ApiDriveListListSubscriptionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDriveListListSubscriptionsRequest) Expand(expand []string) ApiDriveListListSubscriptionsRequest {
	r.expand = &expand
	return r
}

func (r ApiDriveListListSubscriptionsRequest) Execute() (CollectionOfSubscription, *_nethttp.Response, error) {
	return r.ApiService.DriveListListSubscriptionsExecute(r)
}

/*
DriveListListSubscriptions Get subscriptions from drive

The set of subscriptions on the list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDriveListListSubscriptionsRequest
*/
func (a *DriveListApiService) DriveListListSubscriptions(ctx _context.Context) ApiDriveListListSubscriptionsRequest {
	return ApiDriveListListSubscriptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionOfSubscription
func (a *DriveListApiService) DriveListListSubscriptionsExecute(r ApiDriveListListSubscriptionsRequest) (CollectionOfSubscription, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfSubscription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListListSubscriptions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/subscriptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDriveListUpdateColumnsRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	columnDefinitionId string
	microsoftGraphColumnDefinition *MicrosoftGraphColumnDefinition
}

// New navigation property values
func (r ApiDriveListUpdateColumnsRequest) MicrosoftGraphColumnDefinition(microsoftGraphColumnDefinition MicrosoftGraphColumnDefinition) ApiDriveListUpdateColumnsRequest {
	r.microsoftGraphColumnDefinition = &microsoftGraphColumnDefinition
	return r
}

func (r ApiDriveListUpdateColumnsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DriveListUpdateColumnsExecute(r)
}

/*
DriveListUpdateColumns Update the navigation property columns in drive

The collection of field definitions for this list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param columnDefinitionId key: id of columnDefinition
 @return ApiDriveListUpdateColumnsRequest
*/
func (a *DriveListApiService) DriveListUpdateColumns(ctx _context.Context, columnDefinitionId string) ApiDriveListUpdateColumnsRequest {
	return ApiDriveListUpdateColumnsRequest{
		ApiService: a,
		ctx: ctx,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
func (a *DriveListApiService) DriveListUpdateColumnsExecute(r ApiDriveListUpdateColumnsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListUpdateColumns")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/columns/{columnDefinition-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphColumnDefinition == nil {
		return nil, reportError("microsoftGraphColumnDefinition is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphColumnDefinition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDriveListUpdateContentTypesRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	contentTypeId string
	microsoftGraphContentType *MicrosoftGraphContentType
}

// New navigation property values
func (r ApiDriveListUpdateContentTypesRequest) MicrosoftGraphContentType(microsoftGraphContentType MicrosoftGraphContentType) ApiDriveListUpdateContentTypesRequest {
	r.microsoftGraphContentType = &microsoftGraphContentType
	return r
}

func (r ApiDriveListUpdateContentTypesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DriveListUpdateContentTypesExecute(r)
}

/*
DriveListUpdateContentTypes Update the navigation property contentTypes in drive

The collection of content types present in this list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentTypeId key: id of contentType
 @return ApiDriveListUpdateContentTypesRequest
*/
func (a *DriveListApiService) DriveListUpdateContentTypes(ctx _context.Context, contentTypeId string) ApiDriveListUpdateContentTypesRequest {
	return ApiDriveListUpdateContentTypesRequest{
		ApiService: a,
		ctx: ctx,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
func (a *DriveListApiService) DriveListUpdateContentTypesExecute(r ApiDriveListUpdateContentTypesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListUpdateContentTypes")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/contentTypes/{contentType-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphContentType == nil {
		return nil, reportError("microsoftGraphContentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphContentType
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDriveListUpdateDriveRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	microsoftGraphDrive *MicrosoftGraphDrive
}

// New navigation property values
func (r ApiDriveListUpdateDriveRequest) MicrosoftGraphDrive(microsoftGraphDrive MicrosoftGraphDrive) ApiDriveListUpdateDriveRequest {
	r.microsoftGraphDrive = &microsoftGraphDrive
	return r
}

func (r ApiDriveListUpdateDriveRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DriveListUpdateDriveExecute(r)
}

/*
DriveListUpdateDrive Update the navigation property drive in drive

Only present on document libraries. Allows access to the list as a [drive][] resource with [driveItems][driveItem].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDriveListUpdateDriveRequest
*/
func (a *DriveListApiService) DriveListUpdateDrive(ctx _context.Context) ApiDriveListUpdateDriveRequest {
	return ApiDriveListUpdateDriveRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DriveListApiService) DriveListUpdateDriveExecute(r ApiDriveListUpdateDriveRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListUpdateDrive")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/drive"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphDrive == nil {
		return nil, reportError("microsoftGraphDrive is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphDrive
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDriveListUpdateItemsRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	listItemId string
	microsoftGraphListItem *MicrosoftGraphListItem
}

// New navigation property values
func (r ApiDriveListUpdateItemsRequest) MicrosoftGraphListItem(microsoftGraphListItem MicrosoftGraphListItem) ApiDriveListUpdateItemsRequest {
	r.microsoftGraphListItem = &microsoftGraphListItem
	return r
}

func (r ApiDriveListUpdateItemsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DriveListUpdateItemsExecute(r)
}

/*
DriveListUpdateItems Update the navigation property items in drive

All items contained in the list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listItemId key: id of listItem
 @return ApiDriveListUpdateItemsRequest
*/
func (a *DriveListApiService) DriveListUpdateItems(ctx _context.Context, listItemId string) ApiDriveListUpdateItemsRequest {
	return ApiDriveListUpdateItemsRequest{
		ApiService: a,
		ctx: ctx,
		listItemId: listItemId,
	}
}

// Execute executes the request
func (a *DriveListApiService) DriveListUpdateItemsExecute(r ApiDriveListUpdateItemsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListUpdateItems")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/items/{listItem-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphListItem == nil {
		return nil, reportError("microsoftGraphListItem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphListItem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDriveListUpdateSubscriptionsRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	subscriptionId string
	microsoftGraphSubscription *MicrosoftGraphSubscription
}

// New navigation property values
func (r ApiDriveListUpdateSubscriptionsRequest) MicrosoftGraphSubscription(microsoftGraphSubscription MicrosoftGraphSubscription) ApiDriveListUpdateSubscriptionsRequest {
	r.microsoftGraphSubscription = &microsoftGraphSubscription
	return r
}

func (r ApiDriveListUpdateSubscriptionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DriveListUpdateSubscriptionsExecute(r)
}

/*
DriveListUpdateSubscriptions Update the navigation property subscriptions in drive

The set of subscriptions on the list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param subscriptionId key: id of subscription
 @return ApiDriveListUpdateSubscriptionsRequest
*/
func (a *DriveListApiService) DriveListUpdateSubscriptions(ctx _context.Context, subscriptionId string) ApiDriveListUpdateSubscriptionsRequest {
	return ApiDriveListUpdateSubscriptionsRequest{
		ApiService: a,
		ctx: ctx,
		subscriptionId: subscriptionId,
	}
}

// Execute executes the request
func (a *DriveListApiService) DriveListUpdateSubscriptionsExecute(r ApiDriveListUpdateSubscriptionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveListUpdateSubscriptions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list/subscriptions/{subscription-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"subscription-id"+"}", _neturl.PathEscape(parameterToString(r.subscriptionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphSubscription == nil {
		return nil, reportError("microsoftGraphSubscription is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphSubscription
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDriveUpdateListRequest struct {
	ctx _context.Context
	ApiService *DriveListApiService
	microsoftGraphList *MicrosoftGraphList
}

// New navigation property values
func (r ApiDriveUpdateListRequest) MicrosoftGraphList(microsoftGraphList MicrosoftGraphList) ApiDriveUpdateListRequest {
	r.microsoftGraphList = &microsoftGraphList
	return r
}

func (r ApiDriveUpdateListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DriveUpdateListExecute(r)
}

/*
DriveUpdateList Update the navigation property list in drive

For drives in SharePoint, the underlying document library list. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDriveUpdateListRequest
*/
func (a *DriveListApiService) DriveUpdateList(ctx _context.Context) ApiDriveUpdateListRequest {
	return ApiDriveUpdateListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DriveListApiService) DriveUpdateListExecute(r ApiDriveUpdateListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DriveListApiService.DriveUpdateList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drive/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphList == nil {
		return nil, reportError("microsoftGraphList is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphList
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
