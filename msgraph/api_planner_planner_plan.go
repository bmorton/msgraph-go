/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// PlannerPlannerPlanApiService PlannerPlannerPlanApi service
type PlannerPlannerPlanApiService service

type ApiPlannerCreatePlansRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerPlanApiService
	microsoftGraphPlannerPlan *MicrosoftGraphPlannerPlan
}

// New navigation property
func (r ApiPlannerCreatePlansRequest) MicrosoftGraphPlannerPlan(microsoftGraphPlannerPlan MicrosoftGraphPlannerPlan) ApiPlannerCreatePlansRequest {
	r.microsoftGraphPlannerPlan = &microsoftGraphPlannerPlan
	return r
}

func (r ApiPlannerCreatePlansRequest) Execute() (MicrosoftGraphPlannerPlan, *_nethttp.Response, error) {
	return r.ApiService.PlannerCreatePlansExecute(r)
}

/*
PlannerCreatePlans Create new navigation property to plans for planner

Read-only. Nullable. Returns a collection of the specified plans

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPlannerCreatePlansRequest
*/
func (a *PlannerPlannerPlanApiService) PlannerCreatePlans(ctx _context.Context) ApiPlannerCreatePlansRequest {
	return ApiPlannerCreatePlansRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerPlan
func (a *PlannerPlannerPlanApiService) PlannerCreatePlansExecute(r ApiPlannerCreatePlansRequest) (MicrosoftGraphPlannerPlan, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerPlan
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerPlanApiService.PlannerCreatePlans")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/plans"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerPlan == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphPlannerPlan is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerPlan
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlannerDeletePlansRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerPlanApiService
	plannerPlanId string
	ifMatch *string
}

// ETag
func (r ApiPlannerDeletePlansRequest) IfMatch(ifMatch string) ApiPlannerDeletePlansRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiPlannerDeletePlansRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PlannerDeletePlansExecute(r)
}

/*
PlannerDeletePlans Delete navigation property plans for planner

Read-only. Nullable. Returns a collection of the specified plans

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @return ApiPlannerDeletePlansRequest
*/
func (a *PlannerPlannerPlanApiService) PlannerDeletePlans(ctx _context.Context, plannerPlanId string) ApiPlannerDeletePlansRequest {
	return ApiPlannerDeletePlansRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
	}
}

// Execute executes the request
func (a *PlannerPlannerPlanApiService) PlannerDeletePlansExecute(r ApiPlannerDeletePlansRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerPlanApiService.PlannerDeletePlans")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/plans/{plannerPlan-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPlannerGetPlansRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerPlanApiService
	plannerPlanId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiPlannerGetPlansRequest) Select_(select_ []string) ApiPlannerGetPlansRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiPlannerGetPlansRequest) Expand(expand []string) ApiPlannerGetPlansRequest {
	r.expand = &expand
	return r
}

func (r ApiPlannerGetPlansRequest) Execute() (MicrosoftGraphPlannerPlan, *_nethttp.Response, error) {
	return r.ApiService.PlannerGetPlansExecute(r)
}

/*
PlannerGetPlans Get plans from planner

Read-only. Nullable. Returns a collection of the specified plans

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @return ApiPlannerGetPlansRequest
*/
func (a *PlannerPlannerPlanApiService) PlannerGetPlans(ctx _context.Context, plannerPlanId string) ApiPlannerGetPlansRequest {
	return ApiPlannerGetPlansRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerPlan
func (a *PlannerPlannerPlanApiService) PlannerGetPlansExecute(r ApiPlannerGetPlansRequest) (MicrosoftGraphPlannerPlan, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerPlan
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerPlanApiService.PlannerGetPlans")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/plans/{plannerPlan-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlannerListPlansRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerPlanApiService
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiPlannerListPlansRequest) Top(top int32) ApiPlannerListPlansRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiPlannerListPlansRequest) Skip(skip int32) ApiPlannerListPlansRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiPlannerListPlansRequest) Search(search string) ApiPlannerListPlansRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiPlannerListPlansRequest) Filter(filter string) ApiPlannerListPlansRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiPlannerListPlansRequest) Count(count bool) ApiPlannerListPlansRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiPlannerListPlansRequest) Orderby(orderby []string) ApiPlannerListPlansRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiPlannerListPlansRequest) Select_(select_ []string) ApiPlannerListPlansRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiPlannerListPlansRequest) Expand(expand []string) ApiPlannerListPlansRequest {
	r.expand = &expand
	return r
}

func (r ApiPlannerListPlansRequest) Execute() (CollectionOfPlannerPlan, *_nethttp.Response, error) {
	return r.ApiService.PlannerListPlansExecute(r)
}

/*
PlannerListPlans Get plans from planner

Read-only. Nullable. Returns a collection of the specified plans

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPlannerListPlansRequest
*/
func (a *PlannerPlannerPlanApiService) PlannerListPlans(ctx _context.Context) ApiPlannerListPlansRequest {
	return ApiPlannerListPlansRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionOfPlannerPlan
func (a *PlannerPlannerPlanApiService) PlannerListPlansExecute(r ApiPlannerListPlansRequest) (CollectionOfPlannerPlan, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfPlannerPlan
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerPlanApiService.PlannerListPlans")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/plans"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlannerPlansBucketsCreateTasksRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerPlanApiService
	plannerPlanId string
	plannerBucketId string
	microsoftGraphPlannerTask *MicrosoftGraphPlannerTask
}

// New navigation property
func (r ApiPlannerPlansBucketsCreateTasksRequest) MicrosoftGraphPlannerTask(microsoftGraphPlannerTask MicrosoftGraphPlannerTask) ApiPlannerPlansBucketsCreateTasksRequest {
	r.microsoftGraphPlannerTask = &microsoftGraphPlannerTask
	return r
}

func (r ApiPlannerPlansBucketsCreateTasksRequest) Execute() (MicrosoftGraphPlannerTask, *_nethttp.Response, error) {
	return r.ApiService.PlannerPlansBucketsCreateTasksExecute(r)
}

/*
PlannerPlansBucketsCreateTasks Create new navigation property to tasks for planner

Read-only. Nullable. The collection of tasks in the bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @return ApiPlannerPlansBucketsCreateTasksRequest
*/
func (a *PlannerPlannerPlanApiService) PlannerPlansBucketsCreateTasks(ctx _context.Context, plannerPlanId string, plannerBucketId string) ApiPlannerPlansBucketsCreateTasksRequest {
	return ApiPlannerPlansBucketsCreateTasksRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerTask
func (a *PlannerPlannerPlanApiService) PlannerPlansBucketsCreateTasksExecute(r ApiPlannerPlansBucketsCreateTasksRequest) (MicrosoftGraphPlannerTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerPlanApiService.PlannerPlansBucketsCreateTasks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerTask == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphPlannerTask is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerTask
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlannerPlansBucketsDeleteTasksRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerPlanApiService
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiPlannerPlansBucketsDeleteTasksRequest) IfMatch(ifMatch string) ApiPlannerPlansBucketsDeleteTasksRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiPlannerPlansBucketsDeleteTasksRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PlannerPlansBucketsDeleteTasksExecute(r)
}

/*
PlannerPlansBucketsDeleteTasks Delete navigation property tasks for planner

Read-only. Nullable. The collection of tasks in the bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiPlannerPlansBucketsDeleteTasksRequest
*/
func (a *PlannerPlannerPlanApiService) PlannerPlansBucketsDeleteTasks(ctx _context.Context, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiPlannerPlansBucketsDeleteTasksRequest {
	return ApiPlannerPlansBucketsDeleteTasksRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *PlannerPlannerPlanApiService) PlannerPlansBucketsDeleteTasksExecute(r ApiPlannerPlansBucketsDeleteTasksRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerPlanApiService.PlannerPlansBucketsDeleteTasks")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPlannerPlansBucketsGetTasksRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerPlanApiService
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiPlannerPlansBucketsGetTasksRequest) Select_(select_ []string) ApiPlannerPlansBucketsGetTasksRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiPlannerPlansBucketsGetTasksRequest) Expand(expand []string) ApiPlannerPlansBucketsGetTasksRequest {
	r.expand = &expand
	return r
}

func (r ApiPlannerPlansBucketsGetTasksRequest) Execute() (MicrosoftGraphPlannerTask, *_nethttp.Response, error) {
	return r.ApiService.PlannerPlansBucketsGetTasksExecute(r)
}

/*
PlannerPlansBucketsGetTasks Get tasks from planner

Read-only. Nullable. The collection of tasks in the bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiPlannerPlansBucketsGetTasksRequest
*/
func (a *PlannerPlannerPlanApiService) PlannerPlansBucketsGetTasks(ctx _context.Context, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiPlannerPlansBucketsGetTasksRequest {
	return ApiPlannerPlansBucketsGetTasksRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerTask
func (a *PlannerPlannerPlanApiService) PlannerPlansBucketsGetTasksExecute(r ApiPlannerPlansBucketsGetTasksRequest) (MicrosoftGraphPlannerTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerPlanApiService.PlannerPlansBucketsGetTasks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlannerPlansBucketsListTasksRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerPlanApiService
	plannerPlanId string
	plannerBucketId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiPlannerPlansBucketsListTasksRequest) Top(top int32) ApiPlannerPlansBucketsListTasksRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiPlannerPlansBucketsListTasksRequest) Skip(skip int32) ApiPlannerPlansBucketsListTasksRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiPlannerPlansBucketsListTasksRequest) Search(search string) ApiPlannerPlansBucketsListTasksRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiPlannerPlansBucketsListTasksRequest) Filter(filter string) ApiPlannerPlansBucketsListTasksRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiPlannerPlansBucketsListTasksRequest) Count(count bool) ApiPlannerPlansBucketsListTasksRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiPlannerPlansBucketsListTasksRequest) Orderby(orderby []string) ApiPlannerPlansBucketsListTasksRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiPlannerPlansBucketsListTasksRequest) Select_(select_ []string) ApiPlannerPlansBucketsListTasksRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiPlannerPlansBucketsListTasksRequest) Expand(expand []string) ApiPlannerPlansBucketsListTasksRequest {
	r.expand = &expand
	return r
}

func (r ApiPlannerPlansBucketsListTasksRequest) Execute() (CollectionOfPlannerTask, *_nethttp.Response, error) {
	return r.ApiService.PlannerPlansBucketsListTasksExecute(r)
}

/*
PlannerPlansBucketsListTasks Get tasks from planner

Read-only. Nullable. The collection of tasks in the bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @return ApiPlannerPlansBucketsListTasksRequest
*/
func (a *PlannerPlannerPlanApiService) PlannerPlansBucketsListTasks(ctx _context.Context, plannerPlanId string, plannerBucketId string) ApiPlannerPlansBucketsListTasksRequest {
	return ApiPlannerPlansBucketsListTasksRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
	}
}

// Execute executes the request
//  @return CollectionOfPlannerTask
func (a *PlannerPlannerPlanApiService) PlannerPlansBucketsListTasksExecute(r ApiPlannerPlansBucketsListTasksRequest) (CollectionOfPlannerTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfPlannerTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerPlanApiService.PlannerPlansBucketsListTasks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerPlanApiService
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiPlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormatRequest) IfMatch(ifMatch string) ApiPlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormatRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiPlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormatExecute(r)
}

/*
PlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormat Delete navigation property assignedToTaskBoardFormat for planner

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by assignedTo.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiPlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormatRequest
*/
func (a *PlannerPlannerPlanApiService) PlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormat(ctx _context.Context, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiPlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormatRequest {
	return ApiPlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *PlannerPlannerPlanApiService) PlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormatExecute(r ApiPlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerPlanApiService.PlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPlannerPlansBucketsTasksDeleteBucketTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerPlanApiService
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiPlannerPlansBucketsTasksDeleteBucketTaskBoardFormatRequest) IfMatch(ifMatch string) ApiPlannerPlansBucketsTasksDeleteBucketTaskBoardFormatRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiPlannerPlansBucketsTasksDeleteBucketTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PlannerPlansBucketsTasksDeleteBucketTaskBoardFormatExecute(r)
}

/*
PlannerPlansBucketsTasksDeleteBucketTaskBoardFormat Delete navigation property bucketTaskBoardFormat for planner

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiPlannerPlansBucketsTasksDeleteBucketTaskBoardFormatRequest
*/
func (a *PlannerPlannerPlanApiService) PlannerPlansBucketsTasksDeleteBucketTaskBoardFormat(ctx _context.Context, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiPlannerPlansBucketsTasksDeleteBucketTaskBoardFormatRequest {
	return ApiPlannerPlansBucketsTasksDeleteBucketTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *PlannerPlannerPlanApiService) PlannerPlansBucketsTasksDeleteBucketTaskBoardFormatExecute(r ApiPlannerPlansBucketsTasksDeleteBucketTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerPlanApiService.PlannerPlansBucketsTasksDeleteBucketTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPlannerPlansBucketsTasksDeleteDetailsRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerPlanApiService
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiPlannerPlansBucketsTasksDeleteDetailsRequest) IfMatch(ifMatch string) ApiPlannerPlansBucketsTasksDeleteDetailsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiPlannerPlansBucketsTasksDeleteDetailsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PlannerPlansBucketsTasksDeleteDetailsExecute(r)
}

/*
PlannerPlansBucketsTasksDeleteDetails Delete navigation property details for planner

Read-only. Nullable. Additional details about the task.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiPlannerPlansBucketsTasksDeleteDetailsRequest
*/
func (a *PlannerPlannerPlanApiService) PlannerPlansBucketsTasksDeleteDetails(ctx _context.Context, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiPlannerPlansBucketsTasksDeleteDetailsRequest {
	return ApiPlannerPlansBucketsTasksDeleteDetailsRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *PlannerPlannerPlanApiService) PlannerPlansBucketsTasksDeleteDetailsExecute(r ApiPlannerPlansBucketsTasksDeleteDetailsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerPlanApiService.PlannerPlansBucketsTasksDeleteDetails")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPlannerPlansBucketsTasksDeleteProgressTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerPlanApiService
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiPlannerPlansBucketsTasksDeleteProgressTaskBoardFormatRequest) IfMatch(ifMatch string) ApiPlannerPlansBucketsTasksDeleteProgressTaskBoardFormatRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiPlannerPlansBucketsTasksDeleteProgressTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PlannerPlansBucketsTasksDeleteProgressTaskBoardFormatExecute(r)
}

/*
PlannerPlansBucketsTasksDeleteProgressTaskBoardFormat Delete navigation property progressTaskBoardFormat for planner

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by progress.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiPlannerPlansBucketsTasksDeleteProgressTaskBoardFormatRequest
*/
func (a *PlannerPlannerPlanApiService) PlannerPlansBucketsTasksDeleteProgressTaskBoardFormat(ctx _context.Context, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiPlannerPlansBucketsTasksDeleteProgressTaskBoardFormatRequest {
	return ApiPlannerPlansBucketsTasksDeleteProgressTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *PlannerPlannerPlanApiService) PlannerPlansBucketsTasksDeleteProgressTaskBoardFormatExecute(r ApiPlannerPlansBucketsTasksDeleteProgressTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerPlanApiService.PlannerPlansBucketsTasksDeleteProgressTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/progressTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPlannerPlansBucketsTasksGetAssignedToTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerPlanApiService
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiPlannerPlansBucketsTasksGetAssignedToTaskBoardFormatRequest) Select_(select_ []string) ApiPlannerPlansBucketsTasksGetAssignedToTaskBoardFormatRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiPlannerPlansBucketsTasksGetAssignedToTaskBoardFormatRequest) Expand(expand []string) ApiPlannerPlansBucketsTasksGetAssignedToTaskBoardFormatRequest {
	r.expand = &expand
	return r
}

func (r ApiPlannerPlansBucketsTasksGetAssignedToTaskBoardFormatRequest) Execute() (MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat, *_nethttp.Response, error) {
	return r.ApiService.PlannerPlansBucketsTasksGetAssignedToTaskBoardFormatExecute(r)
}

/*
PlannerPlansBucketsTasksGetAssignedToTaskBoardFormat Get assignedToTaskBoardFormat from planner

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by assignedTo.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiPlannerPlansBucketsTasksGetAssignedToTaskBoardFormatRequest
*/
func (a *PlannerPlannerPlanApiService) PlannerPlansBucketsTasksGetAssignedToTaskBoardFormat(ctx _context.Context, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiPlannerPlansBucketsTasksGetAssignedToTaskBoardFormatRequest {
	return ApiPlannerPlansBucketsTasksGetAssignedToTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat
func (a *PlannerPlannerPlanApiService) PlannerPlansBucketsTasksGetAssignedToTaskBoardFormatExecute(r ApiPlannerPlansBucketsTasksGetAssignedToTaskBoardFormatRequest) (MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerPlanApiService.PlannerPlansBucketsTasksGetAssignedToTaskBoardFormat")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlannerPlansBucketsTasksGetBucketTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerPlanApiService
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiPlannerPlansBucketsTasksGetBucketTaskBoardFormatRequest) Select_(select_ []string) ApiPlannerPlansBucketsTasksGetBucketTaskBoardFormatRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiPlannerPlansBucketsTasksGetBucketTaskBoardFormatRequest) Expand(expand []string) ApiPlannerPlansBucketsTasksGetBucketTaskBoardFormatRequest {
	r.expand = &expand
	return r
}

func (r ApiPlannerPlansBucketsTasksGetBucketTaskBoardFormatRequest) Execute() (MicrosoftGraphPlannerBucketTaskBoardTaskFormat, *_nethttp.Response, error) {
	return r.ApiService.PlannerPlansBucketsTasksGetBucketTaskBoardFormatExecute(r)
}

/*
PlannerPlansBucketsTasksGetBucketTaskBoardFormat Get bucketTaskBoardFormat from planner

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiPlannerPlansBucketsTasksGetBucketTaskBoardFormatRequest
*/
func (a *PlannerPlannerPlanApiService) PlannerPlansBucketsTasksGetBucketTaskBoardFormat(ctx _context.Context, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiPlannerPlansBucketsTasksGetBucketTaskBoardFormatRequest {
	return ApiPlannerPlansBucketsTasksGetBucketTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerBucketTaskBoardTaskFormat
func (a *PlannerPlannerPlanApiService) PlannerPlansBucketsTasksGetBucketTaskBoardFormatExecute(r ApiPlannerPlansBucketsTasksGetBucketTaskBoardFormatRequest) (MicrosoftGraphPlannerBucketTaskBoardTaskFormat, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerBucketTaskBoardTaskFormat
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerPlanApiService.PlannerPlansBucketsTasksGetBucketTaskBoardFormat")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlannerPlansBucketsTasksGetDetailsRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerPlanApiService
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiPlannerPlansBucketsTasksGetDetailsRequest) Select_(select_ []string) ApiPlannerPlansBucketsTasksGetDetailsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiPlannerPlansBucketsTasksGetDetailsRequest) Expand(expand []string) ApiPlannerPlansBucketsTasksGetDetailsRequest {
	r.expand = &expand
	return r
}

func (r ApiPlannerPlansBucketsTasksGetDetailsRequest) Execute() (MicrosoftGraphPlannerTaskDetails, *_nethttp.Response, error) {
	return r.ApiService.PlannerPlansBucketsTasksGetDetailsExecute(r)
}

/*
PlannerPlansBucketsTasksGetDetails Get details from planner

Read-only. Nullable. Additional details about the task.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiPlannerPlansBucketsTasksGetDetailsRequest
*/
func (a *PlannerPlannerPlanApiService) PlannerPlansBucketsTasksGetDetails(ctx _context.Context, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiPlannerPlansBucketsTasksGetDetailsRequest {
	return ApiPlannerPlansBucketsTasksGetDetailsRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerTaskDetails
func (a *PlannerPlannerPlanApiService) PlannerPlansBucketsTasksGetDetailsExecute(r ApiPlannerPlansBucketsTasksGetDetailsRequest) (MicrosoftGraphPlannerTaskDetails, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerTaskDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerPlanApiService.PlannerPlansBucketsTasksGetDetails")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlannerPlansBucketsTasksGetProgressTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerPlanApiService
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiPlannerPlansBucketsTasksGetProgressTaskBoardFormatRequest) Select_(select_ []string) ApiPlannerPlansBucketsTasksGetProgressTaskBoardFormatRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiPlannerPlansBucketsTasksGetProgressTaskBoardFormatRequest) Expand(expand []string) ApiPlannerPlansBucketsTasksGetProgressTaskBoardFormatRequest {
	r.expand = &expand
	return r
}

func (r ApiPlannerPlansBucketsTasksGetProgressTaskBoardFormatRequest) Execute() (MicrosoftGraphPlannerProgressTaskBoardTaskFormat, *_nethttp.Response, error) {
	return r.ApiService.PlannerPlansBucketsTasksGetProgressTaskBoardFormatExecute(r)
}

/*
PlannerPlansBucketsTasksGetProgressTaskBoardFormat Get progressTaskBoardFormat from planner

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by progress.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiPlannerPlansBucketsTasksGetProgressTaskBoardFormatRequest
*/
func (a *PlannerPlannerPlanApiService) PlannerPlansBucketsTasksGetProgressTaskBoardFormat(ctx _context.Context, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiPlannerPlansBucketsTasksGetProgressTaskBoardFormatRequest {
	return ApiPlannerPlansBucketsTasksGetProgressTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerProgressTaskBoardTaskFormat
func (a *PlannerPlannerPlanApiService) PlannerPlansBucketsTasksGetProgressTaskBoardFormatExecute(r ApiPlannerPlansBucketsTasksGetProgressTaskBoardFormatRequest) (MicrosoftGraphPlannerProgressTaskBoardTaskFormat, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerProgressTaskBoardTaskFormat
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerPlanApiService.PlannerPlansBucketsTasksGetProgressTaskBoardFormat")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/progressTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerPlanApiService
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	microsoftGraphPlannerAssignedToTaskBoardTaskFormat *MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat
}

// New navigation property values
func (r ApiPlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormatRequest) MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat(microsoftGraphPlannerAssignedToTaskBoardTaskFormat MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat) ApiPlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormatRequest {
	r.microsoftGraphPlannerAssignedToTaskBoardTaskFormat = &microsoftGraphPlannerAssignedToTaskBoardTaskFormat
	return r
}

func (r ApiPlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormatExecute(r)
}

/*
PlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormat Update the navigation property assignedToTaskBoardFormat in planner

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by assignedTo.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiPlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormatRequest
*/
func (a *PlannerPlannerPlanApiService) PlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormat(ctx _context.Context, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiPlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormatRequest {
	return ApiPlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *PlannerPlannerPlanApiService) PlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormatExecute(r ApiPlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerPlanApiService.PlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerAssignedToTaskBoardTaskFormat == nil {
		return nil, reportError("microsoftGraphPlannerAssignedToTaskBoardTaskFormat is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerAssignedToTaskBoardTaskFormat
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPlannerPlansBucketsTasksUpdateBucketTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerPlanApiService
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	microsoftGraphPlannerBucketTaskBoardTaskFormat *MicrosoftGraphPlannerBucketTaskBoardTaskFormat
}

// New navigation property values
func (r ApiPlannerPlansBucketsTasksUpdateBucketTaskBoardFormatRequest) MicrosoftGraphPlannerBucketTaskBoardTaskFormat(microsoftGraphPlannerBucketTaskBoardTaskFormat MicrosoftGraphPlannerBucketTaskBoardTaskFormat) ApiPlannerPlansBucketsTasksUpdateBucketTaskBoardFormatRequest {
	r.microsoftGraphPlannerBucketTaskBoardTaskFormat = &microsoftGraphPlannerBucketTaskBoardTaskFormat
	return r
}

func (r ApiPlannerPlansBucketsTasksUpdateBucketTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PlannerPlansBucketsTasksUpdateBucketTaskBoardFormatExecute(r)
}

/*
PlannerPlansBucketsTasksUpdateBucketTaskBoardFormat Update the navigation property bucketTaskBoardFormat in planner

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiPlannerPlansBucketsTasksUpdateBucketTaskBoardFormatRequest
*/
func (a *PlannerPlannerPlanApiService) PlannerPlansBucketsTasksUpdateBucketTaskBoardFormat(ctx _context.Context, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiPlannerPlansBucketsTasksUpdateBucketTaskBoardFormatRequest {
	return ApiPlannerPlansBucketsTasksUpdateBucketTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *PlannerPlannerPlanApiService) PlannerPlansBucketsTasksUpdateBucketTaskBoardFormatExecute(r ApiPlannerPlansBucketsTasksUpdateBucketTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerPlanApiService.PlannerPlansBucketsTasksUpdateBucketTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerBucketTaskBoardTaskFormat == nil {
		return nil, reportError("microsoftGraphPlannerBucketTaskBoardTaskFormat is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerBucketTaskBoardTaskFormat
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPlannerPlansBucketsTasksUpdateDetailsRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerPlanApiService
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	microsoftGraphPlannerTaskDetails *MicrosoftGraphPlannerTaskDetails
}

// New navigation property values
func (r ApiPlannerPlansBucketsTasksUpdateDetailsRequest) MicrosoftGraphPlannerTaskDetails(microsoftGraphPlannerTaskDetails MicrosoftGraphPlannerTaskDetails) ApiPlannerPlansBucketsTasksUpdateDetailsRequest {
	r.microsoftGraphPlannerTaskDetails = &microsoftGraphPlannerTaskDetails
	return r
}

func (r ApiPlannerPlansBucketsTasksUpdateDetailsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PlannerPlansBucketsTasksUpdateDetailsExecute(r)
}

/*
PlannerPlansBucketsTasksUpdateDetails Update the navigation property details in planner

Read-only. Nullable. Additional details about the task.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiPlannerPlansBucketsTasksUpdateDetailsRequest
*/
func (a *PlannerPlannerPlanApiService) PlannerPlansBucketsTasksUpdateDetails(ctx _context.Context, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiPlannerPlansBucketsTasksUpdateDetailsRequest {
	return ApiPlannerPlansBucketsTasksUpdateDetailsRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *PlannerPlannerPlanApiService) PlannerPlansBucketsTasksUpdateDetailsExecute(r ApiPlannerPlansBucketsTasksUpdateDetailsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerPlanApiService.PlannerPlansBucketsTasksUpdateDetails")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerTaskDetails == nil {
		return nil, reportError("microsoftGraphPlannerTaskDetails is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerTaskDetails
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPlannerPlansBucketsTasksUpdateProgressTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerPlanApiService
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	microsoftGraphPlannerProgressTaskBoardTaskFormat *MicrosoftGraphPlannerProgressTaskBoardTaskFormat
}

// New navigation property values
func (r ApiPlannerPlansBucketsTasksUpdateProgressTaskBoardFormatRequest) MicrosoftGraphPlannerProgressTaskBoardTaskFormat(microsoftGraphPlannerProgressTaskBoardTaskFormat MicrosoftGraphPlannerProgressTaskBoardTaskFormat) ApiPlannerPlansBucketsTasksUpdateProgressTaskBoardFormatRequest {
	r.microsoftGraphPlannerProgressTaskBoardTaskFormat = &microsoftGraphPlannerProgressTaskBoardTaskFormat
	return r
}

func (r ApiPlannerPlansBucketsTasksUpdateProgressTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PlannerPlansBucketsTasksUpdateProgressTaskBoardFormatExecute(r)
}

/*
PlannerPlansBucketsTasksUpdateProgressTaskBoardFormat Update the navigation property progressTaskBoardFormat in planner

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by progress.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiPlannerPlansBucketsTasksUpdateProgressTaskBoardFormatRequest
*/
func (a *PlannerPlannerPlanApiService) PlannerPlansBucketsTasksUpdateProgressTaskBoardFormat(ctx _context.Context, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiPlannerPlansBucketsTasksUpdateProgressTaskBoardFormatRequest {
	return ApiPlannerPlansBucketsTasksUpdateProgressTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *PlannerPlannerPlanApiService) PlannerPlansBucketsTasksUpdateProgressTaskBoardFormatExecute(r ApiPlannerPlansBucketsTasksUpdateProgressTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerPlanApiService.PlannerPlansBucketsTasksUpdateProgressTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/progressTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerProgressTaskBoardTaskFormat == nil {
		return nil, reportError("microsoftGraphPlannerProgressTaskBoardTaskFormat is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerProgressTaskBoardTaskFormat
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPlannerPlansBucketsUpdateTasksRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerPlanApiService
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	microsoftGraphPlannerTask *MicrosoftGraphPlannerTask
}

// New navigation property values
func (r ApiPlannerPlansBucketsUpdateTasksRequest) MicrosoftGraphPlannerTask(microsoftGraphPlannerTask MicrosoftGraphPlannerTask) ApiPlannerPlansBucketsUpdateTasksRequest {
	r.microsoftGraphPlannerTask = &microsoftGraphPlannerTask
	return r
}

func (r ApiPlannerPlansBucketsUpdateTasksRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PlannerPlansBucketsUpdateTasksExecute(r)
}

/*
PlannerPlansBucketsUpdateTasks Update the navigation property tasks in planner

Read-only. Nullable. The collection of tasks in the bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiPlannerPlansBucketsUpdateTasksRequest
*/
func (a *PlannerPlannerPlanApiService) PlannerPlansBucketsUpdateTasks(ctx _context.Context, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiPlannerPlansBucketsUpdateTasksRequest {
	return ApiPlannerPlansBucketsUpdateTasksRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *PlannerPlannerPlanApiService) PlannerPlansBucketsUpdateTasksExecute(r ApiPlannerPlansBucketsUpdateTasksRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerPlanApiService.PlannerPlansBucketsUpdateTasks")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerTask == nil {
		return nil, reportError("microsoftGraphPlannerTask is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerTask
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPlannerPlansCreateBucketsRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerPlanApiService
	plannerPlanId string
	microsoftGraphPlannerBucket *MicrosoftGraphPlannerBucket
}

// New navigation property
func (r ApiPlannerPlansCreateBucketsRequest) MicrosoftGraphPlannerBucket(microsoftGraphPlannerBucket MicrosoftGraphPlannerBucket) ApiPlannerPlansCreateBucketsRequest {
	r.microsoftGraphPlannerBucket = &microsoftGraphPlannerBucket
	return r
}

func (r ApiPlannerPlansCreateBucketsRequest) Execute() (MicrosoftGraphPlannerBucket, *_nethttp.Response, error) {
	return r.ApiService.PlannerPlansCreateBucketsExecute(r)
}

/*
PlannerPlansCreateBuckets Create new navigation property to buckets for planner

Read-only. Nullable. Collection of buckets in the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @return ApiPlannerPlansCreateBucketsRequest
*/
func (a *PlannerPlannerPlanApiService) PlannerPlansCreateBuckets(ctx _context.Context, plannerPlanId string) ApiPlannerPlansCreateBucketsRequest {
	return ApiPlannerPlansCreateBucketsRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerBucket
func (a *PlannerPlannerPlanApiService) PlannerPlansCreateBucketsExecute(r ApiPlannerPlansCreateBucketsRequest) (MicrosoftGraphPlannerBucket, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerBucket
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerPlanApiService.PlannerPlansCreateBuckets")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/plans/{plannerPlan-id}/buckets"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerBucket == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphPlannerBucket is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerBucket
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlannerPlansCreateTasksRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerPlanApiService
	plannerPlanId string
	microsoftGraphPlannerTask *MicrosoftGraphPlannerTask
}

// New navigation property
func (r ApiPlannerPlansCreateTasksRequest) MicrosoftGraphPlannerTask(microsoftGraphPlannerTask MicrosoftGraphPlannerTask) ApiPlannerPlansCreateTasksRequest {
	r.microsoftGraphPlannerTask = &microsoftGraphPlannerTask
	return r
}

func (r ApiPlannerPlansCreateTasksRequest) Execute() (MicrosoftGraphPlannerTask, *_nethttp.Response, error) {
	return r.ApiService.PlannerPlansCreateTasksExecute(r)
}

/*
PlannerPlansCreateTasks Create new navigation property to tasks for planner

Read-only. Nullable. Collection of tasks in the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @return ApiPlannerPlansCreateTasksRequest
*/
func (a *PlannerPlannerPlanApiService) PlannerPlansCreateTasks(ctx _context.Context, plannerPlanId string) ApiPlannerPlansCreateTasksRequest {
	return ApiPlannerPlansCreateTasksRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerTask
func (a *PlannerPlannerPlanApiService) PlannerPlansCreateTasksExecute(r ApiPlannerPlansCreateTasksRequest) (MicrosoftGraphPlannerTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerPlanApiService.PlannerPlansCreateTasks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/plans/{plannerPlan-id}/tasks"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerTask == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphPlannerTask is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerTask
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlannerPlansDeleteBucketsRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerPlanApiService
	plannerPlanId string
	plannerBucketId string
	ifMatch *string
}

// ETag
func (r ApiPlannerPlansDeleteBucketsRequest) IfMatch(ifMatch string) ApiPlannerPlansDeleteBucketsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiPlannerPlansDeleteBucketsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PlannerPlansDeleteBucketsExecute(r)
}

/*
PlannerPlansDeleteBuckets Delete navigation property buckets for planner

Read-only. Nullable. Collection of buckets in the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @return ApiPlannerPlansDeleteBucketsRequest
*/
func (a *PlannerPlannerPlanApiService) PlannerPlansDeleteBuckets(ctx _context.Context, plannerPlanId string, plannerBucketId string) ApiPlannerPlansDeleteBucketsRequest {
	return ApiPlannerPlansDeleteBucketsRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
	}
}

// Execute executes the request
func (a *PlannerPlannerPlanApiService) PlannerPlansDeleteBucketsExecute(r ApiPlannerPlansDeleteBucketsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerPlanApiService.PlannerPlansDeleteBuckets")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPlannerPlansDeleteDetailsRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerPlanApiService
	plannerPlanId string
	ifMatch *string
}

// ETag
func (r ApiPlannerPlansDeleteDetailsRequest) IfMatch(ifMatch string) ApiPlannerPlansDeleteDetailsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiPlannerPlansDeleteDetailsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PlannerPlansDeleteDetailsExecute(r)
}

/*
PlannerPlansDeleteDetails Delete navigation property details for planner

Read-only. Nullable. Additional details about the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @return ApiPlannerPlansDeleteDetailsRequest
*/
func (a *PlannerPlannerPlanApiService) PlannerPlansDeleteDetails(ctx _context.Context, plannerPlanId string) ApiPlannerPlansDeleteDetailsRequest {
	return ApiPlannerPlansDeleteDetailsRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
	}
}

// Execute executes the request
func (a *PlannerPlannerPlanApiService) PlannerPlansDeleteDetailsExecute(r ApiPlannerPlansDeleteDetailsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerPlanApiService.PlannerPlansDeleteDetails")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/plans/{plannerPlan-id}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPlannerPlansDeleteTasksRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerPlanApiService
	plannerPlanId string
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiPlannerPlansDeleteTasksRequest) IfMatch(ifMatch string) ApiPlannerPlansDeleteTasksRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiPlannerPlansDeleteTasksRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PlannerPlansDeleteTasksExecute(r)
}

/*
PlannerPlansDeleteTasks Delete navigation property tasks for planner

Read-only. Nullable. Collection of tasks in the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiPlannerPlansDeleteTasksRequest
*/
func (a *PlannerPlannerPlanApiService) PlannerPlansDeleteTasks(ctx _context.Context, plannerPlanId string, plannerTaskId string) ApiPlannerPlansDeleteTasksRequest {
	return ApiPlannerPlansDeleteTasksRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *PlannerPlannerPlanApiService) PlannerPlansDeleteTasksExecute(r ApiPlannerPlansDeleteTasksRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerPlanApiService.PlannerPlansDeleteTasks")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPlannerPlansGetBucketsRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerPlanApiService
	plannerPlanId string
	plannerBucketId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiPlannerPlansGetBucketsRequest) Select_(select_ []string) ApiPlannerPlansGetBucketsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiPlannerPlansGetBucketsRequest) Expand(expand []string) ApiPlannerPlansGetBucketsRequest {
	r.expand = &expand
	return r
}

func (r ApiPlannerPlansGetBucketsRequest) Execute() (MicrosoftGraphPlannerBucket, *_nethttp.Response, error) {
	return r.ApiService.PlannerPlansGetBucketsExecute(r)
}

/*
PlannerPlansGetBuckets Get buckets from planner

Read-only. Nullable. Collection of buckets in the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @return ApiPlannerPlansGetBucketsRequest
*/
func (a *PlannerPlannerPlanApiService) PlannerPlansGetBuckets(ctx _context.Context, plannerPlanId string, plannerBucketId string) ApiPlannerPlansGetBucketsRequest {
	return ApiPlannerPlansGetBucketsRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerBucket
func (a *PlannerPlannerPlanApiService) PlannerPlansGetBucketsExecute(r ApiPlannerPlansGetBucketsRequest) (MicrosoftGraphPlannerBucket, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerBucket
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerPlanApiService.PlannerPlansGetBuckets")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlannerPlansGetDetailsRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerPlanApiService
	plannerPlanId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiPlannerPlansGetDetailsRequest) Select_(select_ []string) ApiPlannerPlansGetDetailsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiPlannerPlansGetDetailsRequest) Expand(expand []string) ApiPlannerPlansGetDetailsRequest {
	r.expand = &expand
	return r
}

func (r ApiPlannerPlansGetDetailsRequest) Execute() (MicrosoftGraphPlannerPlanDetails, *_nethttp.Response, error) {
	return r.ApiService.PlannerPlansGetDetailsExecute(r)
}

/*
PlannerPlansGetDetails Get details from planner

Read-only. Nullable. Additional details about the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @return ApiPlannerPlansGetDetailsRequest
*/
func (a *PlannerPlannerPlanApiService) PlannerPlansGetDetails(ctx _context.Context, plannerPlanId string) ApiPlannerPlansGetDetailsRequest {
	return ApiPlannerPlansGetDetailsRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerPlanDetails
func (a *PlannerPlannerPlanApiService) PlannerPlansGetDetailsExecute(r ApiPlannerPlansGetDetailsRequest) (MicrosoftGraphPlannerPlanDetails, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerPlanDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerPlanApiService.PlannerPlansGetDetails")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/plans/{plannerPlan-id}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlannerPlansGetTasksRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerPlanApiService
	plannerPlanId string
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiPlannerPlansGetTasksRequest) Select_(select_ []string) ApiPlannerPlansGetTasksRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiPlannerPlansGetTasksRequest) Expand(expand []string) ApiPlannerPlansGetTasksRequest {
	r.expand = &expand
	return r
}

func (r ApiPlannerPlansGetTasksRequest) Execute() (MicrosoftGraphPlannerTask, *_nethttp.Response, error) {
	return r.ApiService.PlannerPlansGetTasksExecute(r)
}

/*
PlannerPlansGetTasks Get tasks from planner

Read-only. Nullable. Collection of tasks in the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiPlannerPlansGetTasksRequest
*/
func (a *PlannerPlannerPlanApiService) PlannerPlansGetTasks(ctx _context.Context, plannerPlanId string, plannerTaskId string) ApiPlannerPlansGetTasksRequest {
	return ApiPlannerPlansGetTasksRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerTask
func (a *PlannerPlannerPlanApiService) PlannerPlansGetTasksExecute(r ApiPlannerPlansGetTasksRequest) (MicrosoftGraphPlannerTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerPlanApiService.PlannerPlansGetTasks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlannerPlansListBucketsRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerPlanApiService
	plannerPlanId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiPlannerPlansListBucketsRequest) Top(top int32) ApiPlannerPlansListBucketsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiPlannerPlansListBucketsRequest) Skip(skip int32) ApiPlannerPlansListBucketsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiPlannerPlansListBucketsRequest) Search(search string) ApiPlannerPlansListBucketsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiPlannerPlansListBucketsRequest) Filter(filter string) ApiPlannerPlansListBucketsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiPlannerPlansListBucketsRequest) Count(count bool) ApiPlannerPlansListBucketsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiPlannerPlansListBucketsRequest) Orderby(orderby []string) ApiPlannerPlansListBucketsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiPlannerPlansListBucketsRequest) Select_(select_ []string) ApiPlannerPlansListBucketsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiPlannerPlansListBucketsRequest) Expand(expand []string) ApiPlannerPlansListBucketsRequest {
	r.expand = &expand
	return r
}

func (r ApiPlannerPlansListBucketsRequest) Execute() (CollectionOfPlannerBucket, *_nethttp.Response, error) {
	return r.ApiService.PlannerPlansListBucketsExecute(r)
}

/*
PlannerPlansListBuckets Get buckets from planner

Read-only. Nullable. Collection of buckets in the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @return ApiPlannerPlansListBucketsRequest
*/
func (a *PlannerPlannerPlanApiService) PlannerPlansListBuckets(ctx _context.Context, plannerPlanId string) ApiPlannerPlansListBucketsRequest {
	return ApiPlannerPlansListBucketsRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
	}
}

// Execute executes the request
//  @return CollectionOfPlannerBucket
func (a *PlannerPlannerPlanApiService) PlannerPlansListBucketsExecute(r ApiPlannerPlansListBucketsRequest) (CollectionOfPlannerBucket, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfPlannerBucket
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerPlanApiService.PlannerPlansListBuckets")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/plans/{plannerPlan-id}/buckets"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlannerPlansListTasksRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerPlanApiService
	plannerPlanId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiPlannerPlansListTasksRequest) Top(top int32) ApiPlannerPlansListTasksRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiPlannerPlansListTasksRequest) Skip(skip int32) ApiPlannerPlansListTasksRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiPlannerPlansListTasksRequest) Search(search string) ApiPlannerPlansListTasksRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiPlannerPlansListTasksRequest) Filter(filter string) ApiPlannerPlansListTasksRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiPlannerPlansListTasksRequest) Count(count bool) ApiPlannerPlansListTasksRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiPlannerPlansListTasksRequest) Orderby(orderby []string) ApiPlannerPlansListTasksRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiPlannerPlansListTasksRequest) Select_(select_ []string) ApiPlannerPlansListTasksRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiPlannerPlansListTasksRequest) Expand(expand []string) ApiPlannerPlansListTasksRequest {
	r.expand = &expand
	return r
}

func (r ApiPlannerPlansListTasksRequest) Execute() (CollectionOfPlannerTask, *_nethttp.Response, error) {
	return r.ApiService.PlannerPlansListTasksExecute(r)
}

/*
PlannerPlansListTasks Get tasks from planner

Read-only. Nullable. Collection of tasks in the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @return ApiPlannerPlansListTasksRequest
*/
func (a *PlannerPlannerPlanApiService) PlannerPlansListTasks(ctx _context.Context, plannerPlanId string) ApiPlannerPlansListTasksRequest {
	return ApiPlannerPlansListTasksRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
	}
}

// Execute executes the request
//  @return CollectionOfPlannerTask
func (a *PlannerPlannerPlanApiService) PlannerPlansListTasksExecute(r ApiPlannerPlansListTasksRequest) (CollectionOfPlannerTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfPlannerTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerPlanApiService.PlannerPlansListTasks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/plans/{plannerPlan-id}/tasks"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlannerPlansTasksDeleteAssignedToTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerPlanApiService
	plannerPlanId string
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiPlannerPlansTasksDeleteAssignedToTaskBoardFormatRequest) IfMatch(ifMatch string) ApiPlannerPlansTasksDeleteAssignedToTaskBoardFormatRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiPlannerPlansTasksDeleteAssignedToTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PlannerPlansTasksDeleteAssignedToTaskBoardFormatExecute(r)
}

/*
PlannerPlansTasksDeleteAssignedToTaskBoardFormat Delete navigation property assignedToTaskBoardFormat for planner

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by assignedTo.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiPlannerPlansTasksDeleteAssignedToTaskBoardFormatRequest
*/
func (a *PlannerPlannerPlanApiService) PlannerPlansTasksDeleteAssignedToTaskBoardFormat(ctx _context.Context, plannerPlanId string, plannerTaskId string) ApiPlannerPlansTasksDeleteAssignedToTaskBoardFormatRequest {
	return ApiPlannerPlansTasksDeleteAssignedToTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *PlannerPlannerPlanApiService) PlannerPlansTasksDeleteAssignedToTaskBoardFormatExecute(r ApiPlannerPlansTasksDeleteAssignedToTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerPlanApiService.PlannerPlansTasksDeleteAssignedToTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPlannerPlansTasksDeleteBucketTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerPlanApiService
	plannerPlanId string
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiPlannerPlansTasksDeleteBucketTaskBoardFormatRequest) IfMatch(ifMatch string) ApiPlannerPlansTasksDeleteBucketTaskBoardFormatRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiPlannerPlansTasksDeleteBucketTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PlannerPlansTasksDeleteBucketTaskBoardFormatExecute(r)
}

/*
PlannerPlansTasksDeleteBucketTaskBoardFormat Delete navigation property bucketTaskBoardFormat for planner

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiPlannerPlansTasksDeleteBucketTaskBoardFormatRequest
*/
func (a *PlannerPlannerPlanApiService) PlannerPlansTasksDeleteBucketTaskBoardFormat(ctx _context.Context, plannerPlanId string, plannerTaskId string) ApiPlannerPlansTasksDeleteBucketTaskBoardFormatRequest {
	return ApiPlannerPlansTasksDeleteBucketTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *PlannerPlannerPlanApiService) PlannerPlansTasksDeleteBucketTaskBoardFormatExecute(r ApiPlannerPlansTasksDeleteBucketTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerPlanApiService.PlannerPlansTasksDeleteBucketTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPlannerPlansTasksDeleteDetailsRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerPlanApiService
	plannerPlanId string
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiPlannerPlansTasksDeleteDetailsRequest) IfMatch(ifMatch string) ApiPlannerPlansTasksDeleteDetailsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiPlannerPlansTasksDeleteDetailsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PlannerPlansTasksDeleteDetailsExecute(r)
}

/*
PlannerPlansTasksDeleteDetails Delete navigation property details for planner

Read-only. Nullable. Additional details about the task.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiPlannerPlansTasksDeleteDetailsRequest
*/
func (a *PlannerPlannerPlanApiService) PlannerPlansTasksDeleteDetails(ctx _context.Context, plannerPlanId string, plannerTaskId string) ApiPlannerPlansTasksDeleteDetailsRequest {
	return ApiPlannerPlansTasksDeleteDetailsRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *PlannerPlannerPlanApiService) PlannerPlansTasksDeleteDetailsExecute(r ApiPlannerPlansTasksDeleteDetailsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerPlanApiService.PlannerPlansTasksDeleteDetails")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPlannerPlansTasksDeleteProgressTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerPlanApiService
	plannerPlanId string
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiPlannerPlansTasksDeleteProgressTaskBoardFormatRequest) IfMatch(ifMatch string) ApiPlannerPlansTasksDeleteProgressTaskBoardFormatRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiPlannerPlansTasksDeleteProgressTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PlannerPlansTasksDeleteProgressTaskBoardFormatExecute(r)
}

/*
PlannerPlansTasksDeleteProgressTaskBoardFormat Delete navigation property progressTaskBoardFormat for planner

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by progress.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiPlannerPlansTasksDeleteProgressTaskBoardFormatRequest
*/
func (a *PlannerPlannerPlanApiService) PlannerPlansTasksDeleteProgressTaskBoardFormat(ctx _context.Context, plannerPlanId string, plannerTaskId string) ApiPlannerPlansTasksDeleteProgressTaskBoardFormatRequest {
	return ApiPlannerPlansTasksDeleteProgressTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *PlannerPlannerPlanApiService) PlannerPlansTasksDeleteProgressTaskBoardFormatExecute(r ApiPlannerPlansTasksDeleteProgressTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerPlanApiService.PlannerPlansTasksDeleteProgressTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/progressTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPlannerPlansTasksGetAssignedToTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerPlanApiService
	plannerPlanId string
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiPlannerPlansTasksGetAssignedToTaskBoardFormatRequest) Select_(select_ []string) ApiPlannerPlansTasksGetAssignedToTaskBoardFormatRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiPlannerPlansTasksGetAssignedToTaskBoardFormatRequest) Expand(expand []string) ApiPlannerPlansTasksGetAssignedToTaskBoardFormatRequest {
	r.expand = &expand
	return r
}

func (r ApiPlannerPlansTasksGetAssignedToTaskBoardFormatRequest) Execute() (MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat, *_nethttp.Response, error) {
	return r.ApiService.PlannerPlansTasksGetAssignedToTaskBoardFormatExecute(r)
}

/*
PlannerPlansTasksGetAssignedToTaskBoardFormat Get assignedToTaskBoardFormat from planner

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by assignedTo.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiPlannerPlansTasksGetAssignedToTaskBoardFormatRequest
*/
func (a *PlannerPlannerPlanApiService) PlannerPlansTasksGetAssignedToTaskBoardFormat(ctx _context.Context, plannerPlanId string, plannerTaskId string) ApiPlannerPlansTasksGetAssignedToTaskBoardFormatRequest {
	return ApiPlannerPlansTasksGetAssignedToTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat
func (a *PlannerPlannerPlanApiService) PlannerPlansTasksGetAssignedToTaskBoardFormatExecute(r ApiPlannerPlansTasksGetAssignedToTaskBoardFormatRequest) (MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerPlanApiService.PlannerPlansTasksGetAssignedToTaskBoardFormat")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlannerPlansTasksGetBucketTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerPlanApiService
	plannerPlanId string
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiPlannerPlansTasksGetBucketTaskBoardFormatRequest) Select_(select_ []string) ApiPlannerPlansTasksGetBucketTaskBoardFormatRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiPlannerPlansTasksGetBucketTaskBoardFormatRequest) Expand(expand []string) ApiPlannerPlansTasksGetBucketTaskBoardFormatRequest {
	r.expand = &expand
	return r
}

func (r ApiPlannerPlansTasksGetBucketTaskBoardFormatRequest) Execute() (MicrosoftGraphPlannerBucketTaskBoardTaskFormat, *_nethttp.Response, error) {
	return r.ApiService.PlannerPlansTasksGetBucketTaskBoardFormatExecute(r)
}

/*
PlannerPlansTasksGetBucketTaskBoardFormat Get bucketTaskBoardFormat from planner

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiPlannerPlansTasksGetBucketTaskBoardFormatRequest
*/
func (a *PlannerPlannerPlanApiService) PlannerPlansTasksGetBucketTaskBoardFormat(ctx _context.Context, plannerPlanId string, plannerTaskId string) ApiPlannerPlansTasksGetBucketTaskBoardFormatRequest {
	return ApiPlannerPlansTasksGetBucketTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerBucketTaskBoardTaskFormat
func (a *PlannerPlannerPlanApiService) PlannerPlansTasksGetBucketTaskBoardFormatExecute(r ApiPlannerPlansTasksGetBucketTaskBoardFormatRequest) (MicrosoftGraphPlannerBucketTaskBoardTaskFormat, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerBucketTaskBoardTaskFormat
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerPlanApiService.PlannerPlansTasksGetBucketTaskBoardFormat")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlannerPlansTasksGetDetailsRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerPlanApiService
	plannerPlanId string
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiPlannerPlansTasksGetDetailsRequest) Select_(select_ []string) ApiPlannerPlansTasksGetDetailsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiPlannerPlansTasksGetDetailsRequest) Expand(expand []string) ApiPlannerPlansTasksGetDetailsRequest {
	r.expand = &expand
	return r
}

func (r ApiPlannerPlansTasksGetDetailsRequest) Execute() (MicrosoftGraphPlannerTaskDetails, *_nethttp.Response, error) {
	return r.ApiService.PlannerPlansTasksGetDetailsExecute(r)
}

/*
PlannerPlansTasksGetDetails Get details from planner

Read-only. Nullable. Additional details about the task.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiPlannerPlansTasksGetDetailsRequest
*/
func (a *PlannerPlannerPlanApiService) PlannerPlansTasksGetDetails(ctx _context.Context, plannerPlanId string, plannerTaskId string) ApiPlannerPlansTasksGetDetailsRequest {
	return ApiPlannerPlansTasksGetDetailsRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerTaskDetails
func (a *PlannerPlannerPlanApiService) PlannerPlansTasksGetDetailsExecute(r ApiPlannerPlansTasksGetDetailsRequest) (MicrosoftGraphPlannerTaskDetails, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerTaskDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerPlanApiService.PlannerPlansTasksGetDetails")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlannerPlansTasksGetProgressTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerPlanApiService
	plannerPlanId string
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiPlannerPlansTasksGetProgressTaskBoardFormatRequest) Select_(select_ []string) ApiPlannerPlansTasksGetProgressTaskBoardFormatRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiPlannerPlansTasksGetProgressTaskBoardFormatRequest) Expand(expand []string) ApiPlannerPlansTasksGetProgressTaskBoardFormatRequest {
	r.expand = &expand
	return r
}

func (r ApiPlannerPlansTasksGetProgressTaskBoardFormatRequest) Execute() (MicrosoftGraphPlannerProgressTaskBoardTaskFormat, *_nethttp.Response, error) {
	return r.ApiService.PlannerPlansTasksGetProgressTaskBoardFormatExecute(r)
}

/*
PlannerPlansTasksGetProgressTaskBoardFormat Get progressTaskBoardFormat from planner

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by progress.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiPlannerPlansTasksGetProgressTaskBoardFormatRequest
*/
func (a *PlannerPlannerPlanApiService) PlannerPlansTasksGetProgressTaskBoardFormat(ctx _context.Context, plannerPlanId string, plannerTaskId string) ApiPlannerPlansTasksGetProgressTaskBoardFormatRequest {
	return ApiPlannerPlansTasksGetProgressTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerProgressTaskBoardTaskFormat
func (a *PlannerPlannerPlanApiService) PlannerPlansTasksGetProgressTaskBoardFormatExecute(r ApiPlannerPlansTasksGetProgressTaskBoardFormatRequest) (MicrosoftGraphPlannerProgressTaskBoardTaskFormat, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerProgressTaskBoardTaskFormat
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerPlanApiService.PlannerPlansTasksGetProgressTaskBoardFormat")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/progressTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlannerPlansTasksUpdateAssignedToTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerPlanApiService
	plannerPlanId string
	plannerTaskId string
	microsoftGraphPlannerAssignedToTaskBoardTaskFormat *MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat
}

// New navigation property values
func (r ApiPlannerPlansTasksUpdateAssignedToTaskBoardFormatRequest) MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat(microsoftGraphPlannerAssignedToTaskBoardTaskFormat MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat) ApiPlannerPlansTasksUpdateAssignedToTaskBoardFormatRequest {
	r.microsoftGraphPlannerAssignedToTaskBoardTaskFormat = &microsoftGraphPlannerAssignedToTaskBoardTaskFormat
	return r
}

func (r ApiPlannerPlansTasksUpdateAssignedToTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PlannerPlansTasksUpdateAssignedToTaskBoardFormatExecute(r)
}

/*
PlannerPlansTasksUpdateAssignedToTaskBoardFormat Update the navigation property assignedToTaskBoardFormat in planner

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by assignedTo.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiPlannerPlansTasksUpdateAssignedToTaskBoardFormatRequest
*/
func (a *PlannerPlannerPlanApiService) PlannerPlansTasksUpdateAssignedToTaskBoardFormat(ctx _context.Context, plannerPlanId string, plannerTaskId string) ApiPlannerPlansTasksUpdateAssignedToTaskBoardFormatRequest {
	return ApiPlannerPlansTasksUpdateAssignedToTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *PlannerPlannerPlanApiService) PlannerPlansTasksUpdateAssignedToTaskBoardFormatExecute(r ApiPlannerPlansTasksUpdateAssignedToTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerPlanApiService.PlannerPlansTasksUpdateAssignedToTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerAssignedToTaskBoardTaskFormat == nil {
		return nil, reportError("microsoftGraphPlannerAssignedToTaskBoardTaskFormat is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerAssignedToTaskBoardTaskFormat
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPlannerPlansTasksUpdateBucketTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerPlanApiService
	plannerPlanId string
	plannerTaskId string
	microsoftGraphPlannerBucketTaskBoardTaskFormat *MicrosoftGraphPlannerBucketTaskBoardTaskFormat
}

// New navigation property values
func (r ApiPlannerPlansTasksUpdateBucketTaskBoardFormatRequest) MicrosoftGraphPlannerBucketTaskBoardTaskFormat(microsoftGraphPlannerBucketTaskBoardTaskFormat MicrosoftGraphPlannerBucketTaskBoardTaskFormat) ApiPlannerPlansTasksUpdateBucketTaskBoardFormatRequest {
	r.microsoftGraphPlannerBucketTaskBoardTaskFormat = &microsoftGraphPlannerBucketTaskBoardTaskFormat
	return r
}

func (r ApiPlannerPlansTasksUpdateBucketTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PlannerPlansTasksUpdateBucketTaskBoardFormatExecute(r)
}

/*
PlannerPlansTasksUpdateBucketTaskBoardFormat Update the navigation property bucketTaskBoardFormat in planner

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiPlannerPlansTasksUpdateBucketTaskBoardFormatRequest
*/
func (a *PlannerPlannerPlanApiService) PlannerPlansTasksUpdateBucketTaskBoardFormat(ctx _context.Context, plannerPlanId string, plannerTaskId string) ApiPlannerPlansTasksUpdateBucketTaskBoardFormatRequest {
	return ApiPlannerPlansTasksUpdateBucketTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *PlannerPlannerPlanApiService) PlannerPlansTasksUpdateBucketTaskBoardFormatExecute(r ApiPlannerPlansTasksUpdateBucketTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerPlanApiService.PlannerPlansTasksUpdateBucketTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerBucketTaskBoardTaskFormat == nil {
		return nil, reportError("microsoftGraphPlannerBucketTaskBoardTaskFormat is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerBucketTaskBoardTaskFormat
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPlannerPlansTasksUpdateDetailsRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerPlanApiService
	plannerPlanId string
	plannerTaskId string
	microsoftGraphPlannerTaskDetails *MicrosoftGraphPlannerTaskDetails
}

// New navigation property values
func (r ApiPlannerPlansTasksUpdateDetailsRequest) MicrosoftGraphPlannerTaskDetails(microsoftGraphPlannerTaskDetails MicrosoftGraphPlannerTaskDetails) ApiPlannerPlansTasksUpdateDetailsRequest {
	r.microsoftGraphPlannerTaskDetails = &microsoftGraphPlannerTaskDetails
	return r
}

func (r ApiPlannerPlansTasksUpdateDetailsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PlannerPlansTasksUpdateDetailsExecute(r)
}

/*
PlannerPlansTasksUpdateDetails Update the navigation property details in planner

Read-only. Nullable. Additional details about the task.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiPlannerPlansTasksUpdateDetailsRequest
*/
func (a *PlannerPlannerPlanApiService) PlannerPlansTasksUpdateDetails(ctx _context.Context, plannerPlanId string, plannerTaskId string) ApiPlannerPlansTasksUpdateDetailsRequest {
	return ApiPlannerPlansTasksUpdateDetailsRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *PlannerPlannerPlanApiService) PlannerPlansTasksUpdateDetailsExecute(r ApiPlannerPlansTasksUpdateDetailsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerPlanApiService.PlannerPlansTasksUpdateDetails")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerTaskDetails == nil {
		return nil, reportError("microsoftGraphPlannerTaskDetails is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerTaskDetails
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPlannerPlansTasksUpdateProgressTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerPlanApiService
	plannerPlanId string
	plannerTaskId string
	microsoftGraphPlannerProgressTaskBoardTaskFormat *MicrosoftGraphPlannerProgressTaskBoardTaskFormat
}

// New navigation property values
func (r ApiPlannerPlansTasksUpdateProgressTaskBoardFormatRequest) MicrosoftGraphPlannerProgressTaskBoardTaskFormat(microsoftGraphPlannerProgressTaskBoardTaskFormat MicrosoftGraphPlannerProgressTaskBoardTaskFormat) ApiPlannerPlansTasksUpdateProgressTaskBoardFormatRequest {
	r.microsoftGraphPlannerProgressTaskBoardTaskFormat = &microsoftGraphPlannerProgressTaskBoardTaskFormat
	return r
}

func (r ApiPlannerPlansTasksUpdateProgressTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PlannerPlansTasksUpdateProgressTaskBoardFormatExecute(r)
}

/*
PlannerPlansTasksUpdateProgressTaskBoardFormat Update the navigation property progressTaskBoardFormat in planner

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by progress.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiPlannerPlansTasksUpdateProgressTaskBoardFormatRequest
*/
func (a *PlannerPlannerPlanApiService) PlannerPlansTasksUpdateProgressTaskBoardFormat(ctx _context.Context, plannerPlanId string, plannerTaskId string) ApiPlannerPlansTasksUpdateProgressTaskBoardFormatRequest {
	return ApiPlannerPlansTasksUpdateProgressTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *PlannerPlannerPlanApiService) PlannerPlansTasksUpdateProgressTaskBoardFormatExecute(r ApiPlannerPlansTasksUpdateProgressTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerPlanApiService.PlannerPlansTasksUpdateProgressTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/progressTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerProgressTaskBoardTaskFormat == nil {
		return nil, reportError("microsoftGraphPlannerProgressTaskBoardTaskFormat is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerProgressTaskBoardTaskFormat
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPlannerPlansUpdateBucketsRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerPlanApiService
	plannerPlanId string
	plannerBucketId string
	microsoftGraphPlannerBucket *MicrosoftGraphPlannerBucket
}

// New navigation property values
func (r ApiPlannerPlansUpdateBucketsRequest) MicrosoftGraphPlannerBucket(microsoftGraphPlannerBucket MicrosoftGraphPlannerBucket) ApiPlannerPlansUpdateBucketsRequest {
	r.microsoftGraphPlannerBucket = &microsoftGraphPlannerBucket
	return r
}

func (r ApiPlannerPlansUpdateBucketsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PlannerPlansUpdateBucketsExecute(r)
}

/*
PlannerPlansUpdateBuckets Update the navigation property buckets in planner

Read-only. Nullable. Collection of buckets in the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @return ApiPlannerPlansUpdateBucketsRequest
*/
func (a *PlannerPlannerPlanApiService) PlannerPlansUpdateBuckets(ctx _context.Context, plannerPlanId string, plannerBucketId string) ApiPlannerPlansUpdateBucketsRequest {
	return ApiPlannerPlansUpdateBucketsRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
	}
}

// Execute executes the request
func (a *PlannerPlannerPlanApiService) PlannerPlansUpdateBucketsExecute(r ApiPlannerPlansUpdateBucketsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerPlanApiService.PlannerPlansUpdateBuckets")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerBucket == nil {
		return nil, reportError("microsoftGraphPlannerBucket is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerBucket
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPlannerPlansUpdateDetailsRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerPlanApiService
	plannerPlanId string
	microsoftGraphPlannerPlanDetails *MicrosoftGraphPlannerPlanDetails
}

// New navigation property values
func (r ApiPlannerPlansUpdateDetailsRequest) MicrosoftGraphPlannerPlanDetails(microsoftGraphPlannerPlanDetails MicrosoftGraphPlannerPlanDetails) ApiPlannerPlansUpdateDetailsRequest {
	r.microsoftGraphPlannerPlanDetails = &microsoftGraphPlannerPlanDetails
	return r
}

func (r ApiPlannerPlansUpdateDetailsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PlannerPlansUpdateDetailsExecute(r)
}

/*
PlannerPlansUpdateDetails Update the navigation property details in planner

Read-only. Nullable. Additional details about the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @return ApiPlannerPlansUpdateDetailsRequest
*/
func (a *PlannerPlannerPlanApiService) PlannerPlansUpdateDetails(ctx _context.Context, plannerPlanId string) ApiPlannerPlansUpdateDetailsRequest {
	return ApiPlannerPlansUpdateDetailsRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
	}
}

// Execute executes the request
func (a *PlannerPlannerPlanApiService) PlannerPlansUpdateDetailsExecute(r ApiPlannerPlansUpdateDetailsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerPlanApiService.PlannerPlansUpdateDetails")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/plans/{plannerPlan-id}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerPlanDetails == nil {
		return nil, reportError("microsoftGraphPlannerPlanDetails is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerPlanDetails
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPlannerPlansUpdateTasksRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerPlanApiService
	plannerPlanId string
	plannerTaskId string
	microsoftGraphPlannerTask *MicrosoftGraphPlannerTask
}

// New navigation property values
func (r ApiPlannerPlansUpdateTasksRequest) MicrosoftGraphPlannerTask(microsoftGraphPlannerTask MicrosoftGraphPlannerTask) ApiPlannerPlansUpdateTasksRequest {
	r.microsoftGraphPlannerTask = &microsoftGraphPlannerTask
	return r
}

func (r ApiPlannerPlansUpdateTasksRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PlannerPlansUpdateTasksExecute(r)
}

/*
PlannerPlansUpdateTasks Update the navigation property tasks in planner

Read-only. Nullable. Collection of tasks in the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiPlannerPlansUpdateTasksRequest
*/
func (a *PlannerPlannerPlanApiService) PlannerPlansUpdateTasks(ctx _context.Context, plannerPlanId string, plannerTaskId string) ApiPlannerPlansUpdateTasksRequest {
	return ApiPlannerPlansUpdateTasksRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *PlannerPlannerPlanApiService) PlannerPlansUpdateTasksExecute(r ApiPlannerPlansUpdateTasksRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerPlanApiService.PlannerPlansUpdateTasks")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerTask == nil {
		return nil, reportError("microsoftGraphPlannerTask is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerTask
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPlannerUpdatePlansRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerPlanApiService
	plannerPlanId string
	microsoftGraphPlannerPlan *MicrosoftGraphPlannerPlan
}

// New navigation property values
func (r ApiPlannerUpdatePlansRequest) MicrosoftGraphPlannerPlan(microsoftGraphPlannerPlan MicrosoftGraphPlannerPlan) ApiPlannerUpdatePlansRequest {
	r.microsoftGraphPlannerPlan = &microsoftGraphPlannerPlan
	return r
}

func (r ApiPlannerUpdatePlansRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PlannerUpdatePlansExecute(r)
}

/*
PlannerUpdatePlans Update the navigation property plans in planner

Read-only. Nullable. Returns a collection of the specified plans

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerPlanId key: id of plannerPlan
 @return ApiPlannerUpdatePlansRequest
*/
func (a *PlannerPlannerPlanApiService) PlannerUpdatePlans(ctx _context.Context, plannerPlanId string) ApiPlannerUpdatePlansRequest {
	return ApiPlannerUpdatePlansRequest{
		ApiService: a,
		ctx: ctx,
		plannerPlanId: plannerPlanId,
	}
}

// Execute executes the request
func (a *PlannerPlannerPlanApiService) PlannerUpdatePlansExecute(r ApiPlannerUpdatePlansRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerPlanApiService.PlannerUpdatePlans")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/plans/{plannerPlan-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerPlan == nil {
		return nil, reportError("microsoftGraphPlannerPlan is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerPlan
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
