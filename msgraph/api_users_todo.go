/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// UsersTodoApiService UsersTodoApi service
type UsersTodoApiService service

type ApiUsersDeleteTodoRequest struct {
	ctx _context.Context
	ApiService *UsersTodoApiService
	userId string
	ifMatch *string
}

// ETag
func (r ApiUsersDeleteTodoRequest) IfMatch(ifMatch string) ApiUsersDeleteTodoRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersDeleteTodoRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersDeleteTodoExecute(r)
}

/*
UsersDeleteTodo Delete navigation property todo for users

Represents the To Do services available to a user.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @return ApiUsersDeleteTodoRequest
*/
func (a *UsersTodoApiService) UsersDeleteTodo(ctx _context.Context, userId string) ApiUsersDeleteTodoRequest {
	return ApiUsersDeleteTodoRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
func (a *UsersTodoApiService) UsersDeleteTodoExecute(r ApiUsersDeleteTodoRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersTodoApiService.UsersDeleteTodo")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/todo"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersGetTodoRequest struct {
	ctx _context.Context
	ApiService *UsersTodoApiService
	userId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiUsersGetTodoRequest) Select_(select_ []string) ApiUsersGetTodoRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersGetTodoRequest) Expand(expand []string) ApiUsersGetTodoRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersGetTodoRequest) Execute() (MicrosoftGraphTodo, *_nethttp.Response, error) {
	return r.ApiService.UsersGetTodoExecute(r)
}

/*
UsersGetTodo Get todo from users

Represents the To Do services available to a user.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @return ApiUsersGetTodoRequest
*/
func (a *UsersTodoApiService) UsersGetTodo(ctx _context.Context, userId string) ApiUsersGetTodoRequest {
	return ApiUsersGetTodoRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTodo
func (a *UsersTodoApiService) UsersGetTodoExecute(r ApiUsersGetTodoRequest) (MicrosoftGraphTodo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTodo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersTodoApiService.UsersGetTodo")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/todo"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersTodoCreateListsRequest struct {
	ctx _context.Context
	ApiService *UsersTodoApiService
	userId string
	microsoftGraphTodoTaskList *MicrosoftGraphTodoTaskList
}

// New navigation property
func (r ApiUsersTodoCreateListsRequest) MicrosoftGraphTodoTaskList(microsoftGraphTodoTaskList MicrosoftGraphTodoTaskList) ApiUsersTodoCreateListsRequest {
	r.microsoftGraphTodoTaskList = &microsoftGraphTodoTaskList
	return r
}

func (r ApiUsersTodoCreateListsRequest) Execute() (MicrosoftGraphTodoTaskList, *_nethttp.Response, error) {
	return r.ApiService.UsersTodoCreateListsExecute(r)
}

/*
UsersTodoCreateLists Create new navigation property to lists for users

The task lists in the users mailbox.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @return ApiUsersTodoCreateListsRequest
*/
func (a *UsersTodoApiService) UsersTodoCreateLists(ctx _context.Context, userId string) ApiUsersTodoCreateListsRequest {
	return ApiUsersTodoCreateListsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTodoTaskList
func (a *UsersTodoApiService) UsersTodoCreateListsExecute(r ApiUsersTodoCreateListsRequest) (MicrosoftGraphTodoTaskList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTodoTaskList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersTodoApiService.UsersTodoCreateLists")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/todo/lists"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTodoTaskList == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphTodoTaskList is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTodoTaskList
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersTodoDeleteListsRequest struct {
	ctx _context.Context
	ApiService *UsersTodoApiService
	userId string
	todoTaskListId string
	ifMatch *string
}

// ETag
func (r ApiUsersTodoDeleteListsRequest) IfMatch(ifMatch string) ApiUsersTodoDeleteListsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersTodoDeleteListsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersTodoDeleteListsExecute(r)
}

/*
UsersTodoDeleteLists Delete navigation property lists for users

The task lists in the users mailbox.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param todoTaskListId key: id of todoTaskList
 @return ApiUsersTodoDeleteListsRequest
*/
func (a *UsersTodoApiService) UsersTodoDeleteLists(ctx _context.Context, userId string, todoTaskListId string) ApiUsersTodoDeleteListsRequest {
	return ApiUsersTodoDeleteListsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		todoTaskListId: todoTaskListId,
	}
}

// Execute executes the request
func (a *UsersTodoApiService) UsersTodoDeleteListsExecute(r ApiUsersTodoDeleteListsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersTodoApiService.UsersTodoDeleteLists")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/todo/lists/{todoTaskList-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"todoTaskList-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskListId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersTodoGetListsRequest struct {
	ctx _context.Context
	ApiService *UsersTodoApiService
	userId string
	todoTaskListId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiUsersTodoGetListsRequest) Select_(select_ []string) ApiUsersTodoGetListsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersTodoGetListsRequest) Expand(expand []string) ApiUsersTodoGetListsRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersTodoGetListsRequest) Execute() (MicrosoftGraphTodoTaskList, *_nethttp.Response, error) {
	return r.ApiService.UsersTodoGetListsExecute(r)
}

/*
UsersTodoGetLists Get lists from users

The task lists in the users mailbox.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param todoTaskListId key: id of todoTaskList
 @return ApiUsersTodoGetListsRequest
*/
func (a *UsersTodoApiService) UsersTodoGetLists(ctx _context.Context, userId string, todoTaskListId string) ApiUsersTodoGetListsRequest {
	return ApiUsersTodoGetListsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		todoTaskListId: todoTaskListId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTodoTaskList
func (a *UsersTodoApiService) UsersTodoGetListsExecute(r ApiUsersTodoGetListsRequest) (MicrosoftGraphTodoTaskList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTodoTaskList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersTodoApiService.UsersTodoGetLists")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/todo/lists/{todoTaskList-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"todoTaskList-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskListId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersTodoListListsRequest struct {
	ctx _context.Context
	ApiService *UsersTodoApiService
	userId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiUsersTodoListListsRequest) Top(top int32) ApiUsersTodoListListsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiUsersTodoListListsRequest) Skip(skip int32) ApiUsersTodoListListsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiUsersTodoListListsRequest) Search(search string) ApiUsersTodoListListsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiUsersTodoListListsRequest) Filter(filter string) ApiUsersTodoListListsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiUsersTodoListListsRequest) Count(count bool) ApiUsersTodoListListsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiUsersTodoListListsRequest) Orderby(orderby []string) ApiUsersTodoListListsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiUsersTodoListListsRequest) Select_(select_ []string) ApiUsersTodoListListsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersTodoListListsRequest) Expand(expand []string) ApiUsersTodoListListsRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersTodoListListsRequest) Execute() (CollectionOfTodoTaskList, *_nethttp.Response, error) {
	return r.ApiService.UsersTodoListListsExecute(r)
}

/*
UsersTodoListLists Get lists from users

The task lists in the users mailbox.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @return ApiUsersTodoListListsRequest
*/
func (a *UsersTodoApiService) UsersTodoListLists(ctx _context.Context, userId string) ApiUsersTodoListListsRequest {
	return ApiUsersTodoListListsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return CollectionOfTodoTaskList
func (a *UsersTodoApiService) UsersTodoListListsExecute(r ApiUsersTodoListListsRequest) (CollectionOfTodoTaskList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfTodoTaskList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersTodoApiService.UsersTodoListLists")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/todo/lists"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersTodoListsCreateExtensionsRequest struct {
	ctx _context.Context
	ApiService *UsersTodoApiService
	userId string
	todoTaskListId string
	microsoftGraphExtension *MicrosoftGraphExtension
}

// New navigation property
func (r ApiUsersTodoListsCreateExtensionsRequest) MicrosoftGraphExtension(microsoftGraphExtension MicrosoftGraphExtension) ApiUsersTodoListsCreateExtensionsRequest {
	r.microsoftGraphExtension = &microsoftGraphExtension
	return r
}

func (r ApiUsersTodoListsCreateExtensionsRequest) Execute() (MicrosoftGraphExtension, *_nethttp.Response, error) {
	return r.ApiService.UsersTodoListsCreateExtensionsExecute(r)
}

/*
UsersTodoListsCreateExtensions Create new navigation property to extensions for users

The collection of open extensions defined for the task list. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param todoTaskListId key: id of todoTaskList
 @return ApiUsersTodoListsCreateExtensionsRequest
*/
func (a *UsersTodoApiService) UsersTodoListsCreateExtensions(ctx _context.Context, userId string, todoTaskListId string) ApiUsersTodoListsCreateExtensionsRequest {
	return ApiUsersTodoListsCreateExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		todoTaskListId: todoTaskListId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphExtension
func (a *UsersTodoApiService) UsersTodoListsCreateExtensionsExecute(r ApiUsersTodoListsCreateExtensionsRequest) (MicrosoftGraphExtension, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphExtension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersTodoApiService.UsersTodoListsCreateExtensions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/todo/lists/{todoTaskList-id}/extensions"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"todoTaskList-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskListId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphExtension == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphExtension is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphExtension
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersTodoListsCreateTasksRequest struct {
	ctx _context.Context
	ApiService *UsersTodoApiService
	userId string
	todoTaskListId string
	microsoftGraphTodoTask *MicrosoftGraphTodoTask
}

// New navigation property
func (r ApiUsersTodoListsCreateTasksRequest) MicrosoftGraphTodoTask(microsoftGraphTodoTask MicrosoftGraphTodoTask) ApiUsersTodoListsCreateTasksRequest {
	r.microsoftGraphTodoTask = &microsoftGraphTodoTask
	return r
}

func (r ApiUsersTodoListsCreateTasksRequest) Execute() (MicrosoftGraphTodoTask, *_nethttp.Response, error) {
	return r.ApiService.UsersTodoListsCreateTasksExecute(r)
}

/*
UsersTodoListsCreateTasks Create new navigation property to tasks for users

The tasks in this task list. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param todoTaskListId key: id of todoTaskList
 @return ApiUsersTodoListsCreateTasksRequest
*/
func (a *UsersTodoApiService) UsersTodoListsCreateTasks(ctx _context.Context, userId string, todoTaskListId string) ApiUsersTodoListsCreateTasksRequest {
	return ApiUsersTodoListsCreateTasksRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		todoTaskListId: todoTaskListId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTodoTask
func (a *UsersTodoApiService) UsersTodoListsCreateTasksExecute(r ApiUsersTodoListsCreateTasksRequest) (MicrosoftGraphTodoTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTodoTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersTodoApiService.UsersTodoListsCreateTasks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/todo/lists/{todoTaskList-id}/tasks"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"todoTaskList-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskListId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTodoTask == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphTodoTask is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTodoTask
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersTodoListsDeleteExtensionsRequest struct {
	ctx _context.Context
	ApiService *UsersTodoApiService
	userId string
	todoTaskListId string
	extensionId string
	ifMatch *string
}

// ETag
func (r ApiUsersTodoListsDeleteExtensionsRequest) IfMatch(ifMatch string) ApiUsersTodoListsDeleteExtensionsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersTodoListsDeleteExtensionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersTodoListsDeleteExtensionsExecute(r)
}

/*
UsersTodoListsDeleteExtensions Delete navigation property extensions for users

The collection of open extensions defined for the task list. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param todoTaskListId key: id of todoTaskList
 @param extensionId key: id of extension
 @return ApiUsersTodoListsDeleteExtensionsRequest
*/
func (a *UsersTodoApiService) UsersTodoListsDeleteExtensions(ctx _context.Context, userId string, todoTaskListId string, extensionId string) ApiUsersTodoListsDeleteExtensionsRequest {
	return ApiUsersTodoListsDeleteExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		todoTaskListId: todoTaskListId,
		extensionId: extensionId,
	}
}

// Execute executes the request
func (a *UsersTodoApiService) UsersTodoListsDeleteExtensionsExecute(r ApiUsersTodoListsDeleteExtensionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersTodoApiService.UsersTodoListsDeleteExtensions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/todo/lists/{todoTaskList-id}/extensions/{extension-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"todoTaskList-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskListId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension-id"+"}", _neturl.PathEscape(parameterToString(r.extensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersTodoListsDeleteTasksRequest struct {
	ctx _context.Context
	ApiService *UsersTodoApiService
	userId string
	todoTaskListId string
	todoTaskId string
	ifMatch *string
}

// ETag
func (r ApiUsersTodoListsDeleteTasksRequest) IfMatch(ifMatch string) ApiUsersTodoListsDeleteTasksRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersTodoListsDeleteTasksRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersTodoListsDeleteTasksExecute(r)
}

/*
UsersTodoListsDeleteTasks Delete navigation property tasks for users

The tasks in this task list. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param todoTaskListId key: id of todoTaskList
 @param todoTaskId key: id of todoTask
 @return ApiUsersTodoListsDeleteTasksRequest
*/
func (a *UsersTodoApiService) UsersTodoListsDeleteTasks(ctx _context.Context, userId string, todoTaskListId string, todoTaskId string) ApiUsersTodoListsDeleteTasksRequest {
	return ApiUsersTodoListsDeleteTasksRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		todoTaskListId: todoTaskListId,
		todoTaskId: todoTaskId,
	}
}

// Execute executes the request
func (a *UsersTodoApiService) UsersTodoListsDeleteTasksExecute(r ApiUsersTodoListsDeleteTasksRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersTodoApiService.UsersTodoListsDeleteTasks")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/todo/lists/{todoTaskList-id}/tasks/{todoTask-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"todoTaskList-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskListId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"todoTask-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersTodoListsGetExtensionsRequest struct {
	ctx _context.Context
	ApiService *UsersTodoApiService
	userId string
	todoTaskListId string
	extensionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiUsersTodoListsGetExtensionsRequest) Select_(select_ []string) ApiUsersTodoListsGetExtensionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersTodoListsGetExtensionsRequest) Expand(expand []string) ApiUsersTodoListsGetExtensionsRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersTodoListsGetExtensionsRequest) Execute() (MicrosoftGraphExtension, *_nethttp.Response, error) {
	return r.ApiService.UsersTodoListsGetExtensionsExecute(r)
}

/*
UsersTodoListsGetExtensions Get extensions from users

The collection of open extensions defined for the task list. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param todoTaskListId key: id of todoTaskList
 @param extensionId key: id of extension
 @return ApiUsersTodoListsGetExtensionsRequest
*/
func (a *UsersTodoApiService) UsersTodoListsGetExtensions(ctx _context.Context, userId string, todoTaskListId string, extensionId string) ApiUsersTodoListsGetExtensionsRequest {
	return ApiUsersTodoListsGetExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		todoTaskListId: todoTaskListId,
		extensionId: extensionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphExtension
func (a *UsersTodoApiService) UsersTodoListsGetExtensionsExecute(r ApiUsersTodoListsGetExtensionsRequest) (MicrosoftGraphExtension, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphExtension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersTodoApiService.UsersTodoListsGetExtensions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/todo/lists/{todoTaskList-id}/extensions/{extension-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"todoTaskList-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskListId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension-id"+"}", _neturl.PathEscape(parameterToString(r.extensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersTodoListsGetTasksRequest struct {
	ctx _context.Context
	ApiService *UsersTodoApiService
	userId string
	todoTaskListId string
	todoTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiUsersTodoListsGetTasksRequest) Select_(select_ []string) ApiUsersTodoListsGetTasksRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersTodoListsGetTasksRequest) Expand(expand []string) ApiUsersTodoListsGetTasksRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersTodoListsGetTasksRequest) Execute() (MicrosoftGraphTodoTask, *_nethttp.Response, error) {
	return r.ApiService.UsersTodoListsGetTasksExecute(r)
}

/*
UsersTodoListsGetTasks Get tasks from users

The tasks in this task list. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param todoTaskListId key: id of todoTaskList
 @param todoTaskId key: id of todoTask
 @return ApiUsersTodoListsGetTasksRequest
*/
func (a *UsersTodoApiService) UsersTodoListsGetTasks(ctx _context.Context, userId string, todoTaskListId string, todoTaskId string) ApiUsersTodoListsGetTasksRequest {
	return ApiUsersTodoListsGetTasksRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		todoTaskListId: todoTaskListId,
		todoTaskId: todoTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTodoTask
func (a *UsersTodoApiService) UsersTodoListsGetTasksExecute(r ApiUsersTodoListsGetTasksRequest) (MicrosoftGraphTodoTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTodoTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersTodoApiService.UsersTodoListsGetTasks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/todo/lists/{todoTaskList-id}/tasks/{todoTask-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"todoTaskList-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskListId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"todoTask-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersTodoListsListExtensionsRequest struct {
	ctx _context.Context
	ApiService *UsersTodoApiService
	userId string
	todoTaskListId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiUsersTodoListsListExtensionsRequest) Top(top int32) ApiUsersTodoListsListExtensionsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiUsersTodoListsListExtensionsRequest) Skip(skip int32) ApiUsersTodoListsListExtensionsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiUsersTodoListsListExtensionsRequest) Search(search string) ApiUsersTodoListsListExtensionsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiUsersTodoListsListExtensionsRequest) Filter(filter string) ApiUsersTodoListsListExtensionsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiUsersTodoListsListExtensionsRequest) Count(count bool) ApiUsersTodoListsListExtensionsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiUsersTodoListsListExtensionsRequest) Orderby(orderby []string) ApiUsersTodoListsListExtensionsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiUsersTodoListsListExtensionsRequest) Select_(select_ []string) ApiUsersTodoListsListExtensionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersTodoListsListExtensionsRequest) Expand(expand []string) ApiUsersTodoListsListExtensionsRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersTodoListsListExtensionsRequest) Execute() (CollectionOfExtension, *_nethttp.Response, error) {
	return r.ApiService.UsersTodoListsListExtensionsExecute(r)
}

/*
UsersTodoListsListExtensions Get extensions from users

The collection of open extensions defined for the task list. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param todoTaskListId key: id of todoTaskList
 @return ApiUsersTodoListsListExtensionsRequest
*/
func (a *UsersTodoApiService) UsersTodoListsListExtensions(ctx _context.Context, userId string, todoTaskListId string) ApiUsersTodoListsListExtensionsRequest {
	return ApiUsersTodoListsListExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		todoTaskListId: todoTaskListId,
	}
}

// Execute executes the request
//  @return CollectionOfExtension
func (a *UsersTodoApiService) UsersTodoListsListExtensionsExecute(r ApiUsersTodoListsListExtensionsRequest) (CollectionOfExtension, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfExtension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersTodoApiService.UsersTodoListsListExtensions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/todo/lists/{todoTaskList-id}/extensions"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"todoTaskList-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskListId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersTodoListsListTasksRequest struct {
	ctx _context.Context
	ApiService *UsersTodoApiService
	userId string
	todoTaskListId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiUsersTodoListsListTasksRequest) Top(top int32) ApiUsersTodoListsListTasksRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiUsersTodoListsListTasksRequest) Skip(skip int32) ApiUsersTodoListsListTasksRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiUsersTodoListsListTasksRequest) Search(search string) ApiUsersTodoListsListTasksRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiUsersTodoListsListTasksRequest) Filter(filter string) ApiUsersTodoListsListTasksRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiUsersTodoListsListTasksRequest) Count(count bool) ApiUsersTodoListsListTasksRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiUsersTodoListsListTasksRequest) Orderby(orderby []string) ApiUsersTodoListsListTasksRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiUsersTodoListsListTasksRequest) Select_(select_ []string) ApiUsersTodoListsListTasksRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersTodoListsListTasksRequest) Expand(expand []string) ApiUsersTodoListsListTasksRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersTodoListsListTasksRequest) Execute() (CollectionOfTodoTask, *_nethttp.Response, error) {
	return r.ApiService.UsersTodoListsListTasksExecute(r)
}

/*
UsersTodoListsListTasks Get tasks from users

The tasks in this task list. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param todoTaskListId key: id of todoTaskList
 @return ApiUsersTodoListsListTasksRequest
*/
func (a *UsersTodoApiService) UsersTodoListsListTasks(ctx _context.Context, userId string, todoTaskListId string) ApiUsersTodoListsListTasksRequest {
	return ApiUsersTodoListsListTasksRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		todoTaskListId: todoTaskListId,
	}
}

// Execute executes the request
//  @return CollectionOfTodoTask
func (a *UsersTodoApiService) UsersTodoListsListTasksExecute(r ApiUsersTodoListsListTasksRequest) (CollectionOfTodoTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfTodoTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersTodoApiService.UsersTodoListsListTasks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/todo/lists/{todoTaskList-id}/tasks"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"todoTaskList-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskListId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersTodoListsTasksCreateExtensionsRequest struct {
	ctx _context.Context
	ApiService *UsersTodoApiService
	userId string
	todoTaskListId string
	todoTaskId string
	microsoftGraphExtension *MicrosoftGraphExtension
}

// New navigation property
func (r ApiUsersTodoListsTasksCreateExtensionsRequest) MicrosoftGraphExtension(microsoftGraphExtension MicrosoftGraphExtension) ApiUsersTodoListsTasksCreateExtensionsRequest {
	r.microsoftGraphExtension = &microsoftGraphExtension
	return r
}

func (r ApiUsersTodoListsTasksCreateExtensionsRequest) Execute() (MicrosoftGraphExtension, *_nethttp.Response, error) {
	return r.ApiService.UsersTodoListsTasksCreateExtensionsExecute(r)
}

/*
UsersTodoListsTasksCreateExtensions Create new navigation property to extensions for users

The collection of open extensions defined for the task. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param todoTaskListId key: id of todoTaskList
 @param todoTaskId key: id of todoTask
 @return ApiUsersTodoListsTasksCreateExtensionsRequest
*/
func (a *UsersTodoApiService) UsersTodoListsTasksCreateExtensions(ctx _context.Context, userId string, todoTaskListId string, todoTaskId string) ApiUsersTodoListsTasksCreateExtensionsRequest {
	return ApiUsersTodoListsTasksCreateExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		todoTaskListId: todoTaskListId,
		todoTaskId: todoTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphExtension
func (a *UsersTodoApiService) UsersTodoListsTasksCreateExtensionsExecute(r ApiUsersTodoListsTasksCreateExtensionsRequest) (MicrosoftGraphExtension, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphExtension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersTodoApiService.UsersTodoListsTasksCreateExtensions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/todo/lists/{todoTaskList-id}/tasks/{todoTask-id}/extensions"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"todoTaskList-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskListId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"todoTask-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphExtension == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphExtension is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphExtension
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersTodoListsTasksCreateLinkedResourcesRequest struct {
	ctx _context.Context
	ApiService *UsersTodoApiService
	userId string
	todoTaskListId string
	todoTaskId string
	microsoftGraphLinkedResource *MicrosoftGraphLinkedResource
}

// New navigation property
func (r ApiUsersTodoListsTasksCreateLinkedResourcesRequest) MicrosoftGraphLinkedResource(microsoftGraphLinkedResource MicrosoftGraphLinkedResource) ApiUsersTodoListsTasksCreateLinkedResourcesRequest {
	r.microsoftGraphLinkedResource = &microsoftGraphLinkedResource
	return r
}

func (r ApiUsersTodoListsTasksCreateLinkedResourcesRequest) Execute() (MicrosoftGraphLinkedResource, *_nethttp.Response, error) {
	return r.ApiService.UsersTodoListsTasksCreateLinkedResourcesExecute(r)
}

/*
UsersTodoListsTasksCreateLinkedResources Create new navigation property to linkedResources for users

A collection of resources linked to the task.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param todoTaskListId key: id of todoTaskList
 @param todoTaskId key: id of todoTask
 @return ApiUsersTodoListsTasksCreateLinkedResourcesRequest
*/
func (a *UsersTodoApiService) UsersTodoListsTasksCreateLinkedResources(ctx _context.Context, userId string, todoTaskListId string, todoTaskId string) ApiUsersTodoListsTasksCreateLinkedResourcesRequest {
	return ApiUsersTodoListsTasksCreateLinkedResourcesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		todoTaskListId: todoTaskListId,
		todoTaskId: todoTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphLinkedResource
func (a *UsersTodoApiService) UsersTodoListsTasksCreateLinkedResourcesExecute(r ApiUsersTodoListsTasksCreateLinkedResourcesRequest) (MicrosoftGraphLinkedResource, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphLinkedResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersTodoApiService.UsersTodoListsTasksCreateLinkedResources")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/todo/lists/{todoTaskList-id}/tasks/{todoTask-id}/linkedResources"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"todoTaskList-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskListId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"todoTask-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphLinkedResource == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphLinkedResource is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphLinkedResource
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersTodoListsTasksDeleteExtensionsRequest struct {
	ctx _context.Context
	ApiService *UsersTodoApiService
	userId string
	todoTaskListId string
	todoTaskId string
	extensionId string
	ifMatch *string
}

// ETag
func (r ApiUsersTodoListsTasksDeleteExtensionsRequest) IfMatch(ifMatch string) ApiUsersTodoListsTasksDeleteExtensionsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersTodoListsTasksDeleteExtensionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersTodoListsTasksDeleteExtensionsExecute(r)
}

/*
UsersTodoListsTasksDeleteExtensions Delete navigation property extensions for users

The collection of open extensions defined for the task. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param todoTaskListId key: id of todoTaskList
 @param todoTaskId key: id of todoTask
 @param extensionId key: id of extension
 @return ApiUsersTodoListsTasksDeleteExtensionsRequest
*/
func (a *UsersTodoApiService) UsersTodoListsTasksDeleteExtensions(ctx _context.Context, userId string, todoTaskListId string, todoTaskId string, extensionId string) ApiUsersTodoListsTasksDeleteExtensionsRequest {
	return ApiUsersTodoListsTasksDeleteExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		todoTaskListId: todoTaskListId,
		todoTaskId: todoTaskId,
		extensionId: extensionId,
	}
}

// Execute executes the request
func (a *UsersTodoApiService) UsersTodoListsTasksDeleteExtensionsExecute(r ApiUsersTodoListsTasksDeleteExtensionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersTodoApiService.UsersTodoListsTasksDeleteExtensions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/todo/lists/{todoTaskList-id}/tasks/{todoTask-id}/extensions/{extension-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"todoTaskList-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskListId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"todoTask-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension-id"+"}", _neturl.PathEscape(parameterToString(r.extensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersTodoListsTasksDeleteLinkedResourcesRequest struct {
	ctx _context.Context
	ApiService *UsersTodoApiService
	userId string
	todoTaskListId string
	todoTaskId string
	linkedResourceId string
	ifMatch *string
}

// ETag
func (r ApiUsersTodoListsTasksDeleteLinkedResourcesRequest) IfMatch(ifMatch string) ApiUsersTodoListsTasksDeleteLinkedResourcesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersTodoListsTasksDeleteLinkedResourcesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersTodoListsTasksDeleteLinkedResourcesExecute(r)
}

/*
UsersTodoListsTasksDeleteLinkedResources Delete navigation property linkedResources for users

A collection of resources linked to the task.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param todoTaskListId key: id of todoTaskList
 @param todoTaskId key: id of todoTask
 @param linkedResourceId key: id of linkedResource
 @return ApiUsersTodoListsTasksDeleteLinkedResourcesRequest
*/
func (a *UsersTodoApiService) UsersTodoListsTasksDeleteLinkedResources(ctx _context.Context, userId string, todoTaskListId string, todoTaskId string, linkedResourceId string) ApiUsersTodoListsTasksDeleteLinkedResourcesRequest {
	return ApiUsersTodoListsTasksDeleteLinkedResourcesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		todoTaskListId: todoTaskListId,
		todoTaskId: todoTaskId,
		linkedResourceId: linkedResourceId,
	}
}

// Execute executes the request
func (a *UsersTodoApiService) UsersTodoListsTasksDeleteLinkedResourcesExecute(r ApiUsersTodoListsTasksDeleteLinkedResourcesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersTodoApiService.UsersTodoListsTasksDeleteLinkedResources")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/todo/lists/{todoTaskList-id}/tasks/{todoTask-id}/linkedResources/{linkedResource-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"todoTaskList-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskListId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"todoTask-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"linkedResource-id"+"}", _neturl.PathEscape(parameterToString(r.linkedResourceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersTodoListsTasksGetExtensionsRequest struct {
	ctx _context.Context
	ApiService *UsersTodoApiService
	userId string
	todoTaskListId string
	todoTaskId string
	extensionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiUsersTodoListsTasksGetExtensionsRequest) Select_(select_ []string) ApiUsersTodoListsTasksGetExtensionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersTodoListsTasksGetExtensionsRequest) Expand(expand []string) ApiUsersTodoListsTasksGetExtensionsRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersTodoListsTasksGetExtensionsRequest) Execute() (MicrosoftGraphExtension, *_nethttp.Response, error) {
	return r.ApiService.UsersTodoListsTasksGetExtensionsExecute(r)
}

/*
UsersTodoListsTasksGetExtensions Get extensions from users

The collection of open extensions defined for the task. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param todoTaskListId key: id of todoTaskList
 @param todoTaskId key: id of todoTask
 @param extensionId key: id of extension
 @return ApiUsersTodoListsTasksGetExtensionsRequest
*/
func (a *UsersTodoApiService) UsersTodoListsTasksGetExtensions(ctx _context.Context, userId string, todoTaskListId string, todoTaskId string, extensionId string) ApiUsersTodoListsTasksGetExtensionsRequest {
	return ApiUsersTodoListsTasksGetExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		todoTaskListId: todoTaskListId,
		todoTaskId: todoTaskId,
		extensionId: extensionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphExtension
func (a *UsersTodoApiService) UsersTodoListsTasksGetExtensionsExecute(r ApiUsersTodoListsTasksGetExtensionsRequest) (MicrosoftGraphExtension, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphExtension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersTodoApiService.UsersTodoListsTasksGetExtensions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/todo/lists/{todoTaskList-id}/tasks/{todoTask-id}/extensions/{extension-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"todoTaskList-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskListId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"todoTask-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension-id"+"}", _neturl.PathEscape(parameterToString(r.extensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersTodoListsTasksGetLinkedResourcesRequest struct {
	ctx _context.Context
	ApiService *UsersTodoApiService
	userId string
	todoTaskListId string
	todoTaskId string
	linkedResourceId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiUsersTodoListsTasksGetLinkedResourcesRequest) Select_(select_ []string) ApiUsersTodoListsTasksGetLinkedResourcesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersTodoListsTasksGetLinkedResourcesRequest) Expand(expand []string) ApiUsersTodoListsTasksGetLinkedResourcesRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersTodoListsTasksGetLinkedResourcesRequest) Execute() (MicrosoftGraphLinkedResource, *_nethttp.Response, error) {
	return r.ApiService.UsersTodoListsTasksGetLinkedResourcesExecute(r)
}

/*
UsersTodoListsTasksGetLinkedResources Get linkedResources from users

A collection of resources linked to the task.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param todoTaskListId key: id of todoTaskList
 @param todoTaskId key: id of todoTask
 @param linkedResourceId key: id of linkedResource
 @return ApiUsersTodoListsTasksGetLinkedResourcesRequest
*/
func (a *UsersTodoApiService) UsersTodoListsTasksGetLinkedResources(ctx _context.Context, userId string, todoTaskListId string, todoTaskId string, linkedResourceId string) ApiUsersTodoListsTasksGetLinkedResourcesRequest {
	return ApiUsersTodoListsTasksGetLinkedResourcesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		todoTaskListId: todoTaskListId,
		todoTaskId: todoTaskId,
		linkedResourceId: linkedResourceId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphLinkedResource
func (a *UsersTodoApiService) UsersTodoListsTasksGetLinkedResourcesExecute(r ApiUsersTodoListsTasksGetLinkedResourcesRequest) (MicrosoftGraphLinkedResource, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphLinkedResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersTodoApiService.UsersTodoListsTasksGetLinkedResources")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/todo/lists/{todoTaskList-id}/tasks/{todoTask-id}/linkedResources/{linkedResource-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"todoTaskList-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskListId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"todoTask-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"linkedResource-id"+"}", _neturl.PathEscape(parameterToString(r.linkedResourceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersTodoListsTasksListExtensionsRequest struct {
	ctx _context.Context
	ApiService *UsersTodoApiService
	userId string
	todoTaskListId string
	todoTaskId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiUsersTodoListsTasksListExtensionsRequest) Top(top int32) ApiUsersTodoListsTasksListExtensionsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiUsersTodoListsTasksListExtensionsRequest) Skip(skip int32) ApiUsersTodoListsTasksListExtensionsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiUsersTodoListsTasksListExtensionsRequest) Search(search string) ApiUsersTodoListsTasksListExtensionsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiUsersTodoListsTasksListExtensionsRequest) Filter(filter string) ApiUsersTodoListsTasksListExtensionsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiUsersTodoListsTasksListExtensionsRequest) Count(count bool) ApiUsersTodoListsTasksListExtensionsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiUsersTodoListsTasksListExtensionsRequest) Orderby(orderby []string) ApiUsersTodoListsTasksListExtensionsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiUsersTodoListsTasksListExtensionsRequest) Select_(select_ []string) ApiUsersTodoListsTasksListExtensionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersTodoListsTasksListExtensionsRequest) Expand(expand []string) ApiUsersTodoListsTasksListExtensionsRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersTodoListsTasksListExtensionsRequest) Execute() (CollectionOfExtension, *_nethttp.Response, error) {
	return r.ApiService.UsersTodoListsTasksListExtensionsExecute(r)
}

/*
UsersTodoListsTasksListExtensions Get extensions from users

The collection of open extensions defined for the task. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param todoTaskListId key: id of todoTaskList
 @param todoTaskId key: id of todoTask
 @return ApiUsersTodoListsTasksListExtensionsRequest
*/
func (a *UsersTodoApiService) UsersTodoListsTasksListExtensions(ctx _context.Context, userId string, todoTaskListId string, todoTaskId string) ApiUsersTodoListsTasksListExtensionsRequest {
	return ApiUsersTodoListsTasksListExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		todoTaskListId: todoTaskListId,
		todoTaskId: todoTaskId,
	}
}

// Execute executes the request
//  @return CollectionOfExtension
func (a *UsersTodoApiService) UsersTodoListsTasksListExtensionsExecute(r ApiUsersTodoListsTasksListExtensionsRequest) (CollectionOfExtension, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfExtension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersTodoApiService.UsersTodoListsTasksListExtensions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/todo/lists/{todoTaskList-id}/tasks/{todoTask-id}/extensions"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"todoTaskList-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskListId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"todoTask-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersTodoListsTasksListLinkedResourcesRequest struct {
	ctx _context.Context
	ApiService *UsersTodoApiService
	userId string
	todoTaskListId string
	todoTaskId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiUsersTodoListsTasksListLinkedResourcesRequest) Top(top int32) ApiUsersTodoListsTasksListLinkedResourcesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiUsersTodoListsTasksListLinkedResourcesRequest) Skip(skip int32) ApiUsersTodoListsTasksListLinkedResourcesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiUsersTodoListsTasksListLinkedResourcesRequest) Search(search string) ApiUsersTodoListsTasksListLinkedResourcesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiUsersTodoListsTasksListLinkedResourcesRequest) Filter(filter string) ApiUsersTodoListsTasksListLinkedResourcesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiUsersTodoListsTasksListLinkedResourcesRequest) Count(count bool) ApiUsersTodoListsTasksListLinkedResourcesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiUsersTodoListsTasksListLinkedResourcesRequest) Orderby(orderby []string) ApiUsersTodoListsTasksListLinkedResourcesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiUsersTodoListsTasksListLinkedResourcesRequest) Select_(select_ []string) ApiUsersTodoListsTasksListLinkedResourcesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersTodoListsTasksListLinkedResourcesRequest) Expand(expand []string) ApiUsersTodoListsTasksListLinkedResourcesRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersTodoListsTasksListLinkedResourcesRequest) Execute() (CollectionOfLinkedResource, *_nethttp.Response, error) {
	return r.ApiService.UsersTodoListsTasksListLinkedResourcesExecute(r)
}

/*
UsersTodoListsTasksListLinkedResources Get linkedResources from users

A collection of resources linked to the task.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param todoTaskListId key: id of todoTaskList
 @param todoTaskId key: id of todoTask
 @return ApiUsersTodoListsTasksListLinkedResourcesRequest
*/
func (a *UsersTodoApiService) UsersTodoListsTasksListLinkedResources(ctx _context.Context, userId string, todoTaskListId string, todoTaskId string) ApiUsersTodoListsTasksListLinkedResourcesRequest {
	return ApiUsersTodoListsTasksListLinkedResourcesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		todoTaskListId: todoTaskListId,
		todoTaskId: todoTaskId,
	}
}

// Execute executes the request
//  @return CollectionOfLinkedResource
func (a *UsersTodoApiService) UsersTodoListsTasksListLinkedResourcesExecute(r ApiUsersTodoListsTasksListLinkedResourcesRequest) (CollectionOfLinkedResource, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfLinkedResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersTodoApiService.UsersTodoListsTasksListLinkedResources")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/todo/lists/{todoTaskList-id}/tasks/{todoTask-id}/linkedResources"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"todoTaskList-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskListId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"todoTask-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersTodoListsTasksUpdateExtensionsRequest struct {
	ctx _context.Context
	ApiService *UsersTodoApiService
	userId string
	todoTaskListId string
	todoTaskId string
	extensionId string
	microsoftGraphExtension *MicrosoftGraphExtension
}

// New navigation property values
func (r ApiUsersTodoListsTasksUpdateExtensionsRequest) MicrosoftGraphExtension(microsoftGraphExtension MicrosoftGraphExtension) ApiUsersTodoListsTasksUpdateExtensionsRequest {
	r.microsoftGraphExtension = &microsoftGraphExtension
	return r
}

func (r ApiUsersTodoListsTasksUpdateExtensionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersTodoListsTasksUpdateExtensionsExecute(r)
}

/*
UsersTodoListsTasksUpdateExtensions Update the navigation property extensions in users

The collection of open extensions defined for the task. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param todoTaskListId key: id of todoTaskList
 @param todoTaskId key: id of todoTask
 @param extensionId key: id of extension
 @return ApiUsersTodoListsTasksUpdateExtensionsRequest
*/
func (a *UsersTodoApiService) UsersTodoListsTasksUpdateExtensions(ctx _context.Context, userId string, todoTaskListId string, todoTaskId string, extensionId string) ApiUsersTodoListsTasksUpdateExtensionsRequest {
	return ApiUsersTodoListsTasksUpdateExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		todoTaskListId: todoTaskListId,
		todoTaskId: todoTaskId,
		extensionId: extensionId,
	}
}

// Execute executes the request
func (a *UsersTodoApiService) UsersTodoListsTasksUpdateExtensionsExecute(r ApiUsersTodoListsTasksUpdateExtensionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersTodoApiService.UsersTodoListsTasksUpdateExtensions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/todo/lists/{todoTaskList-id}/tasks/{todoTask-id}/extensions/{extension-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"todoTaskList-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskListId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"todoTask-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension-id"+"}", _neturl.PathEscape(parameterToString(r.extensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphExtension == nil {
		return nil, reportError("microsoftGraphExtension is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphExtension
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersTodoListsTasksUpdateLinkedResourcesRequest struct {
	ctx _context.Context
	ApiService *UsersTodoApiService
	userId string
	todoTaskListId string
	todoTaskId string
	linkedResourceId string
	microsoftGraphLinkedResource *MicrosoftGraphLinkedResource
}

// New navigation property values
func (r ApiUsersTodoListsTasksUpdateLinkedResourcesRequest) MicrosoftGraphLinkedResource(microsoftGraphLinkedResource MicrosoftGraphLinkedResource) ApiUsersTodoListsTasksUpdateLinkedResourcesRequest {
	r.microsoftGraphLinkedResource = &microsoftGraphLinkedResource
	return r
}

func (r ApiUsersTodoListsTasksUpdateLinkedResourcesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersTodoListsTasksUpdateLinkedResourcesExecute(r)
}

/*
UsersTodoListsTasksUpdateLinkedResources Update the navigation property linkedResources in users

A collection of resources linked to the task.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param todoTaskListId key: id of todoTaskList
 @param todoTaskId key: id of todoTask
 @param linkedResourceId key: id of linkedResource
 @return ApiUsersTodoListsTasksUpdateLinkedResourcesRequest
*/
func (a *UsersTodoApiService) UsersTodoListsTasksUpdateLinkedResources(ctx _context.Context, userId string, todoTaskListId string, todoTaskId string, linkedResourceId string) ApiUsersTodoListsTasksUpdateLinkedResourcesRequest {
	return ApiUsersTodoListsTasksUpdateLinkedResourcesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		todoTaskListId: todoTaskListId,
		todoTaskId: todoTaskId,
		linkedResourceId: linkedResourceId,
	}
}

// Execute executes the request
func (a *UsersTodoApiService) UsersTodoListsTasksUpdateLinkedResourcesExecute(r ApiUsersTodoListsTasksUpdateLinkedResourcesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersTodoApiService.UsersTodoListsTasksUpdateLinkedResources")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/todo/lists/{todoTaskList-id}/tasks/{todoTask-id}/linkedResources/{linkedResource-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"todoTaskList-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskListId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"todoTask-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"linkedResource-id"+"}", _neturl.PathEscape(parameterToString(r.linkedResourceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphLinkedResource == nil {
		return nil, reportError("microsoftGraphLinkedResource is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphLinkedResource
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersTodoListsUpdateExtensionsRequest struct {
	ctx _context.Context
	ApiService *UsersTodoApiService
	userId string
	todoTaskListId string
	extensionId string
	microsoftGraphExtension *MicrosoftGraphExtension
}

// New navigation property values
func (r ApiUsersTodoListsUpdateExtensionsRequest) MicrosoftGraphExtension(microsoftGraphExtension MicrosoftGraphExtension) ApiUsersTodoListsUpdateExtensionsRequest {
	r.microsoftGraphExtension = &microsoftGraphExtension
	return r
}

func (r ApiUsersTodoListsUpdateExtensionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersTodoListsUpdateExtensionsExecute(r)
}

/*
UsersTodoListsUpdateExtensions Update the navigation property extensions in users

The collection of open extensions defined for the task list. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param todoTaskListId key: id of todoTaskList
 @param extensionId key: id of extension
 @return ApiUsersTodoListsUpdateExtensionsRequest
*/
func (a *UsersTodoApiService) UsersTodoListsUpdateExtensions(ctx _context.Context, userId string, todoTaskListId string, extensionId string) ApiUsersTodoListsUpdateExtensionsRequest {
	return ApiUsersTodoListsUpdateExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		todoTaskListId: todoTaskListId,
		extensionId: extensionId,
	}
}

// Execute executes the request
func (a *UsersTodoApiService) UsersTodoListsUpdateExtensionsExecute(r ApiUsersTodoListsUpdateExtensionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersTodoApiService.UsersTodoListsUpdateExtensions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/todo/lists/{todoTaskList-id}/extensions/{extension-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"todoTaskList-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskListId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension-id"+"}", _neturl.PathEscape(parameterToString(r.extensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphExtension == nil {
		return nil, reportError("microsoftGraphExtension is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphExtension
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersTodoListsUpdateTasksRequest struct {
	ctx _context.Context
	ApiService *UsersTodoApiService
	userId string
	todoTaskListId string
	todoTaskId string
	microsoftGraphTodoTask *MicrosoftGraphTodoTask
}

// New navigation property values
func (r ApiUsersTodoListsUpdateTasksRequest) MicrosoftGraphTodoTask(microsoftGraphTodoTask MicrosoftGraphTodoTask) ApiUsersTodoListsUpdateTasksRequest {
	r.microsoftGraphTodoTask = &microsoftGraphTodoTask
	return r
}

func (r ApiUsersTodoListsUpdateTasksRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersTodoListsUpdateTasksExecute(r)
}

/*
UsersTodoListsUpdateTasks Update the navigation property tasks in users

The tasks in this task list. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param todoTaskListId key: id of todoTaskList
 @param todoTaskId key: id of todoTask
 @return ApiUsersTodoListsUpdateTasksRequest
*/
func (a *UsersTodoApiService) UsersTodoListsUpdateTasks(ctx _context.Context, userId string, todoTaskListId string, todoTaskId string) ApiUsersTodoListsUpdateTasksRequest {
	return ApiUsersTodoListsUpdateTasksRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		todoTaskListId: todoTaskListId,
		todoTaskId: todoTaskId,
	}
}

// Execute executes the request
func (a *UsersTodoApiService) UsersTodoListsUpdateTasksExecute(r ApiUsersTodoListsUpdateTasksRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersTodoApiService.UsersTodoListsUpdateTasks")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/todo/lists/{todoTaskList-id}/tasks/{todoTask-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"todoTaskList-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskListId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"todoTask-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTodoTask == nil {
		return nil, reportError("microsoftGraphTodoTask is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTodoTask
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersTodoUpdateListsRequest struct {
	ctx _context.Context
	ApiService *UsersTodoApiService
	userId string
	todoTaskListId string
	microsoftGraphTodoTaskList *MicrosoftGraphTodoTaskList
}

// New navigation property values
func (r ApiUsersTodoUpdateListsRequest) MicrosoftGraphTodoTaskList(microsoftGraphTodoTaskList MicrosoftGraphTodoTaskList) ApiUsersTodoUpdateListsRequest {
	r.microsoftGraphTodoTaskList = &microsoftGraphTodoTaskList
	return r
}

func (r ApiUsersTodoUpdateListsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersTodoUpdateListsExecute(r)
}

/*
UsersTodoUpdateLists Update the navigation property lists in users

The task lists in the users mailbox.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param todoTaskListId key: id of todoTaskList
 @return ApiUsersTodoUpdateListsRequest
*/
func (a *UsersTodoApiService) UsersTodoUpdateLists(ctx _context.Context, userId string, todoTaskListId string) ApiUsersTodoUpdateListsRequest {
	return ApiUsersTodoUpdateListsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		todoTaskListId: todoTaskListId,
	}
}

// Execute executes the request
func (a *UsersTodoApiService) UsersTodoUpdateListsExecute(r ApiUsersTodoUpdateListsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersTodoApiService.UsersTodoUpdateLists")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/todo/lists/{todoTaskList-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"todoTaskList-id"+"}", _neturl.PathEscape(parameterToString(r.todoTaskListId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTodoTaskList == nil {
		return nil, reportError("microsoftGraphTodoTaskList is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTodoTaskList
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUpdateTodoRequest struct {
	ctx _context.Context
	ApiService *UsersTodoApiService
	userId string
	microsoftGraphTodo *MicrosoftGraphTodo
}

// New navigation property values
func (r ApiUsersUpdateTodoRequest) MicrosoftGraphTodo(microsoftGraphTodo MicrosoftGraphTodo) ApiUsersUpdateTodoRequest {
	r.microsoftGraphTodo = &microsoftGraphTodo
	return r
}

func (r ApiUsersUpdateTodoRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUpdateTodoExecute(r)
}

/*
UsersUpdateTodo Update the navigation property todo in users

Represents the To Do services available to a user.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @return ApiUsersUpdateTodoRequest
*/
func (a *UsersTodoApiService) UsersUpdateTodo(ctx _context.Context, userId string) ApiUsersUpdateTodoRequest {
	return ApiUsersUpdateTodoRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
func (a *UsersTodoApiService) UsersUpdateTodoExecute(r ApiUsersUpdateTodoRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersTodoApiService.UsersUpdateTodo")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/todo"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTodo == nil {
		return nil, reportError("microsoftGraphTodo is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTodo
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
