/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package msgraph

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// GroupsPlannerGroupApiService GroupsPlannerGroupApi service
type GroupsPlannerGroupApiService service

type ApiGroupsDeletePlannerRequest struct {
	ctx _context.Context
	ApiService *GroupsPlannerGroupApiService
	groupId string
	ifMatch *string
}

// ETag
func (r ApiGroupsDeletePlannerRequest) IfMatch(ifMatch string) ApiGroupsDeletePlannerRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsDeletePlannerRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsDeletePlannerExecute(r)
}

/*
GroupsDeletePlanner Delete navigation property planner for groups

Entry-point to Planner resource that might exist for a Unified Group.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsDeletePlannerRequest
*/
func (a *GroupsPlannerGroupApiService) GroupsDeletePlanner(ctx _context.Context, groupId string) ApiGroupsDeletePlannerRequest {
	return ApiGroupsDeletePlannerRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
func (a *GroupsPlannerGroupApiService) GroupsDeletePlannerExecute(r ApiGroupsDeletePlannerRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsPlannerGroupApiService.GroupsDeletePlanner")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/planner"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGetPlannerRequest struct {
	ctx _context.Context
	ApiService *GroupsPlannerGroupApiService
	groupId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiGroupsGetPlannerRequest) Select_(select_ []string) ApiGroupsGetPlannerRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsGetPlannerRequest) Expand(expand []string) ApiGroupsGetPlannerRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsGetPlannerRequest) Execute() (MicrosoftGraphPlannerGroup, *_nethttp.Response, error) {
	return r.ApiService.GroupsGetPlannerExecute(r)
}

/*
GroupsGetPlanner Get planner from groups

Entry-point to Planner resource that might exist for a Unified Group.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsGetPlannerRequest
*/
func (a *GroupsPlannerGroupApiService) GroupsGetPlanner(ctx _context.Context, groupId string) ApiGroupsGetPlannerRequest {
	return ApiGroupsGetPlannerRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerGroup
func (a *GroupsPlannerGroupApiService) GroupsGetPlannerExecute(r ApiGroupsGetPlannerRequest) (MicrosoftGraphPlannerGroup, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsPlannerGroupApiService.GroupsGetPlanner")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/planner"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsPlannerCreatePlansRequest struct {
	ctx _context.Context
	ApiService *GroupsPlannerGroupApiService
	groupId string
	microsoftGraphPlannerPlan *MicrosoftGraphPlannerPlan
}

// New navigation property
func (r ApiGroupsPlannerCreatePlansRequest) MicrosoftGraphPlannerPlan(microsoftGraphPlannerPlan MicrosoftGraphPlannerPlan) ApiGroupsPlannerCreatePlansRequest {
	r.microsoftGraphPlannerPlan = &microsoftGraphPlannerPlan
	return r
}

func (r ApiGroupsPlannerCreatePlansRequest) Execute() (MicrosoftGraphPlannerPlan, *_nethttp.Response, error) {
	return r.ApiService.GroupsPlannerCreatePlansExecute(r)
}

/*
GroupsPlannerCreatePlans Create new navigation property to plans for groups

Read-only. Nullable. Returns the plannerPlans owned by the group.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsPlannerCreatePlansRequest
*/
func (a *GroupsPlannerGroupApiService) GroupsPlannerCreatePlans(ctx _context.Context, groupId string) ApiGroupsPlannerCreatePlansRequest {
	return ApiGroupsPlannerCreatePlansRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerPlan
func (a *GroupsPlannerGroupApiService) GroupsPlannerCreatePlansExecute(r ApiGroupsPlannerCreatePlansRequest) (MicrosoftGraphPlannerPlan, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerPlan
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsPlannerGroupApiService.GroupsPlannerCreatePlans")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/planner/plans"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerPlan == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphPlannerPlan is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerPlan
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsPlannerDeletePlansRequest struct {
	ctx _context.Context
	ApiService *GroupsPlannerGroupApiService
	groupId string
	plannerPlanId string
	ifMatch *string
}

// ETag
func (r ApiGroupsPlannerDeletePlansRequest) IfMatch(ifMatch string) ApiGroupsPlannerDeletePlansRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsPlannerDeletePlansRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsPlannerDeletePlansExecute(r)
}

/*
GroupsPlannerDeletePlans Delete navigation property plans for groups

Read-only. Nullable. Returns the plannerPlans owned by the group.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param plannerPlanId key: id of plannerPlan
 @return ApiGroupsPlannerDeletePlansRequest
*/
func (a *GroupsPlannerGroupApiService) GroupsPlannerDeletePlans(ctx _context.Context, groupId string, plannerPlanId string) ApiGroupsPlannerDeletePlansRequest {
	return ApiGroupsPlannerDeletePlansRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		plannerPlanId: plannerPlanId,
	}
}

// Execute executes the request
func (a *GroupsPlannerGroupApiService) GroupsPlannerDeletePlansExecute(r ApiGroupsPlannerDeletePlansRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsPlannerGroupApiService.GroupsPlannerDeletePlans")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/planner/plans/{plannerPlan-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsPlannerGetPlansRequest struct {
	ctx _context.Context
	ApiService *GroupsPlannerGroupApiService
	groupId string
	plannerPlanId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiGroupsPlannerGetPlansRequest) Select_(select_ []string) ApiGroupsPlannerGetPlansRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsPlannerGetPlansRequest) Expand(expand []string) ApiGroupsPlannerGetPlansRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsPlannerGetPlansRequest) Execute() (MicrosoftGraphPlannerPlan, *_nethttp.Response, error) {
	return r.ApiService.GroupsPlannerGetPlansExecute(r)
}

/*
GroupsPlannerGetPlans Get plans from groups

Read-only. Nullable. Returns the plannerPlans owned by the group.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param plannerPlanId key: id of plannerPlan
 @return ApiGroupsPlannerGetPlansRequest
*/
func (a *GroupsPlannerGroupApiService) GroupsPlannerGetPlans(ctx _context.Context, groupId string, plannerPlanId string) ApiGroupsPlannerGetPlansRequest {
	return ApiGroupsPlannerGetPlansRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		plannerPlanId: plannerPlanId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerPlan
func (a *GroupsPlannerGroupApiService) GroupsPlannerGetPlansExecute(r ApiGroupsPlannerGetPlansRequest) (MicrosoftGraphPlannerPlan, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerPlan
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsPlannerGroupApiService.GroupsPlannerGetPlans")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/planner/plans/{plannerPlan-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsPlannerListPlansRequest struct {
	ctx _context.Context
	ApiService *GroupsPlannerGroupApiService
	groupId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiGroupsPlannerListPlansRequest) Top(top int32) ApiGroupsPlannerListPlansRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsPlannerListPlansRequest) Skip(skip int32) ApiGroupsPlannerListPlansRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiGroupsPlannerListPlansRequest) Search(search string) ApiGroupsPlannerListPlansRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiGroupsPlannerListPlansRequest) Filter(filter string) ApiGroupsPlannerListPlansRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsPlannerListPlansRequest) Count(count bool) ApiGroupsPlannerListPlansRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsPlannerListPlansRequest) Orderby(orderby []string) ApiGroupsPlannerListPlansRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiGroupsPlannerListPlansRequest) Select_(select_ []string) ApiGroupsPlannerListPlansRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsPlannerListPlansRequest) Expand(expand []string) ApiGroupsPlannerListPlansRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsPlannerListPlansRequest) Execute() (CollectionOfPlannerPlan, *_nethttp.Response, error) {
	return r.ApiService.GroupsPlannerListPlansExecute(r)
}

/*
GroupsPlannerListPlans Get plans from groups

Read-only. Nullable. Returns the plannerPlans owned by the group.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsPlannerListPlansRequest
*/
func (a *GroupsPlannerGroupApiService) GroupsPlannerListPlans(ctx _context.Context, groupId string) ApiGroupsPlannerListPlansRequest {
	return ApiGroupsPlannerListPlansRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return CollectionOfPlannerPlan
func (a *GroupsPlannerGroupApiService) GroupsPlannerListPlansExecute(r ApiGroupsPlannerListPlansRequest) (CollectionOfPlannerPlan, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfPlannerPlan
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsPlannerGroupApiService.GroupsPlannerListPlans")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/planner/plans"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsPlannerPlansBucketsCreateTasksRequest struct {
	ctx _context.Context
	ApiService *GroupsPlannerGroupApiService
	groupId string
	plannerPlanId string
	plannerBucketId string
	microsoftGraphPlannerTask *MicrosoftGraphPlannerTask
}

// New navigation property
func (r ApiGroupsPlannerPlansBucketsCreateTasksRequest) MicrosoftGraphPlannerTask(microsoftGraphPlannerTask MicrosoftGraphPlannerTask) ApiGroupsPlannerPlansBucketsCreateTasksRequest {
	r.microsoftGraphPlannerTask = &microsoftGraphPlannerTask
	return r
}

func (r ApiGroupsPlannerPlansBucketsCreateTasksRequest) Execute() (MicrosoftGraphPlannerTask, *_nethttp.Response, error) {
	return r.ApiService.GroupsPlannerPlansBucketsCreateTasksExecute(r)
}

/*
GroupsPlannerPlansBucketsCreateTasks Create new navigation property to tasks for groups

Read-only. Nullable. The collection of tasks in the bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @return ApiGroupsPlannerPlansBucketsCreateTasksRequest
*/
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansBucketsCreateTasks(ctx _context.Context, groupId string, plannerPlanId string, plannerBucketId string) ApiGroupsPlannerPlansBucketsCreateTasksRequest {
	return ApiGroupsPlannerPlansBucketsCreateTasksRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerTask
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansBucketsCreateTasksExecute(r ApiGroupsPlannerPlansBucketsCreateTasksRequest) (MicrosoftGraphPlannerTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsPlannerGroupApiService.GroupsPlannerPlansBucketsCreateTasks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerTask == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphPlannerTask is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerTask
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsPlannerPlansBucketsDeleteTasksRequest struct {
	ctx _context.Context
	ApiService *GroupsPlannerGroupApiService
	groupId string
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiGroupsPlannerPlansBucketsDeleteTasksRequest) IfMatch(ifMatch string) ApiGroupsPlannerPlansBucketsDeleteTasksRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsPlannerPlansBucketsDeleteTasksRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsPlannerPlansBucketsDeleteTasksExecute(r)
}

/*
GroupsPlannerPlansBucketsDeleteTasks Delete navigation property tasks for groups

Read-only. Nullable. The collection of tasks in the bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiGroupsPlannerPlansBucketsDeleteTasksRequest
*/
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansBucketsDeleteTasks(ctx _context.Context, groupId string, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiGroupsPlannerPlansBucketsDeleteTasksRequest {
	return ApiGroupsPlannerPlansBucketsDeleteTasksRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansBucketsDeleteTasksExecute(r ApiGroupsPlannerPlansBucketsDeleteTasksRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsPlannerGroupApiService.GroupsPlannerPlansBucketsDeleteTasks")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsPlannerPlansBucketsGetTasksRequest struct {
	ctx _context.Context
	ApiService *GroupsPlannerGroupApiService
	groupId string
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiGroupsPlannerPlansBucketsGetTasksRequest) Select_(select_ []string) ApiGroupsPlannerPlansBucketsGetTasksRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsPlannerPlansBucketsGetTasksRequest) Expand(expand []string) ApiGroupsPlannerPlansBucketsGetTasksRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsPlannerPlansBucketsGetTasksRequest) Execute() (MicrosoftGraphPlannerTask, *_nethttp.Response, error) {
	return r.ApiService.GroupsPlannerPlansBucketsGetTasksExecute(r)
}

/*
GroupsPlannerPlansBucketsGetTasks Get tasks from groups

Read-only. Nullable. The collection of tasks in the bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiGroupsPlannerPlansBucketsGetTasksRequest
*/
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansBucketsGetTasks(ctx _context.Context, groupId string, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiGroupsPlannerPlansBucketsGetTasksRequest {
	return ApiGroupsPlannerPlansBucketsGetTasksRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerTask
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansBucketsGetTasksExecute(r ApiGroupsPlannerPlansBucketsGetTasksRequest) (MicrosoftGraphPlannerTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsPlannerGroupApiService.GroupsPlannerPlansBucketsGetTasks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsPlannerPlansBucketsListTasksRequest struct {
	ctx _context.Context
	ApiService *GroupsPlannerGroupApiService
	groupId string
	plannerPlanId string
	plannerBucketId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiGroupsPlannerPlansBucketsListTasksRequest) Top(top int32) ApiGroupsPlannerPlansBucketsListTasksRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsPlannerPlansBucketsListTasksRequest) Skip(skip int32) ApiGroupsPlannerPlansBucketsListTasksRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiGroupsPlannerPlansBucketsListTasksRequest) Search(search string) ApiGroupsPlannerPlansBucketsListTasksRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiGroupsPlannerPlansBucketsListTasksRequest) Filter(filter string) ApiGroupsPlannerPlansBucketsListTasksRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsPlannerPlansBucketsListTasksRequest) Count(count bool) ApiGroupsPlannerPlansBucketsListTasksRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsPlannerPlansBucketsListTasksRequest) Orderby(orderby []string) ApiGroupsPlannerPlansBucketsListTasksRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiGroupsPlannerPlansBucketsListTasksRequest) Select_(select_ []string) ApiGroupsPlannerPlansBucketsListTasksRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsPlannerPlansBucketsListTasksRequest) Expand(expand []string) ApiGroupsPlannerPlansBucketsListTasksRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsPlannerPlansBucketsListTasksRequest) Execute() (CollectionOfPlannerTask, *_nethttp.Response, error) {
	return r.ApiService.GroupsPlannerPlansBucketsListTasksExecute(r)
}

/*
GroupsPlannerPlansBucketsListTasks Get tasks from groups

Read-only. Nullable. The collection of tasks in the bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @return ApiGroupsPlannerPlansBucketsListTasksRequest
*/
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansBucketsListTasks(ctx _context.Context, groupId string, plannerPlanId string, plannerBucketId string) ApiGroupsPlannerPlansBucketsListTasksRequest {
	return ApiGroupsPlannerPlansBucketsListTasksRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
	}
}

// Execute executes the request
//  @return CollectionOfPlannerTask
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansBucketsListTasksExecute(r ApiGroupsPlannerPlansBucketsListTasksRequest) (CollectionOfPlannerTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfPlannerTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsPlannerGroupApiService.GroupsPlannerPlansBucketsListTasks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsPlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *GroupsPlannerGroupApiService
	groupId string
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiGroupsPlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormatRequest) IfMatch(ifMatch string) ApiGroupsPlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormatRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsPlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsPlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormatExecute(r)
}

/*
GroupsPlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormat Delete navigation property assignedToTaskBoardFormat for groups

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by assignedTo.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiGroupsPlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormatRequest
*/
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormat(ctx _context.Context, groupId string, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiGroupsPlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormatRequest {
	return ApiGroupsPlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormatExecute(r ApiGroupsPlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsPlannerGroupApiService.GroupsPlannerPlansBucketsTasksDeleteAssignedToTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsPlannerPlansBucketsTasksDeleteBucketTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *GroupsPlannerGroupApiService
	groupId string
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiGroupsPlannerPlansBucketsTasksDeleteBucketTaskBoardFormatRequest) IfMatch(ifMatch string) ApiGroupsPlannerPlansBucketsTasksDeleteBucketTaskBoardFormatRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsPlannerPlansBucketsTasksDeleteBucketTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsPlannerPlansBucketsTasksDeleteBucketTaskBoardFormatExecute(r)
}

/*
GroupsPlannerPlansBucketsTasksDeleteBucketTaskBoardFormat Delete navigation property bucketTaskBoardFormat for groups

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiGroupsPlannerPlansBucketsTasksDeleteBucketTaskBoardFormatRequest
*/
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansBucketsTasksDeleteBucketTaskBoardFormat(ctx _context.Context, groupId string, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiGroupsPlannerPlansBucketsTasksDeleteBucketTaskBoardFormatRequest {
	return ApiGroupsPlannerPlansBucketsTasksDeleteBucketTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansBucketsTasksDeleteBucketTaskBoardFormatExecute(r ApiGroupsPlannerPlansBucketsTasksDeleteBucketTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsPlannerGroupApiService.GroupsPlannerPlansBucketsTasksDeleteBucketTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsPlannerPlansBucketsTasksDeleteDetailsRequest struct {
	ctx _context.Context
	ApiService *GroupsPlannerGroupApiService
	groupId string
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiGroupsPlannerPlansBucketsTasksDeleteDetailsRequest) IfMatch(ifMatch string) ApiGroupsPlannerPlansBucketsTasksDeleteDetailsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsPlannerPlansBucketsTasksDeleteDetailsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsPlannerPlansBucketsTasksDeleteDetailsExecute(r)
}

/*
GroupsPlannerPlansBucketsTasksDeleteDetails Delete navigation property details for groups

Read-only. Nullable. Additional details about the task.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiGroupsPlannerPlansBucketsTasksDeleteDetailsRequest
*/
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansBucketsTasksDeleteDetails(ctx _context.Context, groupId string, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiGroupsPlannerPlansBucketsTasksDeleteDetailsRequest {
	return ApiGroupsPlannerPlansBucketsTasksDeleteDetailsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansBucketsTasksDeleteDetailsExecute(r ApiGroupsPlannerPlansBucketsTasksDeleteDetailsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsPlannerGroupApiService.GroupsPlannerPlansBucketsTasksDeleteDetails")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsPlannerPlansBucketsTasksDeleteProgressTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *GroupsPlannerGroupApiService
	groupId string
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiGroupsPlannerPlansBucketsTasksDeleteProgressTaskBoardFormatRequest) IfMatch(ifMatch string) ApiGroupsPlannerPlansBucketsTasksDeleteProgressTaskBoardFormatRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsPlannerPlansBucketsTasksDeleteProgressTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsPlannerPlansBucketsTasksDeleteProgressTaskBoardFormatExecute(r)
}

/*
GroupsPlannerPlansBucketsTasksDeleteProgressTaskBoardFormat Delete navigation property progressTaskBoardFormat for groups

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by progress.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiGroupsPlannerPlansBucketsTasksDeleteProgressTaskBoardFormatRequest
*/
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansBucketsTasksDeleteProgressTaskBoardFormat(ctx _context.Context, groupId string, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiGroupsPlannerPlansBucketsTasksDeleteProgressTaskBoardFormatRequest {
	return ApiGroupsPlannerPlansBucketsTasksDeleteProgressTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansBucketsTasksDeleteProgressTaskBoardFormatExecute(r ApiGroupsPlannerPlansBucketsTasksDeleteProgressTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsPlannerGroupApiService.GroupsPlannerPlansBucketsTasksDeleteProgressTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/progressTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsPlannerPlansBucketsTasksGetAssignedToTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *GroupsPlannerGroupApiService
	groupId string
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiGroupsPlannerPlansBucketsTasksGetAssignedToTaskBoardFormatRequest) Select_(select_ []string) ApiGroupsPlannerPlansBucketsTasksGetAssignedToTaskBoardFormatRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsPlannerPlansBucketsTasksGetAssignedToTaskBoardFormatRequest) Expand(expand []string) ApiGroupsPlannerPlansBucketsTasksGetAssignedToTaskBoardFormatRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsPlannerPlansBucketsTasksGetAssignedToTaskBoardFormatRequest) Execute() (MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat, *_nethttp.Response, error) {
	return r.ApiService.GroupsPlannerPlansBucketsTasksGetAssignedToTaskBoardFormatExecute(r)
}

/*
GroupsPlannerPlansBucketsTasksGetAssignedToTaskBoardFormat Get assignedToTaskBoardFormat from groups

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by assignedTo.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiGroupsPlannerPlansBucketsTasksGetAssignedToTaskBoardFormatRequest
*/
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansBucketsTasksGetAssignedToTaskBoardFormat(ctx _context.Context, groupId string, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiGroupsPlannerPlansBucketsTasksGetAssignedToTaskBoardFormatRequest {
	return ApiGroupsPlannerPlansBucketsTasksGetAssignedToTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansBucketsTasksGetAssignedToTaskBoardFormatExecute(r ApiGroupsPlannerPlansBucketsTasksGetAssignedToTaskBoardFormatRequest) (MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsPlannerGroupApiService.GroupsPlannerPlansBucketsTasksGetAssignedToTaskBoardFormat")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsPlannerPlansBucketsTasksGetBucketTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *GroupsPlannerGroupApiService
	groupId string
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiGroupsPlannerPlansBucketsTasksGetBucketTaskBoardFormatRequest) Select_(select_ []string) ApiGroupsPlannerPlansBucketsTasksGetBucketTaskBoardFormatRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsPlannerPlansBucketsTasksGetBucketTaskBoardFormatRequest) Expand(expand []string) ApiGroupsPlannerPlansBucketsTasksGetBucketTaskBoardFormatRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsPlannerPlansBucketsTasksGetBucketTaskBoardFormatRequest) Execute() (MicrosoftGraphPlannerBucketTaskBoardTaskFormat, *_nethttp.Response, error) {
	return r.ApiService.GroupsPlannerPlansBucketsTasksGetBucketTaskBoardFormatExecute(r)
}

/*
GroupsPlannerPlansBucketsTasksGetBucketTaskBoardFormat Get bucketTaskBoardFormat from groups

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiGroupsPlannerPlansBucketsTasksGetBucketTaskBoardFormatRequest
*/
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansBucketsTasksGetBucketTaskBoardFormat(ctx _context.Context, groupId string, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiGroupsPlannerPlansBucketsTasksGetBucketTaskBoardFormatRequest {
	return ApiGroupsPlannerPlansBucketsTasksGetBucketTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerBucketTaskBoardTaskFormat
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansBucketsTasksGetBucketTaskBoardFormatExecute(r ApiGroupsPlannerPlansBucketsTasksGetBucketTaskBoardFormatRequest) (MicrosoftGraphPlannerBucketTaskBoardTaskFormat, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerBucketTaskBoardTaskFormat
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsPlannerGroupApiService.GroupsPlannerPlansBucketsTasksGetBucketTaskBoardFormat")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsPlannerPlansBucketsTasksGetDetailsRequest struct {
	ctx _context.Context
	ApiService *GroupsPlannerGroupApiService
	groupId string
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiGroupsPlannerPlansBucketsTasksGetDetailsRequest) Select_(select_ []string) ApiGroupsPlannerPlansBucketsTasksGetDetailsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsPlannerPlansBucketsTasksGetDetailsRequest) Expand(expand []string) ApiGroupsPlannerPlansBucketsTasksGetDetailsRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsPlannerPlansBucketsTasksGetDetailsRequest) Execute() (MicrosoftGraphPlannerTaskDetails, *_nethttp.Response, error) {
	return r.ApiService.GroupsPlannerPlansBucketsTasksGetDetailsExecute(r)
}

/*
GroupsPlannerPlansBucketsTasksGetDetails Get details from groups

Read-only. Nullable. Additional details about the task.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiGroupsPlannerPlansBucketsTasksGetDetailsRequest
*/
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansBucketsTasksGetDetails(ctx _context.Context, groupId string, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiGroupsPlannerPlansBucketsTasksGetDetailsRequest {
	return ApiGroupsPlannerPlansBucketsTasksGetDetailsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerTaskDetails
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansBucketsTasksGetDetailsExecute(r ApiGroupsPlannerPlansBucketsTasksGetDetailsRequest) (MicrosoftGraphPlannerTaskDetails, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerTaskDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsPlannerGroupApiService.GroupsPlannerPlansBucketsTasksGetDetails")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsPlannerPlansBucketsTasksGetProgressTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *GroupsPlannerGroupApiService
	groupId string
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiGroupsPlannerPlansBucketsTasksGetProgressTaskBoardFormatRequest) Select_(select_ []string) ApiGroupsPlannerPlansBucketsTasksGetProgressTaskBoardFormatRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsPlannerPlansBucketsTasksGetProgressTaskBoardFormatRequest) Expand(expand []string) ApiGroupsPlannerPlansBucketsTasksGetProgressTaskBoardFormatRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsPlannerPlansBucketsTasksGetProgressTaskBoardFormatRequest) Execute() (MicrosoftGraphPlannerProgressTaskBoardTaskFormat, *_nethttp.Response, error) {
	return r.ApiService.GroupsPlannerPlansBucketsTasksGetProgressTaskBoardFormatExecute(r)
}

/*
GroupsPlannerPlansBucketsTasksGetProgressTaskBoardFormat Get progressTaskBoardFormat from groups

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by progress.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiGroupsPlannerPlansBucketsTasksGetProgressTaskBoardFormatRequest
*/
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansBucketsTasksGetProgressTaskBoardFormat(ctx _context.Context, groupId string, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiGroupsPlannerPlansBucketsTasksGetProgressTaskBoardFormatRequest {
	return ApiGroupsPlannerPlansBucketsTasksGetProgressTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerProgressTaskBoardTaskFormat
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansBucketsTasksGetProgressTaskBoardFormatExecute(r ApiGroupsPlannerPlansBucketsTasksGetProgressTaskBoardFormatRequest) (MicrosoftGraphPlannerProgressTaskBoardTaskFormat, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerProgressTaskBoardTaskFormat
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsPlannerGroupApiService.GroupsPlannerPlansBucketsTasksGetProgressTaskBoardFormat")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/progressTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsPlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *GroupsPlannerGroupApiService
	groupId string
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	microsoftGraphPlannerAssignedToTaskBoardTaskFormat *MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat
}

// New navigation property values
func (r ApiGroupsPlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormatRequest) MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat(microsoftGraphPlannerAssignedToTaskBoardTaskFormat MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat) ApiGroupsPlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormatRequest {
	r.microsoftGraphPlannerAssignedToTaskBoardTaskFormat = &microsoftGraphPlannerAssignedToTaskBoardTaskFormat
	return r
}

func (r ApiGroupsPlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsPlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormatExecute(r)
}

/*
GroupsPlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormat Update the navigation property assignedToTaskBoardFormat in groups

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by assignedTo.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiGroupsPlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormatRequest
*/
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormat(ctx _context.Context, groupId string, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiGroupsPlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormatRequest {
	return ApiGroupsPlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormatExecute(r ApiGroupsPlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsPlannerGroupApiService.GroupsPlannerPlansBucketsTasksUpdateAssignedToTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerAssignedToTaskBoardTaskFormat == nil {
		return nil, reportError("microsoftGraphPlannerAssignedToTaskBoardTaskFormat is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerAssignedToTaskBoardTaskFormat
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsPlannerPlansBucketsTasksUpdateBucketTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *GroupsPlannerGroupApiService
	groupId string
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	microsoftGraphPlannerBucketTaskBoardTaskFormat *MicrosoftGraphPlannerBucketTaskBoardTaskFormat
}

// New navigation property values
func (r ApiGroupsPlannerPlansBucketsTasksUpdateBucketTaskBoardFormatRequest) MicrosoftGraphPlannerBucketTaskBoardTaskFormat(microsoftGraphPlannerBucketTaskBoardTaskFormat MicrosoftGraphPlannerBucketTaskBoardTaskFormat) ApiGroupsPlannerPlansBucketsTasksUpdateBucketTaskBoardFormatRequest {
	r.microsoftGraphPlannerBucketTaskBoardTaskFormat = &microsoftGraphPlannerBucketTaskBoardTaskFormat
	return r
}

func (r ApiGroupsPlannerPlansBucketsTasksUpdateBucketTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsPlannerPlansBucketsTasksUpdateBucketTaskBoardFormatExecute(r)
}

/*
GroupsPlannerPlansBucketsTasksUpdateBucketTaskBoardFormat Update the navigation property bucketTaskBoardFormat in groups

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiGroupsPlannerPlansBucketsTasksUpdateBucketTaskBoardFormatRequest
*/
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansBucketsTasksUpdateBucketTaskBoardFormat(ctx _context.Context, groupId string, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiGroupsPlannerPlansBucketsTasksUpdateBucketTaskBoardFormatRequest {
	return ApiGroupsPlannerPlansBucketsTasksUpdateBucketTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansBucketsTasksUpdateBucketTaskBoardFormatExecute(r ApiGroupsPlannerPlansBucketsTasksUpdateBucketTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsPlannerGroupApiService.GroupsPlannerPlansBucketsTasksUpdateBucketTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerBucketTaskBoardTaskFormat == nil {
		return nil, reportError("microsoftGraphPlannerBucketTaskBoardTaskFormat is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerBucketTaskBoardTaskFormat
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsPlannerPlansBucketsTasksUpdateDetailsRequest struct {
	ctx _context.Context
	ApiService *GroupsPlannerGroupApiService
	groupId string
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	microsoftGraphPlannerTaskDetails *MicrosoftGraphPlannerTaskDetails
}

// New navigation property values
func (r ApiGroupsPlannerPlansBucketsTasksUpdateDetailsRequest) MicrosoftGraphPlannerTaskDetails(microsoftGraphPlannerTaskDetails MicrosoftGraphPlannerTaskDetails) ApiGroupsPlannerPlansBucketsTasksUpdateDetailsRequest {
	r.microsoftGraphPlannerTaskDetails = &microsoftGraphPlannerTaskDetails
	return r
}

func (r ApiGroupsPlannerPlansBucketsTasksUpdateDetailsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsPlannerPlansBucketsTasksUpdateDetailsExecute(r)
}

/*
GroupsPlannerPlansBucketsTasksUpdateDetails Update the navigation property details in groups

Read-only. Nullable. Additional details about the task.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiGroupsPlannerPlansBucketsTasksUpdateDetailsRequest
*/
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansBucketsTasksUpdateDetails(ctx _context.Context, groupId string, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiGroupsPlannerPlansBucketsTasksUpdateDetailsRequest {
	return ApiGroupsPlannerPlansBucketsTasksUpdateDetailsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansBucketsTasksUpdateDetailsExecute(r ApiGroupsPlannerPlansBucketsTasksUpdateDetailsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsPlannerGroupApiService.GroupsPlannerPlansBucketsTasksUpdateDetails")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerTaskDetails == nil {
		return nil, reportError("microsoftGraphPlannerTaskDetails is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerTaskDetails
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsPlannerPlansBucketsTasksUpdateProgressTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *GroupsPlannerGroupApiService
	groupId string
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	microsoftGraphPlannerProgressTaskBoardTaskFormat *MicrosoftGraphPlannerProgressTaskBoardTaskFormat
}

// New navigation property values
func (r ApiGroupsPlannerPlansBucketsTasksUpdateProgressTaskBoardFormatRequest) MicrosoftGraphPlannerProgressTaskBoardTaskFormat(microsoftGraphPlannerProgressTaskBoardTaskFormat MicrosoftGraphPlannerProgressTaskBoardTaskFormat) ApiGroupsPlannerPlansBucketsTasksUpdateProgressTaskBoardFormatRequest {
	r.microsoftGraphPlannerProgressTaskBoardTaskFormat = &microsoftGraphPlannerProgressTaskBoardTaskFormat
	return r
}

func (r ApiGroupsPlannerPlansBucketsTasksUpdateProgressTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsPlannerPlansBucketsTasksUpdateProgressTaskBoardFormatExecute(r)
}

/*
GroupsPlannerPlansBucketsTasksUpdateProgressTaskBoardFormat Update the navigation property progressTaskBoardFormat in groups

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by progress.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiGroupsPlannerPlansBucketsTasksUpdateProgressTaskBoardFormatRequest
*/
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansBucketsTasksUpdateProgressTaskBoardFormat(ctx _context.Context, groupId string, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiGroupsPlannerPlansBucketsTasksUpdateProgressTaskBoardFormatRequest {
	return ApiGroupsPlannerPlansBucketsTasksUpdateProgressTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansBucketsTasksUpdateProgressTaskBoardFormatExecute(r ApiGroupsPlannerPlansBucketsTasksUpdateProgressTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsPlannerGroupApiService.GroupsPlannerPlansBucketsTasksUpdateProgressTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/progressTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerProgressTaskBoardTaskFormat == nil {
		return nil, reportError("microsoftGraphPlannerProgressTaskBoardTaskFormat is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerProgressTaskBoardTaskFormat
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsPlannerPlansBucketsUpdateTasksRequest struct {
	ctx _context.Context
	ApiService *GroupsPlannerGroupApiService
	groupId string
	plannerPlanId string
	plannerBucketId string
	plannerTaskId string
	microsoftGraphPlannerTask *MicrosoftGraphPlannerTask
}

// New navigation property values
func (r ApiGroupsPlannerPlansBucketsUpdateTasksRequest) MicrosoftGraphPlannerTask(microsoftGraphPlannerTask MicrosoftGraphPlannerTask) ApiGroupsPlannerPlansBucketsUpdateTasksRequest {
	r.microsoftGraphPlannerTask = &microsoftGraphPlannerTask
	return r
}

func (r ApiGroupsPlannerPlansBucketsUpdateTasksRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsPlannerPlansBucketsUpdateTasksExecute(r)
}

/*
GroupsPlannerPlansBucketsUpdateTasks Update the navigation property tasks in groups

Read-only. Nullable. The collection of tasks in the bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiGroupsPlannerPlansBucketsUpdateTasksRequest
*/
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansBucketsUpdateTasks(ctx _context.Context, groupId string, plannerPlanId string, plannerBucketId string, plannerTaskId string) ApiGroupsPlannerPlansBucketsUpdateTasksRequest {
	return ApiGroupsPlannerPlansBucketsUpdateTasksRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansBucketsUpdateTasksExecute(r ApiGroupsPlannerPlansBucketsUpdateTasksRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsPlannerGroupApiService.GroupsPlannerPlansBucketsUpdateTasks")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerTask == nil {
		return nil, reportError("microsoftGraphPlannerTask is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerTask
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsPlannerPlansCreateBucketsRequest struct {
	ctx _context.Context
	ApiService *GroupsPlannerGroupApiService
	groupId string
	plannerPlanId string
	microsoftGraphPlannerBucket *MicrosoftGraphPlannerBucket
}

// New navigation property
func (r ApiGroupsPlannerPlansCreateBucketsRequest) MicrosoftGraphPlannerBucket(microsoftGraphPlannerBucket MicrosoftGraphPlannerBucket) ApiGroupsPlannerPlansCreateBucketsRequest {
	r.microsoftGraphPlannerBucket = &microsoftGraphPlannerBucket
	return r
}

func (r ApiGroupsPlannerPlansCreateBucketsRequest) Execute() (MicrosoftGraphPlannerBucket, *_nethttp.Response, error) {
	return r.ApiService.GroupsPlannerPlansCreateBucketsExecute(r)
}

/*
GroupsPlannerPlansCreateBuckets Create new navigation property to buckets for groups

Read-only. Nullable. Collection of buckets in the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param plannerPlanId key: id of plannerPlan
 @return ApiGroupsPlannerPlansCreateBucketsRequest
*/
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansCreateBuckets(ctx _context.Context, groupId string, plannerPlanId string) ApiGroupsPlannerPlansCreateBucketsRequest {
	return ApiGroupsPlannerPlansCreateBucketsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		plannerPlanId: plannerPlanId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerBucket
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansCreateBucketsExecute(r ApiGroupsPlannerPlansCreateBucketsRequest) (MicrosoftGraphPlannerBucket, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerBucket
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsPlannerGroupApiService.GroupsPlannerPlansCreateBuckets")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/planner/plans/{plannerPlan-id}/buckets"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerBucket == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphPlannerBucket is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerBucket
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsPlannerPlansCreateTasksRequest struct {
	ctx _context.Context
	ApiService *GroupsPlannerGroupApiService
	groupId string
	plannerPlanId string
	microsoftGraphPlannerTask *MicrosoftGraphPlannerTask
}

// New navigation property
func (r ApiGroupsPlannerPlansCreateTasksRequest) MicrosoftGraphPlannerTask(microsoftGraphPlannerTask MicrosoftGraphPlannerTask) ApiGroupsPlannerPlansCreateTasksRequest {
	r.microsoftGraphPlannerTask = &microsoftGraphPlannerTask
	return r
}

func (r ApiGroupsPlannerPlansCreateTasksRequest) Execute() (MicrosoftGraphPlannerTask, *_nethttp.Response, error) {
	return r.ApiService.GroupsPlannerPlansCreateTasksExecute(r)
}

/*
GroupsPlannerPlansCreateTasks Create new navigation property to tasks for groups

Read-only. Nullable. Collection of tasks in the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param plannerPlanId key: id of plannerPlan
 @return ApiGroupsPlannerPlansCreateTasksRequest
*/
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansCreateTasks(ctx _context.Context, groupId string, plannerPlanId string) ApiGroupsPlannerPlansCreateTasksRequest {
	return ApiGroupsPlannerPlansCreateTasksRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		plannerPlanId: plannerPlanId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerTask
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansCreateTasksExecute(r ApiGroupsPlannerPlansCreateTasksRequest) (MicrosoftGraphPlannerTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsPlannerGroupApiService.GroupsPlannerPlansCreateTasks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/planner/plans/{plannerPlan-id}/tasks"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerTask == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphPlannerTask is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerTask
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsPlannerPlansDeleteBucketsRequest struct {
	ctx _context.Context
	ApiService *GroupsPlannerGroupApiService
	groupId string
	plannerPlanId string
	plannerBucketId string
	ifMatch *string
}

// ETag
func (r ApiGroupsPlannerPlansDeleteBucketsRequest) IfMatch(ifMatch string) ApiGroupsPlannerPlansDeleteBucketsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsPlannerPlansDeleteBucketsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsPlannerPlansDeleteBucketsExecute(r)
}

/*
GroupsPlannerPlansDeleteBuckets Delete navigation property buckets for groups

Read-only. Nullable. Collection of buckets in the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @return ApiGroupsPlannerPlansDeleteBucketsRequest
*/
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansDeleteBuckets(ctx _context.Context, groupId string, plannerPlanId string, plannerBucketId string) ApiGroupsPlannerPlansDeleteBucketsRequest {
	return ApiGroupsPlannerPlansDeleteBucketsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
	}
}

// Execute executes the request
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansDeleteBucketsExecute(r ApiGroupsPlannerPlansDeleteBucketsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsPlannerGroupApiService.GroupsPlannerPlansDeleteBuckets")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsPlannerPlansDeleteDetailsRequest struct {
	ctx _context.Context
	ApiService *GroupsPlannerGroupApiService
	groupId string
	plannerPlanId string
	ifMatch *string
}

// ETag
func (r ApiGroupsPlannerPlansDeleteDetailsRequest) IfMatch(ifMatch string) ApiGroupsPlannerPlansDeleteDetailsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsPlannerPlansDeleteDetailsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsPlannerPlansDeleteDetailsExecute(r)
}

/*
GroupsPlannerPlansDeleteDetails Delete navigation property details for groups

Read-only. Nullable. Additional details about the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param plannerPlanId key: id of plannerPlan
 @return ApiGroupsPlannerPlansDeleteDetailsRequest
*/
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansDeleteDetails(ctx _context.Context, groupId string, plannerPlanId string) ApiGroupsPlannerPlansDeleteDetailsRequest {
	return ApiGroupsPlannerPlansDeleteDetailsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		plannerPlanId: plannerPlanId,
	}
}

// Execute executes the request
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansDeleteDetailsExecute(r ApiGroupsPlannerPlansDeleteDetailsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsPlannerGroupApiService.GroupsPlannerPlansDeleteDetails")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/planner/plans/{plannerPlan-id}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsPlannerPlansDeleteTasksRequest struct {
	ctx _context.Context
	ApiService *GroupsPlannerGroupApiService
	groupId string
	plannerPlanId string
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiGroupsPlannerPlansDeleteTasksRequest) IfMatch(ifMatch string) ApiGroupsPlannerPlansDeleteTasksRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsPlannerPlansDeleteTasksRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsPlannerPlansDeleteTasksExecute(r)
}

/*
GroupsPlannerPlansDeleteTasks Delete navigation property tasks for groups

Read-only. Nullable. Collection of tasks in the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiGroupsPlannerPlansDeleteTasksRequest
*/
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansDeleteTasks(ctx _context.Context, groupId string, plannerPlanId string, plannerTaskId string) ApiGroupsPlannerPlansDeleteTasksRequest {
	return ApiGroupsPlannerPlansDeleteTasksRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansDeleteTasksExecute(r ApiGroupsPlannerPlansDeleteTasksRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsPlannerGroupApiService.GroupsPlannerPlansDeleteTasks")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsPlannerPlansGetBucketsRequest struct {
	ctx _context.Context
	ApiService *GroupsPlannerGroupApiService
	groupId string
	plannerPlanId string
	plannerBucketId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiGroupsPlannerPlansGetBucketsRequest) Select_(select_ []string) ApiGroupsPlannerPlansGetBucketsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsPlannerPlansGetBucketsRequest) Expand(expand []string) ApiGroupsPlannerPlansGetBucketsRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsPlannerPlansGetBucketsRequest) Execute() (MicrosoftGraphPlannerBucket, *_nethttp.Response, error) {
	return r.ApiService.GroupsPlannerPlansGetBucketsExecute(r)
}

/*
GroupsPlannerPlansGetBuckets Get buckets from groups

Read-only. Nullable. Collection of buckets in the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @return ApiGroupsPlannerPlansGetBucketsRequest
*/
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansGetBuckets(ctx _context.Context, groupId string, plannerPlanId string, plannerBucketId string) ApiGroupsPlannerPlansGetBucketsRequest {
	return ApiGroupsPlannerPlansGetBucketsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerBucket
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansGetBucketsExecute(r ApiGroupsPlannerPlansGetBucketsRequest) (MicrosoftGraphPlannerBucket, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerBucket
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsPlannerGroupApiService.GroupsPlannerPlansGetBuckets")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsPlannerPlansGetDetailsRequest struct {
	ctx _context.Context
	ApiService *GroupsPlannerGroupApiService
	groupId string
	plannerPlanId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiGroupsPlannerPlansGetDetailsRequest) Select_(select_ []string) ApiGroupsPlannerPlansGetDetailsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsPlannerPlansGetDetailsRequest) Expand(expand []string) ApiGroupsPlannerPlansGetDetailsRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsPlannerPlansGetDetailsRequest) Execute() (MicrosoftGraphPlannerPlanDetails, *_nethttp.Response, error) {
	return r.ApiService.GroupsPlannerPlansGetDetailsExecute(r)
}

/*
GroupsPlannerPlansGetDetails Get details from groups

Read-only. Nullable. Additional details about the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param plannerPlanId key: id of plannerPlan
 @return ApiGroupsPlannerPlansGetDetailsRequest
*/
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansGetDetails(ctx _context.Context, groupId string, plannerPlanId string) ApiGroupsPlannerPlansGetDetailsRequest {
	return ApiGroupsPlannerPlansGetDetailsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		plannerPlanId: plannerPlanId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerPlanDetails
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansGetDetailsExecute(r ApiGroupsPlannerPlansGetDetailsRequest) (MicrosoftGraphPlannerPlanDetails, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerPlanDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsPlannerGroupApiService.GroupsPlannerPlansGetDetails")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/planner/plans/{plannerPlan-id}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsPlannerPlansGetTasksRequest struct {
	ctx _context.Context
	ApiService *GroupsPlannerGroupApiService
	groupId string
	plannerPlanId string
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiGroupsPlannerPlansGetTasksRequest) Select_(select_ []string) ApiGroupsPlannerPlansGetTasksRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsPlannerPlansGetTasksRequest) Expand(expand []string) ApiGroupsPlannerPlansGetTasksRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsPlannerPlansGetTasksRequest) Execute() (MicrosoftGraphPlannerTask, *_nethttp.Response, error) {
	return r.ApiService.GroupsPlannerPlansGetTasksExecute(r)
}

/*
GroupsPlannerPlansGetTasks Get tasks from groups

Read-only. Nullable. Collection of tasks in the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiGroupsPlannerPlansGetTasksRequest
*/
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansGetTasks(ctx _context.Context, groupId string, plannerPlanId string, plannerTaskId string) ApiGroupsPlannerPlansGetTasksRequest {
	return ApiGroupsPlannerPlansGetTasksRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerTask
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansGetTasksExecute(r ApiGroupsPlannerPlansGetTasksRequest) (MicrosoftGraphPlannerTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsPlannerGroupApiService.GroupsPlannerPlansGetTasks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsPlannerPlansListBucketsRequest struct {
	ctx _context.Context
	ApiService *GroupsPlannerGroupApiService
	groupId string
	plannerPlanId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiGroupsPlannerPlansListBucketsRequest) Top(top int32) ApiGroupsPlannerPlansListBucketsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsPlannerPlansListBucketsRequest) Skip(skip int32) ApiGroupsPlannerPlansListBucketsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiGroupsPlannerPlansListBucketsRequest) Search(search string) ApiGroupsPlannerPlansListBucketsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiGroupsPlannerPlansListBucketsRequest) Filter(filter string) ApiGroupsPlannerPlansListBucketsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsPlannerPlansListBucketsRequest) Count(count bool) ApiGroupsPlannerPlansListBucketsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsPlannerPlansListBucketsRequest) Orderby(orderby []string) ApiGroupsPlannerPlansListBucketsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiGroupsPlannerPlansListBucketsRequest) Select_(select_ []string) ApiGroupsPlannerPlansListBucketsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsPlannerPlansListBucketsRequest) Expand(expand []string) ApiGroupsPlannerPlansListBucketsRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsPlannerPlansListBucketsRequest) Execute() (CollectionOfPlannerBucket, *_nethttp.Response, error) {
	return r.ApiService.GroupsPlannerPlansListBucketsExecute(r)
}

/*
GroupsPlannerPlansListBuckets Get buckets from groups

Read-only. Nullable. Collection of buckets in the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param plannerPlanId key: id of plannerPlan
 @return ApiGroupsPlannerPlansListBucketsRequest
*/
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansListBuckets(ctx _context.Context, groupId string, plannerPlanId string) ApiGroupsPlannerPlansListBucketsRequest {
	return ApiGroupsPlannerPlansListBucketsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		plannerPlanId: plannerPlanId,
	}
}

// Execute executes the request
//  @return CollectionOfPlannerBucket
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansListBucketsExecute(r ApiGroupsPlannerPlansListBucketsRequest) (CollectionOfPlannerBucket, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfPlannerBucket
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsPlannerGroupApiService.GroupsPlannerPlansListBuckets")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/planner/plans/{plannerPlan-id}/buckets"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsPlannerPlansListTasksRequest struct {
	ctx _context.Context
	ApiService *GroupsPlannerGroupApiService
	groupId string
	plannerPlanId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiGroupsPlannerPlansListTasksRequest) Top(top int32) ApiGroupsPlannerPlansListTasksRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsPlannerPlansListTasksRequest) Skip(skip int32) ApiGroupsPlannerPlansListTasksRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiGroupsPlannerPlansListTasksRequest) Search(search string) ApiGroupsPlannerPlansListTasksRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiGroupsPlannerPlansListTasksRequest) Filter(filter string) ApiGroupsPlannerPlansListTasksRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsPlannerPlansListTasksRequest) Count(count bool) ApiGroupsPlannerPlansListTasksRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsPlannerPlansListTasksRequest) Orderby(orderby []string) ApiGroupsPlannerPlansListTasksRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiGroupsPlannerPlansListTasksRequest) Select_(select_ []string) ApiGroupsPlannerPlansListTasksRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsPlannerPlansListTasksRequest) Expand(expand []string) ApiGroupsPlannerPlansListTasksRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsPlannerPlansListTasksRequest) Execute() (CollectionOfPlannerTask, *_nethttp.Response, error) {
	return r.ApiService.GroupsPlannerPlansListTasksExecute(r)
}

/*
GroupsPlannerPlansListTasks Get tasks from groups

Read-only. Nullable. Collection of tasks in the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param plannerPlanId key: id of plannerPlan
 @return ApiGroupsPlannerPlansListTasksRequest
*/
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansListTasks(ctx _context.Context, groupId string, plannerPlanId string) ApiGroupsPlannerPlansListTasksRequest {
	return ApiGroupsPlannerPlansListTasksRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		plannerPlanId: plannerPlanId,
	}
}

// Execute executes the request
//  @return CollectionOfPlannerTask
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansListTasksExecute(r ApiGroupsPlannerPlansListTasksRequest) (CollectionOfPlannerTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfPlannerTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsPlannerGroupApiService.GroupsPlannerPlansListTasks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/planner/plans/{plannerPlan-id}/tasks"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsPlannerPlansTasksDeleteAssignedToTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *GroupsPlannerGroupApiService
	groupId string
	plannerPlanId string
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiGroupsPlannerPlansTasksDeleteAssignedToTaskBoardFormatRequest) IfMatch(ifMatch string) ApiGroupsPlannerPlansTasksDeleteAssignedToTaskBoardFormatRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsPlannerPlansTasksDeleteAssignedToTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsPlannerPlansTasksDeleteAssignedToTaskBoardFormatExecute(r)
}

/*
GroupsPlannerPlansTasksDeleteAssignedToTaskBoardFormat Delete navigation property assignedToTaskBoardFormat for groups

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by assignedTo.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiGroupsPlannerPlansTasksDeleteAssignedToTaskBoardFormatRequest
*/
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansTasksDeleteAssignedToTaskBoardFormat(ctx _context.Context, groupId string, plannerPlanId string, plannerTaskId string) ApiGroupsPlannerPlansTasksDeleteAssignedToTaskBoardFormatRequest {
	return ApiGroupsPlannerPlansTasksDeleteAssignedToTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansTasksDeleteAssignedToTaskBoardFormatExecute(r ApiGroupsPlannerPlansTasksDeleteAssignedToTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsPlannerGroupApiService.GroupsPlannerPlansTasksDeleteAssignedToTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsPlannerPlansTasksDeleteBucketTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *GroupsPlannerGroupApiService
	groupId string
	plannerPlanId string
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiGroupsPlannerPlansTasksDeleteBucketTaskBoardFormatRequest) IfMatch(ifMatch string) ApiGroupsPlannerPlansTasksDeleteBucketTaskBoardFormatRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsPlannerPlansTasksDeleteBucketTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsPlannerPlansTasksDeleteBucketTaskBoardFormatExecute(r)
}

/*
GroupsPlannerPlansTasksDeleteBucketTaskBoardFormat Delete navigation property bucketTaskBoardFormat for groups

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiGroupsPlannerPlansTasksDeleteBucketTaskBoardFormatRequest
*/
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansTasksDeleteBucketTaskBoardFormat(ctx _context.Context, groupId string, plannerPlanId string, plannerTaskId string) ApiGroupsPlannerPlansTasksDeleteBucketTaskBoardFormatRequest {
	return ApiGroupsPlannerPlansTasksDeleteBucketTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansTasksDeleteBucketTaskBoardFormatExecute(r ApiGroupsPlannerPlansTasksDeleteBucketTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsPlannerGroupApiService.GroupsPlannerPlansTasksDeleteBucketTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsPlannerPlansTasksDeleteDetailsRequest struct {
	ctx _context.Context
	ApiService *GroupsPlannerGroupApiService
	groupId string
	plannerPlanId string
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiGroupsPlannerPlansTasksDeleteDetailsRequest) IfMatch(ifMatch string) ApiGroupsPlannerPlansTasksDeleteDetailsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsPlannerPlansTasksDeleteDetailsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsPlannerPlansTasksDeleteDetailsExecute(r)
}

/*
GroupsPlannerPlansTasksDeleteDetails Delete navigation property details for groups

Read-only. Nullable. Additional details about the task.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiGroupsPlannerPlansTasksDeleteDetailsRequest
*/
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansTasksDeleteDetails(ctx _context.Context, groupId string, plannerPlanId string, plannerTaskId string) ApiGroupsPlannerPlansTasksDeleteDetailsRequest {
	return ApiGroupsPlannerPlansTasksDeleteDetailsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansTasksDeleteDetailsExecute(r ApiGroupsPlannerPlansTasksDeleteDetailsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsPlannerGroupApiService.GroupsPlannerPlansTasksDeleteDetails")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsPlannerPlansTasksDeleteProgressTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *GroupsPlannerGroupApiService
	groupId string
	plannerPlanId string
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiGroupsPlannerPlansTasksDeleteProgressTaskBoardFormatRequest) IfMatch(ifMatch string) ApiGroupsPlannerPlansTasksDeleteProgressTaskBoardFormatRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsPlannerPlansTasksDeleteProgressTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsPlannerPlansTasksDeleteProgressTaskBoardFormatExecute(r)
}

/*
GroupsPlannerPlansTasksDeleteProgressTaskBoardFormat Delete navigation property progressTaskBoardFormat for groups

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by progress.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiGroupsPlannerPlansTasksDeleteProgressTaskBoardFormatRequest
*/
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansTasksDeleteProgressTaskBoardFormat(ctx _context.Context, groupId string, plannerPlanId string, plannerTaskId string) ApiGroupsPlannerPlansTasksDeleteProgressTaskBoardFormatRequest {
	return ApiGroupsPlannerPlansTasksDeleteProgressTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansTasksDeleteProgressTaskBoardFormatExecute(r ApiGroupsPlannerPlansTasksDeleteProgressTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsPlannerGroupApiService.GroupsPlannerPlansTasksDeleteProgressTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/progressTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsPlannerPlansTasksGetAssignedToTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *GroupsPlannerGroupApiService
	groupId string
	plannerPlanId string
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiGroupsPlannerPlansTasksGetAssignedToTaskBoardFormatRequest) Select_(select_ []string) ApiGroupsPlannerPlansTasksGetAssignedToTaskBoardFormatRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsPlannerPlansTasksGetAssignedToTaskBoardFormatRequest) Expand(expand []string) ApiGroupsPlannerPlansTasksGetAssignedToTaskBoardFormatRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsPlannerPlansTasksGetAssignedToTaskBoardFormatRequest) Execute() (MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat, *_nethttp.Response, error) {
	return r.ApiService.GroupsPlannerPlansTasksGetAssignedToTaskBoardFormatExecute(r)
}

/*
GroupsPlannerPlansTasksGetAssignedToTaskBoardFormat Get assignedToTaskBoardFormat from groups

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by assignedTo.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiGroupsPlannerPlansTasksGetAssignedToTaskBoardFormatRequest
*/
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansTasksGetAssignedToTaskBoardFormat(ctx _context.Context, groupId string, plannerPlanId string, plannerTaskId string) ApiGroupsPlannerPlansTasksGetAssignedToTaskBoardFormatRequest {
	return ApiGroupsPlannerPlansTasksGetAssignedToTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansTasksGetAssignedToTaskBoardFormatExecute(r ApiGroupsPlannerPlansTasksGetAssignedToTaskBoardFormatRequest) (MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsPlannerGroupApiService.GroupsPlannerPlansTasksGetAssignedToTaskBoardFormat")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsPlannerPlansTasksGetBucketTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *GroupsPlannerGroupApiService
	groupId string
	plannerPlanId string
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiGroupsPlannerPlansTasksGetBucketTaskBoardFormatRequest) Select_(select_ []string) ApiGroupsPlannerPlansTasksGetBucketTaskBoardFormatRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsPlannerPlansTasksGetBucketTaskBoardFormatRequest) Expand(expand []string) ApiGroupsPlannerPlansTasksGetBucketTaskBoardFormatRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsPlannerPlansTasksGetBucketTaskBoardFormatRequest) Execute() (MicrosoftGraphPlannerBucketTaskBoardTaskFormat, *_nethttp.Response, error) {
	return r.ApiService.GroupsPlannerPlansTasksGetBucketTaskBoardFormatExecute(r)
}

/*
GroupsPlannerPlansTasksGetBucketTaskBoardFormat Get bucketTaskBoardFormat from groups

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiGroupsPlannerPlansTasksGetBucketTaskBoardFormatRequest
*/
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansTasksGetBucketTaskBoardFormat(ctx _context.Context, groupId string, plannerPlanId string, plannerTaskId string) ApiGroupsPlannerPlansTasksGetBucketTaskBoardFormatRequest {
	return ApiGroupsPlannerPlansTasksGetBucketTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerBucketTaskBoardTaskFormat
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansTasksGetBucketTaskBoardFormatExecute(r ApiGroupsPlannerPlansTasksGetBucketTaskBoardFormatRequest) (MicrosoftGraphPlannerBucketTaskBoardTaskFormat, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerBucketTaskBoardTaskFormat
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsPlannerGroupApiService.GroupsPlannerPlansTasksGetBucketTaskBoardFormat")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsPlannerPlansTasksGetDetailsRequest struct {
	ctx _context.Context
	ApiService *GroupsPlannerGroupApiService
	groupId string
	plannerPlanId string
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiGroupsPlannerPlansTasksGetDetailsRequest) Select_(select_ []string) ApiGroupsPlannerPlansTasksGetDetailsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsPlannerPlansTasksGetDetailsRequest) Expand(expand []string) ApiGroupsPlannerPlansTasksGetDetailsRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsPlannerPlansTasksGetDetailsRequest) Execute() (MicrosoftGraphPlannerTaskDetails, *_nethttp.Response, error) {
	return r.ApiService.GroupsPlannerPlansTasksGetDetailsExecute(r)
}

/*
GroupsPlannerPlansTasksGetDetails Get details from groups

Read-only. Nullable. Additional details about the task.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiGroupsPlannerPlansTasksGetDetailsRequest
*/
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansTasksGetDetails(ctx _context.Context, groupId string, plannerPlanId string, plannerTaskId string) ApiGroupsPlannerPlansTasksGetDetailsRequest {
	return ApiGroupsPlannerPlansTasksGetDetailsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerTaskDetails
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansTasksGetDetailsExecute(r ApiGroupsPlannerPlansTasksGetDetailsRequest) (MicrosoftGraphPlannerTaskDetails, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerTaskDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsPlannerGroupApiService.GroupsPlannerPlansTasksGetDetails")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsPlannerPlansTasksGetProgressTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *GroupsPlannerGroupApiService
	groupId string
	plannerPlanId string
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiGroupsPlannerPlansTasksGetProgressTaskBoardFormatRequest) Select_(select_ []string) ApiGroupsPlannerPlansTasksGetProgressTaskBoardFormatRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsPlannerPlansTasksGetProgressTaskBoardFormatRequest) Expand(expand []string) ApiGroupsPlannerPlansTasksGetProgressTaskBoardFormatRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsPlannerPlansTasksGetProgressTaskBoardFormatRequest) Execute() (MicrosoftGraphPlannerProgressTaskBoardTaskFormat, *_nethttp.Response, error) {
	return r.ApiService.GroupsPlannerPlansTasksGetProgressTaskBoardFormatExecute(r)
}

/*
GroupsPlannerPlansTasksGetProgressTaskBoardFormat Get progressTaskBoardFormat from groups

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by progress.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiGroupsPlannerPlansTasksGetProgressTaskBoardFormatRequest
*/
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansTasksGetProgressTaskBoardFormat(ctx _context.Context, groupId string, plannerPlanId string, plannerTaskId string) ApiGroupsPlannerPlansTasksGetProgressTaskBoardFormatRequest {
	return ApiGroupsPlannerPlansTasksGetProgressTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerProgressTaskBoardTaskFormat
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansTasksGetProgressTaskBoardFormatExecute(r ApiGroupsPlannerPlansTasksGetProgressTaskBoardFormatRequest) (MicrosoftGraphPlannerProgressTaskBoardTaskFormat, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerProgressTaskBoardTaskFormat
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsPlannerGroupApiService.GroupsPlannerPlansTasksGetProgressTaskBoardFormat")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/progressTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsPlannerPlansTasksUpdateAssignedToTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *GroupsPlannerGroupApiService
	groupId string
	plannerPlanId string
	plannerTaskId string
	microsoftGraphPlannerAssignedToTaskBoardTaskFormat *MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat
}

// New navigation property values
func (r ApiGroupsPlannerPlansTasksUpdateAssignedToTaskBoardFormatRequest) MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat(microsoftGraphPlannerAssignedToTaskBoardTaskFormat MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat) ApiGroupsPlannerPlansTasksUpdateAssignedToTaskBoardFormatRequest {
	r.microsoftGraphPlannerAssignedToTaskBoardTaskFormat = &microsoftGraphPlannerAssignedToTaskBoardTaskFormat
	return r
}

func (r ApiGroupsPlannerPlansTasksUpdateAssignedToTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsPlannerPlansTasksUpdateAssignedToTaskBoardFormatExecute(r)
}

/*
GroupsPlannerPlansTasksUpdateAssignedToTaskBoardFormat Update the navigation property assignedToTaskBoardFormat in groups

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by assignedTo.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiGroupsPlannerPlansTasksUpdateAssignedToTaskBoardFormatRequest
*/
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansTasksUpdateAssignedToTaskBoardFormat(ctx _context.Context, groupId string, plannerPlanId string, plannerTaskId string) ApiGroupsPlannerPlansTasksUpdateAssignedToTaskBoardFormatRequest {
	return ApiGroupsPlannerPlansTasksUpdateAssignedToTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansTasksUpdateAssignedToTaskBoardFormatExecute(r ApiGroupsPlannerPlansTasksUpdateAssignedToTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsPlannerGroupApiService.GroupsPlannerPlansTasksUpdateAssignedToTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerAssignedToTaskBoardTaskFormat == nil {
		return nil, reportError("microsoftGraphPlannerAssignedToTaskBoardTaskFormat is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerAssignedToTaskBoardTaskFormat
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsPlannerPlansTasksUpdateBucketTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *GroupsPlannerGroupApiService
	groupId string
	plannerPlanId string
	plannerTaskId string
	microsoftGraphPlannerBucketTaskBoardTaskFormat *MicrosoftGraphPlannerBucketTaskBoardTaskFormat
}

// New navigation property values
func (r ApiGroupsPlannerPlansTasksUpdateBucketTaskBoardFormatRequest) MicrosoftGraphPlannerBucketTaskBoardTaskFormat(microsoftGraphPlannerBucketTaskBoardTaskFormat MicrosoftGraphPlannerBucketTaskBoardTaskFormat) ApiGroupsPlannerPlansTasksUpdateBucketTaskBoardFormatRequest {
	r.microsoftGraphPlannerBucketTaskBoardTaskFormat = &microsoftGraphPlannerBucketTaskBoardTaskFormat
	return r
}

func (r ApiGroupsPlannerPlansTasksUpdateBucketTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsPlannerPlansTasksUpdateBucketTaskBoardFormatExecute(r)
}

/*
GroupsPlannerPlansTasksUpdateBucketTaskBoardFormat Update the navigation property bucketTaskBoardFormat in groups

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiGroupsPlannerPlansTasksUpdateBucketTaskBoardFormatRequest
*/
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansTasksUpdateBucketTaskBoardFormat(ctx _context.Context, groupId string, plannerPlanId string, plannerTaskId string) ApiGroupsPlannerPlansTasksUpdateBucketTaskBoardFormatRequest {
	return ApiGroupsPlannerPlansTasksUpdateBucketTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansTasksUpdateBucketTaskBoardFormatExecute(r ApiGroupsPlannerPlansTasksUpdateBucketTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsPlannerGroupApiService.GroupsPlannerPlansTasksUpdateBucketTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerBucketTaskBoardTaskFormat == nil {
		return nil, reportError("microsoftGraphPlannerBucketTaskBoardTaskFormat is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerBucketTaskBoardTaskFormat
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsPlannerPlansTasksUpdateDetailsRequest struct {
	ctx _context.Context
	ApiService *GroupsPlannerGroupApiService
	groupId string
	plannerPlanId string
	plannerTaskId string
	microsoftGraphPlannerTaskDetails *MicrosoftGraphPlannerTaskDetails
}

// New navigation property values
func (r ApiGroupsPlannerPlansTasksUpdateDetailsRequest) MicrosoftGraphPlannerTaskDetails(microsoftGraphPlannerTaskDetails MicrosoftGraphPlannerTaskDetails) ApiGroupsPlannerPlansTasksUpdateDetailsRequest {
	r.microsoftGraphPlannerTaskDetails = &microsoftGraphPlannerTaskDetails
	return r
}

func (r ApiGroupsPlannerPlansTasksUpdateDetailsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsPlannerPlansTasksUpdateDetailsExecute(r)
}

/*
GroupsPlannerPlansTasksUpdateDetails Update the navigation property details in groups

Read-only. Nullable. Additional details about the task.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiGroupsPlannerPlansTasksUpdateDetailsRequest
*/
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansTasksUpdateDetails(ctx _context.Context, groupId string, plannerPlanId string, plannerTaskId string) ApiGroupsPlannerPlansTasksUpdateDetailsRequest {
	return ApiGroupsPlannerPlansTasksUpdateDetailsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansTasksUpdateDetailsExecute(r ApiGroupsPlannerPlansTasksUpdateDetailsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsPlannerGroupApiService.GroupsPlannerPlansTasksUpdateDetails")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerTaskDetails == nil {
		return nil, reportError("microsoftGraphPlannerTaskDetails is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerTaskDetails
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsPlannerPlansTasksUpdateProgressTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *GroupsPlannerGroupApiService
	groupId string
	plannerPlanId string
	plannerTaskId string
	microsoftGraphPlannerProgressTaskBoardTaskFormat *MicrosoftGraphPlannerProgressTaskBoardTaskFormat
}

// New navigation property values
func (r ApiGroupsPlannerPlansTasksUpdateProgressTaskBoardFormatRequest) MicrosoftGraphPlannerProgressTaskBoardTaskFormat(microsoftGraphPlannerProgressTaskBoardTaskFormat MicrosoftGraphPlannerProgressTaskBoardTaskFormat) ApiGroupsPlannerPlansTasksUpdateProgressTaskBoardFormatRequest {
	r.microsoftGraphPlannerProgressTaskBoardTaskFormat = &microsoftGraphPlannerProgressTaskBoardTaskFormat
	return r
}

func (r ApiGroupsPlannerPlansTasksUpdateProgressTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsPlannerPlansTasksUpdateProgressTaskBoardFormatExecute(r)
}

/*
GroupsPlannerPlansTasksUpdateProgressTaskBoardFormat Update the navigation property progressTaskBoardFormat in groups

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by progress.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiGroupsPlannerPlansTasksUpdateProgressTaskBoardFormatRequest
*/
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansTasksUpdateProgressTaskBoardFormat(ctx _context.Context, groupId string, plannerPlanId string, plannerTaskId string) ApiGroupsPlannerPlansTasksUpdateProgressTaskBoardFormatRequest {
	return ApiGroupsPlannerPlansTasksUpdateProgressTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansTasksUpdateProgressTaskBoardFormatExecute(r ApiGroupsPlannerPlansTasksUpdateProgressTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsPlannerGroupApiService.GroupsPlannerPlansTasksUpdateProgressTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/progressTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerProgressTaskBoardTaskFormat == nil {
		return nil, reportError("microsoftGraphPlannerProgressTaskBoardTaskFormat is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerProgressTaskBoardTaskFormat
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsPlannerPlansUpdateBucketsRequest struct {
	ctx _context.Context
	ApiService *GroupsPlannerGroupApiService
	groupId string
	plannerPlanId string
	plannerBucketId string
	microsoftGraphPlannerBucket *MicrosoftGraphPlannerBucket
}

// New navigation property values
func (r ApiGroupsPlannerPlansUpdateBucketsRequest) MicrosoftGraphPlannerBucket(microsoftGraphPlannerBucket MicrosoftGraphPlannerBucket) ApiGroupsPlannerPlansUpdateBucketsRequest {
	r.microsoftGraphPlannerBucket = &microsoftGraphPlannerBucket
	return r
}

func (r ApiGroupsPlannerPlansUpdateBucketsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsPlannerPlansUpdateBucketsExecute(r)
}

/*
GroupsPlannerPlansUpdateBuckets Update the navigation property buckets in groups

Read-only. Nullable. Collection of buckets in the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param plannerPlanId key: id of plannerPlan
 @param plannerBucketId key: id of plannerBucket
 @return ApiGroupsPlannerPlansUpdateBucketsRequest
*/
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansUpdateBuckets(ctx _context.Context, groupId string, plannerPlanId string, plannerBucketId string) ApiGroupsPlannerPlansUpdateBucketsRequest {
	return ApiGroupsPlannerPlansUpdateBucketsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		plannerPlanId: plannerPlanId,
		plannerBucketId: plannerBucketId,
	}
}

// Execute executes the request
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansUpdateBucketsExecute(r ApiGroupsPlannerPlansUpdateBucketsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsPlannerGroupApiService.GroupsPlannerPlansUpdateBuckets")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerBucket == nil {
		return nil, reportError("microsoftGraphPlannerBucket is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerBucket
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsPlannerPlansUpdateDetailsRequest struct {
	ctx _context.Context
	ApiService *GroupsPlannerGroupApiService
	groupId string
	plannerPlanId string
	microsoftGraphPlannerPlanDetails *MicrosoftGraphPlannerPlanDetails
}

// New navigation property values
func (r ApiGroupsPlannerPlansUpdateDetailsRequest) MicrosoftGraphPlannerPlanDetails(microsoftGraphPlannerPlanDetails MicrosoftGraphPlannerPlanDetails) ApiGroupsPlannerPlansUpdateDetailsRequest {
	r.microsoftGraphPlannerPlanDetails = &microsoftGraphPlannerPlanDetails
	return r
}

func (r ApiGroupsPlannerPlansUpdateDetailsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsPlannerPlansUpdateDetailsExecute(r)
}

/*
GroupsPlannerPlansUpdateDetails Update the navigation property details in groups

Read-only. Nullable. Additional details about the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param plannerPlanId key: id of plannerPlan
 @return ApiGroupsPlannerPlansUpdateDetailsRequest
*/
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansUpdateDetails(ctx _context.Context, groupId string, plannerPlanId string) ApiGroupsPlannerPlansUpdateDetailsRequest {
	return ApiGroupsPlannerPlansUpdateDetailsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		plannerPlanId: plannerPlanId,
	}
}

// Execute executes the request
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansUpdateDetailsExecute(r ApiGroupsPlannerPlansUpdateDetailsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsPlannerGroupApiService.GroupsPlannerPlansUpdateDetails")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/planner/plans/{plannerPlan-id}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerPlanDetails == nil {
		return nil, reportError("microsoftGraphPlannerPlanDetails is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerPlanDetails
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsPlannerPlansUpdateTasksRequest struct {
	ctx _context.Context
	ApiService *GroupsPlannerGroupApiService
	groupId string
	plannerPlanId string
	plannerTaskId string
	microsoftGraphPlannerTask *MicrosoftGraphPlannerTask
}

// New navigation property values
func (r ApiGroupsPlannerPlansUpdateTasksRequest) MicrosoftGraphPlannerTask(microsoftGraphPlannerTask MicrosoftGraphPlannerTask) ApiGroupsPlannerPlansUpdateTasksRequest {
	r.microsoftGraphPlannerTask = &microsoftGraphPlannerTask
	return r
}

func (r ApiGroupsPlannerPlansUpdateTasksRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsPlannerPlansUpdateTasksExecute(r)
}

/*
GroupsPlannerPlansUpdateTasks Update the navigation property tasks in groups

Read-only. Nullable. Collection of tasks in the plan.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param plannerPlanId key: id of plannerPlan
 @param plannerTaskId key: id of plannerTask
 @return ApiGroupsPlannerPlansUpdateTasksRequest
*/
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansUpdateTasks(ctx _context.Context, groupId string, plannerPlanId string, plannerTaskId string) ApiGroupsPlannerPlansUpdateTasksRequest {
	return ApiGroupsPlannerPlansUpdateTasksRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		plannerPlanId: plannerPlanId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *GroupsPlannerGroupApiService) GroupsPlannerPlansUpdateTasksExecute(r ApiGroupsPlannerPlansUpdateTasksRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsPlannerGroupApiService.GroupsPlannerPlansUpdateTasks")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerTask == nil {
		return nil, reportError("microsoftGraphPlannerTask is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerTask
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsPlannerUpdatePlansRequest struct {
	ctx _context.Context
	ApiService *GroupsPlannerGroupApiService
	groupId string
	plannerPlanId string
	microsoftGraphPlannerPlan *MicrosoftGraphPlannerPlan
}

// New navigation property values
func (r ApiGroupsPlannerUpdatePlansRequest) MicrosoftGraphPlannerPlan(microsoftGraphPlannerPlan MicrosoftGraphPlannerPlan) ApiGroupsPlannerUpdatePlansRequest {
	r.microsoftGraphPlannerPlan = &microsoftGraphPlannerPlan
	return r
}

func (r ApiGroupsPlannerUpdatePlansRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsPlannerUpdatePlansExecute(r)
}

/*
GroupsPlannerUpdatePlans Update the navigation property plans in groups

Read-only. Nullable. Returns the plannerPlans owned by the group.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param plannerPlanId key: id of plannerPlan
 @return ApiGroupsPlannerUpdatePlansRequest
*/
func (a *GroupsPlannerGroupApiService) GroupsPlannerUpdatePlans(ctx _context.Context, groupId string, plannerPlanId string) ApiGroupsPlannerUpdatePlansRequest {
	return ApiGroupsPlannerUpdatePlansRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		plannerPlanId: plannerPlanId,
	}
}

// Execute executes the request
func (a *GroupsPlannerGroupApiService) GroupsPlannerUpdatePlansExecute(r ApiGroupsPlannerUpdatePlansRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsPlannerGroupApiService.GroupsPlannerUpdatePlans")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/planner/plans/{plannerPlan-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerPlan-id"+"}", _neturl.PathEscape(parameterToString(r.plannerPlanId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerPlan == nil {
		return nil, reportError("microsoftGraphPlannerPlan is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerPlan
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsUpdatePlannerRequest struct {
	ctx _context.Context
	ApiService *GroupsPlannerGroupApiService
	groupId string
	microsoftGraphPlannerGroup *MicrosoftGraphPlannerGroup
}

// New navigation property values
func (r ApiGroupsUpdatePlannerRequest) MicrosoftGraphPlannerGroup(microsoftGraphPlannerGroup MicrosoftGraphPlannerGroup) ApiGroupsUpdatePlannerRequest {
	r.microsoftGraphPlannerGroup = &microsoftGraphPlannerGroup
	return r
}

func (r ApiGroupsUpdatePlannerRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsUpdatePlannerExecute(r)
}

/*
GroupsUpdatePlanner Update the navigation property planner in groups

Entry-point to Planner resource that might exist for a Unified Group.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsUpdatePlannerRequest
*/
func (a *GroupsPlannerGroupApiService) GroupsUpdatePlanner(ctx _context.Context, groupId string) ApiGroupsUpdatePlannerRequest {
	return ApiGroupsUpdatePlannerRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
func (a *GroupsPlannerGroupApiService) GroupsUpdatePlannerExecute(r ApiGroupsUpdatePlannerRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsPlannerGroupApiService.GroupsUpdatePlanner")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/planner"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerGroup == nil {
		return nil, reportError("microsoftGraphPlannerGroup is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerGroup
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
