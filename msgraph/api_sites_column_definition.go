/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// SitesColumnDefinitionApiService SitesColumnDefinitionApi service
type SitesColumnDefinitionApiService service

type ApiSitesColumnsDeleteRefSourceColumnRequest struct {
	ctx _context.Context
	ApiService *SitesColumnDefinitionApiService
	siteId string
	columnDefinitionId string
	ifMatch *string
}

// ETag
func (r ApiSitesColumnsDeleteRefSourceColumnRequest) IfMatch(ifMatch string) ApiSitesColumnsDeleteRefSourceColumnRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesColumnsDeleteRefSourceColumnRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesColumnsDeleteRefSourceColumnExecute(r)
}

/*
SitesColumnsDeleteRefSourceColumn Delete ref of navigation property sourceColumn for sites

The source column for the content type column.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param columnDefinitionId key: id of columnDefinition
 @return ApiSitesColumnsDeleteRefSourceColumnRequest
*/
func (a *SitesColumnDefinitionApiService) SitesColumnsDeleteRefSourceColumn(ctx _context.Context, siteId string, columnDefinitionId string) ApiSitesColumnsDeleteRefSourceColumnRequest {
	return ApiSitesColumnsDeleteRefSourceColumnRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
func (a *SitesColumnDefinitionApiService) SitesColumnsDeleteRefSourceColumnExecute(r ApiSitesColumnsDeleteRefSourceColumnRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesColumnDefinitionApiService.SitesColumnsDeleteRefSourceColumn")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/columns/{columnDefinition-id}/sourceColumn/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesColumnsGetRefSourceColumnRequest struct {
	ctx _context.Context
	ApiService *SitesColumnDefinitionApiService
	siteId string
	columnDefinitionId string
}


func (r ApiSitesColumnsGetRefSourceColumnRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.SitesColumnsGetRefSourceColumnExecute(r)
}

/*
SitesColumnsGetRefSourceColumn Get ref of sourceColumn from sites

The source column for the content type column.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param columnDefinitionId key: id of columnDefinition
 @return ApiSitesColumnsGetRefSourceColumnRequest
*/
func (a *SitesColumnDefinitionApiService) SitesColumnsGetRefSourceColumn(ctx _context.Context, siteId string, columnDefinitionId string) ApiSitesColumnsGetRefSourceColumnRequest {
	return ApiSitesColumnsGetRefSourceColumnRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
//  @return string
func (a *SitesColumnDefinitionApiService) SitesColumnsGetRefSourceColumnExecute(r ApiSitesColumnsGetRefSourceColumnRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesColumnDefinitionApiService.SitesColumnsGetRefSourceColumn")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/columns/{columnDefinition-id}/sourceColumn/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesColumnsGetSourceColumnRequest struct {
	ctx _context.Context
	ApiService *SitesColumnDefinitionApiService
	siteId string
	columnDefinitionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesColumnsGetSourceColumnRequest) Select_(select_ []string) ApiSitesColumnsGetSourceColumnRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesColumnsGetSourceColumnRequest) Expand(expand []string) ApiSitesColumnsGetSourceColumnRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesColumnsGetSourceColumnRequest) Execute() (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.SitesColumnsGetSourceColumnExecute(r)
}

/*
SitesColumnsGetSourceColumn Get sourceColumn from sites

The source column for the content type column.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param columnDefinitionId key: id of columnDefinition
 @return ApiSitesColumnsGetSourceColumnRequest
*/
func (a *SitesColumnDefinitionApiService) SitesColumnsGetSourceColumn(ctx _context.Context, siteId string, columnDefinitionId string) ApiSitesColumnsGetSourceColumnRequest {
	return ApiSitesColumnsGetSourceColumnRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphColumnDefinition
func (a *SitesColumnDefinitionApiService) SitesColumnsGetSourceColumnExecute(r ApiSitesColumnsGetSourceColumnRequest) (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesColumnDefinitionApiService.SitesColumnsGetSourceColumn")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/columns/{columnDefinition-id}/sourceColumn"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesColumnsUpdateRefSourceColumnRequest struct {
	ctx _context.Context
	ApiService *SitesColumnDefinitionApiService
	siteId string
	columnDefinitionId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiSitesColumnsUpdateRefSourceColumnRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesColumnsUpdateRefSourceColumnRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesColumnsUpdateRefSourceColumnRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesColumnsUpdateRefSourceColumnExecute(r)
}

/*
SitesColumnsUpdateRefSourceColumn Update the ref of navigation property sourceColumn in sites

The source column for the content type column.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param columnDefinitionId key: id of columnDefinition
 @return ApiSitesColumnsUpdateRefSourceColumnRequest
*/
func (a *SitesColumnDefinitionApiService) SitesColumnsUpdateRefSourceColumn(ctx _context.Context, siteId string, columnDefinitionId string) ApiSitesColumnsUpdateRefSourceColumnRequest {
	return ApiSitesColumnsUpdateRefSourceColumnRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
func (a *SitesColumnDefinitionApiService) SitesColumnsUpdateRefSourceColumnExecute(r ApiSitesColumnsUpdateRefSourceColumnRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesColumnDefinitionApiService.SitesColumnsUpdateRefSourceColumn")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/columns/{columnDefinition-id}/sourceColumn/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesCreateColumnsRequest struct {
	ctx _context.Context
	ApiService *SitesColumnDefinitionApiService
	siteId string
	microsoftGraphColumnDefinition *MicrosoftGraphColumnDefinition
}

// New navigation property
func (r ApiSitesCreateColumnsRequest) MicrosoftGraphColumnDefinition(microsoftGraphColumnDefinition MicrosoftGraphColumnDefinition) ApiSitesCreateColumnsRequest {
	r.microsoftGraphColumnDefinition = &microsoftGraphColumnDefinition
	return r
}

func (r ApiSitesCreateColumnsRequest) Execute() (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.SitesCreateColumnsExecute(r)
}

/*
SitesCreateColumns Create new navigation property to columns for sites

The collection of column definitions reusable across lists under this site.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @return ApiSitesCreateColumnsRequest
*/
func (a *SitesColumnDefinitionApiService) SitesCreateColumns(ctx _context.Context, siteId string) ApiSitesCreateColumnsRequest {
	return ApiSitesCreateColumnsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphColumnDefinition
func (a *SitesColumnDefinitionApiService) SitesCreateColumnsExecute(r ApiSitesCreateColumnsRequest) (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesColumnDefinitionApiService.SitesCreateColumns")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/columns"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphColumnDefinition == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphColumnDefinition is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphColumnDefinition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesCreateRefExternalColumnsRequest struct {
	ctx _context.Context
	ApiService *SitesColumnDefinitionApiService
	siteId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref value
func (r ApiSitesCreateRefExternalColumnsRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiSitesCreateRefExternalColumnsRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSitesCreateRefExternalColumnsRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.SitesCreateRefExternalColumnsExecute(r)
}

/*
SitesCreateRefExternalColumns Create new navigation property ref to externalColumns for sites

The collection of column definitions available in the site that are referenced from the sites in the parent hierarchy of the current site.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @return ApiSitesCreateRefExternalColumnsRequest
*/
func (a *SitesColumnDefinitionApiService) SitesCreateRefExternalColumns(ctx _context.Context, siteId string) ApiSitesCreateRefExternalColumnsRequest {
	return ApiSitesCreateRefExternalColumnsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *SitesColumnDefinitionApiService) SitesCreateRefExternalColumnsExecute(r ApiSitesCreateRefExternalColumnsRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesColumnDefinitionApiService.SitesCreateRefExternalColumns")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/externalColumns/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesDeleteColumnsRequest struct {
	ctx _context.Context
	ApiService *SitesColumnDefinitionApiService
	siteId string
	columnDefinitionId string
	ifMatch *string
}

// ETag
func (r ApiSitesDeleteColumnsRequest) IfMatch(ifMatch string) ApiSitesDeleteColumnsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiSitesDeleteColumnsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesDeleteColumnsExecute(r)
}

/*
SitesDeleteColumns Delete navigation property columns for sites

The collection of column definitions reusable across lists under this site.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param columnDefinitionId key: id of columnDefinition
 @return ApiSitesDeleteColumnsRequest
*/
func (a *SitesColumnDefinitionApiService) SitesDeleteColumns(ctx _context.Context, siteId string, columnDefinitionId string) ApiSitesDeleteColumnsRequest {
	return ApiSitesDeleteColumnsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
func (a *SitesColumnDefinitionApiService) SitesDeleteColumnsExecute(r ApiSitesDeleteColumnsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesColumnDefinitionApiService.SitesDeleteColumns")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/columns/{columnDefinition-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSitesGetColumnsRequest struct {
	ctx _context.Context
	ApiService *SitesColumnDefinitionApiService
	siteId string
	columnDefinitionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiSitesGetColumnsRequest) Select_(select_ []string) ApiSitesGetColumnsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesGetColumnsRequest) Expand(expand []string) ApiSitesGetColumnsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesGetColumnsRequest) Execute() (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.SitesGetColumnsExecute(r)
}

/*
SitesGetColumns Get columns from sites

The collection of column definitions reusable across lists under this site.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param columnDefinitionId key: id of columnDefinition
 @return ApiSitesGetColumnsRequest
*/
func (a *SitesColumnDefinitionApiService) SitesGetColumns(ctx _context.Context, siteId string, columnDefinitionId string) ApiSitesGetColumnsRequest {
	return ApiSitesGetColumnsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphColumnDefinition
func (a *SitesColumnDefinitionApiService) SitesGetColumnsExecute(r ApiSitesGetColumnsRequest) (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesColumnDefinitionApiService.SitesGetColumns")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/columns/{columnDefinition-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesListColumnsRequest struct {
	ctx _context.Context
	ApiService *SitesColumnDefinitionApiService
	siteId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesListColumnsRequest) Top(top int32) ApiSitesListColumnsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesListColumnsRequest) Skip(skip int32) ApiSitesListColumnsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesListColumnsRequest) Search(search string) ApiSitesListColumnsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesListColumnsRequest) Filter(filter string) ApiSitesListColumnsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesListColumnsRequest) Count(count bool) ApiSitesListColumnsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesListColumnsRequest) Orderby(orderby []string) ApiSitesListColumnsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesListColumnsRequest) Select_(select_ []string) ApiSitesListColumnsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesListColumnsRequest) Expand(expand []string) ApiSitesListColumnsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesListColumnsRequest) Execute() (CollectionOfColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.SitesListColumnsExecute(r)
}

/*
SitesListColumns Get columns from sites

The collection of column definitions reusable across lists under this site.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @return ApiSitesListColumnsRequest
*/
func (a *SitesColumnDefinitionApiService) SitesListColumns(ctx _context.Context, siteId string) ApiSitesListColumnsRequest {
	return ApiSitesListColumnsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return CollectionOfColumnDefinition
func (a *SitesColumnDefinitionApiService) SitesListColumnsExecute(r ApiSitesListColumnsRequest) (CollectionOfColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesColumnDefinitionApiService.SitesListColumns")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/columns"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesListExternalColumnsRequest struct {
	ctx _context.Context
	ApiService *SitesColumnDefinitionApiService
	siteId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiSitesListExternalColumnsRequest) Top(top int32) ApiSitesListExternalColumnsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesListExternalColumnsRequest) Skip(skip int32) ApiSitesListExternalColumnsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesListExternalColumnsRequest) Search(search string) ApiSitesListExternalColumnsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesListExternalColumnsRequest) Filter(filter string) ApiSitesListExternalColumnsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesListExternalColumnsRequest) Count(count bool) ApiSitesListExternalColumnsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesListExternalColumnsRequest) Orderby(orderby []string) ApiSitesListExternalColumnsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiSitesListExternalColumnsRequest) Select_(select_ []string) ApiSitesListExternalColumnsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiSitesListExternalColumnsRequest) Expand(expand []string) ApiSitesListExternalColumnsRequest {
	r.expand = &expand
	return r
}

func (r ApiSitesListExternalColumnsRequest) Execute() (CollectionOfColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.SitesListExternalColumnsExecute(r)
}

/*
SitesListExternalColumns Get externalColumns from sites

The collection of column definitions available in the site that are referenced from the sites in the parent hierarchy of the current site.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @return ApiSitesListExternalColumnsRequest
*/
func (a *SitesColumnDefinitionApiService) SitesListExternalColumns(ctx _context.Context, siteId string) ApiSitesListExternalColumnsRequest {
	return ApiSitesListExternalColumnsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return CollectionOfColumnDefinition
func (a *SitesColumnDefinitionApiService) SitesListExternalColumnsExecute(r ApiSitesListExternalColumnsRequest) (CollectionOfColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesColumnDefinitionApiService.SitesListExternalColumns")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/externalColumns"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesListRefExternalColumnsRequest struct {
	ctx _context.Context
	ApiService *SitesColumnDefinitionApiService
	siteId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
}

// Show only the first n items
func (r ApiSitesListRefExternalColumnsRequest) Top(top int32) ApiSitesListRefExternalColumnsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiSitesListRefExternalColumnsRequest) Skip(skip int32) ApiSitesListRefExternalColumnsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiSitesListRefExternalColumnsRequest) Search(search string) ApiSitesListRefExternalColumnsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiSitesListRefExternalColumnsRequest) Filter(filter string) ApiSitesListRefExternalColumnsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiSitesListRefExternalColumnsRequest) Count(count bool) ApiSitesListRefExternalColumnsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiSitesListRefExternalColumnsRequest) Orderby(orderby []string) ApiSitesListRefExternalColumnsRequest {
	r.orderby = &orderby
	return r
}

func (r ApiSitesListRefExternalColumnsRequest) Execute() (CollectionOfLinksOfColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.SitesListRefExternalColumnsExecute(r)
}

/*
SitesListRefExternalColumns Get ref of externalColumns from sites

The collection of column definitions available in the site that are referenced from the sites in the parent hierarchy of the current site.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @return ApiSitesListRefExternalColumnsRequest
*/
func (a *SitesColumnDefinitionApiService) SitesListRefExternalColumns(ctx _context.Context, siteId string) ApiSitesListRefExternalColumnsRequest {
	return ApiSitesListRefExternalColumnsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return CollectionOfLinksOfColumnDefinition
func (a *SitesColumnDefinitionApiService) SitesListRefExternalColumnsExecute(r ApiSitesListRefExternalColumnsRequest) (CollectionOfLinksOfColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfLinksOfColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesColumnDefinitionApiService.SitesListRefExternalColumns")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/externalColumns/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSitesUpdateColumnsRequest struct {
	ctx _context.Context
	ApiService *SitesColumnDefinitionApiService
	siteId string
	columnDefinitionId string
	microsoftGraphColumnDefinition *MicrosoftGraphColumnDefinition
}

// New navigation property values
func (r ApiSitesUpdateColumnsRequest) MicrosoftGraphColumnDefinition(microsoftGraphColumnDefinition MicrosoftGraphColumnDefinition) ApiSitesUpdateColumnsRequest {
	r.microsoftGraphColumnDefinition = &microsoftGraphColumnDefinition
	return r
}

func (r ApiSitesUpdateColumnsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SitesUpdateColumnsExecute(r)
}

/*
SitesUpdateColumns Update the navigation property columns in sites

The collection of column definitions reusable across lists under this site.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId key: id of site
 @param columnDefinitionId key: id of columnDefinition
 @return ApiSitesUpdateColumnsRequest
*/
func (a *SitesColumnDefinitionApiService) SitesUpdateColumns(ctx _context.Context, siteId string, columnDefinitionId string) ApiSitesUpdateColumnsRequest {
	return ApiSitesUpdateColumnsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
func (a *SitesColumnDefinitionApiService) SitesUpdateColumnsExecute(r ApiSitesUpdateColumnsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesColumnDefinitionApiService.SitesUpdateColumns")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{site-id}/columns/{columnDefinition-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site-id"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphColumnDefinition == nil {
		return nil, reportError("microsoftGraphColumnDefinition is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphColumnDefinition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
