/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// PoliciesPermissionGrantPolicyApiService PoliciesPermissionGrantPolicyApi service
type PoliciesPermissionGrantPolicyApiService service

type ApiPoliciesCreatePermissionGrantPoliciesRequest struct {
	ctx _context.Context
	ApiService *PoliciesPermissionGrantPolicyApiService
	microsoftGraphPermissionGrantPolicy *MicrosoftGraphPermissionGrantPolicy
}

// New navigation property
func (r ApiPoliciesCreatePermissionGrantPoliciesRequest) MicrosoftGraphPermissionGrantPolicy(microsoftGraphPermissionGrantPolicy MicrosoftGraphPermissionGrantPolicy) ApiPoliciesCreatePermissionGrantPoliciesRequest {
	r.microsoftGraphPermissionGrantPolicy = &microsoftGraphPermissionGrantPolicy
	return r
}

func (r ApiPoliciesCreatePermissionGrantPoliciesRequest) Execute() (MicrosoftGraphPermissionGrantPolicy, *_nethttp.Response, error) {
	return r.ApiService.PoliciesCreatePermissionGrantPoliciesExecute(r)
}

/*
PoliciesCreatePermissionGrantPolicies Create new navigation property to permissionGrantPolicies for policies

The policy that specifies the conditions under which consent can be granted.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPoliciesCreatePermissionGrantPoliciesRequest
*/
func (a *PoliciesPermissionGrantPolicyApiService) PoliciesCreatePermissionGrantPolicies(ctx _context.Context) ApiPoliciesCreatePermissionGrantPoliciesRequest {
	return ApiPoliciesCreatePermissionGrantPoliciesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPermissionGrantPolicy
func (a *PoliciesPermissionGrantPolicyApiService) PoliciesCreatePermissionGrantPoliciesExecute(r ApiPoliciesCreatePermissionGrantPoliciesRequest) (MicrosoftGraphPermissionGrantPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPermissionGrantPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesPermissionGrantPolicyApiService.PoliciesCreatePermissionGrantPolicies")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/permissionGrantPolicies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPermissionGrantPolicy == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphPermissionGrantPolicy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPermissionGrantPolicy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesDeletePermissionGrantPoliciesRequest struct {
	ctx _context.Context
	ApiService *PoliciesPermissionGrantPolicyApiService
	permissionGrantPolicyId string
	ifMatch *string
}

// ETag
func (r ApiPoliciesDeletePermissionGrantPoliciesRequest) IfMatch(ifMatch string) ApiPoliciesDeletePermissionGrantPoliciesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiPoliciesDeletePermissionGrantPoliciesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PoliciesDeletePermissionGrantPoliciesExecute(r)
}

/*
PoliciesDeletePermissionGrantPolicies Delete navigation property permissionGrantPolicies for policies

The policy that specifies the conditions under which consent can be granted.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param permissionGrantPolicyId key: id of permissionGrantPolicy
 @return ApiPoliciesDeletePermissionGrantPoliciesRequest
*/
func (a *PoliciesPermissionGrantPolicyApiService) PoliciesDeletePermissionGrantPolicies(ctx _context.Context, permissionGrantPolicyId string) ApiPoliciesDeletePermissionGrantPoliciesRequest {
	return ApiPoliciesDeletePermissionGrantPoliciesRequest{
		ApiService: a,
		ctx: ctx,
		permissionGrantPolicyId: permissionGrantPolicyId,
	}
}

// Execute executes the request
func (a *PoliciesPermissionGrantPolicyApiService) PoliciesDeletePermissionGrantPoliciesExecute(r ApiPoliciesDeletePermissionGrantPoliciesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesPermissionGrantPolicyApiService.PoliciesDeletePermissionGrantPolicies")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/permissionGrantPolicies/{permissionGrantPolicy-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"permissionGrantPolicy-id"+"}", _neturl.PathEscape(parameterToString(r.permissionGrantPolicyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoliciesGetPermissionGrantPoliciesRequest struct {
	ctx _context.Context
	ApiService *PoliciesPermissionGrantPolicyApiService
	permissionGrantPolicyId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiPoliciesGetPermissionGrantPoliciesRequest) Select_(select_ []string) ApiPoliciesGetPermissionGrantPoliciesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiPoliciesGetPermissionGrantPoliciesRequest) Expand(expand []string) ApiPoliciesGetPermissionGrantPoliciesRequest {
	r.expand = &expand
	return r
}

func (r ApiPoliciesGetPermissionGrantPoliciesRequest) Execute() (MicrosoftGraphPermissionGrantPolicy, *_nethttp.Response, error) {
	return r.ApiService.PoliciesGetPermissionGrantPoliciesExecute(r)
}

/*
PoliciesGetPermissionGrantPolicies Get permissionGrantPolicies from policies

The policy that specifies the conditions under which consent can be granted.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param permissionGrantPolicyId key: id of permissionGrantPolicy
 @return ApiPoliciesGetPermissionGrantPoliciesRequest
*/
func (a *PoliciesPermissionGrantPolicyApiService) PoliciesGetPermissionGrantPolicies(ctx _context.Context, permissionGrantPolicyId string) ApiPoliciesGetPermissionGrantPoliciesRequest {
	return ApiPoliciesGetPermissionGrantPoliciesRequest{
		ApiService: a,
		ctx: ctx,
		permissionGrantPolicyId: permissionGrantPolicyId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPermissionGrantPolicy
func (a *PoliciesPermissionGrantPolicyApiService) PoliciesGetPermissionGrantPoliciesExecute(r ApiPoliciesGetPermissionGrantPoliciesRequest) (MicrosoftGraphPermissionGrantPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPermissionGrantPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesPermissionGrantPolicyApiService.PoliciesGetPermissionGrantPolicies")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/permissionGrantPolicies/{permissionGrantPolicy-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"permissionGrantPolicy-id"+"}", _neturl.PathEscape(parameterToString(r.permissionGrantPolicyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesListPermissionGrantPoliciesRequest struct {
	ctx _context.Context
	ApiService *PoliciesPermissionGrantPolicyApiService
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiPoliciesListPermissionGrantPoliciesRequest) Top(top int32) ApiPoliciesListPermissionGrantPoliciesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiPoliciesListPermissionGrantPoliciesRequest) Skip(skip int32) ApiPoliciesListPermissionGrantPoliciesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiPoliciesListPermissionGrantPoliciesRequest) Search(search string) ApiPoliciesListPermissionGrantPoliciesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiPoliciesListPermissionGrantPoliciesRequest) Filter(filter string) ApiPoliciesListPermissionGrantPoliciesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiPoliciesListPermissionGrantPoliciesRequest) Count(count bool) ApiPoliciesListPermissionGrantPoliciesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiPoliciesListPermissionGrantPoliciesRequest) Orderby(orderby []string) ApiPoliciesListPermissionGrantPoliciesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiPoliciesListPermissionGrantPoliciesRequest) Select_(select_ []string) ApiPoliciesListPermissionGrantPoliciesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiPoliciesListPermissionGrantPoliciesRequest) Expand(expand []string) ApiPoliciesListPermissionGrantPoliciesRequest {
	r.expand = &expand
	return r
}

func (r ApiPoliciesListPermissionGrantPoliciesRequest) Execute() (CollectionOfPermissionGrantPolicy, *_nethttp.Response, error) {
	return r.ApiService.PoliciesListPermissionGrantPoliciesExecute(r)
}

/*
PoliciesListPermissionGrantPolicies Get permissionGrantPolicies from policies

The policy that specifies the conditions under which consent can be granted.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPoliciesListPermissionGrantPoliciesRequest
*/
func (a *PoliciesPermissionGrantPolicyApiService) PoliciesListPermissionGrantPolicies(ctx _context.Context) ApiPoliciesListPermissionGrantPoliciesRequest {
	return ApiPoliciesListPermissionGrantPoliciesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionOfPermissionGrantPolicy
func (a *PoliciesPermissionGrantPolicyApiService) PoliciesListPermissionGrantPoliciesExecute(r ApiPoliciesListPermissionGrantPoliciesRequest) (CollectionOfPermissionGrantPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfPermissionGrantPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesPermissionGrantPolicyApiService.PoliciesListPermissionGrantPolicies")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/permissionGrantPolicies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesPermissionGrantPoliciesCreateExcludesRequest struct {
	ctx _context.Context
	ApiService *PoliciesPermissionGrantPolicyApiService
	permissionGrantPolicyId string
	microsoftGraphPermissionGrantConditionSet *MicrosoftGraphPermissionGrantConditionSet
}

// New navigation property
func (r ApiPoliciesPermissionGrantPoliciesCreateExcludesRequest) MicrosoftGraphPermissionGrantConditionSet(microsoftGraphPermissionGrantConditionSet MicrosoftGraphPermissionGrantConditionSet) ApiPoliciesPermissionGrantPoliciesCreateExcludesRequest {
	r.microsoftGraphPermissionGrantConditionSet = &microsoftGraphPermissionGrantConditionSet
	return r
}

func (r ApiPoliciesPermissionGrantPoliciesCreateExcludesRequest) Execute() (MicrosoftGraphPermissionGrantConditionSet, *_nethttp.Response, error) {
	return r.ApiService.PoliciesPermissionGrantPoliciesCreateExcludesExecute(r)
}

/*
PoliciesPermissionGrantPoliciesCreateExcludes Create new navigation property to excludes for policies

Condition sets which are excluded in this permission grant policy. Automatically expanded on GET.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param permissionGrantPolicyId key: id of permissionGrantPolicy
 @return ApiPoliciesPermissionGrantPoliciesCreateExcludesRequest
*/
func (a *PoliciesPermissionGrantPolicyApiService) PoliciesPermissionGrantPoliciesCreateExcludes(ctx _context.Context, permissionGrantPolicyId string) ApiPoliciesPermissionGrantPoliciesCreateExcludesRequest {
	return ApiPoliciesPermissionGrantPoliciesCreateExcludesRequest{
		ApiService: a,
		ctx: ctx,
		permissionGrantPolicyId: permissionGrantPolicyId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPermissionGrantConditionSet
func (a *PoliciesPermissionGrantPolicyApiService) PoliciesPermissionGrantPoliciesCreateExcludesExecute(r ApiPoliciesPermissionGrantPoliciesCreateExcludesRequest) (MicrosoftGraphPermissionGrantConditionSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPermissionGrantConditionSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesPermissionGrantPolicyApiService.PoliciesPermissionGrantPoliciesCreateExcludes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/permissionGrantPolicies/{permissionGrantPolicy-id}/excludes"
	localVarPath = strings.Replace(localVarPath, "{"+"permissionGrantPolicy-id"+"}", _neturl.PathEscape(parameterToString(r.permissionGrantPolicyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPermissionGrantConditionSet == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphPermissionGrantConditionSet is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPermissionGrantConditionSet
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesPermissionGrantPoliciesCreateIncludesRequest struct {
	ctx _context.Context
	ApiService *PoliciesPermissionGrantPolicyApiService
	permissionGrantPolicyId string
	microsoftGraphPermissionGrantConditionSet *MicrosoftGraphPermissionGrantConditionSet
}

// New navigation property
func (r ApiPoliciesPermissionGrantPoliciesCreateIncludesRequest) MicrosoftGraphPermissionGrantConditionSet(microsoftGraphPermissionGrantConditionSet MicrosoftGraphPermissionGrantConditionSet) ApiPoliciesPermissionGrantPoliciesCreateIncludesRequest {
	r.microsoftGraphPermissionGrantConditionSet = &microsoftGraphPermissionGrantConditionSet
	return r
}

func (r ApiPoliciesPermissionGrantPoliciesCreateIncludesRequest) Execute() (MicrosoftGraphPermissionGrantConditionSet, *_nethttp.Response, error) {
	return r.ApiService.PoliciesPermissionGrantPoliciesCreateIncludesExecute(r)
}

/*
PoliciesPermissionGrantPoliciesCreateIncludes Create new navigation property to includes for policies

Condition sets which are included in this permission grant policy. Automatically expanded on GET.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param permissionGrantPolicyId key: id of permissionGrantPolicy
 @return ApiPoliciesPermissionGrantPoliciesCreateIncludesRequest
*/
func (a *PoliciesPermissionGrantPolicyApiService) PoliciesPermissionGrantPoliciesCreateIncludes(ctx _context.Context, permissionGrantPolicyId string) ApiPoliciesPermissionGrantPoliciesCreateIncludesRequest {
	return ApiPoliciesPermissionGrantPoliciesCreateIncludesRequest{
		ApiService: a,
		ctx: ctx,
		permissionGrantPolicyId: permissionGrantPolicyId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPermissionGrantConditionSet
func (a *PoliciesPermissionGrantPolicyApiService) PoliciesPermissionGrantPoliciesCreateIncludesExecute(r ApiPoliciesPermissionGrantPoliciesCreateIncludesRequest) (MicrosoftGraphPermissionGrantConditionSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPermissionGrantConditionSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesPermissionGrantPolicyApiService.PoliciesPermissionGrantPoliciesCreateIncludes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/permissionGrantPolicies/{permissionGrantPolicy-id}/includes"
	localVarPath = strings.Replace(localVarPath, "{"+"permissionGrantPolicy-id"+"}", _neturl.PathEscape(parameterToString(r.permissionGrantPolicyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPermissionGrantConditionSet == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphPermissionGrantConditionSet is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPermissionGrantConditionSet
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesPermissionGrantPoliciesDeleteExcludesRequest struct {
	ctx _context.Context
	ApiService *PoliciesPermissionGrantPolicyApiService
	permissionGrantPolicyId string
	permissionGrantConditionSetId string
	ifMatch *string
}

// ETag
func (r ApiPoliciesPermissionGrantPoliciesDeleteExcludesRequest) IfMatch(ifMatch string) ApiPoliciesPermissionGrantPoliciesDeleteExcludesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiPoliciesPermissionGrantPoliciesDeleteExcludesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PoliciesPermissionGrantPoliciesDeleteExcludesExecute(r)
}

/*
PoliciesPermissionGrantPoliciesDeleteExcludes Delete navigation property excludes for policies

Condition sets which are excluded in this permission grant policy. Automatically expanded on GET.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param permissionGrantPolicyId key: id of permissionGrantPolicy
 @param permissionGrantConditionSetId key: id of permissionGrantConditionSet
 @return ApiPoliciesPermissionGrantPoliciesDeleteExcludesRequest
*/
func (a *PoliciesPermissionGrantPolicyApiService) PoliciesPermissionGrantPoliciesDeleteExcludes(ctx _context.Context, permissionGrantPolicyId string, permissionGrantConditionSetId string) ApiPoliciesPermissionGrantPoliciesDeleteExcludesRequest {
	return ApiPoliciesPermissionGrantPoliciesDeleteExcludesRequest{
		ApiService: a,
		ctx: ctx,
		permissionGrantPolicyId: permissionGrantPolicyId,
		permissionGrantConditionSetId: permissionGrantConditionSetId,
	}
}

// Execute executes the request
func (a *PoliciesPermissionGrantPolicyApiService) PoliciesPermissionGrantPoliciesDeleteExcludesExecute(r ApiPoliciesPermissionGrantPoliciesDeleteExcludesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesPermissionGrantPolicyApiService.PoliciesPermissionGrantPoliciesDeleteExcludes")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/permissionGrantPolicies/{permissionGrantPolicy-id}/excludes/{permissionGrantConditionSet-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"permissionGrantPolicy-id"+"}", _neturl.PathEscape(parameterToString(r.permissionGrantPolicyId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"permissionGrantConditionSet-id"+"}", _neturl.PathEscape(parameterToString(r.permissionGrantConditionSetId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoliciesPermissionGrantPoliciesDeleteIncludesRequest struct {
	ctx _context.Context
	ApiService *PoliciesPermissionGrantPolicyApiService
	permissionGrantPolicyId string
	permissionGrantConditionSetId string
	ifMatch *string
}

// ETag
func (r ApiPoliciesPermissionGrantPoliciesDeleteIncludesRequest) IfMatch(ifMatch string) ApiPoliciesPermissionGrantPoliciesDeleteIncludesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiPoliciesPermissionGrantPoliciesDeleteIncludesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PoliciesPermissionGrantPoliciesDeleteIncludesExecute(r)
}

/*
PoliciesPermissionGrantPoliciesDeleteIncludes Delete navigation property includes for policies

Condition sets which are included in this permission grant policy. Automatically expanded on GET.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param permissionGrantPolicyId key: id of permissionGrantPolicy
 @param permissionGrantConditionSetId key: id of permissionGrantConditionSet
 @return ApiPoliciesPermissionGrantPoliciesDeleteIncludesRequest
*/
func (a *PoliciesPermissionGrantPolicyApiService) PoliciesPermissionGrantPoliciesDeleteIncludes(ctx _context.Context, permissionGrantPolicyId string, permissionGrantConditionSetId string) ApiPoliciesPermissionGrantPoliciesDeleteIncludesRequest {
	return ApiPoliciesPermissionGrantPoliciesDeleteIncludesRequest{
		ApiService: a,
		ctx: ctx,
		permissionGrantPolicyId: permissionGrantPolicyId,
		permissionGrantConditionSetId: permissionGrantConditionSetId,
	}
}

// Execute executes the request
func (a *PoliciesPermissionGrantPolicyApiService) PoliciesPermissionGrantPoliciesDeleteIncludesExecute(r ApiPoliciesPermissionGrantPoliciesDeleteIncludesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesPermissionGrantPolicyApiService.PoliciesPermissionGrantPoliciesDeleteIncludes")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/permissionGrantPolicies/{permissionGrantPolicy-id}/includes/{permissionGrantConditionSet-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"permissionGrantPolicy-id"+"}", _neturl.PathEscape(parameterToString(r.permissionGrantPolicyId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"permissionGrantConditionSet-id"+"}", _neturl.PathEscape(parameterToString(r.permissionGrantConditionSetId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoliciesPermissionGrantPoliciesGetExcludesRequest struct {
	ctx _context.Context
	ApiService *PoliciesPermissionGrantPolicyApiService
	permissionGrantPolicyId string
	permissionGrantConditionSetId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiPoliciesPermissionGrantPoliciesGetExcludesRequest) Select_(select_ []string) ApiPoliciesPermissionGrantPoliciesGetExcludesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiPoliciesPermissionGrantPoliciesGetExcludesRequest) Expand(expand []string) ApiPoliciesPermissionGrantPoliciesGetExcludesRequest {
	r.expand = &expand
	return r
}

func (r ApiPoliciesPermissionGrantPoliciesGetExcludesRequest) Execute() (MicrosoftGraphPermissionGrantConditionSet, *_nethttp.Response, error) {
	return r.ApiService.PoliciesPermissionGrantPoliciesGetExcludesExecute(r)
}

/*
PoliciesPermissionGrantPoliciesGetExcludes Get excludes from policies

Condition sets which are excluded in this permission grant policy. Automatically expanded on GET.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param permissionGrantPolicyId key: id of permissionGrantPolicy
 @param permissionGrantConditionSetId key: id of permissionGrantConditionSet
 @return ApiPoliciesPermissionGrantPoliciesGetExcludesRequest
*/
func (a *PoliciesPermissionGrantPolicyApiService) PoliciesPermissionGrantPoliciesGetExcludes(ctx _context.Context, permissionGrantPolicyId string, permissionGrantConditionSetId string) ApiPoliciesPermissionGrantPoliciesGetExcludesRequest {
	return ApiPoliciesPermissionGrantPoliciesGetExcludesRequest{
		ApiService: a,
		ctx: ctx,
		permissionGrantPolicyId: permissionGrantPolicyId,
		permissionGrantConditionSetId: permissionGrantConditionSetId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPermissionGrantConditionSet
func (a *PoliciesPermissionGrantPolicyApiService) PoliciesPermissionGrantPoliciesGetExcludesExecute(r ApiPoliciesPermissionGrantPoliciesGetExcludesRequest) (MicrosoftGraphPermissionGrantConditionSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPermissionGrantConditionSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesPermissionGrantPolicyApiService.PoliciesPermissionGrantPoliciesGetExcludes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/permissionGrantPolicies/{permissionGrantPolicy-id}/excludes/{permissionGrantConditionSet-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"permissionGrantPolicy-id"+"}", _neturl.PathEscape(parameterToString(r.permissionGrantPolicyId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"permissionGrantConditionSet-id"+"}", _neturl.PathEscape(parameterToString(r.permissionGrantConditionSetId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesPermissionGrantPoliciesGetIncludesRequest struct {
	ctx _context.Context
	ApiService *PoliciesPermissionGrantPolicyApiService
	permissionGrantPolicyId string
	permissionGrantConditionSetId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiPoliciesPermissionGrantPoliciesGetIncludesRequest) Select_(select_ []string) ApiPoliciesPermissionGrantPoliciesGetIncludesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiPoliciesPermissionGrantPoliciesGetIncludesRequest) Expand(expand []string) ApiPoliciesPermissionGrantPoliciesGetIncludesRequest {
	r.expand = &expand
	return r
}

func (r ApiPoliciesPermissionGrantPoliciesGetIncludesRequest) Execute() (MicrosoftGraphPermissionGrantConditionSet, *_nethttp.Response, error) {
	return r.ApiService.PoliciesPermissionGrantPoliciesGetIncludesExecute(r)
}

/*
PoliciesPermissionGrantPoliciesGetIncludes Get includes from policies

Condition sets which are included in this permission grant policy. Automatically expanded on GET.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param permissionGrantPolicyId key: id of permissionGrantPolicy
 @param permissionGrantConditionSetId key: id of permissionGrantConditionSet
 @return ApiPoliciesPermissionGrantPoliciesGetIncludesRequest
*/
func (a *PoliciesPermissionGrantPolicyApiService) PoliciesPermissionGrantPoliciesGetIncludes(ctx _context.Context, permissionGrantPolicyId string, permissionGrantConditionSetId string) ApiPoliciesPermissionGrantPoliciesGetIncludesRequest {
	return ApiPoliciesPermissionGrantPoliciesGetIncludesRequest{
		ApiService: a,
		ctx: ctx,
		permissionGrantPolicyId: permissionGrantPolicyId,
		permissionGrantConditionSetId: permissionGrantConditionSetId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPermissionGrantConditionSet
func (a *PoliciesPermissionGrantPolicyApiService) PoliciesPermissionGrantPoliciesGetIncludesExecute(r ApiPoliciesPermissionGrantPoliciesGetIncludesRequest) (MicrosoftGraphPermissionGrantConditionSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPermissionGrantConditionSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesPermissionGrantPolicyApiService.PoliciesPermissionGrantPoliciesGetIncludes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/permissionGrantPolicies/{permissionGrantPolicy-id}/includes/{permissionGrantConditionSet-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"permissionGrantPolicy-id"+"}", _neturl.PathEscape(parameterToString(r.permissionGrantPolicyId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"permissionGrantConditionSet-id"+"}", _neturl.PathEscape(parameterToString(r.permissionGrantConditionSetId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesPermissionGrantPoliciesListExcludesRequest struct {
	ctx _context.Context
	ApiService *PoliciesPermissionGrantPolicyApiService
	permissionGrantPolicyId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiPoliciesPermissionGrantPoliciesListExcludesRequest) Top(top int32) ApiPoliciesPermissionGrantPoliciesListExcludesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiPoliciesPermissionGrantPoliciesListExcludesRequest) Skip(skip int32) ApiPoliciesPermissionGrantPoliciesListExcludesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiPoliciesPermissionGrantPoliciesListExcludesRequest) Search(search string) ApiPoliciesPermissionGrantPoliciesListExcludesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiPoliciesPermissionGrantPoliciesListExcludesRequest) Filter(filter string) ApiPoliciesPermissionGrantPoliciesListExcludesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiPoliciesPermissionGrantPoliciesListExcludesRequest) Count(count bool) ApiPoliciesPermissionGrantPoliciesListExcludesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiPoliciesPermissionGrantPoliciesListExcludesRequest) Orderby(orderby []string) ApiPoliciesPermissionGrantPoliciesListExcludesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiPoliciesPermissionGrantPoliciesListExcludesRequest) Select_(select_ []string) ApiPoliciesPermissionGrantPoliciesListExcludesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiPoliciesPermissionGrantPoliciesListExcludesRequest) Expand(expand []string) ApiPoliciesPermissionGrantPoliciesListExcludesRequest {
	r.expand = &expand
	return r
}

func (r ApiPoliciesPermissionGrantPoliciesListExcludesRequest) Execute() (CollectionOfPermissionGrantConditionSet, *_nethttp.Response, error) {
	return r.ApiService.PoliciesPermissionGrantPoliciesListExcludesExecute(r)
}

/*
PoliciesPermissionGrantPoliciesListExcludes Get excludes from policies

Condition sets which are excluded in this permission grant policy. Automatically expanded on GET.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param permissionGrantPolicyId key: id of permissionGrantPolicy
 @return ApiPoliciesPermissionGrantPoliciesListExcludesRequest
*/
func (a *PoliciesPermissionGrantPolicyApiService) PoliciesPermissionGrantPoliciesListExcludes(ctx _context.Context, permissionGrantPolicyId string) ApiPoliciesPermissionGrantPoliciesListExcludesRequest {
	return ApiPoliciesPermissionGrantPoliciesListExcludesRequest{
		ApiService: a,
		ctx: ctx,
		permissionGrantPolicyId: permissionGrantPolicyId,
	}
}

// Execute executes the request
//  @return CollectionOfPermissionGrantConditionSet
func (a *PoliciesPermissionGrantPolicyApiService) PoliciesPermissionGrantPoliciesListExcludesExecute(r ApiPoliciesPermissionGrantPoliciesListExcludesRequest) (CollectionOfPermissionGrantConditionSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfPermissionGrantConditionSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesPermissionGrantPolicyApiService.PoliciesPermissionGrantPoliciesListExcludes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/permissionGrantPolicies/{permissionGrantPolicy-id}/excludes"
	localVarPath = strings.Replace(localVarPath, "{"+"permissionGrantPolicy-id"+"}", _neturl.PathEscape(parameterToString(r.permissionGrantPolicyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesPermissionGrantPoliciesListIncludesRequest struct {
	ctx _context.Context
	ApiService *PoliciesPermissionGrantPolicyApiService
	permissionGrantPolicyId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiPoliciesPermissionGrantPoliciesListIncludesRequest) Top(top int32) ApiPoliciesPermissionGrantPoliciesListIncludesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiPoliciesPermissionGrantPoliciesListIncludesRequest) Skip(skip int32) ApiPoliciesPermissionGrantPoliciesListIncludesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiPoliciesPermissionGrantPoliciesListIncludesRequest) Search(search string) ApiPoliciesPermissionGrantPoliciesListIncludesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiPoliciesPermissionGrantPoliciesListIncludesRequest) Filter(filter string) ApiPoliciesPermissionGrantPoliciesListIncludesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiPoliciesPermissionGrantPoliciesListIncludesRequest) Count(count bool) ApiPoliciesPermissionGrantPoliciesListIncludesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiPoliciesPermissionGrantPoliciesListIncludesRequest) Orderby(orderby []string) ApiPoliciesPermissionGrantPoliciesListIncludesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiPoliciesPermissionGrantPoliciesListIncludesRequest) Select_(select_ []string) ApiPoliciesPermissionGrantPoliciesListIncludesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiPoliciesPermissionGrantPoliciesListIncludesRequest) Expand(expand []string) ApiPoliciesPermissionGrantPoliciesListIncludesRequest {
	r.expand = &expand
	return r
}

func (r ApiPoliciesPermissionGrantPoliciesListIncludesRequest) Execute() (CollectionOfPermissionGrantConditionSet, *_nethttp.Response, error) {
	return r.ApiService.PoliciesPermissionGrantPoliciesListIncludesExecute(r)
}

/*
PoliciesPermissionGrantPoliciesListIncludes Get includes from policies

Condition sets which are included in this permission grant policy. Automatically expanded on GET.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param permissionGrantPolicyId key: id of permissionGrantPolicy
 @return ApiPoliciesPermissionGrantPoliciesListIncludesRequest
*/
func (a *PoliciesPermissionGrantPolicyApiService) PoliciesPermissionGrantPoliciesListIncludes(ctx _context.Context, permissionGrantPolicyId string) ApiPoliciesPermissionGrantPoliciesListIncludesRequest {
	return ApiPoliciesPermissionGrantPoliciesListIncludesRequest{
		ApiService: a,
		ctx: ctx,
		permissionGrantPolicyId: permissionGrantPolicyId,
	}
}

// Execute executes the request
//  @return CollectionOfPermissionGrantConditionSet
func (a *PoliciesPermissionGrantPolicyApiService) PoliciesPermissionGrantPoliciesListIncludesExecute(r ApiPoliciesPermissionGrantPoliciesListIncludesRequest) (CollectionOfPermissionGrantConditionSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfPermissionGrantConditionSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesPermissionGrantPolicyApiService.PoliciesPermissionGrantPoliciesListIncludes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/permissionGrantPolicies/{permissionGrantPolicy-id}/includes"
	localVarPath = strings.Replace(localVarPath, "{"+"permissionGrantPolicy-id"+"}", _neturl.PathEscape(parameterToString(r.permissionGrantPolicyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesPermissionGrantPoliciesUpdateExcludesRequest struct {
	ctx _context.Context
	ApiService *PoliciesPermissionGrantPolicyApiService
	permissionGrantPolicyId string
	permissionGrantConditionSetId string
	microsoftGraphPermissionGrantConditionSet *MicrosoftGraphPermissionGrantConditionSet
}

// New navigation property values
func (r ApiPoliciesPermissionGrantPoliciesUpdateExcludesRequest) MicrosoftGraphPermissionGrantConditionSet(microsoftGraphPermissionGrantConditionSet MicrosoftGraphPermissionGrantConditionSet) ApiPoliciesPermissionGrantPoliciesUpdateExcludesRequest {
	r.microsoftGraphPermissionGrantConditionSet = &microsoftGraphPermissionGrantConditionSet
	return r
}

func (r ApiPoliciesPermissionGrantPoliciesUpdateExcludesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PoliciesPermissionGrantPoliciesUpdateExcludesExecute(r)
}

/*
PoliciesPermissionGrantPoliciesUpdateExcludes Update the navigation property excludes in policies

Condition sets which are excluded in this permission grant policy. Automatically expanded on GET.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param permissionGrantPolicyId key: id of permissionGrantPolicy
 @param permissionGrantConditionSetId key: id of permissionGrantConditionSet
 @return ApiPoliciesPermissionGrantPoliciesUpdateExcludesRequest
*/
func (a *PoliciesPermissionGrantPolicyApiService) PoliciesPermissionGrantPoliciesUpdateExcludes(ctx _context.Context, permissionGrantPolicyId string, permissionGrantConditionSetId string) ApiPoliciesPermissionGrantPoliciesUpdateExcludesRequest {
	return ApiPoliciesPermissionGrantPoliciesUpdateExcludesRequest{
		ApiService: a,
		ctx: ctx,
		permissionGrantPolicyId: permissionGrantPolicyId,
		permissionGrantConditionSetId: permissionGrantConditionSetId,
	}
}

// Execute executes the request
func (a *PoliciesPermissionGrantPolicyApiService) PoliciesPermissionGrantPoliciesUpdateExcludesExecute(r ApiPoliciesPermissionGrantPoliciesUpdateExcludesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesPermissionGrantPolicyApiService.PoliciesPermissionGrantPoliciesUpdateExcludes")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/permissionGrantPolicies/{permissionGrantPolicy-id}/excludes/{permissionGrantConditionSet-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"permissionGrantPolicy-id"+"}", _neturl.PathEscape(parameterToString(r.permissionGrantPolicyId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"permissionGrantConditionSet-id"+"}", _neturl.PathEscape(parameterToString(r.permissionGrantConditionSetId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPermissionGrantConditionSet == nil {
		return nil, reportError("microsoftGraphPermissionGrantConditionSet is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPermissionGrantConditionSet
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoliciesPermissionGrantPoliciesUpdateIncludesRequest struct {
	ctx _context.Context
	ApiService *PoliciesPermissionGrantPolicyApiService
	permissionGrantPolicyId string
	permissionGrantConditionSetId string
	microsoftGraphPermissionGrantConditionSet *MicrosoftGraphPermissionGrantConditionSet
}

// New navigation property values
func (r ApiPoliciesPermissionGrantPoliciesUpdateIncludesRequest) MicrosoftGraphPermissionGrantConditionSet(microsoftGraphPermissionGrantConditionSet MicrosoftGraphPermissionGrantConditionSet) ApiPoliciesPermissionGrantPoliciesUpdateIncludesRequest {
	r.microsoftGraphPermissionGrantConditionSet = &microsoftGraphPermissionGrantConditionSet
	return r
}

func (r ApiPoliciesPermissionGrantPoliciesUpdateIncludesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PoliciesPermissionGrantPoliciesUpdateIncludesExecute(r)
}

/*
PoliciesPermissionGrantPoliciesUpdateIncludes Update the navigation property includes in policies

Condition sets which are included in this permission grant policy. Automatically expanded on GET.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param permissionGrantPolicyId key: id of permissionGrantPolicy
 @param permissionGrantConditionSetId key: id of permissionGrantConditionSet
 @return ApiPoliciesPermissionGrantPoliciesUpdateIncludesRequest
*/
func (a *PoliciesPermissionGrantPolicyApiService) PoliciesPermissionGrantPoliciesUpdateIncludes(ctx _context.Context, permissionGrantPolicyId string, permissionGrantConditionSetId string) ApiPoliciesPermissionGrantPoliciesUpdateIncludesRequest {
	return ApiPoliciesPermissionGrantPoliciesUpdateIncludesRequest{
		ApiService: a,
		ctx: ctx,
		permissionGrantPolicyId: permissionGrantPolicyId,
		permissionGrantConditionSetId: permissionGrantConditionSetId,
	}
}

// Execute executes the request
func (a *PoliciesPermissionGrantPolicyApiService) PoliciesPermissionGrantPoliciesUpdateIncludesExecute(r ApiPoliciesPermissionGrantPoliciesUpdateIncludesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesPermissionGrantPolicyApiService.PoliciesPermissionGrantPoliciesUpdateIncludes")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/permissionGrantPolicies/{permissionGrantPolicy-id}/includes/{permissionGrantConditionSet-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"permissionGrantPolicy-id"+"}", _neturl.PathEscape(parameterToString(r.permissionGrantPolicyId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"permissionGrantConditionSet-id"+"}", _neturl.PathEscape(parameterToString(r.permissionGrantConditionSetId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPermissionGrantConditionSet == nil {
		return nil, reportError("microsoftGraphPermissionGrantConditionSet is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPermissionGrantConditionSet
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoliciesUpdatePermissionGrantPoliciesRequest struct {
	ctx _context.Context
	ApiService *PoliciesPermissionGrantPolicyApiService
	permissionGrantPolicyId string
	microsoftGraphPermissionGrantPolicy *MicrosoftGraphPermissionGrantPolicy
}

// New navigation property values
func (r ApiPoliciesUpdatePermissionGrantPoliciesRequest) MicrosoftGraphPermissionGrantPolicy(microsoftGraphPermissionGrantPolicy MicrosoftGraphPermissionGrantPolicy) ApiPoliciesUpdatePermissionGrantPoliciesRequest {
	r.microsoftGraphPermissionGrantPolicy = &microsoftGraphPermissionGrantPolicy
	return r
}

func (r ApiPoliciesUpdatePermissionGrantPoliciesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PoliciesUpdatePermissionGrantPoliciesExecute(r)
}

/*
PoliciesUpdatePermissionGrantPolicies Update the navigation property permissionGrantPolicies in policies

The policy that specifies the conditions under which consent can be granted.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param permissionGrantPolicyId key: id of permissionGrantPolicy
 @return ApiPoliciesUpdatePermissionGrantPoliciesRequest
*/
func (a *PoliciesPermissionGrantPolicyApiService) PoliciesUpdatePermissionGrantPolicies(ctx _context.Context, permissionGrantPolicyId string) ApiPoliciesUpdatePermissionGrantPoliciesRequest {
	return ApiPoliciesUpdatePermissionGrantPoliciesRequest{
		ApiService: a,
		ctx: ctx,
		permissionGrantPolicyId: permissionGrantPolicyId,
	}
}

// Execute executes the request
func (a *PoliciesPermissionGrantPolicyApiService) PoliciesUpdatePermissionGrantPoliciesExecute(r ApiPoliciesUpdatePermissionGrantPoliciesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesPermissionGrantPolicyApiService.PoliciesUpdatePermissionGrantPolicies")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/permissionGrantPolicies/{permissionGrantPolicy-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"permissionGrantPolicy-id"+"}", _neturl.PathEscape(parameterToString(r.permissionGrantPolicyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPermissionGrantPolicy == nil {
		return nil, reportError("microsoftGraphPermissionGrantPolicy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPermissionGrantPolicy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
