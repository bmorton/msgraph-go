/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// PlannerPlannerBucketApiService PlannerPlannerBucketApi service
type PlannerPlannerBucketApiService service

type ApiPlannerBucketsCreateTasksRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerBucketApiService
	plannerBucketId string
	microsoftGraphPlannerTask *MicrosoftGraphPlannerTask
}

// New navigation property
func (r ApiPlannerBucketsCreateTasksRequest) MicrosoftGraphPlannerTask(microsoftGraphPlannerTask MicrosoftGraphPlannerTask) ApiPlannerBucketsCreateTasksRequest {
	r.microsoftGraphPlannerTask = &microsoftGraphPlannerTask
	return r
}

func (r ApiPlannerBucketsCreateTasksRequest) Execute() (MicrosoftGraphPlannerTask, *_nethttp.Response, error) {
	return r.ApiService.PlannerBucketsCreateTasksExecute(r)
}

/*
PlannerBucketsCreateTasks Create new navigation property to tasks for planner

Read-only. Nullable. The collection of tasks in the bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerBucketId key: id of plannerBucket
 @return ApiPlannerBucketsCreateTasksRequest
*/
func (a *PlannerPlannerBucketApiService) PlannerBucketsCreateTasks(ctx _context.Context, plannerBucketId string) ApiPlannerBucketsCreateTasksRequest {
	return ApiPlannerBucketsCreateTasksRequest{
		ApiService: a,
		ctx: ctx,
		plannerBucketId: plannerBucketId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerTask
func (a *PlannerPlannerBucketApiService) PlannerBucketsCreateTasksExecute(r ApiPlannerBucketsCreateTasksRequest) (MicrosoftGraphPlannerTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerBucketApiService.PlannerBucketsCreateTasks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/buckets/{plannerBucket-id}/tasks"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerTask == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphPlannerTask is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerTask
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlannerBucketsDeleteTasksRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerBucketApiService
	plannerBucketId string
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiPlannerBucketsDeleteTasksRequest) IfMatch(ifMatch string) ApiPlannerBucketsDeleteTasksRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiPlannerBucketsDeleteTasksRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PlannerBucketsDeleteTasksExecute(r)
}

/*
PlannerBucketsDeleteTasks Delete navigation property tasks for planner

Read-only. Nullable. The collection of tasks in the bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiPlannerBucketsDeleteTasksRequest
*/
func (a *PlannerPlannerBucketApiService) PlannerBucketsDeleteTasks(ctx _context.Context, plannerBucketId string, plannerTaskId string) ApiPlannerBucketsDeleteTasksRequest {
	return ApiPlannerBucketsDeleteTasksRequest{
		ApiService: a,
		ctx: ctx,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *PlannerPlannerBucketApiService) PlannerBucketsDeleteTasksExecute(r ApiPlannerBucketsDeleteTasksRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerBucketApiService.PlannerBucketsDeleteTasks")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/buckets/{plannerBucket-id}/tasks/{plannerTask-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPlannerBucketsGetTasksRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerBucketApiService
	plannerBucketId string
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiPlannerBucketsGetTasksRequest) Select_(select_ []string) ApiPlannerBucketsGetTasksRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiPlannerBucketsGetTasksRequest) Expand(expand []string) ApiPlannerBucketsGetTasksRequest {
	r.expand = &expand
	return r
}

func (r ApiPlannerBucketsGetTasksRequest) Execute() (MicrosoftGraphPlannerTask, *_nethttp.Response, error) {
	return r.ApiService.PlannerBucketsGetTasksExecute(r)
}

/*
PlannerBucketsGetTasks Get tasks from planner

Read-only. Nullable. The collection of tasks in the bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiPlannerBucketsGetTasksRequest
*/
func (a *PlannerPlannerBucketApiService) PlannerBucketsGetTasks(ctx _context.Context, plannerBucketId string, plannerTaskId string) ApiPlannerBucketsGetTasksRequest {
	return ApiPlannerBucketsGetTasksRequest{
		ApiService: a,
		ctx: ctx,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerTask
func (a *PlannerPlannerBucketApiService) PlannerBucketsGetTasksExecute(r ApiPlannerBucketsGetTasksRequest) (MicrosoftGraphPlannerTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerBucketApiService.PlannerBucketsGetTasks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/buckets/{plannerBucket-id}/tasks/{plannerTask-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlannerBucketsListTasksRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerBucketApiService
	plannerBucketId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiPlannerBucketsListTasksRequest) Top(top int32) ApiPlannerBucketsListTasksRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiPlannerBucketsListTasksRequest) Skip(skip int32) ApiPlannerBucketsListTasksRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiPlannerBucketsListTasksRequest) Search(search string) ApiPlannerBucketsListTasksRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiPlannerBucketsListTasksRequest) Filter(filter string) ApiPlannerBucketsListTasksRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiPlannerBucketsListTasksRequest) Count(count bool) ApiPlannerBucketsListTasksRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiPlannerBucketsListTasksRequest) Orderby(orderby []string) ApiPlannerBucketsListTasksRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiPlannerBucketsListTasksRequest) Select_(select_ []string) ApiPlannerBucketsListTasksRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiPlannerBucketsListTasksRequest) Expand(expand []string) ApiPlannerBucketsListTasksRequest {
	r.expand = &expand
	return r
}

func (r ApiPlannerBucketsListTasksRequest) Execute() (CollectionOfPlannerTask, *_nethttp.Response, error) {
	return r.ApiService.PlannerBucketsListTasksExecute(r)
}

/*
PlannerBucketsListTasks Get tasks from planner

Read-only. Nullable. The collection of tasks in the bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerBucketId key: id of plannerBucket
 @return ApiPlannerBucketsListTasksRequest
*/
func (a *PlannerPlannerBucketApiService) PlannerBucketsListTasks(ctx _context.Context, plannerBucketId string) ApiPlannerBucketsListTasksRequest {
	return ApiPlannerBucketsListTasksRequest{
		ApiService: a,
		ctx: ctx,
		plannerBucketId: plannerBucketId,
	}
}

// Execute executes the request
//  @return CollectionOfPlannerTask
func (a *PlannerPlannerBucketApiService) PlannerBucketsListTasksExecute(r ApiPlannerBucketsListTasksRequest) (CollectionOfPlannerTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfPlannerTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerBucketApiService.PlannerBucketsListTasks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/buckets/{plannerBucket-id}/tasks"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlannerBucketsTasksDeleteAssignedToTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerBucketApiService
	plannerBucketId string
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiPlannerBucketsTasksDeleteAssignedToTaskBoardFormatRequest) IfMatch(ifMatch string) ApiPlannerBucketsTasksDeleteAssignedToTaskBoardFormatRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiPlannerBucketsTasksDeleteAssignedToTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PlannerBucketsTasksDeleteAssignedToTaskBoardFormatExecute(r)
}

/*
PlannerBucketsTasksDeleteAssignedToTaskBoardFormat Delete navigation property assignedToTaskBoardFormat for planner

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by assignedTo.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiPlannerBucketsTasksDeleteAssignedToTaskBoardFormatRequest
*/
func (a *PlannerPlannerBucketApiService) PlannerBucketsTasksDeleteAssignedToTaskBoardFormat(ctx _context.Context, plannerBucketId string, plannerTaskId string) ApiPlannerBucketsTasksDeleteAssignedToTaskBoardFormatRequest {
	return ApiPlannerBucketsTasksDeleteAssignedToTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *PlannerPlannerBucketApiService) PlannerBucketsTasksDeleteAssignedToTaskBoardFormatExecute(r ApiPlannerBucketsTasksDeleteAssignedToTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerBucketApiService.PlannerBucketsTasksDeleteAssignedToTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPlannerBucketsTasksDeleteBucketTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerBucketApiService
	plannerBucketId string
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiPlannerBucketsTasksDeleteBucketTaskBoardFormatRequest) IfMatch(ifMatch string) ApiPlannerBucketsTasksDeleteBucketTaskBoardFormatRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiPlannerBucketsTasksDeleteBucketTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PlannerBucketsTasksDeleteBucketTaskBoardFormatExecute(r)
}

/*
PlannerBucketsTasksDeleteBucketTaskBoardFormat Delete navigation property bucketTaskBoardFormat for planner

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiPlannerBucketsTasksDeleteBucketTaskBoardFormatRequest
*/
func (a *PlannerPlannerBucketApiService) PlannerBucketsTasksDeleteBucketTaskBoardFormat(ctx _context.Context, plannerBucketId string, plannerTaskId string) ApiPlannerBucketsTasksDeleteBucketTaskBoardFormatRequest {
	return ApiPlannerBucketsTasksDeleteBucketTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *PlannerPlannerBucketApiService) PlannerBucketsTasksDeleteBucketTaskBoardFormatExecute(r ApiPlannerBucketsTasksDeleteBucketTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerBucketApiService.PlannerBucketsTasksDeleteBucketTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPlannerBucketsTasksDeleteDetailsRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerBucketApiService
	plannerBucketId string
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiPlannerBucketsTasksDeleteDetailsRequest) IfMatch(ifMatch string) ApiPlannerBucketsTasksDeleteDetailsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiPlannerBucketsTasksDeleteDetailsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PlannerBucketsTasksDeleteDetailsExecute(r)
}

/*
PlannerBucketsTasksDeleteDetails Delete navigation property details for planner

Read-only. Nullable. Additional details about the task.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiPlannerBucketsTasksDeleteDetailsRequest
*/
func (a *PlannerPlannerBucketApiService) PlannerBucketsTasksDeleteDetails(ctx _context.Context, plannerBucketId string, plannerTaskId string) ApiPlannerBucketsTasksDeleteDetailsRequest {
	return ApiPlannerBucketsTasksDeleteDetailsRequest{
		ApiService: a,
		ctx: ctx,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *PlannerPlannerBucketApiService) PlannerBucketsTasksDeleteDetailsExecute(r ApiPlannerBucketsTasksDeleteDetailsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerBucketApiService.PlannerBucketsTasksDeleteDetails")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPlannerBucketsTasksDeleteProgressTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerBucketApiService
	plannerBucketId string
	plannerTaskId string
	ifMatch *string
}

// ETag
func (r ApiPlannerBucketsTasksDeleteProgressTaskBoardFormatRequest) IfMatch(ifMatch string) ApiPlannerBucketsTasksDeleteProgressTaskBoardFormatRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiPlannerBucketsTasksDeleteProgressTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PlannerBucketsTasksDeleteProgressTaskBoardFormatExecute(r)
}

/*
PlannerBucketsTasksDeleteProgressTaskBoardFormat Delete navigation property progressTaskBoardFormat for planner

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by progress.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiPlannerBucketsTasksDeleteProgressTaskBoardFormatRequest
*/
func (a *PlannerPlannerBucketApiService) PlannerBucketsTasksDeleteProgressTaskBoardFormat(ctx _context.Context, plannerBucketId string, plannerTaskId string) ApiPlannerBucketsTasksDeleteProgressTaskBoardFormatRequest {
	return ApiPlannerBucketsTasksDeleteProgressTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *PlannerPlannerBucketApiService) PlannerBucketsTasksDeleteProgressTaskBoardFormatExecute(r ApiPlannerBucketsTasksDeleteProgressTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerBucketApiService.PlannerBucketsTasksDeleteProgressTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/progressTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPlannerBucketsTasksGetAssignedToTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerBucketApiService
	plannerBucketId string
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiPlannerBucketsTasksGetAssignedToTaskBoardFormatRequest) Select_(select_ []string) ApiPlannerBucketsTasksGetAssignedToTaskBoardFormatRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiPlannerBucketsTasksGetAssignedToTaskBoardFormatRequest) Expand(expand []string) ApiPlannerBucketsTasksGetAssignedToTaskBoardFormatRequest {
	r.expand = &expand
	return r
}

func (r ApiPlannerBucketsTasksGetAssignedToTaskBoardFormatRequest) Execute() (MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat, *_nethttp.Response, error) {
	return r.ApiService.PlannerBucketsTasksGetAssignedToTaskBoardFormatExecute(r)
}

/*
PlannerBucketsTasksGetAssignedToTaskBoardFormat Get assignedToTaskBoardFormat from planner

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by assignedTo.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiPlannerBucketsTasksGetAssignedToTaskBoardFormatRequest
*/
func (a *PlannerPlannerBucketApiService) PlannerBucketsTasksGetAssignedToTaskBoardFormat(ctx _context.Context, plannerBucketId string, plannerTaskId string) ApiPlannerBucketsTasksGetAssignedToTaskBoardFormatRequest {
	return ApiPlannerBucketsTasksGetAssignedToTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat
func (a *PlannerPlannerBucketApiService) PlannerBucketsTasksGetAssignedToTaskBoardFormatExecute(r ApiPlannerBucketsTasksGetAssignedToTaskBoardFormatRequest) (MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerBucketApiService.PlannerBucketsTasksGetAssignedToTaskBoardFormat")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlannerBucketsTasksGetBucketTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerBucketApiService
	plannerBucketId string
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiPlannerBucketsTasksGetBucketTaskBoardFormatRequest) Select_(select_ []string) ApiPlannerBucketsTasksGetBucketTaskBoardFormatRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiPlannerBucketsTasksGetBucketTaskBoardFormatRequest) Expand(expand []string) ApiPlannerBucketsTasksGetBucketTaskBoardFormatRequest {
	r.expand = &expand
	return r
}

func (r ApiPlannerBucketsTasksGetBucketTaskBoardFormatRequest) Execute() (MicrosoftGraphPlannerBucketTaskBoardTaskFormat, *_nethttp.Response, error) {
	return r.ApiService.PlannerBucketsTasksGetBucketTaskBoardFormatExecute(r)
}

/*
PlannerBucketsTasksGetBucketTaskBoardFormat Get bucketTaskBoardFormat from planner

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiPlannerBucketsTasksGetBucketTaskBoardFormatRequest
*/
func (a *PlannerPlannerBucketApiService) PlannerBucketsTasksGetBucketTaskBoardFormat(ctx _context.Context, plannerBucketId string, plannerTaskId string) ApiPlannerBucketsTasksGetBucketTaskBoardFormatRequest {
	return ApiPlannerBucketsTasksGetBucketTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerBucketTaskBoardTaskFormat
func (a *PlannerPlannerBucketApiService) PlannerBucketsTasksGetBucketTaskBoardFormatExecute(r ApiPlannerBucketsTasksGetBucketTaskBoardFormatRequest) (MicrosoftGraphPlannerBucketTaskBoardTaskFormat, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerBucketTaskBoardTaskFormat
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerBucketApiService.PlannerBucketsTasksGetBucketTaskBoardFormat")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlannerBucketsTasksGetDetailsRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerBucketApiService
	plannerBucketId string
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiPlannerBucketsTasksGetDetailsRequest) Select_(select_ []string) ApiPlannerBucketsTasksGetDetailsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiPlannerBucketsTasksGetDetailsRequest) Expand(expand []string) ApiPlannerBucketsTasksGetDetailsRequest {
	r.expand = &expand
	return r
}

func (r ApiPlannerBucketsTasksGetDetailsRequest) Execute() (MicrosoftGraphPlannerTaskDetails, *_nethttp.Response, error) {
	return r.ApiService.PlannerBucketsTasksGetDetailsExecute(r)
}

/*
PlannerBucketsTasksGetDetails Get details from planner

Read-only. Nullable. Additional details about the task.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiPlannerBucketsTasksGetDetailsRequest
*/
func (a *PlannerPlannerBucketApiService) PlannerBucketsTasksGetDetails(ctx _context.Context, plannerBucketId string, plannerTaskId string) ApiPlannerBucketsTasksGetDetailsRequest {
	return ApiPlannerBucketsTasksGetDetailsRequest{
		ApiService: a,
		ctx: ctx,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerTaskDetails
func (a *PlannerPlannerBucketApiService) PlannerBucketsTasksGetDetailsExecute(r ApiPlannerBucketsTasksGetDetailsRequest) (MicrosoftGraphPlannerTaskDetails, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerTaskDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerBucketApiService.PlannerBucketsTasksGetDetails")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlannerBucketsTasksGetProgressTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerBucketApiService
	plannerBucketId string
	plannerTaskId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiPlannerBucketsTasksGetProgressTaskBoardFormatRequest) Select_(select_ []string) ApiPlannerBucketsTasksGetProgressTaskBoardFormatRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiPlannerBucketsTasksGetProgressTaskBoardFormatRequest) Expand(expand []string) ApiPlannerBucketsTasksGetProgressTaskBoardFormatRequest {
	r.expand = &expand
	return r
}

func (r ApiPlannerBucketsTasksGetProgressTaskBoardFormatRequest) Execute() (MicrosoftGraphPlannerProgressTaskBoardTaskFormat, *_nethttp.Response, error) {
	return r.ApiService.PlannerBucketsTasksGetProgressTaskBoardFormatExecute(r)
}

/*
PlannerBucketsTasksGetProgressTaskBoardFormat Get progressTaskBoardFormat from planner

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by progress.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiPlannerBucketsTasksGetProgressTaskBoardFormatRequest
*/
func (a *PlannerPlannerBucketApiService) PlannerBucketsTasksGetProgressTaskBoardFormat(ctx _context.Context, plannerBucketId string, plannerTaskId string) ApiPlannerBucketsTasksGetProgressTaskBoardFormatRequest {
	return ApiPlannerBucketsTasksGetProgressTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerProgressTaskBoardTaskFormat
func (a *PlannerPlannerBucketApiService) PlannerBucketsTasksGetProgressTaskBoardFormatExecute(r ApiPlannerBucketsTasksGetProgressTaskBoardFormatRequest) (MicrosoftGraphPlannerProgressTaskBoardTaskFormat, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerProgressTaskBoardTaskFormat
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerBucketApiService.PlannerBucketsTasksGetProgressTaskBoardFormat")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/progressTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlannerBucketsTasksUpdateAssignedToTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerBucketApiService
	plannerBucketId string
	plannerTaskId string
	microsoftGraphPlannerAssignedToTaskBoardTaskFormat *MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat
}

// New navigation property values
func (r ApiPlannerBucketsTasksUpdateAssignedToTaskBoardFormatRequest) MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat(microsoftGraphPlannerAssignedToTaskBoardTaskFormat MicrosoftGraphPlannerAssignedToTaskBoardTaskFormat) ApiPlannerBucketsTasksUpdateAssignedToTaskBoardFormatRequest {
	r.microsoftGraphPlannerAssignedToTaskBoardTaskFormat = &microsoftGraphPlannerAssignedToTaskBoardTaskFormat
	return r
}

func (r ApiPlannerBucketsTasksUpdateAssignedToTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PlannerBucketsTasksUpdateAssignedToTaskBoardFormatExecute(r)
}

/*
PlannerBucketsTasksUpdateAssignedToTaskBoardFormat Update the navigation property assignedToTaskBoardFormat in planner

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by assignedTo.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiPlannerBucketsTasksUpdateAssignedToTaskBoardFormatRequest
*/
func (a *PlannerPlannerBucketApiService) PlannerBucketsTasksUpdateAssignedToTaskBoardFormat(ctx _context.Context, plannerBucketId string, plannerTaskId string) ApiPlannerBucketsTasksUpdateAssignedToTaskBoardFormatRequest {
	return ApiPlannerBucketsTasksUpdateAssignedToTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *PlannerPlannerBucketApiService) PlannerBucketsTasksUpdateAssignedToTaskBoardFormatExecute(r ApiPlannerBucketsTasksUpdateAssignedToTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerBucketApiService.PlannerBucketsTasksUpdateAssignedToTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerAssignedToTaskBoardTaskFormat == nil {
		return nil, reportError("microsoftGraphPlannerAssignedToTaskBoardTaskFormat is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerAssignedToTaskBoardTaskFormat
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPlannerBucketsTasksUpdateBucketTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerBucketApiService
	plannerBucketId string
	plannerTaskId string
	microsoftGraphPlannerBucketTaskBoardTaskFormat *MicrosoftGraphPlannerBucketTaskBoardTaskFormat
}

// New navigation property values
func (r ApiPlannerBucketsTasksUpdateBucketTaskBoardFormatRequest) MicrosoftGraphPlannerBucketTaskBoardTaskFormat(microsoftGraphPlannerBucketTaskBoardTaskFormat MicrosoftGraphPlannerBucketTaskBoardTaskFormat) ApiPlannerBucketsTasksUpdateBucketTaskBoardFormatRequest {
	r.microsoftGraphPlannerBucketTaskBoardTaskFormat = &microsoftGraphPlannerBucketTaskBoardTaskFormat
	return r
}

func (r ApiPlannerBucketsTasksUpdateBucketTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PlannerBucketsTasksUpdateBucketTaskBoardFormatExecute(r)
}

/*
PlannerBucketsTasksUpdateBucketTaskBoardFormat Update the navigation property bucketTaskBoardFormat in planner

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiPlannerBucketsTasksUpdateBucketTaskBoardFormatRequest
*/
func (a *PlannerPlannerBucketApiService) PlannerBucketsTasksUpdateBucketTaskBoardFormat(ctx _context.Context, plannerBucketId string, plannerTaskId string) ApiPlannerBucketsTasksUpdateBucketTaskBoardFormatRequest {
	return ApiPlannerBucketsTasksUpdateBucketTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *PlannerPlannerBucketApiService) PlannerBucketsTasksUpdateBucketTaskBoardFormatExecute(r ApiPlannerBucketsTasksUpdateBucketTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerBucketApiService.PlannerBucketsTasksUpdateBucketTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerBucketTaskBoardTaskFormat == nil {
		return nil, reportError("microsoftGraphPlannerBucketTaskBoardTaskFormat is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerBucketTaskBoardTaskFormat
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPlannerBucketsTasksUpdateDetailsRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerBucketApiService
	plannerBucketId string
	plannerTaskId string
	microsoftGraphPlannerTaskDetails *MicrosoftGraphPlannerTaskDetails
}

// New navigation property values
func (r ApiPlannerBucketsTasksUpdateDetailsRequest) MicrosoftGraphPlannerTaskDetails(microsoftGraphPlannerTaskDetails MicrosoftGraphPlannerTaskDetails) ApiPlannerBucketsTasksUpdateDetailsRequest {
	r.microsoftGraphPlannerTaskDetails = &microsoftGraphPlannerTaskDetails
	return r
}

func (r ApiPlannerBucketsTasksUpdateDetailsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PlannerBucketsTasksUpdateDetailsExecute(r)
}

/*
PlannerBucketsTasksUpdateDetails Update the navigation property details in planner

Read-only. Nullable. Additional details about the task.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiPlannerBucketsTasksUpdateDetailsRequest
*/
func (a *PlannerPlannerBucketApiService) PlannerBucketsTasksUpdateDetails(ctx _context.Context, plannerBucketId string, plannerTaskId string) ApiPlannerBucketsTasksUpdateDetailsRequest {
	return ApiPlannerBucketsTasksUpdateDetailsRequest{
		ApiService: a,
		ctx: ctx,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *PlannerPlannerBucketApiService) PlannerBucketsTasksUpdateDetailsExecute(r ApiPlannerBucketsTasksUpdateDetailsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerBucketApiService.PlannerBucketsTasksUpdateDetails")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerTaskDetails == nil {
		return nil, reportError("microsoftGraphPlannerTaskDetails is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerTaskDetails
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPlannerBucketsTasksUpdateProgressTaskBoardFormatRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerBucketApiService
	plannerBucketId string
	plannerTaskId string
	microsoftGraphPlannerProgressTaskBoardTaskFormat *MicrosoftGraphPlannerProgressTaskBoardTaskFormat
}

// New navigation property values
func (r ApiPlannerBucketsTasksUpdateProgressTaskBoardFormatRequest) MicrosoftGraphPlannerProgressTaskBoardTaskFormat(microsoftGraphPlannerProgressTaskBoardTaskFormat MicrosoftGraphPlannerProgressTaskBoardTaskFormat) ApiPlannerBucketsTasksUpdateProgressTaskBoardFormatRequest {
	r.microsoftGraphPlannerProgressTaskBoardTaskFormat = &microsoftGraphPlannerProgressTaskBoardTaskFormat
	return r
}

func (r ApiPlannerBucketsTasksUpdateProgressTaskBoardFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PlannerBucketsTasksUpdateProgressTaskBoardFormatExecute(r)
}

/*
PlannerBucketsTasksUpdateProgressTaskBoardFormat Update the navigation property progressTaskBoardFormat in planner

Read-only. Nullable. Used to render the task correctly in the task board view when grouped by progress.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiPlannerBucketsTasksUpdateProgressTaskBoardFormatRequest
*/
func (a *PlannerPlannerBucketApiService) PlannerBucketsTasksUpdateProgressTaskBoardFormat(ctx _context.Context, plannerBucketId string, plannerTaskId string) ApiPlannerBucketsTasksUpdateProgressTaskBoardFormatRequest {
	return ApiPlannerBucketsTasksUpdateProgressTaskBoardFormatRequest{
		ApiService: a,
		ctx: ctx,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *PlannerPlannerBucketApiService) PlannerBucketsTasksUpdateProgressTaskBoardFormatExecute(r ApiPlannerBucketsTasksUpdateProgressTaskBoardFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerBucketApiService.PlannerBucketsTasksUpdateProgressTaskBoardFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/progressTaskBoardFormat"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerProgressTaskBoardTaskFormat == nil {
		return nil, reportError("microsoftGraphPlannerProgressTaskBoardTaskFormat is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerProgressTaskBoardTaskFormat
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPlannerBucketsUpdateTasksRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerBucketApiService
	plannerBucketId string
	plannerTaskId string
	microsoftGraphPlannerTask *MicrosoftGraphPlannerTask
}

// New navigation property values
func (r ApiPlannerBucketsUpdateTasksRequest) MicrosoftGraphPlannerTask(microsoftGraphPlannerTask MicrosoftGraphPlannerTask) ApiPlannerBucketsUpdateTasksRequest {
	r.microsoftGraphPlannerTask = &microsoftGraphPlannerTask
	return r
}

func (r ApiPlannerBucketsUpdateTasksRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PlannerBucketsUpdateTasksExecute(r)
}

/*
PlannerBucketsUpdateTasks Update the navigation property tasks in planner

Read-only. Nullable. The collection of tasks in the bucket.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerBucketId key: id of plannerBucket
 @param plannerTaskId key: id of plannerTask
 @return ApiPlannerBucketsUpdateTasksRequest
*/
func (a *PlannerPlannerBucketApiService) PlannerBucketsUpdateTasks(ctx _context.Context, plannerBucketId string, plannerTaskId string) ApiPlannerBucketsUpdateTasksRequest {
	return ApiPlannerBucketsUpdateTasksRequest{
		ApiService: a,
		ctx: ctx,
		plannerBucketId: plannerBucketId,
		plannerTaskId: plannerTaskId,
	}
}

// Execute executes the request
func (a *PlannerPlannerBucketApiService) PlannerBucketsUpdateTasksExecute(r ApiPlannerBucketsUpdateTasksRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerBucketApiService.PlannerBucketsUpdateTasks")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/buckets/{plannerBucket-id}/tasks/{plannerTask-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plannerTask-id"+"}", _neturl.PathEscape(parameterToString(r.plannerTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerTask == nil {
		return nil, reportError("microsoftGraphPlannerTask is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerTask
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPlannerCreateBucketsRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerBucketApiService
	microsoftGraphPlannerBucket *MicrosoftGraphPlannerBucket
}

// New navigation property
func (r ApiPlannerCreateBucketsRequest) MicrosoftGraphPlannerBucket(microsoftGraphPlannerBucket MicrosoftGraphPlannerBucket) ApiPlannerCreateBucketsRequest {
	r.microsoftGraphPlannerBucket = &microsoftGraphPlannerBucket
	return r
}

func (r ApiPlannerCreateBucketsRequest) Execute() (MicrosoftGraphPlannerBucket, *_nethttp.Response, error) {
	return r.ApiService.PlannerCreateBucketsExecute(r)
}

/*
PlannerCreateBuckets Create new navigation property to buckets for planner

Read-only. Nullable. Returns a collection of the specified buckets

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPlannerCreateBucketsRequest
*/
func (a *PlannerPlannerBucketApiService) PlannerCreateBuckets(ctx _context.Context) ApiPlannerCreateBucketsRequest {
	return ApiPlannerCreateBucketsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerBucket
func (a *PlannerPlannerBucketApiService) PlannerCreateBucketsExecute(r ApiPlannerCreateBucketsRequest) (MicrosoftGraphPlannerBucket, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerBucket
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerBucketApiService.PlannerCreateBuckets")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/buckets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerBucket == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphPlannerBucket is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerBucket
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlannerDeleteBucketsRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerBucketApiService
	plannerBucketId string
	ifMatch *string
}

// ETag
func (r ApiPlannerDeleteBucketsRequest) IfMatch(ifMatch string) ApiPlannerDeleteBucketsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiPlannerDeleteBucketsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PlannerDeleteBucketsExecute(r)
}

/*
PlannerDeleteBuckets Delete navigation property buckets for planner

Read-only. Nullable. Returns a collection of the specified buckets

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerBucketId key: id of plannerBucket
 @return ApiPlannerDeleteBucketsRequest
*/
func (a *PlannerPlannerBucketApiService) PlannerDeleteBuckets(ctx _context.Context, plannerBucketId string) ApiPlannerDeleteBucketsRequest {
	return ApiPlannerDeleteBucketsRequest{
		ApiService: a,
		ctx: ctx,
		plannerBucketId: plannerBucketId,
	}
}

// Execute executes the request
func (a *PlannerPlannerBucketApiService) PlannerDeleteBucketsExecute(r ApiPlannerDeleteBucketsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerBucketApiService.PlannerDeleteBuckets")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/buckets/{plannerBucket-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPlannerGetBucketsRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerBucketApiService
	plannerBucketId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiPlannerGetBucketsRequest) Select_(select_ []string) ApiPlannerGetBucketsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiPlannerGetBucketsRequest) Expand(expand []string) ApiPlannerGetBucketsRequest {
	r.expand = &expand
	return r
}

func (r ApiPlannerGetBucketsRequest) Execute() (MicrosoftGraphPlannerBucket, *_nethttp.Response, error) {
	return r.ApiService.PlannerGetBucketsExecute(r)
}

/*
PlannerGetBuckets Get buckets from planner

Read-only. Nullable. Returns a collection of the specified buckets

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerBucketId key: id of plannerBucket
 @return ApiPlannerGetBucketsRequest
*/
func (a *PlannerPlannerBucketApiService) PlannerGetBuckets(ctx _context.Context, plannerBucketId string) ApiPlannerGetBucketsRequest {
	return ApiPlannerGetBucketsRequest{
		ApiService: a,
		ctx: ctx,
		plannerBucketId: plannerBucketId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPlannerBucket
func (a *PlannerPlannerBucketApiService) PlannerGetBucketsExecute(r ApiPlannerGetBucketsRequest) (MicrosoftGraphPlannerBucket, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPlannerBucket
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerBucketApiService.PlannerGetBuckets")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/buckets/{plannerBucket-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlannerListBucketsRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerBucketApiService
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiPlannerListBucketsRequest) Top(top int32) ApiPlannerListBucketsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiPlannerListBucketsRequest) Skip(skip int32) ApiPlannerListBucketsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiPlannerListBucketsRequest) Search(search string) ApiPlannerListBucketsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiPlannerListBucketsRequest) Filter(filter string) ApiPlannerListBucketsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiPlannerListBucketsRequest) Count(count bool) ApiPlannerListBucketsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiPlannerListBucketsRequest) Orderby(orderby []string) ApiPlannerListBucketsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiPlannerListBucketsRequest) Select_(select_ []string) ApiPlannerListBucketsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiPlannerListBucketsRequest) Expand(expand []string) ApiPlannerListBucketsRequest {
	r.expand = &expand
	return r
}

func (r ApiPlannerListBucketsRequest) Execute() (CollectionOfPlannerBucket, *_nethttp.Response, error) {
	return r.ApiService.PlannerListBucketsExecute(r)
}

/*
PlannerListBuckets Get buckets from planner

Read-only. Nullable. Returns a collection of the specified buckets

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPlannerListBucketsRequest
*/
func (a *PlannerPlannerBucketApiService) PlannerListBuckets(ctx _context.Context) ApiPlannerListBucketsRequest {
	return ApiPlannerListBucketsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionOfPlannerBucket
func (a *PlannerPlannerBucketApiService) PlannerListBucketsExecute(r ApiPlannerListBucketsRequest) (CollectionOfPlannerBucket, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfPlannerBucket
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerBucketApiService.PlannerListBuckets")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/buckets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlannerUpdateBucketsRequest struct {
	ctx _context.Context
	ApiService *PlannerPlannerBucketApiService
	plannerBucketId string
	microsoftGraphPlannerBucket *MicrosoftGraphPlannerBucket
}

// New navigation property values
func (r ApiPlannerUpdateBucketsRequest) MicrosoftGraphPlannerBucket(microsoftGraphPlannerBucket MicrosoftGraphPlannerBucket) ApiPlannerUpdateBucketsRequest {
	r.microsoftGraphPlannerBucket = &microsoftGraphPlannerBucket
	return r
}

func (r ApiPlannerUpdateBucketsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PlannerUpdateBucketsExecute(r)
}

/*
PlannerUpdateBuckets Update the navigation property buckets in planner

Read-only. Nullable. Returns a collection of the specified buckets

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plannerBucketId key: id of plannerBucket
 @return ApiPlannerUpdateBucketsRequest
*/
func (a *PlannerPlannerBucketApiService) PlannerUpdateBuckets(ctx _context.Context, plannerBucketId string) ApiPlannerUpdateBucketsRequest {
	return ApiPlannerUpdateBucketsRequest{
		ApiService: a,
		ctx: ctx,
		plannerBucketId: plannerBucketId,
	}
}

// Execute executes the request
func (a *PlannerPlannerBucketApiService) PlannerUpdateBucketsExecute(r ApiPlannerUpdateBucketsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlannerPlannerBucketApiService.PlannerUpdateBuckets")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/planner/buckets/{plannerBucket-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"plannerBucket-id"+"}", _neturl.PathEscape(parameterToString(r.plannerBucketId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPlannerBucket == nil {
		return nil, reportError("microsoftGraphPlannerBucket is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPlannerBucket
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
