/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// MeOfficeGraphInsightsApiService MeOfficeGraphInsightsApi service
type MeOfficeGraphInsightsApiService service

type ApiMeDeleteInsightsRequest struct {
	ctx _context.Context
	ApiService *MeOfficeGraphInsightsApiService
	ifMatch *string
}

// ETag
func (r ApiMeDeleteInsightsRequest) IfMatch(ifMatch string) ApiMeDeleteInsightsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMeDeleteInsightsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeDeleteInsightsExecute(r)
}

/*
MeDeleteInsights Delete navigation property insights for me

Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMeDeleteInsightsRequest
*/
func (a *MeOfficeGraphInsightsApiService) MeDeleteInsights(ctx _context.Context) ApiMeDeleteInsightsRequest {
	return ApiMeDeleteInsightsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MeOfficeGraphInsightsApiService) MeDeleteInsightsExecute(r ApiMeDeleteInsightsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeOfficeGraphInsightsApiService.MeDeleteInsights")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeGetInsightsRequest struct {
	ctx _context.Context
	ApiService *MeOfficeGraphInsightsApiService
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiMeGetInsightsRequest) Select_(select_ []string) ApiMeGetInsightsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeGetInsightsRequest) Expand(expand []string) ApiMeGetInsightsRequest {
	r.expand = &expand
	return r
}

func (r ApiMeGetInsightsRequest) Execute() (MicrosoftGraphOfficeGraphInsights, *_nethttp.Response, error) {
	return r.ApiService.MeGetInsightsExecute(r)
}

/*
MeGetInsights Get insights from me

Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMeGetInsightsRequest
*/
func (a *MeOfficeGraphInsightsApiService) MeGetInsights(ctx _context.Context) ApiMeGetInsightsRequest {
	return ApiMeGetInsightsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphOfficeGraphInsights
func (a *MeOfficeGraphInsightsApiService) MeGetInsightsExecute(r ApiMeGetInsightsRequest) (MicrosoftGraphOfficeGraphInsights, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphOfficeGraphInsights
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeOfficeGraphInsightsApiService.MeGetInsights")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeInsightsCreateSharedRequest struct {
	ctx _context.Context
	ApiService *MeOfficeGraphInsightsApiService
	microsoftGraphSharedInsight *MicrosoftGraphSharedInsight
}

// New navigation property
func (r ApiMeInsightsCreateSharedRequest) MicrosoftGraphSharedInsight(microsoftGraphSharedInsight MicrosoftGraphSharedInsight) ApiMeInsightsCreateSharedRequest {
	r.microsoftGraphSharedInsight = &microsoftGraphSharedInsight
	return r
}

func (r ApiMeInsightsCreateSharedRequest) Execute() (MicrosoftGraphSharedInsight, *_nethttp.Response, error) {
	return r.ApiService.MeInsightsCreateSharedExecute(r)
}

/*
MeInsightsCreateShared Create new navigation property to shared for me

Calculated relationship identifying documents shared with or by the user. This includes URLs, file attachments, and reference attachments to OneDrive for Business and SharePoint files found in Outlook messages and meetings. This also includes URLs and reference attachments to Teams conversations. Ordered by recency of share.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMeInsightsCreateSharedRequest
*/
func (a *MeOfficeGraphInsightsApiService) MeInsightsCreateShared(ctx _context.Context) ApiMeInsightsCreateSharedRequest {
	return ApiMeInsightsCreateSharedRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphSharedInsight
func (a *MeOfficeGraphInsightsApiService) MeInsightsCreateSharedExecute(r ApiMeInsightsCreateSharedRequest) (MicrosoftGraphSharedInsight, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphSharedInsight
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeOfficeGraphInsightsApiService.MeInsightsCreateShared")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphSharedInsight == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphSharedInsight is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphSharedInsight
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeInsightsCreateTrendingRequest struct {
	ctx _context.Context
	ApiService *MeOfficeGraphInsightsApiService
	microsoftGraphTrending *MicrosoftGraphTrending
}

// New navigation property
func (r ApiMeInsightsCreateTrendingRequest) MicrosoftGraphTrending(microsoftGraphTrending MicrosoftGraphTrending) ApiMeInsightsCreateTrendingRequest {
	r.microsoftGraphTrending = &microsoftGraphTrending
	return r
}

func (r ApiMeInsightsCreateTrendingRequest) Execute() (MicrosoftGraphTrending, *_nethttp.Response, error) {
	return r.ApiService.MeInsightsCreateTrendingExecute(r)
}

/*
MeInsightsCreateTrending Create new navigation property to trending for me

Calculated relationship identifying documents trending around a user. Trending documents are calculated based on activity of the user's closest network of people and include files stored in OneDrive for Business and SharePoint. Trending insights help the user to discover potentially useful content that the user has access to, but has never viewed before.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMeInsightsCreateTrendingRequest
*/
func (a *MeOfficeGraphInsightsApiService) MeInsightsCreateTrending(ctx _context.Context) ApiMeInsightsCreateTrendingRequest {
	return ApiMeInsightsCreateTrendingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTrending
func (a *MeOfficeGraphInsightsApiService) MeInsightsCreateTrendingExecute(r ApiMeInsightsCreateTrendingRequest) (MicrosoftGraphTrending, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTrending
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeOfficeGraphInsightsApiService.MeInsightsCreateTrending")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/trending"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTrending == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphTrending is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTrending
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeInsightsCreateUsedRequest struct {
	ctx _context.Context
	ApiService *MeOfficeGraphInsightsApiService
	microsoftGraphUsedInsight *MicrosoftGraphUsedInsight
}

// New navigation property
func (r ApiMeInsightsCreateUsedRequest) MicrosoftGraphUsedInsight(microsoftGraphUsedInsight MicrosoftGraphUsedInsight) ApiMeInsightsCreateUsedRequest {
	r.microsoftGraphUsedInsight = &microsoftGraphUsedInsight
	return r
}

func (r ApiMeInsightsCreateUsedRequest) Execute() (MicrosoftGraphUsedInsight, *_nethttp.Response, error) {
	return r.ApiService.MeInsightsCreateUsedExecute(r)
}

/*
MeInsightsCreateUsed Create new navigation property to used for me

Calculated relationship identifying the latest documents viewed or modified by a user, including OneDrive for Business and SharePoint documents, ranked by recency of use.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMeInsightsCreateUsedRequest
*/
func (a *MeOfficeGraphInsightsApiService) MeInsightsCreateUsed(ctx _context.Context) ApiMeInsightsCreateUsedRequest {
	return ApiMeInsightsCreateUsedRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphUsedInsight
func (a *MeOfficeGraphInsightsApiService) MeInsightsCreateUsedExecute(r ApiMeInsightsCreateUsedRequest) (MicrosoftGraphUsedInsight, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphUsedInsight
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeOfficeGraphInsightsApiService.MeInsightsCreateUsed")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/used"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphUsedInsight == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphUsedInsight is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphUsedInsight
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeInsightsDeleteSharedRequest struct {
	ctx _context.Context
	ApiService *MeOfficeGraphInsightsApiService
	sharedInsightId string
	ifMatch *string
}

// ETag
func (r ApiMeInsightsDeleteSharedRequest) IfMatch(ifMatch string) ApiMeInsightsDeleteSharedRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMeInsightsDeleteSharedRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsDeleteSharedExecute(r)
}

/*
MeInsightsDeleteShared Delete navigation property shared for me

Calculated relationship identifying documents shared with or by the user. This includes URLs, file attachments, and reference attachments to OneDrive for Business and SharePoint files found in Outlook messages and meetings. This also includes URLs and reference attachments to Teams conversations. Ordered by recency of share.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsDeleteSharedRequest
*/
func (a *MeOfficeGraphInsightsApiService) MeInsightsDeleteShared(ctx _context.Context, sharedInsightId string) ApiMeInsightsDeleteSharedRequest {
	return ApiMeInsightsDeleteSharedRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *MeOfficeGraphInsightsApiService) MeInsightsDeleteSharedExecute(r ApiMeInsightsDeleteSharedRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeOfficeGraphInsightsApiService.MeInsightsDeleteShared")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsDeleteTrendingRequest struct {
	ctx _context.Context
	ApiService *MeOfficeGraphInsightsApiService
	trendingId string
	ifMatch *string
}

// ETag
func (r ApiMeInsightsDeleteTrendingRequest) IfMatch(ifMatch string) ApiMeInsightsDeleteTrendingRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMeInsightsDeleteTrendingRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsDeleteTrendingExecute(r)
}

/*
MeInsightsDeleteTrending Delete navigation property trending for me

Calculated relationship identifying documents trending around a user. Trending documents are calculated based on activity of the user's closest network of people and include files stored in OneDrive for Business and SharePoint. Trending insights help the user to discover potentially useful content that the user has access to, but has never viewed before.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param trendingId key: id of trending
 @return ApiMeInsightsDeleteTrendingRequest
*/
func (a *MeOfficeGraphInsightsApiService) MeInsightsDeleteTrending(ctx _context.Context, trendingId string) ApiMeInsightsDeleteTrendingRequest {
	return ApiMeInsightsDeleteTrendingRequest{
		ApiService: a,
		ctx: ctx,
		trendingId: trendingId,
	}
}

// Execute executes the request
func (a *MeOfficeGraphInsightsApiService) MeInsightsDeleteTrendingExecute(r ApiMeInsightsDeleteTrendingRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeOfficeGraphInsightsApiService.MeInsightsDeleteTrending")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/trending/{trending-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsDeleteUsedRequest struct {
	ctx _context.Context
	ApiService *MeOfficeGraphInsightsApiService
	usedInsightId string
	ifMatch *string
}

// ETag
func (r ApiMeInsightsDeleteUsedRequest) IfMatch(ifMatch string) ApiMeInsightsDeleteUsedRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMeInsightsDeleteUsedRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsDeleteUsedExecute(r)
}

/*
MeInsightsDeleteUsed Delete navigation property used for me

Calculated relationship identifying the latest documents viewed or modified by a user, including OneDrive for Business and SharePoint documents, ranked by recency of use.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param usedInsightId key: id of usedInsight
 @return ApiMeInsightsDeleteUsedRequest
*/
func (a *MeOfficeGraphInsightsApiService) MeInsightsDeleteUsed(ctx _context.Context, usedInsightId string) ApiMeInsightsDeleteUsedRequest {
	return ApiMeInsightsDeleteUsedRequest{
		ApiService: a,
		ctx: ctx,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
func (a *MeOfficeGraphInsightsApiService) MeInsightsDeleteUsedExecute(r ApiMeInsightsDeleteUsedRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeOfficeGraphInsightsApiService.MeInsightsDeleteUsed")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/used/{usedInsight-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsGetSharedRequest struct {
	ctx _context.Context
	ApiService *MeOfficeGraphInsightsApiService
	sharedInsightId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiMeInsightsGetSharedRequest) Select_(select_ []string) ApiMeInsightsGetSharedRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeInsightsGetSharedRequest) Expand(expand []string) ApiMeInsightsGetSharedRequest {
	r.expand = &expand
	return r
}

func (r ApiMeInsightsGetSharedRequest) Execute() (MicrosoftGraphSharedInsight, *_nethttp.Response, error) {
	return r.ApiService.MeInsightsGetSharedExecute(r)
}

/*
MeInsightsGetShared Get shared from me

Calculated relationship identifying documents shared with or by the user. This includes URLs, file attachments, and reference attachments to OneDrive for Business and SharePoint files found in Outlook messages and meetings. This also includes URLs and reference attachments to Teams conversations. Ordered by recency of share.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsGetSharedRequest
*/
func (a *MeOfficeGraphInsightsApiService) MeInsightsGetShared(ctx _context.Context, sharedInsightId string) ApiMeInsightsGetSharedRequest {
	return ApiMeInsightsGetSharedRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphSharedInsight
func (a *MeOfficeGraphInsightsApiService) MeInsightsGetSharedExecute(r ApiMeInsightsGetSharedRequest) (MicrosoftGraphSharedInsight, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphSharedInsight
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeOfficeGraphInsightsApiService.MeInsightsGetShared")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeInsightsGetTrendingRequest struct {
	ctx _context.Context
	ApiService *MeOfficeGraphInsightsApiService
	trendingId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiMeInsightsGetTrendingRequest) Select_(select_ []string) ApiMeInsightsGetTrendingRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeInsightsGetTrendingRequest) Expand(expand []string) ApiMeInsightsGetTrendingRequest {
	r.expand = &expand
	return r
}

func (r ApiMeInsightsGetTrendingRequest) Execute() (MicrosoftGraphTrending, *_nethttp.Response, error) {
	return r.ApiService.MeInsightsGetTrendingExecute(r)
}

/*
MeInsightsGetTrending Get trending from me

Calculated relationship identifying documents trending around a user. Trending documents are calculated based on activity of the user's closest network of people and include files stored in OneDrive for Business and SharePoint. Trending insights help the user to discover potentially useful content that the user has access to, but has never viewed before.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param trendingId key: id of trending
 @return ApiMeInsightsGetTrendingRequest
*/
func (a *MeOfficeGraphInsightsApiService) MeInsightsGetTrending(ctx _context.Context, trendingId string) ApiMeInsightsGetTrendingRequest {
	return ApiMeInsightsGetTrendingRequest{
		ApiService: a,
		ctx: ctx,
		trendingId: trendingId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphTrending
func (a *MeOfficeGraphInsightsApiService) MeInsightsGetTrendingExecute(r ApiMeInsightsGetTrendingRequest) (MicrosoftGraphTrending, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphTrending
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeOfficeGraphInsightsApiService.MeInsightsGetTrending")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/trending/{trending-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeInsightsGetUsedRequest struct {
	ctx _context.Context
	ApiService *MeOfficeGraphInsightsApiService
	usedInsightId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiMeInsightsGetUsedRequest) Select_(select_ []string) ApiMeInsightsGetUsedRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeInsightsGetUsedRequest) Expand(expand []string) ApiMeInsightsGetUsedRequest {
	r.expand = &expand
	return r
}

func (r ApiMeInsightsGetUsedRequest) Execute() (MicrosoftGraphUsedInsight, *_nethttp.Response, error) {
	return r.ApiService.MeInsightsGetUsedExecute(r)
}

/*
MeInsightsGetUsed Get used from me

Calculated relationship identifying the latest documents viewed or modified by a user, including OneDrive for Business and SharePoint documents, ranked by recency of use.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param usedInsightId key: id of usedInsight
 @return ApiMeInsightsGetUsedRequest
*/
func (a *MeOfficeGraphInsightsApiService) MeInsightsGetUsed(ctx _context.Context, usedInsightId string) ApiMeInsightsGetUsedRequest {
	return ApiMeInsightsGetUsedRequest{
		ApiService: a,
		ctx: ctx,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphUsedInsight
func (a *MeOfficeGraphInsightsApiService) MeInsightsGetUsedExecute(r ApiMeInsightsGetUsedRequest) (MicrosoftGraphUsedInsight, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphUsedInsight
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeOfficeGraphInsightsApiService.MeInsightsGetUsed")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/used/{usedInsight-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeInsightsListSharedRequest struct {
	ctx _context.Context
	ApiService *MeOfficeGraphInsightsApiService
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiMeInsightsListSharedRequest) Top(top int32) ApiMeInsightsListSharedRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiMeInsightsListSharedRequest) Skip(skip int32) ApiMeInsightsListSharedRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiMeInsightsListSharedRequest) Search(search string) ApiMeInsightsListSharedRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiMeInsightsListSharedRequest) Filter(filter string) ApiMeInsightsListSharedRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiMeInsightsListSharedRequest) Count(count bool) ApiMeInsightsListSharedRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiMeInsightsListSharedRequest) Orderby(orderby []string) ApiMeInsightsListSharedRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiMeInsightsListSharedRequest) Select_(select_ []string) ApiMeInsightsListSharedRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeInsightsListSharedRequest) Expand(expand []string) ApiMeInsightsListSharedRequest {
	r.expand = &expand
	return r
}

func (r ApiMeInsightsListSharedRequest) Execute() (CollectionOfSharedInsight, *_nethttp.Response, error) {
	return r.ApiService.MeInsightsListSharedExecute(r)
}

/*
MeInsightsListShared Get shared from me

Calculated relationship identifying documents shared with or by the user. This includes URLs, file attachments, and reference attachments to OneDrive for Business and SharePoint files found in Outlook messages and meetings. This also includes URLs and reference attachments to Teams conversations. Ordered by recency of share.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMeInsightsListSharedRequest
*/
func (a *MeOfficeGraphInsightsApiService) MeInsightsListShared(ctx _context.Context) ApiMeInsightsListSharedRequest {
	return ApiMeInsightsListSharedRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionOfSharedInsight
func (a *MeOfficeGraphInsightsApiService) MeInsightsListSharedExecute(r ApiMeInsightsListSharedRequest) (CollectionOfSharedInsight, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfSharedInsight
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeOfficeGraphInsightsApiService.MeInsightsListShared")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeInsightsListTrendingRequest struct {
	ctx _context.Context
	ApiService *MeOfficeGraphInsightsApiService
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiMeInsightsListTrendingRequest) Top(top int32) ApiMeInsightsListTrendingRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiMeInsightsListTrendingRequest) Skip(skip int32) ApiMeInsightsListTrendingRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiMeInsightsListTrendingRequest) Search(search string) ApiMeInsightsListTrendingRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiMeInsightsListTrendingRequest) Filter(filter string) ApiMeInsightsListTrendingRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiMeInsightsListTrendingRequest) Count(count bool) ApiMeInsightsListTrendingRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiMeInsightsListTrendingRequest) Orderby(orderby []string) ApiMeInsightsListTrendingRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiMeInsightsListTrendingRequest) Select_(select_ []string) ApiMeInsightsListTrendingRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeInsightsListTrendingRequest) Expand(expand []string) ApiMeInsightsListTrendingRequest {
	r.expand = &expand
	return r
}

func (r ApiMeInsightsListTrendingRequest) Execute() (CollectionOfTrending, *_nethttp.Response, error) {
	return r.ApiService.MeInsightsListTrendingExecute(r)
}

/*
MeInsightsListTrending Get trending from me

Calculated relationship identifying documents trending around a user. Trending documents are calculated based on activity of the user's closest network of people and include files stored in OneDrive for Business and SharePoint. Trending insights help the user to discover potentially useful content that the user has access to, but has never viewed before.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMeInsightsListTrendingRequest
*/
func (a *MeOfficeGraphInsightsApiService) MeInsightsListTrending(ctx _context.Context) ApiMeInsightsListTrendingRequest {
	return ApiMeInsightsListTrendingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionOfTrending
func (a *MeOfficeGraphInsightsApiService) MeInsightsListTrendingExecute(r ApiMeInsightsListTrendingRequest) (CollectionOfTrending, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfTrending
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeOfficeGraphInsightsApiService.MeInsightsListTrending")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/trending"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeInsightsListUsedRequest struct {
	ctx _context.Context
	ApiService *MeOfficeGraphInsightsApiService
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiMeInsightsListUsedRequest) Top(top int32) ApiMeInsightsListUsedRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiMeInsightsListUsedRequest) Skip(skip int32) ApiMeInsightsListUsedRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiMeInsightsListUsedRequest) Search(search string) ApiMeInsightsListUsedRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiMeInsightsListUsedRequest) Filter(filter string) ApiMeInsightsListUsedRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiMeInsightsListUsedRequest) Count(count bool) ApiMeInsightsListUsedRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiMeInsightsListUsedRequest) Orderby(orderby []string) ApiMeInsightsListUsedRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiMeInsightsListUsedRequest) Select_(select_ []string) ApiMeInsightsListUsedRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeInsightsListUsedRequest) Expand(expand []string) ApiMeInsightsListUsedRequest {
	r.expand = &expand
	return r
}

func (r ApiMeInsightsListUsedRequest) Execute() (CollectionOfUsedInsight, *_nethttp.Response, error) {
	return r.ApiService.MeInsightsListUsedExecute(r)
}

/*
MeInsightsListUsed Get used from me

Calculated relationship identifying the latest documents viewed or modified by a user, including OneDrive for Business and SharePoint documents, ranked by recency of use.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMeInsightsListUsedRequest
*/
func (a *MeOfficeGraphInsightsApiService) MeInsightsListUsed(ctx _context.Context) ApiMeInsightsListUsedRequest {
	return ApiMeInsightsListUsedRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionOfUsedInsight
func (a *MeOfficeGraphInsightsApiService) MeInsightsListUsedExecute(r ApiMeInsightsListUsedRequest) (CollectionOfUsedInsight, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfUsedInsight
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeOfficeGraphInsightsApiService.MeInsightsListUsed")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/used"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeInsightsSharedDeleteRefLastSharedMethodRequest struct {
	ctx _context.Context
	ApiService *MeOfficeGraphInsightsApiService
	sharedInsightId string
	ifMatch *string
}

// ETag
func (r ApiMeInsightsSharedDeleteRefLastSharedMethodRequest) IfMatch(ifMatch string) ApiMeInsightsSharedDeleteRefLastSharedMethodRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMeInsightsSharedDeleteRefLastSharedMethodRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedDeleteRefLastSharedMethodExecute(r)
}

/*
MeInsightsSharedDeleteRefLastSharedMethod Delete ref of navigation property lastSharedMethod for me

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedDeleteRefLastSharedMethodRequest
*/
func (a *MeOfficeGraphInsightsApiService) MeInsightsSharedDeleteRefLastSharedMethod(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedDeleteRefLastSharedMethodRequest {
	return ApiMeInsightsSharedDeleteRefLastSharedMethodRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *MeOfficeGraphInsightsApiService) MeInsightsSharedDeleteRefLastSharedMethodExecute(r ApiMeInsightsSharedDeleteRefLastSharedMethodRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeOfficeGraphInsightsApiService.MeInsightsSharedDeleteRefLastSharedMethod")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/lastSharedMethod/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsSharedDeleteRefResourceRequest struct {
	ctx _context.Context
	ApiService *MeOfficeGraphInsightsApiService
	sharedInsightId string
	ifMatch *string
}

// ETag
func (r ApiMeInsightsSharedDeleteRefResourceRequest) IfMatch(ifMatch string) ApiMeInsightsSharedDeleteRefResourceRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMeInsightsSharedDeleteRefResourceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedDeleteRefResourceExecute(r)
}

/*
MeInsightsSharedDeleteRefResource Delete ref of navigation property resource for me

Used for navigating to the item that was shared. For file attachments, the type is fileAttachment. For linked attachments, the type is driveItem.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedDeleteRefResourceRequest
*/
func (a *MeOfficeGraphInsightsApiService) MeInsightsSharedDeleteRefResource(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedDeleteRefResourceRequest {
	return ApiMeInsightsSharedDeleteRefResourceRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *MeOfficeGraphInsightsApiService) MeInsightsSharedDeleteRefResourceExecute(r ApiMeInsightsSharedDeleteRefResourceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeOfficeGraphInsightsApiService.MeInsightsSharedDeleteRefResource")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/resource/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsSharedGetLastSharedMethodRequest struct {
	ctx _context.Context
	ApiService *MeOfficeGraphInsightsApiService
	sharedInsightId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiMeInsightsSharedGetLastSharedMethodRequest) Select_(select_ []string) ApiMeInsightsSharedGetLastSharedMethodRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeInsightsSharedGetLastSharedMethodRequest) Expand(expand []string) ApiMeInsightsSharedGetLastSharedMethodRequest {
	r.expand = &expand
	return r
}

func (r ApiMeInsightsSharedGetLastSharedMethodRequest) Execute() (MicrosoftGraphEntity, *_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedGetLastSharedMethodExecute(r)
}

/*
MeInsightsSharedGetLastSharedMethod Get lastSharedMethod from me

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedGetLastSharedMethodRequest
*/
func (a *MeOfficeGraphInsightsApiService) MeInsightsSharedGetLastSharedMethod(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedGetLastSharedMethodRequest {
	return ApiMeInsightsSharedGetLastSharedMethodRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEntity
func (a *MeOfficeGraphInsightsApiService) MeInsightsSharedGetLastSharedMethodExecute(r ApiMeInsightsSharedGetLastSharedMethodRequest) (MicrosoftGraphEntity, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeOfficeGraphInsightsApiService.MeInsightsSharedGetLastSharedMethod")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/lastSharedMethod"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeInsightsSharedGetRefLastSharedMethodRequest struct {
	ctx _context.Context
	ApiService *MeOfficeGraphInsightsApiService
	sharedInsightId string
}


func (r ApiMeInsightsSharedGetRefLastSharedMethodRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedGetRefLastSharedMethodExecute(r)
}

/*
MeInsightsSharedGetRefLastSharedMethod Get ref of lastSharedMethod from me

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedGetRefLastSharedMethodRequest
*/
func (a *MeOfficeGraphInsightsApiService) MeInsightsSharedGetRefLastSharedMethod(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedGetRefLastSharedMethodRequest {
	return ApiMeInsightsSharedGetRefLastSharedMethodRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
//  @return string
func (a *MeOfficeGraphInsightsApiService) MeInsightsSharedGetRefLastSharedMethodExecute(r ApiMeInsightsSharedGetRefLastSharedMethodRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeOfficeGraphInsightsApiService.MeInsightsSharedGetRefLastSharedMethod")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/lastSharedMethod/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeInsightsSharedGetRefResourceRequest struct {
	ctx _context.Context
	ApiService *MeOfficeGraphInsightsApiService
	sharedInsightId string
}


func (r ApiMeInsightsSharedGetRefResourceRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedGetRefResourceExecute(r)
}

/*
MeInsightsSharedGetRefResource Get ref of resource from me

Used for navigating to the item that was shared. For file attachments, the type is fileAttachment. For linked attachments, the type is driveItem.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedGetRefResourceRequest
*/
func (a *MeOfficeGraphInsightsApiService) MeInsightsSharedGetRefResource(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedGetRefResourceRequest {
	return ApiMeInsightsSharedGetRefResourceRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
//  @return string
func (a *MeOfficeGraphInsightsApiService) MeInsightsSharedGetRefResourceExecute(r ApiMeInsightsSharedGetRefResourceRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeOfficeGraphInsightsApiService.MeInsightsSharedGetRefResource")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/resource/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeInsightsSharedGetResourceRequest struct {
	ctx _context.Context
	ApiService *MeOfficeGraphInsightsApiService
	sharedInsightId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiMeInsightsSharedGetResourceRequest) Select_(select_ []string) ApiMeInsightsSharedGetResourceRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeInsightsSharedGetResourceRequest) Expand(expand []string) ApiMeInsightsSharedGetResourceRequest {
	r.expand = &expand
	return r
}

func (r ApiMeInsightsSharedGetResourceRequest) Execute() (MicrosoftGraphEntity, *_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedGetResourceExecute(r)
}

/*
MeInsightsSharedGetResource Get resource from me

Used for navigating to the item that was shared. For file attachments, the type is fileAttachment. For linked attachments, the type is driveItem.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedGetResourceRequest
*/
func (a *MeOfficeGraphInsightsApiService) MeInsightsSharedGetResource(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedGetResourceRequest {
	return ApiMeInsightsSharedGetResourceRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEntity
func (a *MeOfficeGraphInsightsApiService) MeInsightsSharedGetResourceExecute(r ApiMeInsightsSharedGetResourceRequest) (MicrosoftGraphEntity, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeOfficeGraphInsightsApiService.MeInsightsSharedGetResource")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/resource"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeInsightsSharedUpdateRefLastSharedMethodRequest struct {
	ctx _context.Context
	ApiService *MeOfficeGraphInsightsApiService
	sharedInsightId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiMeInsightsSharedUpdateRefLastSharedMethodRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiMeInsightsSharedUpdateRefLastSharedMethodRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiMeInsightsSharedUpdateRefLastSharedMethodRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedUpdateRefLastSharedMethodExecute(r)
}

/*
MeInsightsSharedUpdateRefLastSharedMethod Update the ref of navigation property lastSharedMethod in me

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedUpdateRefLastSharedMethodRequest
*/
func (a *MeOfficeGraphInsightsApiService) MeInsightsSharedUpdateRefLastSharedMethod(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedUpdateRefLastSharedMethodRequest {
	return ApiMeInsightsSharedUpdateRefLastSharedMethodRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *MeOfficeGraphInsightsApiService) MeInsightsSharedUpdateRefLastSharedMethodExecute(r ApiMeInsightsSharedUpdateRefLastSharedMethodRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeOfficeGraphInsightsApiService.MeInsightsSharedUpdateRefLastSharedMethod")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/lastSharedMethod/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsSharedUpdateRefResourceRequest struct {
	ctx _context.Context
	ApiService *MeOfficeGraphInsightsApiService
	sharedInsightId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiMeInsightsSharedUpdateRefResourceRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiMeInsightsSharedUpdateRefResourceRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiMeInsightsSharedUpdateRefResourceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedUpdateRefResourceExecute(r)
}

/*
MeInsightsSharedUpdateRefResource Update the ref of navigation property resource in me

Used for navigating to the item that was shared. For file attachments, the type is fileAttachment. For linked attachments, the type is driveItem.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedUpdateRefResourceRequest
*/
func (a *MeOfficeGraphInsightsApiService) MeInsightsSharedUpdateRefResource(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedUpdateRefResourceRequest {
	return ApiMeInsightsSharedUpdateRefResourceRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *MeOfficeGraphInsightsApiService) MeInsightsSharedUpdateRefResourceExecute(r ApiMeInsightsSharedUpdateRefResourceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeOfficeGraphInsightsApiService.MeInsightsSharedUpdateRefResource")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/resource/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsTrendingDeleteRefResourceRequest struct {
	ctx _context.Context
	ApiService *MeOfficeGraphInsightsApiService
	trendingId string
	ifMatch *string
}

// ETag
func (r ApiMeInsightsTrendingDeleteRefResourceRequest) IfMatch(ifMatch string) ApiMeInsightsTrendingDeleteRefResourceRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMeInsightsTrendingDeleteRefResourceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsTrendingDeleteRefResourceExecute(r)
}

/*
MeInsightsTrendingDeleteRefResource Delete ref of navigation property resource for me

Used for navigating to the trending document.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param trendingId key: id of trending
 @return ApiMeInsightsTrendingDeleteRefResourceRequest
*/
func (a *MeOfficeGraphInsightsApiService) MeInsightsTrendingDeleteRefResource(ctx _context.Context, trendingId string) ApiMeInsightsTrendingDeleteRefResourceRequest {
	return ApiMeInsightsTrendingDeleteRefResourceRequest{
		ApiService: a,
		ctx: ctx,
		trendingId: trendingId,
	}
}

// Execute executes the request
func (a *MeOfficeGraphInsightsApiService) MeInsightsTrendingDeleteRefResourceExecute(r ApiMeInsightsTrendingDeleteRefResourceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeOfficeGraphInsightsApiService.MeInsightsTrendingDeleteRefResource")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/trending/{trending-id}/resource/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsTrendingGetRefResourceRequest struct {
	ctx _context.Context
	ApiService *MeOfficeGraphInsightsApiService
	trendingId string
}


func (r ApiMeInsightsTrendingGetRefResourceRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.MeInsightsTrendingGetRefResourceExecute(r)
}

/*
MeInsightsTrendingGetRefResource Get ref of resource from me

Used for navigating to the trending document.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param trendingId key: id of trending
 @return ApiMeInsightsTrendingGetRefResourceRequest
*/
func (a *MeOfficeGraphInsightsApiService) MeInsightsTrendingGetRefResource(ctx _context.Context, trendingId string) ApiMeInsightsTrendingGetRefResourceRequest {
	return ApiMeInsightsTrendingGetRefResourceRequest{
		ApiService: a,
		ctx: ctx,
		trendingId: trendingId,
	}
}

// Execute executes the request
//  @return string
func (a *MeOfficeGraphInsightsApiService) MeInsightsTrendingGetRefResourceExecute(r ApiMeInsightsTrendingGetRefResourceRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeOfficeGraphInsightsApiService.MeInsightsTrendingGetRefResource")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/trending/{trending-id}/resource/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeInsightsTrendingGetResourceRequest struct {
	ctx _context.Context
	ApiService *MeOfficeGraphInsightsApiService
	trendingId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiMeInsightsTrendingGetResourceRequest) Select_(select_ []string) ApiMeInsightsTrendingGetResourceRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeInsightsTrendingGetResourceRequest) Expand(expand []string) ApiMeInsightsTrendingGetResourceRequest {
	r.expand = &expand
	return r
}

func (r ApiMeInsightsTrendingGetResourceRequest) Execute() (MicrosoftGraphEntity, *_nethttp.Response, error) {
	return r.ApiService.MeInsightsTrendingGetResourceExecute(r)
}

/*
MeInsightsTrendingGetResource Get resource from me

Used for navigating to the trending document.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param trendingId key: id of trending
 @return ApiMeInsightsTrendingGetResourceRequest
*/
func (a *MeOfficeGraphInsightsApiService) MeInsightsTrendingGetResource(ctx _context.Context, trendingId string) ApiMeInsightsTrendingGetResourceRequest {
	return ApiMeInsightsTrendingGetResourceRequest{
		ApiService: a,
		ctx: ctx,
		trendingId: trendingId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEntity
func (a *MeOfficeGraphInsightsApiService) MeInsightsTrendingGetResourceExecute(r ApiMeInsightsTrendingGetResourceRequest) (MicrosoftGraphEntity, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeOfficeGraphInsightsApiService.MeInsightsTrendingGetResource")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/trending/{trending-id}/resource"
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeInsightsTrendingUpdateRefResourceRequest struct {
	ctx _context.Context
	ApiService *MeOfficeGraphInsightsApiService
	trendingId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiMeInsightsTrendingUpdateRefResourceRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiMeInsightsTrendingUpdateRefResourceRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiMeInsightsTrendingUpdateRefResourceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsTrendingUpdateRefResourceExecute(r)
}

/*
MeInsightsTrendingUpdateRefResource Update the ref of navigation property resource in me

Used for navigating to the trending document.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param trendingId key: id of trending
 @return ApiMeInsightsTrendingUpdateRefResourceRequest
*/
func (a *MeOfficeGraphInsightsApiService) MeInsightsTrendingUpdateRefResource(ctx _context.Context, trendingId string) ApiMeInsightsTrendingUpdateRefResourceRequest {
	return ApiMeInsightsTrendingUpdateRefResourceRequest{
		ApiService: a,
		ctx: ctx,
		trendingId: trendingId,
	}
}

// Execute executes the request
func (a *MeOfficeGraphInsightsApiService) MeInsightsTrendingUpdateRefResourceExecute(r ApiMeInsightsTrendingUpdateRefResourceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeOfficeGraphInsightsApiService.MeInsightsTrendingUpdateRefResource")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/trending/{trending-id}/resource/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsUpdateSharedRequest struct {
	ctx _context.Context
	ApiService *MeOfficeGraphInsightsApiService
	sharedInsightId string
	microsoftGraphSharedInsight *MicrosoftGraphSharedInsight
}

// New navigation property values
func (r ApiMeInsightsUpdateSharedRequest) MicrosoftGraphSharedInsight(microsoftGraphSharedInsight MicrosoftGraphSharedInsight) ApiMeInsightsUpdateSharedRequest {
	r.microsoftGraphSharedInsight = &microsoftGraphSharedInsight
	return r
}

func (r ApiMeInsightsUpdateSharedRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsUpdateSharedExecute(r)
}

/*
MeInsightsUpdateShared Update the navigation property shared in me

Calculated relationship identifying documents shared with or by the user. This includes URLs, file attachments, and reference attachments to OneDrive for Business and SharePoint files found in Outlook messages and meetings. This also includes URLs and reference attachments to Teams conversations. Ordered by recency of share.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsUpdateSharedRequest
*/
func (a *MeOfficeGraphInsightsApiService) MeInsightsUpdateShared(ctx _context.Context, sharedInsightId string) ApiMeInsightsUpdateSharedRequest {
	return ApiMeInsightsUpdateSharedRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *MeOfficeGraphInsightsApiService) MeInsightsUpdateSharedExecute(r ApiMeInsightsUpdateSharedRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeOfficeGraphInsightsApiService.MeInsightsUpdateShared")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphSharedInsight == nil {
		return nil, reportError("microsoftGraphSharedInsight is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphSharedInsight
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsUpdateTrendingRequest struct {
	ctx _context.Context
	ApiService *MeOfficeGraphInsightsApiService
	trendingId string
	microsoftGraphTrending *MicrosoftGraphTrending
}

// New navigation property values
func (r ApiMeInsightsUpdateTrendingRequest) MicrosoftGraphTrending(microsoftGraphTrending MicrosoftGraphTrending) ApiMeInsightsUpdateTrendingRequest {
	r.microsoftGraphTrending = &microsoftGraphTrending
	return r
}

func (r ApiMeInsightsUpdateTrendingRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsUpdateTrendingExecute(r)
}

/*
MeInsightsUpdateTrending Update the navigation property trending in me

Calculated relationship identifying documents trending around a user. Trending documents are calculated based on activity of the user's closest network of people and include files stored in OneDrive for Business and SharePoint. Trending insights help the user to discover potentially useful content that the user has access to, but has never viewed before.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param trendingId key: id of trending
 @return ApiMeInsightsUpdateTrendingRequest
*/
func (a *MeOfficeGraphInsightsApiService) MeInsightsUpdateTrending(ctx _context.Context, trendingId string) ApiMeInsightsUpdateTrendingRequest {
	return ApiMeInsightsUpdateTrendingRequest{
		ApiService: a,
		ctx: ctx,
		trendingId: trendingId,
	}
}

// Execute executes the request
func (a *MeOfficeGraphInsightsApiService) MeInsightsUpdateTrendingExecute(r ApiMeInsightsUpdateTrendingRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeOfficeGraphInsightsApiService.MeInsightsUpdateTrending")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/trending/{trending-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphTrending == nil {
		return nil, reportError("microsoftGraphTrending is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphTrending
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsUpdateUsedRequest struct {
	ctx _context.Context
	ApiService *MeOfficeGraphInsightsApiService
	usedInsightId string
	microsoftGraphUsedInsight *MicrosoftGraphUsedInsight
}

// New navigation property values
func (r ApiMeInsightsUpdateUsedRequest) MicrosoftGraphUsedInsight(microsoftGraphUsedInsight MicrosoftGraphUsedInsight) ApiMeInsightsUpdateUsedRequest {
	r.microsoftGraphUsedInsight = &microsoftGraphUsedInsight
	return r
}

func (r ApiMeInsightsUpdateUsedRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsUpdateUsedExecute(r)
}

/*
MeInsightsUpdateUsed Update the navigation property used in me

Calculated relationship identifying the latest documents viewed or modified by a user, including OneDrive for Business and SharePoint documents, ranked by recency of use.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param usedInsightId key: id of usedInsight
 @return ApiMeInsightsUpdateUsedRequest
*/
func (a *MeOfficeGraphInsightsApiService) MeInsightsUpdateUsed(ctx _context.Context, usedInsightId string) ApiMeInsightsUpdateUsedRequest {
	return ApiMeInsightsUpdateUsedRequest{
		ApiService: a,
		ctx: ctx,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
func (a *MeOfficeGraphInsightsApiService) MeInsightsUpdateUsedExecute(r ApiMeInsightsUpdateUsedRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeOfficeGraphInsightsApiService.MeInsightsUpdateUsed")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/used/{usedInsight-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphUsedInsight == nil {
		return nil, reportError("microsoftGraphUsedInsight is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphUsedInsight
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsUsedDeleteRefResourceRequest struct {
	ctx _context.Context
	ApiService *MeOfficeGraphInsightsApiService
	usedInsightId string
	ifMatch *string
}

// ETag
func (r ApiMeInsightsUsedDeleteRefResourceRequest) IfMatch(ifMatch string) ApiMeInsightsUsedDeleteRefResourceRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiMeInsightsUsedDeleteRefResourceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsUsedDeleteRefResourceExecute(r)
}

/*
MeInsightsUsedDeleteRefResource Delete ref of navigation property resource for me

Used for navigating to the item that was used. For file attachments, the type is fileAttachment. For linked attachments, the type is driveItem.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param usedInsightId key: id of usedInsight
 @return ApiMeInsightsUsedDeleteRefResourceRequest
*/
func (a *MeOfficeGraphInsightsApiService) MeInsightsUsedDeleteRefResource(ctx _context.Context, usedInsightId string) ApiMeInsightsUsedDeleteRefResourceRequest {
	return ApiMeInsightsUsedDeleteRefResourceRequest{
		ApiService: a,
		ctx: ctx,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
func (a *MeOfficeGraphInsightsApiService) MeInsightsUsedDeleteRefResourceExecute(r ApiMeInsightsUsedDeleteRefResourceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeOfficeGraphInsightsApiService.MeInsightsUsedDeleteRefResource")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/used/{usedInsight-id}/resource/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsUsedGetRefResourceRequest struct {
	ctx _context.Context
	ApiService *MeOfficeGraphInsightsApiService
	usedInsightId string
}


func (r ApiMeInsightsUsedGetRefResourceRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.MeInsightsUsedGetRefResourceExecute(r)
}

/*
MeInsightsUsedGetRefResource Get ref of resource from me

Used for navigating to the item that was used. For file attachments, the type is fileAttachment. For linked attachments, the type is driveItem.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param usedInsightId key: id of usedInsight
 @return ApiMeInsightsUsedGetRefResourceRequest
*/
func (a *MeOfficeGraphInsightsApiService) MeInsightsUsedGetRefResource(ctx _context.Context, usedInsightId string) ApiMeInsightsUsedGetRefResourceRequest {
	return ApiMeInsightsUsedGetRefResourceRequest{
		ApiService: a,
		ctx: ctx,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
//  @return string
func (a *MeOfficeGraphInsightsApiService) MeInsightsUsedGetRefResourceExecute(r ApiMeInsightsUsedGetRefResourceRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeOfficeGraphInsightsApiService.MeInsightsUsedGetRefResource")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/used/{usedInsight-id}/resource/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeInsightsUsedGetResourceRequest struct {
	ctx _context.Context
	ApiService *MeOfficeGraphInsightsApiService
	usedInsightId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiMeInsightsUsedGetResourceRequest) Select_(select_ []string) ApiMeInsightsUsedGetResourceRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiMeInsightsUsedGetResourceRequest) Expand(expand []string) ApiMeInsightsUsedGetResourceRequest {
	r.expand = &expand
	return r
}

func (r ApiMeInsightsUsedGetResourceRequest) Execute() (MicrosoftGraphEntity, *_nethttp.Response, error) {
	return r.ApiService.MeInsightsUsedGetResourceExecute(r)
}

/*
MeInsightsUsedGetResource Get resource from me

Used for navigating to the item that was used. For file attachments, the type is fileAttachment. For linked attachments, the type is driveItem.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param usedInsightId key: id of usedInsight
 @return ApiMeInsightsUsedGetResourceRequest
*/
func (a *MeOfficeGraphInsightsApiService) MeInsightsUsedGetResource(ctx _context.Context, usedInsightId string) ApiMeInsightsUsedGetResourceRequest {
	return ApiMeInsightsUsedGetResourceRequest{
		ApiService: a,
		ctx: ctx,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEntity
func (a *MeOfficeGraphInsightsApiService) MeInsightsUsedGetResourceExecute(r ApiMeInsightsUsedGetResourceRequest) (MicrosoftGraphEntity, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeOfficeGraphInsightsApiService.MeInsightsUsedGetResource")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/used/{usedInsight-id}/resource"
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeInsightsUsedUpdateRefResourceRequest struct {
	ctx _context.Context
	ApiService *MeOfficeGraphInsightsApiService
	usedInsightId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiMeInsightsUsedUpdateRefResourceRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiMeInsightsUsedUpdateRefResourceRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiMeInsightsUsedUpdateRefResourceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsUsedUpdateRefResourceExecute(r)
}

/*
MeInsightsUsedUpdateRefResource Update the ref of navigation property resource in me

Used for navigating to the item that was used. For file attachments, the type is fileAttachment. For linked attachments, the type is driveItem.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param usedInsightId key: id of usedInsight
 @return ApiMeInsightsUsedUpdateRefResourceRequest
*/
func (a *MeOfficeGraphInsightsApiService) MeInsightsUsedUpdateRefResource(ctx _context.Context, usedInsightId string) ApiMeInsightsUsedUpdateRefResourceRequest {
	return ApiMeInsightsUsedUpdateRefResourceRequest{
		ApiService: a,
		ctx: ctx,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
func (a *MeOfficeGraphInsightsApiService) MeInsightsUsedUpdateRefResourceExecute(r ApiMeInsightsUsedUpdateRefResourceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeOfficeGraphInsightsApiService.MeInsightsUsedUpdateRefResource")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/used/{usedInsight-id}/resource/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeUpdateInsightsRequest struct {
	ctx _context.Context
	ApiService *MeOfficeGraphInsightsApiService
	microsoftGraphOfficeGraphInsights *MicrosoftGraphOfficeGraphInsights
}

// New navigation property values
func (r ApiMeUpdateInsightsRequest) MicrosoftGraphOfficeGraphInsights(microsoftGraphOfficeGraphInsights MicrosoftGraphOfficeGraphInsights) ApiMeUpdateInsightsRequest {
	r.microsoftGraphOfficeGraphInsights = &microsoftGraphOfficeGraphInsights
	return r
}

func (r ApiMeUpdateInsightsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeUpdateInsightsExecute(r)
}

/*
MeUpdateInsights Update the navigation property insights in me

Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMeUpdateInsightsRequest
*/
func (a *MeOfficeGraphInsightsApiService) MeUpdateInsights(ctx _context.Context) ApiMeUpdateInsightsRequest {
	return ApiMeUpdateInsightsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MeOfficeGraphInsightsApiService) MeUpdateInsightsExecute(r ApiMeUpdateInsightsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeOfficeGraphInsightsApiService.MeUpdateInsights")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphOfficeGraphInsights == nil {
		return nil, reportError("microsoftGraphOfficeGraphInsights is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphOfficeGraphInsights
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
