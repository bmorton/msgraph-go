/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// ServicePrincipalsDirectoryObjectApiService ServicePrincipalsDirectoryObjectApi service
type ServicePrincipalsDirectoryObjectApiService service

type ApiServicePrincipalsCreateRefCreatedObjectsRequest struct {
	ctx _context.Context
	ApiService *ServicePrincipalsDirectoryObjectApiService
	servicePrincipalId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref value
func (r ApiServicePrincipalsCreateRefCreatedObjectsRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiServicePrincipalsCreateRefCreatedObjectsRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiServicePrincipalsCreateRefCreatedObjectsRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.ServicePrincipalsCreateRefCreatedObjectsExecute(r)
}

/*
ServicePrincipalsCreateRefCreatedObjects Create new navigation property ref to createdObjects for servicePrincipals

Directory objects created by this service principal. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param servicePrincipalId key: id of servicePrincipal
 @return ApiServicePrincipalsCreateRefCreatedObjectsRequest
*/
func (a *ServicePrincipalsDirectoryObjectApiService) ServicePrincipalsCreateRefCreatedObjects(ctx _context.Context, servicePrincipalId string) ApiServicePrincipalsCreateRefCreatedObjectsRequest {
	return ApiServicePrincipalsCreateRefCreatedObjectsRequest{
		ApiService: a,
		ctx: ctx,
		servicePrincipalId: servicePrincipalId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ServicePrincipalsDirectoryObjectApiService) ServicePrincipalsCreateRefCreatedObjectsExecute(r ApiServicePrincipalsCreateRefCreatedObjectsRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServicePrincipalsDirectoryObjectApiService.ServicePrincipalsCreateRefCreatedObjects")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/servicePrincipals/{servicePrincipal-id}/createdObjects/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"servicePrincipal-id"+"}", _neturl.PathEscape(parameterToString(r.servicePrincipalId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiServicePrincipalsCreateRefMemberOfRequest struct {
	ctx _context.Context
	ApiService *ServicePrincipalsDirectoryObjectApiService
	servicePrincipalId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref value
func (r ApiServicePrincipalsCreateRefMemberOfRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiServicePrincipalsCreateRefMemberOfRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiServicePrincipalsCreateRefMemberOfRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.ServicePrincipalsCreateRefMemberOfExecute(r)
}

/*
ServicePrincipalsCreateRefMemberOf Create new navigation property ref to memberOf for servicePrincipals

Roles that this service principal is a member of. HTTP Methods: GET Read-only. Nullable. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param servicePrincipalId key: id of servicePrincipal
 @return ApiServicePrincipalsCreateRefMemberOfRequest
*/
func (a *ServicePrincipalsDirectoryObjectApiService) ServicePrincipalsCreateRefMemberOf(ctx _context.Context, servicePrincipalId string) ApiServicePrincipalsCreateRefMemberOfRequest {
	return ApiServicePrincipalsCreateRefMemberOfRequest{
		ApiService: a,
		ctx: ctx,
		servicePrincipalId: servicePrincipalId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ServicePrincipalsDirectoryObjectApiService) ServicePrincipalsCreateRefMemberOfExecute(r ApiServicePrincipalsCreateRefMemberOfRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServicePrincipalsDirectoryObjectApiService.ServicePrincipalsCreateRefMemberOf")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/servicePrincipals/{servicePrincipal-id}/memberOf/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"servicePrincipal-id"+"}", _neturl.PathEscape(parameterToString(r.servicePrincipalId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiServicePrincipalsCreateRefOwnedObjectsRequest struct {
	ctx _context.Context
	ApiService *ServicePrincipalsDirectoryObjectApiService
	servicePrincipalId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref value
func (r ApiServicePrincipalsCreateRefOwnedObjectsRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiServicePrincipalsCreateRefOwnedObjectsRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiServicePrincipalsCreateRefOwnedObjectsRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.ServicePrincipalsCreateRefOwnedObjectsExecute(r)
}

/*
ServicePrincipalsCreateRefOwnedObjects Create new navigation property ref to ownedObjects for servicePrincipals

Directory objects that are owned by this service principal. Read-only. Nullable. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param servicePrincipalId key: id of servicePrincipal
 @return ApiServicePrincipalsCreateRefOwnedObjectsRequest
*/
func (a *ServicePrincipalsDirectoryObjectApiService) ServicePrincipalsCreateRefOwnedObjects(ctx _context.Context, servicePrincipalId string) ApiServicePrincipalsCreateRefOwnedObjectsRequest {
	return ApiServicePrincipalsCreateRefOwnedObjectsRequest{
		ApiService: a,
		ctx: ctx,
		servicePrincipalId: servicePrincipalId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ServicePrincipalsDirectoryObjectApiService) ServicePrincipalsCreateRefOwnedObjectsExecute(r ApiServicePrincipalsCreateRefOwnedObjectsRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServicePrincipalsDirectoryObjectApiService.ServicePrincipalsCreateRefOwnedObjects")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/servicePrincipals/{servicePrincipal-id}/ownedObjects/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"servicePrincipal-id"+"}", _neturl.PathEscape(parameterToString(r.servicePrincipalId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiServicePrincipalsCreateRefOwnersRequest struct {
	ctx _context.Context
	ApiService *ServicePrincipalsDirectoryObjectApiService
	servicePrincipalId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref value
func (r ApiServicePrincipalsCreateRefOwnersRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiServicePrincipalsCreateRefOwnersRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiServicePrincipalsCreateRefOwnersRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.ServicePrincipalsCreateRefOwnersExecute(r)
}

/*
ServicePrincipalsCreateRefOwners Create new navigation property ref to owners for servicePrincipals

Directory objects that are owners of this servicePrincipal. The owners are a set of non-admin users or servicePrincipals who are allowed to modify this object. Read-only. Nullable. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param servicePrincipalId key: id of servicePrincipal
 @return ApiServicePrincipalsCreateRefOwnersRequest
*/
func (a *ServicePrincipalsDirectoryObjectApiService) ServicePrincipalsCreateRefOwners(ctx _context.Context, servicePrincipalId string) ApiServicePrincipalsCreateRefOwnersRequest {
	return ApiServicePrincipalsCreateRefOwnersRequest{
		ApiService: a,
		ctx: ctx,
		servicePrincipalId: servicePrincipalId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ServicePrincipalsDirectoryObjectApiService) ServicePrincipalsCreateRefOwnersExecute(r ApiServicePrincipalsCreateRefOwnersRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServicePrincipalsDirectoryObjectApiService.ServicePrincipalsCreateRefOwners")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/servicePrincipals/{servicePrincipal-id}/owners/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"servicePrincipal-id"+"}", _neturl.PathEscape(parameterToString(r.servicePrincipalId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiServicePrincipalsCreateRefTransitiveMemberOfRequest struct {
	ctx _context.Context
	ApiService *ServicePrincipalsDirectoryObjectApiService
	servicePrincipalId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref value
func (r ApiServicePrincipalsCreateRefTransitiveMemberOfRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiServicePrincipalsCreateRefTransitiveMemberOfRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiServicePrincipalsCreateRefTransitiveMemberOfRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.ServicePrincipalsCreateRefTransitiveMemberOfExecute(r)
}

/*
ServicePrincipalsCreateRefTransitiveMemberOf Create new navigation property ref to transitiveMemberOf for servicePrincipals

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param servicePrincipalId key: id of servicePrincipal
 @return ApiServicePrincipalsCreateRefTransitiveMemberOfRequest
*/
func (a *ServicePrincipalsDirectoryObjectApiService) ServicePrincipalsCreateRefTransitiveMemberOf(ctx _context.Context, servicePrincipalId string) ApiServicePrincipalsCreateRefTransitiveMemberOfRequest {
	return ApiServicePrincipalsCreateRefTransitiveMemberOfRequest{
		ApiService: a,
		ctx: ctx,
		servicePrincipalId: servicePrincipalId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ServicePrincipalsDirectoryObjectApiService) ServicePrincipalsCreateRefTransitiveMemberOfExecute(r ApiServicePrincipalsCreateRefTransitiveMemberOfRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServicePrincipalsDirectoryObjectApiService.ServicePrincipalsCreateRefTransitiveMemberOf")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/servicePrincipals/{servicePrincipal-id}/transitiveMemberOf/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"servicePrincipal-id"+"}", _neturl.PathEscape(parameterToString(r.servicePrincipalId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiServicePrincipalsListCreatedObjectsRequest struct {
	ctx _context.Context
	ApiService *ServicePrincipalsDirectoryObjectApiService
	servicePrincipalId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiServicePrincipalsListCreatedObjectsRequest) Top(top int32) ApiServicePrincipalsListCreatedObjectsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiServicePrincipalsListCreatedObjectsRequest) Skip(skip int32) ApiServicePrincipalsListCreatedObjectsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiServicePrincipalsListCreatedObjectsRequest) Search(search string) ApiServicePrincipalsListCreatedObjectsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiServicePrincipalsListCreatedObjectsRequest) Filter(filter string) ApiServicePrincipalsListCreatedObjectsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiServicePrincipalsListCreatedObjectsRequest) Count(count bool) ApiServicePrincipalsListCreatedObjectsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiServicePrincipalsListCreatedObjectsRequest) Orderby(orderby []string) ApiServicePrincipalsListCreatedObjectsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiServicePrincipalsListCreatedObjectsRequest) Select_(select_ []string) ApiServicePrincipalsListCreatedObjectsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiServicePrincipalsListCreatedObjectsRequest) Expand(expand []string) ApiServicePrincipalsListCreatedObjectsRequest {
	r.expand = &expand
	return r
}

func (r ApiServicePrincipalsListCreatedObjectsRequest) Execute() (CollectionOfDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.ServicePrincipalsListCreatedObjectsExecute(r)
}

/*
ServicePrincipalsListCreatedObjects Get createdObjects from servicePrincipals

Directory objects created by this service principal. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param servicePrincipalId key: id of servicePrincipal
 @return ApiServicePrincipalsListCreatedObjectsRequest
*/
func (a *ServicePrincipalsDirectoryObjectApiService) ServicePrincipalsListCreatedObjects(ctx _context.Context, servicePrincipalId string) ApiServicePrincipalsListCreatedObjectsRequest {
	return ApiServicePrincipalsListCreatedObjectsRequest{
		ApiService: a,
		ctx: ctx,
		servicePrincipalId: servicePrincipalId,
	}
}

// Execute executes the request
//  @return CollectionOfDirectoryObject
func (a *ServicePrincipalsDirectoryObjectApiService) ServicePrincipalsListCreatedObjectsExecute(r ApiServicePrincipalsListCreatedObjectsRequest) (CollectionOfDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServicePrincipalsDirectoryObjectApiService.ServicePrincipalsListCreatedObjects")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/servicePrincipals/{servicePrincipal-id}/createdObjects"
	localVarPath = strings.Replace(localVarPath, "{"+"servicePrincipal-id"+"}", _neturl.PathEscape(parameterToString(r.servicePrincipalId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiServicePrincipalsListMemberOfRequest struct {
	ctx _context.Context
	ApiService *ServicePrincipalsDirectoryObjectApiService
	servicePrincipalId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiServicePrincipalsListMemberOfRequest) Top(top int32) ApiServicePrincipalsListMemberOfRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiServicePrincipalsListMemberOfRequest) Skip(skip int32) ApiServicePrincipalsListMemberOfRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiServicePrincipalsListMemberOfRequest) Search(search string) ApiServicePrincipalsListMemberOfRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiServicePrincipalsListMemberOfRequest) Filter(filter string) ApiServicePrincipalsListMemberOfRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiServicePrincipalsListMemberOfRequest) Count(count bool) ApiServicePrincipalsListMemberOfRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiServicePrincipalsListMemberOfRequest) Orderby(orderby []string) ApiServicePrincipalsListMemberOfRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiServicePrincipalsListMemberOfRequest) Select_(select_ []string) ApiServicePrincipalsListMemberOfRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiServicePrincipalsListMemberOfRequest) Expand(expand []string) ApiServicePrincipalsListMemberOfRequest {
	r.expand = &expand
	return r
}

func (r ApiServicePrincipalsListMemberOfRequest) Execute() (CollectionOfDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.ServicePrincipalsListMemberOfExecute(r)
}

/*
ServicePrincipalsListMemberOf Get memberOf from servicePrincipals

Roles that this service principal is a member of. HTTP Methods: GET Read-only. Nullable. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param servicePrincipalId key: id of servicePrincipal
 @return ApiServicePrincipalsListMemberOfRequest
*/
func (a *ServicePrincipalsDirectoryObjectApiService) ServicePrincipalsListMemberOf(ctx _context.Context, servicePrincipalId string) ApiServicePrincipalsListMemberOfRequest {
	return ApiServicePrincipalsListMemberOfRequest{
		ApiService: a,
		ctx: ctx,
		servicePrincipalId: servicePrincipalId,
	}
}

// Execute executes the request
//  @return CollectionOfDirectoryObject
func (a *ServicePrincipalsDirectoryObjectApiService) ServicePrincipalsListMemberOfExecute(r ApiServicePrincipalsListMemberOfRequest) (CollectionOfDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServicePrincipalsDirectoryObjectApiService.ServicePrincipalsListMemberOf")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/servicePrincipals/{servicePrincipal-id}/memberOf"
	localVarPath = strings.Replace(localVarPath, "{"+"servicePrincipal-id"+"}", _neturl.PathEscape(parameterToString(r.servicePrincipalId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiServicePrincipalsListOwnedObjectsRequest struct {
	ctx _context.Context
	ApiService *ServicePrincipalsDirectoryObjectApiService
	servicePrincipalId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiServicePrincipalsListOwnedObjectsRequest) Top(top int32) ApiServicePrincipalsListOwnedObjectsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiServicePrincipalsListOwnedObjectsRequest) Skip(skip int32) ApiServicePrincipalsListOwnedObjectsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiServicePrincipalsListOwnedObjectsRequest) Search(search string) ApiServicePrincipalsListOwnedObjectsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiServicePrincipalsListOwnedObjectsRequest) Filter(filter string) ApiServicePrincipalsListOwnedObjectsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiServicePrincipalsListOwnedObjectsRequest) Count(count bool) ApiServicePrincipalsListOwnedObjectsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiServicePrincipalsListOwnedObjectsRequest) Orderby(orderby []string) ApiServicePrincipalsListOwnedObjectsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiServicePrincipalsListOwnedObjectsRequest) Select_(select_ []string) ApiServicePrincipalsListOwnedObjectsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiServicePrincipalsListOwnedObjectsRequest) Expand(expand []string) ApiServicePrincipalsListOwnedObjectsRequest {
	r.expand = &expand
	return r
}

func (r ApiServicePrincipalsListOwnedObjectsRequest) Execute() (CollectionOfDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.ServicePrincipalsListOwnedObjectsExecute(r)
}

/*
ServicePrincipalsListOwnedObjects Get ownedObjects from servicePrincipals

Directory objects that are owned by this service principal. Read-only. Nullable. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param servicePrincipalId key: id of servicePrincipal
 @return ApiServicePrincipalsListOwnedObjectsRequest
*/
func (a *ServicePrincipalsDirectoryObjectApiService) ServicePrincipalsListOwnedObjects(ctx _context.Context, servicePrincipalId string) ApiServicePrincipalsListOwnedObjectsRequest {
	return ApiServicePrincipalsListOwnedObjectsRequest{
		ApiService: a,
		ctx: ctx,
		servicePrincipalId: servicePrincipalId,
	}
}

// Execute executes the request
//  @return CollectionOfDirectoryObject
func (a *ServicePrincipalsDirectoryObjectApiService) ServicePrincipalsListOwnedObjectsExecute(r ApiServicePrincipalsListOwnedObjectsRequest) (CollectionOfDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServicePrincipalsDirectoryObjectApiService.ServicePrincipalsListOwnedObjects")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/servicePrincipals/{servicePrincipal-id}/ownedObjects"
	localVarPath = strings.Replace(localVarPath, "{"+"servicePrincipal-id"+"}", _neturl.PathEscape(parameterToString(r.servicePrincipalId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiServicePrincipalsListOwnersRequest struct {
	ctx _context.Context
	ApiService *ServicePrincipalsDirectoryObjectApiService
	servicePrincipalId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiServicePrincipalsListOwnersRequest) Top(top int32) ApiServicePrincipalsListOwnersRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiServicePrincipalsListOwnersRequest) Skip(skip int32) ApiServicePrincipalsListOwnersRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiServicePrincipalsListOwnersRequest) Search(search string) ApiServicePrincipalsListOwnersRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiServicePrincipalsListOwnersRequest) Filter(filter string) ApiServicePrincipalsListOwnersRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiServicePrincipalsListOwnersRequest) Count(count bool) ApiServicePrincipalsListOwnersRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiServicePrincipalsListOwnersRequest) Orderby(orderby []string) ApiServicePrincipalsListOwnersRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiServicePrincipalsListOwnersRequest) Select_(select_ []string) ApiServicePrincipalsListOwnersRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiServicePrincipalsListOwnersRequest) Expand(expand []string) ApiServicePrincipalsListOwnersRequest {
	r.expand = &expand
	return r
}

func (r ApiServicePrincipalsListOwnersRequest) Execute() (CollectionOfDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.ServicePrincipalsListOwnersExecute(r)
}

/*
ServicePrincipalsListOwners Get owners from servicePrincipals

Directory objects that are owners of this servicePrincipal. The owners are a set of non-admin users or servicePrincipals who are allowed to modify this object. Read-only. Nullable. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param servicePrincipalId key: id of servicePrincipal
 @return ApiServicePrincipalsListOwnersRequest
*/
func (a *ServicePrincipalsDirectoryObjectApiService) ServicePrincipalsListOwners(ctx _context.Context, servicePrincipalId string) ApiServicePrincipalsListOwnersRequest {
	return ApiServicePrincipalsListOwnersRequest{
		ApiService: a,
		ctx: ctx,
		servicePrincipalId: servicePrincipalId,
	}
}

// Execute executes the request
//  @return CollectionOfDirectoryObject
func (a *ServicePrincipalsDirectoryObjectApiService) ServicePrincipalsListOwnersExecute(r ApiServicePrincipalsListOwnersRequest) (CollectionOfDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServicePrincipalsDirectoryObjectApiService.ServicePrincipalsListOwners")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/servicePrincipals/{servicePrincipal-id}/owners"
	localVarPath = strings.Replace(localVarPath, "{"+"servicePrincipal-id"+"}", _neturl.PathEscape(parameterToString(r.servicePrincipalId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiServicePrincipalsListRefCreatedObjectsRequest struct {
	ctx _context.Context
	ApiService *ServicePrincipalsDirectoryObjectApiService
	servicePrincipalId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
}

// Show only the first n items
func (r ApiServicePrincipalsListRefCreatedObjectsRequest) Top(top int32) ApiServicePrincipalsListRefCreatedObjectsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiServicePrincipalsListRefCreatedObjectsRequest) Skip(skip int32) ApiServicePrincipalsListRefCreatedObjectsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiServicePrincipalsListRefCreatedObjectsRequest) Search(search string) ApiServicePrincipalsListRefCreatedObjectsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiServicePrincipalsListRefCreatedObjectsRequest) Filter(filter string) ApiServicePrincipalsListRefCreatedObjectsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiServicePrincipalsListRefCreatedObjectsRequest) Count(count bool) ApiServicePrincipalsListRefCreatedObjectsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiServicePrincipalsListRefCreatedObjectsRequest) Orderby(orderby []string) ApiServicePrincipalsListRefCreatedObjectsRequest {
	r.orderby = &orderby
	return r
}

func (r ApiServicePrincipalsListRefCreatedObjectsRequest) Execute() (CollectionOfLinksOfDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.ServicePrincipalsListRefCreatedObjectsExecute(r)
}

/*
ServicePrincipalsListRefCreatedObjects Get ref of createdObjects from servicePrincipals

Directory objects created by this service principal. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param servicePrincipalId key: id of servicePrincipal
 @return ApiServicePrincipalsListRefCreatedObjectsRequest
*/
func (a *ServicePrincipalsDirectoryObjectApiService) ServicePrincipalsListRefCreatedObjects(ctx _context.Context, servicePrincipalId string) ApiServicePrincipalsListRefCreatedObjectsRequest {
	return ApiServicePrincipalsListRefCreatedObjectsRequest{
		ApiService: a,
		ctx: ctx,
		servicePrincipalId: servicePrincipalId,
	}
}

// Execute executes the request
//  @return CollectionOfLinksOfDirectoryObject
func (a *ServicePrincipalsDirectoryObjectApiService) ServicePrincipalsListRefCreatedObjectsExecute(r ApiServicePrincipalsListRefCreatedObjectsRequest) (CollectionOfLinksOfDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfLinksOfDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServicePrincipalsDirectoryObjectApiService.ServicePrincipalsListRefCreatedObjects")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/servicePrincipals/{servicePrincipal-id}/createdObjects/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"servicePrincipal-id"+"}", _neturl.PathEscape(parameterToString(r.servicePrincipalId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiServicePrincipalsListRefMemberOfRequest struct {
	ctx _context.Context
	ApiService *ServicePrincipalsDirectoryObjectApiService
	servicePrincipalId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
}

// Show only the first n items
func (r ApiServicePrincipalsListRefMemberOfRequest) Top(top int32) ApiServicePrincipalsListRefMemberOfRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiServicePrincipalsListRefMemberOfRequest) Skip(skip int32) ApiServicePrincipalsListRefMemberOfRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiServicePrincipalsListRefMemberOfRequest) Search(search string) ApiServicePrincipalsListRefMemberOfRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiServicePrincipalsListRefMemberOfRequest) Filter(filter string) ApiServicePrincipalsListRefMemberOfRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiServicePrincipalsListRefMemberOfRequest) Count(count bool) ApiServicePrincipalsListRefMemberOfRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiServicePrincipalsListRefMemberOfRequest) Orderby(orderby []string) ApiServicePrincipalsListRefMemberOfRequest {
	r.orderby = &orderby
	return r
}

func (r ApiServicePrincipalsListRefMemberOfRequest) Execute() (CollectionOfLinksOfDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.ServicePrincipalsListRefMemberOfExecute(r)
}

/*
ServicePrincipalsListRefMemberOf Get ref of memberOf from servicePrincipals

Roles that this service principal is a member of. HTTP Methods: GET Read-only. Nullable. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param servicePrincipalId key: id of servicePrincipal
 @return ApiServicePrincipalsListRefMemberOfRequest
*/
func (a *ServicePrincipalsDirectoryObjectApiService) ServicePrincipalsListRefMemberOf(ctx _context.Context, servicePrincipalId string) ApiServicePrincipalsListRefMemberOfRequest {
	return ApiServicePrincipalsListRefMemberOfRequest{
		ApiService: a,
		ctx: ctx,
		servicePrincipalId: servicePrincipalId,
	}
}

// Execute executes the request
//  @return CollectionOfLinksOfDirectoryObject
func (a *ServicePrincipalsDirectoryObjectApiService) ServicePrincipalsListRefMemberOfExecute(r ApiServicePrincipalsListRefMemberOfRequest) (CollectionOfLinksOfDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfLinksOfDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServicePrincipalsDirectoryObjectApiService.ServicePrincipalsListRefMemberOf")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/servicePrincipals/{servicePrincipal-id}/memberOf/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"servicePrincipal-id"+"}", _neturl.PathEscape(parameterToString(r.servicePrincipalId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiServicePrincipalsListRefOwnedObjectsRequest struct {
	ctx _context.Context
	ApiService *ServicePrincipalsDirectoryObjectApiService
	servicePrincipalId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
}

// Show only the first n items
func (r ApiServicePrincipalsListRefOwnedObjectsRequest) Top(top int32) ApiServicePrincipalsListRefOwnedObjectsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiServicePrincipalsListRefOwnedObjectsRequest) Skip(skip int32) ApiServicePrincipalsListRefOwnedObjectsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiServicePrincipalsListRefOwnedObjectsRequest) Search(search string) ApiServicePrincipalsListRefOwnedObjectsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiServicePrincipalsListRefOwnedObjectsRequest) Filter(filter string) ApiServicePrincipalsListRefOwnedObjectsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiServicePrincipalsListRefOwnedObjectsRequest) Count(count bool) ApiServicePrincipalsListRefOwnedObjectsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiServicePrincipalsListRefOwnedObjectsRequest) Orderby(orderby []string) ApiServicePrincipalsListRefOwnedObjectsRequest {
	r.orderby = &orderby
	return r
}

func (r ApiServicePrincipalsListRefOwnedObjectsRequest) Execute() (CollectionOfLinksOfDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.ServicePrincipalsListRefOwnedObjectsExecute(r)
}

/*
ServicePrincipalsListRefOwnedObjects Get ref of ownedObjects from servicePrincipals

Directory objects that are owned by this service principal. Read-only. Nullable. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param servicePrincipalId key: id of servicePrincipal
 @return ApiServicePrincipalsListRefOwnedObjectsRequest
*/
func (a *ServicePrincipalsDirectoryObjectApiService) ServicePrincipalsListRefOwnedObjects(ctx _context.Context, servicePrincipalId string) ApiServicePrincipalsListRefOwnedObjectsRequest {
	return ApiServicePrincipalsListRefOwnedObjectsRequest{
		ApiService: a,
		ctx: ctx,
		servicePrincipalId: servicePrincipalId,
	}
}

// Execute executes the request
//  @return CollectionOfLinksOfDirectoryObject
func (a *ServicePrincipalsDirectoryObjectApiService) ServicePrincipalsListRefOwnedObjectsExecute(r ApiServicePrincipalsListRefOwnedObjectsRequest) (CollectionOfLinksOfDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfLinksOfDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServicePrincipalsDirectoryObjectApiService.ServicePrincipalsListRefOwnedObjects")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/servicePrincipals/{servicePrincipal-id}/ownedObjects/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"servicePrincipal-id"+"}", _neturl.PathEscape(parameterToString(r.servicePrincipalId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiServicePrincipalsListRefOwnersRequest struct {
	ctx _context.Context
	ApiService *ServicePrincipalsDirectoryObjectApiService
	servicePrincipalId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
}

// Show only the first n items
func (r ApiServicePrincipalsListRefOwnersRequest) Top(top int32) ApiServicePrincipalsListRefOwnersRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiServicePrincipalsListRefOwnersRequest) Skip(skip int32) ApiServicePrincipalsListRefOwnersRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiServicePrincipalsListRefOwnersRequest) Search(search string) ApiServicePrincipalsListRefOwnersRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiServicePrincipalsListRefOwnersRequest) Filter(filter string) ApiServicePrincipalsListRefOwnersRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiServicePrincipalsListRefOwnersRequest) Count(count bool) ApiServicePrincipalsListRefOwnersRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiServicePrincipalsListRefOwnersRequest) Orderby(orderby []string) ApiServicePrincipalsListRefOwnersRequest {
	r.orderby = &orderby
	return r
}

func (r ApiServicePrincipalsListRefOwnersRequest) Execute() (CollectionOfLinksOfDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.ServicePrincipalsListRefOwnersExecute(r)
}

/*
ServicePrincipalsListRefOwners Get ref of owners from servicePrincipals

Directory objects that are owners of this servicePrincipal. The owners are a set of non-admin users or servicePrincipals who are allowed to modify this object. Read-only. Nullable. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param servicePrincipalId key: id of servicePrincipal
 @return ApiServicePrincipalsListRefOwnersRequest
*/
func (a *ServicePrincipalsDirectoryObjectApiService) ServicePrincipalsListRefOwners(ctx _context.Context, servicePrincipalId string) ApiServicePrincipalsListRefOwnersRequest {
	return ApiServicePrincipalsListRefOwnersRequest{
		ApiService: a,
		ctx: ctx,
		servicePrincipalId: servicePrincipalId,
	}
}

// Execute executes the request
//  @return CollectionOfLinksOfDirectoryObject
func (a *ServicePrincipalsDirectoryObjectApiService) ServicePrincipalsListRefOwnersExecute(r ApiServicePrincipalsListRefOwnersRequest) (CollectionOfLinksOfDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfLinksOfDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServicePrincipalsDirectoryObjectApiService.ServicePrincipalsListRefOwners")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/servicePrincipals/{servicePrincipal-id}/owners/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"servicePrincipal-id"+"}", _neturl.PathEscape(parameterToString(r.servicePrincipalId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiServicePrincipalsListRefTransitiveMemberOfRequest struct {
	ctx _context.Context
	ApiService *ServicePrincipalsDirectoryObjectApiService
	servicePrincipalId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
}

// Show only the first n items
func (r ApiServicePrincipalsListRefTransitiveMemberOfRequest) Top(top int32) ApiServicePrincipalsListRefTransitiveMemberOfRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiServicePrincipalsListRefTransitiveMemberOfRequest) Skip(skip int32) ApiServicePrincipalsListRefTransitiveMemberOfRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiServicePrincipalsListRefTransitiveMemberOfRequest) Search(search string) ApiServicePrincipalsListRefTransitiveMemberOfRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiServicePrincipalsListRefTransitiveMemberOfRequest) Filter(filter string) ApiServicePrincipalsListRefTransitiveMemberOfRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiServicePrincipalsListRefTransitiveMemberOfRequest) Count(count bool) ApiServicePrincipalsListRefTransitiveMemberOfRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiServicePrincipalsListRefTransitiveMemberOfRequest) Orderby(orderby []string) ApiServicePrincipalsListRefTransitiveMemberOfRequest {
	r.orderby = &orderby
	return r
}

func (r ApiServicePrincipalsListRefTransitiveMemberOfRequest) Execute() (CollectionOfLinksOfDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.ServicePrincipalsListRefTransitiveMemberOfExecute(r)
}

/*
ServicePrincipalsListRefTransitiveMemberOf Get ref of transitiveMemberOf from servicePrincipals

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param servicePrincipalId key: id of servicePrincipal
 @return ApiServicePrincipalsListRefTransitiveMemberOfRequest
*/
func (a *ServicePrincipalsDirectoryObjectApiService) ServicePrincipalsListRefTransitiveMemberOf(ctx _context.Context, servicePrincipalId string) ApiServicePrincipalsListRefTransitiveMemberOfRequest {
	return ApiServicePrincipalsListRefTransitiveMemberOfRequest{
		ApiService: a,
		ctx: ctx,
		servicePrincipalId: servicePrincipalId,
	}
}

// Execute executes the request
//  @return CollectionOfLinksOfDirectoryObject
func (a *ServicePrincipalsDirectoryObjectApiService) ServicePrincipalsListRefTransitiveMemberOfExecute(r ApiServicePrincipalsListRefTransitiveMemberOfRequest) (CollectionOfLinksOfDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfLinksOfDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServicePrincipalsDirectoryObjectApiService.ServicePrincipalsListRefTransitiveMemberOf")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/servicePrincipals/{servicePrincipal-id}/transitiveMemberOf/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"servicePrincipal-id"+"}", _neturl.PathEscape(parameterToString(r.servicePrincipalId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiServicePrincipalsListTransitiveMemberOfRequest struct {
	ctx _context.Context
	ApiService *ServicePrincipalsDirectoryObjectApiService
	servicePrincipalId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiServicePrincipalsListTransitiveMemberOfRequest) Top(top int32) ApiServicePrincipalsListTransitiveMemberOfRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiServicePrincipalsListTransitiveMemberOfRequest) Skip(skip int32) ApiServicePrincipalsListTransitiveMemberOfRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiServicePrincipalsListTransitiveMemberOfRequest) Search(search string) ApiServicePrincipalsListTransitiveMemberOfRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiServicePrincipalsListTransitiveMemberOfRequest) Filter(filter string) ApiServicePrincipalsListTransitiveMemberOfRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiServicePrincipalsListTransitiveMemberOfRequest) Count(count bool) ApiServicePrincipalsListTransitiveMemberOfRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiServicePrincipalsListTransitiveMemberOfRequest) Orderby(orderby []string) ApiServicePrincipalsListTransitiveMemberOfRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiServicePrincipalsListTransitiveMemberOfRequest) Select_(select_ []string) ApiServicePrincipalsListTransitiveMemberOfRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiServicePrincipalsListTransitiveMemberOfRequest) Expand(expand []string) ApiServicePrincipalsListTransitiveMemberOfRequest {
	r.expand = &expand
	return r
}

func (r ApiServicePrincipalsListTransitiveMemberOfRequest) Execute() (CollectionOfDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.ServicePrincipalsListTransitiveMemberOfExecute(r)
}

/*
ServicePrincipalsListTransitiveMemberOf Get transitiveMemberOf from servicePrincipals

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param servicePrincipalId key: id of servicePrincipal
 @return ApiServicePrincipalsListTransitiveMemberOfRequest
*/
func (a *ServicePrincipalsDirectoryObjectApiService) ServicePrincipalsListTransitiveMemberOf(ctx _context.Context, servicePrincipalId string) ApiServicePrincipalsListTransitiveMemberOfRequest {
	return ApiServicePrincipalsListTransitiveMemberOfRequest{
		ApiService: a,
		ctx: ctx,
		servicePrincipalId: servicePrincipalId,
	}
}

// Execute executes the request
//  @return CollectionOfDirectoryObject
func (a *ServicePrincipalsDirectoryObjectApiService) ServicePrincipalsListTransitiveMemberOfExecute(r ApiServicePrincipalsListTransitiveMemberOfRequest) (CollectionOfDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServicePrincipalsDirectoryObjectApiService.ServicePrincipalsListTransitiveMemberOf")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/servicePrincipals/{servicePrincipal-id}/transitiveMemberOf"
	localVarPath = strings.Replace(localVarPath, "{"+"servicePrincipal-id"+"}", _neturl.PathEscape(parameterToString(r.servicePrincipalId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
