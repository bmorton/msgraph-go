/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package msgraph

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// DirectoryAdministrativeUnitApiService DirectoryAdministrativeUnitApi service
type DirectoryAdministrativeUnitApiService service

type ApiDirectoryAdministrativeUnitsCreateExtensionsRequest struct {
	ctx _context.Context
	ApiService *DirectoryAdministrativeUnitApiService
	administrativeUnitId string
	microsoftGraphExtension *MicrosoftGraphExtension
}

// New navigation property
func (r ApiDirectoryAdministrativeUnitsCreateExtensionsRequest) MicrosoftGraphExtension(microsoftGraphExtension MicrosoftGraphExtension) ApiDirectoryAdministrativeUnitsCreateExtensionsRequest {
	r.microsoftGraphExtension = &microsoftGraphExtension
	return r
}

func (r ApiDirectoryAdministrativeUnitsCreateExtensionsRequest) Execute() (MicrosoftGraphExtension, *_nethttp.Response, error) {
	return r.ApiService.DirectoryAdministrativeUnitsCreateExtensionsExecute(r)
}

/*
DirectoryAdministrativeUnitsCreateExtensions Create new navigation property to extensions for directory

The collection of open extensions defined for this administrative unit. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param administrativeUnitId key: id of administrativeUnit
 @return ApiDirectoryAdministrativeUnitsCreateExtensionsRequest
*/
func (a *DirectoryAdministrativeUnitApiService) DirectoryAdministrativeUnitsCreateExtensions(ctx _context.Context, administrativeUnitId string) ApiDirectoryAdministrativeUnitsCreateExtensionsRequest {
	return ApiDirectoryAdministrativeUnitsCreateExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		administrativeUnitId: administrativeUnitId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphExtension
func (a *DirectoryAdministrativeUnitApiService) DirectoryAdministrativeUnitsCreateExtensionsExecute(r ApiDirectoryAdministrativeUnitsCreateExtensionsRequest) (MicrosoftGraphExtension, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphExtension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DirectoryAdministrativeUnitApiService.DirectoryAdministrativeUnitsCreateExtensions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/directory/administrativeUnits/{administrativeUnit-id}/extensions"
	localVarPath = strings.Replace(localVarPath, "{"+"administrativeUnit-id"+"}", _neturl.PathEscape(parameterToString(r.administrativeUnitId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphExtension == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphExtension is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphExtension
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDirectoryAdministrativeUnitsCreateRefMembersRequest struct {
	ctx _context.Context
	ApiService *DirectoryAdministrativeUnitApiService
	administrativeUnitId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref value
func (r ApiDirectoryAdministrativeUnitsCreateRefMembersRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiDirectoryAdministrativeUnitsCreateRefMembersRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiDirectoryAdministrativeUnitsCreateRefMembersRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.DirectoryAdministrativeUnitsCreateRefMembersExecute(r)
}

/*
DirectoryAdministrativeUnitsCreateRefMembers Create new navigation property ref to members for directory

Users and groups that are members of this administrative unit. HTTP Methods: GET (list members), POST (add members), DELETE (remove members).

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param administrativeUnitId key: id of administrativeUnit
 @return ApiDirectoryAdministrativeUnitsCreateRefMembersRequest
*/
func (a *DirectoryAdministrativeUnitApiService) DirectoryAdministrativeUnitsCreateRefMembers(ctx _context.Context, administrativeUnitId string) ApiDirectoryAdministrativeUnitsCreateRefMembersRequest {
	return ApiDirectoryAdministrativeUnitsCreateRefMembersRequest{
		ApiService: a,
		ctx: ctx,
		administrativeUnitId: administrativeUnitId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DirectoryAdministrativeUnitApiService) DirectoryAdministrativeUnitsCreateRefMembersExecute(r ApiDirectoryAdministrativeUnitsCreateRefMembersRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DirectoryAdministrativeUnitApiService.DirectoryAdministrativeUnitsCreateRefMembers")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/directory/administrativeUnits/{administrativeUnit-id}/members/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"administrativeUnit-id"+"}", _neturl.PathEscape(parameterToString(r.administrativeUnitId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDirectoryAdministrativeUnitsCreateScopedRoleMembersRequest struct {
	ctx _context.Context
	ApiService *DirectoryAdministrativeUnitApiService
	administrativeUnitId string
	microsoftGraphScopedRoleMembership *MicrosoftGraphScopedRoleMembership
}

// New navigation property
func (r ApiDirectoryAdministrativeUnitsCreateScopedRoleMembersRequest) MicrosoftGraphScopedRoleMembership(microsoftGraphScopedRoleMembership MicrosoftGraphScopedRoleMembership) ApiDirectoryAdministrativeUnitsCreateScopedRoleMembersRequest {
	r.microsoftGraphScopedRoleMembership = &microsoftGraphScopedRoleMembership
	return r
}

func (r ApiDirectoryAdministrativeUnitsCreateScopedRoleMembersRequest) Execute() (MicrosoftGraphScopedRoleMembership, *_nethttp.Response, error) {
	return r.ApiService.DirectoryAdministrativeUnitsCreateScopedRoleMembersExecute(r)
}

/*
DirectoryAdministrativeUnitsCreateScopedRoleMembers Create new navigation property to scopedRoleMembers for directory

Scoped-role members of this administrative unit.  HTTP Methods: GET (list scopedRoleMemberships), POST (add scopedRoleMembership), DELETE (remove scopedRoleMembership).

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param administrativeUnitId key: id of administrativeUnit
 @return ApiDirectoryAdministrativeUnitsCreateScopedRoleMembersRequest
*/
func (a *DirectoryAdministrativeUnitApiService) DirectoryAdministrativeUnitsCreateScopedRoleMembers(ctx _context.Context, administrativeUnitId string) ApiDirectoryAdministrativeUnitsCreateScopedRoleMembersRequest {
	return ApiDirectoryAdministrativeUnitsCreateScopedRoleMembersRequest{
		ApiService: a,
		ctx: ctx,
		administrativeUnitId: administrativeUnitId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphScopedRoleMembership
func (a *DirectoryAdministrativeUnitApiService) DirectoryAdministrativeUnitsCreateScopedRoleMembersExecute(r ApiDirectoryAdministrativeUnitsCreateScopedRoleMembersRequest) (MicrosoftGraphScopedRoleMembership, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphScopedRoleMembership
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DirectoryAdministrativeUnitApiService.DirectoryAdministrativeUnitsCreateScopedRoleMembers")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/directory/administrativeUnits/{administrativeUnit-id}/scopedRoleMembers"
	localVarPath = strings.Replace(localVarPath, "{"+"administrativeUnit-id"+"}", _neturl.PathEscape(parameterToString(r.administrativeUnitId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphScopedRoleMembership == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphScopedRoleMembership is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphScopedRoleMembership
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDirectoryAdministrativeUnitsDeleteExtensionsRequest struct {
	ctx _context.Context
	ApiService *DirectoryAdministrativeUnitApiService
	administrativeUnitId string
	extensionId string
	ifMatch *string
}

// ETag
func (r ApiDirectoryAdministrativeUnitsDeleteExtensionsRequest) IfMatch(ifMatch string) ApiDirectoryAdministrativeUnitsDeleteExtensionsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDirectoryAdministrativeUnitsDeleteExtensionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DirectoryAdministrativeUnitsDeleteExtensionsExecute(r)
}

/*
DirectoryAdministrativeUnitsDeleteExtensions Delete navigation property extensions for directory

The collection of open extensions defined for this administrative unit. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param administrativeUnitId key: id of administrativeUnit
 @param extensionId key: id of extension
 @return ApiDirectoryAdministrativeUnitsDeleteExtensionsRequest
*/
func (a *DirectoryAdministrativeUnitApiService) DirectoryAdministrativeUnitsDeleteExtensions(ctx _context.Context, administrativeUnitId string, extensionId string) ApiDirectoryAdministrativeUnitsDeleteExtensionsRequest {
	return ApiDirectoryAdministrativeUnitsDeleteExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		administrativeUnitId: administrativeUnitId,
		extensionId: extensionId,
	}
}

// Execute executes the request
func (a *DirectoryAdministrativeUnitApiService) DirectoryAdministrativeUnitsDeleteExtensionsExecute(r ApiDirectoryAdministrativeUnitsDeleteExtensionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DirectoryAdministrativeUnitApiService.DirectoryAdministrativeUnitsDeleteExtensions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/directory/administrativeUnits/{administrativeUnit-id}/extensions/{extension-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"administrativeUnit-id"+"}", _neturl.PathEscape(parameterToString(r.administrativeUnitId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension-id"+"}", _neturl.PathEscape(parameterToString(r.extensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDirectoryAdministrativeUnitsDeleteScopedRoleMembersRequest struct {
	ctx _context.Context
	ApiService *DirectoryAdministrativeUnitApiService
	administrativeUnitId string
	scopedRoleMembershipId string
	ifMatch *string
}

// ETag
func (r ApiDirectoryAdministrativeUnitsDeleteScopedRoleMembersRequest) IfMatch(ifMatch string) ApiDirectoryAdministrativeUnitsDeleteScopedRoleMembersRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDirectoryAdministrativeUnitsDeleteScopedRoleMembersRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DirectoryAdministrativeUnitsDeleteScopedRoleMembersExecute(r)
}

/*
DirectoryAdministrativeUnitsDeleteScopedRoleMembers Delete navigation property scopedRoleMembers for directory

Scoped-role members of this administrative unit.  HTTP Methods: GET (list scopedRoleMemberships), POST (add scopedRoleMembership), DELETE (remove scopedRoleMembership).

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param administrativeUnitId key: id of administrativeUnit
 @param scopedRoleMembershipId key: id of scopedRoleMembership
 @return ApiDirectoryAdministrativeUnitsDeleteScopedRoleMembersRequest
*/
func (a *DirectoryAdministrativeUnitApiService) DirectoryAdministrativeUnitsDeleteScopedRoleMembers(ctx _context.Context, administrativeUnitId string, scopedRoleMembershipId string) ApiDirectoryAdministrativeUnitsDeleteScopedRoleMembersRequest {
	return ApiDirectoryAdministrativeUnitsDeleteScopedRoleMembersRequest{
		ApiService: a,
		ctx: ctx,
		administrativeUnitId: administrativeUnitId,
		scopedRoleMembershipId: scopedRoleMembershipId,
	}
}

// Execute executes the request
func (a *DirectoryAdministrativeUnitApiService) DirectoryAdministrativeUnitsDeleteScopedRoleMembersExecute(r ApiDirectoryAdministrativeUnitsDeleteScopedRoleMembersRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DirectoryAdministrativeUnitApiService.DirectoryAdministrativeUnitsDeleteScopedRoleMembers")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/directory/administrativeUnits/{administrativeUnit-id}/scopedRoleMembers/{scopedRoleMembership-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"administrativeUnit-id"+"}", _neturl.PathEscape(parameterToString(r.administrativeUnitId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scopedRoleMembership-id"+"}", _neturl.PathEscape(parameterToString(r.scopedRoleMembershipId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDirectoryAdministrativeUnitsGetExtensionsRequest struct {
	ctx _context.Context
	ApiService *DirectoryAdministrativeUnitApiService
	administrativeUnitId string
	extensionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDirectoryAdministrativeUnitsGetExtensionsRequest) Select_(select_ []string) ApiDirectoryAdministrativeUnitsGetExtensionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDirectoryAdministrativeUnitsGetExtensionsRequest) Expand(expand []string) ApiDirectoryAdministrativeUnitsGetExtensionsRequest {
	r.expand = &expand
	return r
}

func (r ApiDirectoryAdministrativeUnitsGetExtensionsRequest) Execute() (MicrosoftGraphExtension, *_nethttp.Response, error) {
	return r.ApiService.DirectoryAdministrativeUnitsGetExtensionsExecute(r)
}

/*
DirectoryAdministrativeUnitsGetExtensions Get extensions from directory

The collection of open extensions defined for this administrative unit. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param administrativeUnitId key: id of administrativeUnit
 @param extensionId key: id of extension
 @return ApiDirectoryAdministrativeUnitsGetExtensionsRequest
*/
func (a *DirectoryAdministrativeUnitApiService) DirectoryAdministrativeUnitsGetExtensions(ctx _context.Context, administrativeUnitId string, extensionId string) ApiDirectoryAdministrativeUnitsGetExtensionsRequest {
	return ApiDirectoryAdministrativeUnitsGetExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		administrativeUnitId: administrativeUnitId,
		extensionId: extensionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphExtension
func (a *DirectoryAdministrativeUnitApiService) DirectoryAdministrativeUnitsGetExtensionsExecute(r ApiDirectoryAdministrativeUnitsGetExtensionsRequest) (MicrosoftGraphExtension, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphExtension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DirectoryAdministrativeUnitApiService.DirectoryAdministrativeUnitsGetExtensions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/directory/administrativeUnits/{administrativeUnit-id}/extensions/{extension-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"administrativeUnit-id"+"}", _neturl.PathEscape(parameterToString(r.administrativeUnitId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension-id"+"}", _neturl.PathEscape(parameterToString(r.extensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDirectoryAdministrativeUnitsGetScopedRoleMembersRequest struct {
	ctx _context.Context
	ApiService *DirectoryAdministrativeUnitApiService
	administrativeUnitId string
	scopedRoleMembershipId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDirectoryAdministrativeUnitsGetScopedRoleMembersRequest) Select_(select_ []string) ApiDirectoryAdministrativeUnitsGetScopedRoleMembersRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDirectoryAdministrativeUnitsGetScopedRoleMembersRequest) Expand(expand []string) ApiDirectoryAdministrativeUnitsGetScopedRoleMembersRequest {
	r.expand = &expand
	return r
}

func (r ApiDirectoryAdministrativeUnitsGetScopedRoleMembersRequest) Execute() (MicrosoftGraphScopedRoleMembership, *_nethttp.Response, error) {
	return r.ApiService.DirectoryAdministrativeUnitsGetScopedRoleMembersExecute(r)
}

/*
DirectoryAdministrativeUnitsGetScopedRoleMembers Get scopedRoleMembers from directory

Scoped-role members of this administrative unit.  HTTP Methods: GET (list scopedRoleMemberships), POST (add scopedRoleMembership), DELETE (remove scopedRoleMembership).

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param administrativeUnitId key: id of administrativeUnit
 @param scopedRoleMembershipId key: id of scopedRoleMembership
 @return ApiDirectoryAdministrativeUnitsGetScopedRoleMembersRequest
*/
func (a *DirectoryAdministrativeUnitApiService) DirectoryAdministrativeUnitsGetScopedRoleMembers(ctx _context.Context, administrativeUnitId string, scopedRoleMembershipId string) ApiDirectoryAdministrativeUnitsGetScopedRoleMembersRequest {
	return ApiDirectoryAdministrativeUnitsGetScopedRoleMembersRequest{
		ApiService: a,
		ctx: ctx,
		administrativeUnitId: administrativeUnitId,
		scopedRoleMembershipId: scopedRoleMembershipId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphScopedRoleMembership
func (a *DirectoryAdministrativeUnitApiService) DirectoryAdministrativeUnitsGetScopedRoleMembersExecute(r ApiDirectoryAdministrativeUnitsGetScopedRoleMembersRequest) (MicrosoftGraphScopedRoleMembership, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphScopedRoleMembership
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DirectoryAdministrativeUnitApiService.DirectoryAdministrativeUnitsGetScopedRoleMembers")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/directory/administrativeUnits/{administrativeUnit-id}/scopedRoleMembers/{scopedRoleMembership-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"administrativeUnit-id"+"}", _neturl.PathEscape(parameterToString(r.administrativeUnitId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scopedRoleMembership-id"+"}", _neturl.PathEscape(parameterToString(r.scopedRoleMembershipId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDirectoryAdministrativeUnitsListExtensionsRequest struct {
	ctx _context.Context
	ApiService *DirectoryAdministrativeUnitApiService
	administrativeUnitId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiDirectoryAdministrativeUnitsListExtensionsRequest) Top(top int32) ApiDirectoryAdministrativeUnitsListExtensionsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiDirectoryAdministrativeUnitsListExtensionsRequest) Skip(skip int32) ApiDirectoryAdministrativeUnitsListExtensionsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiDirectoryAdministrativeUnitsListExtensionsRequest) Search(search string) ApiDirectoryAdministrativeUnitsListExtensionsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiDirectoryAdministrativeUnitsListExtensionsRequest) Filter(filter string) ApiDirectoryAdministrativeUnitsListExtensionsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiDirectoryAdministrativeUnitsListExtensionsRequest) Count(count bool) ApiDirectoryAdministrativeUnitsListExtensionsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiDirectoryAdministrativeUnitsListExtensionsRequest) Orderby(orderby []string) ApiDirectoryAdministrativeUnitsListExtensionsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiDirectoryAdministrativeUnitsListExtensionsRequest) Select_(select_ []string) ApiDirectoryAdministrativeUnitsListExtensionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDirectoryAdministrativeUnitsListExtensionsRequest) Expand(expand []string) ApiDirectoryAdministrativeUnitsListExtensionsRequest {
	r.expand = &expand
	return r
}

func (r ApiDirectoryAdministrativeUnitsListExtensionsRequest) Execute() (CollectionOfExtension, *_nethttp.Response, error) {
	return r.ApiService.DirectoryAdministrativeUnitsListExtensionsExecute(r)
}

/*
DirectoryAdministrativeUnitsListExtensions Get extensions from directory

The collection of open extensions defined for this administrative unit. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param administrativeUnitId key: id of administrativeUnit
 @return ApiDirectoryAdministrativeUnitsListExtensionsRequest
*/
func (a *DirectoryAdministrativeUnitApiService) DirectoryAdministrativeUnitsListExtensions(ctx _context.Context, administrativeUnitId string) ApiDirectoryAdministrativeUnitsListExtensionsRequest {
	return ApiDirectoryAdministrativeUnitsListExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		administrativeUnitId: administrativeUnitId,
	}
}

// Execute executes the request
//  @return CollectionOfExtension
func (a *DirectoryAdministrativeUnitApiService) DirectoryAdministrativeUnitsListExtensionsExecute(r ApiDirectoryAdministrativeUnitsListExtensionsRequest) (CollectionOfExtension, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfExtension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DirectoryAdministrativeUnitApiService.DirectoryAdministrativeUnitsListExtensions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/directory/administrativeUnits/{administrativeUnit-id}/extensions"
	localVarPath = strings.Replace(localVarPath, "{"+"administrativeUnit-id"+"}", _neturl.PathEscape(parameterToString(r.administrativeUnitId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDirectoryAdministrativeUnitsListMembersRequest struct {
	ctx _context.Context
	ApiService *DirectoryAdministrativeUnitApiService
	administrativeUnitId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiDirectoryAdministrativeUnitsListMembersRequest) Top(top int32) ApiDirectoryAdministrativeUnitsListMembersRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiDirectoryAdministrativeUnitsListMembersRequest) Skip(skip int32) ApiDirectoryAdministrativeUnitsListMembersRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiDirectoryAdministrativeUnitsListMembersRequest) Search(search string) ApiDirectoryAdministrativeUnitsListMembersRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiDirectoryAdministrativeUnitsListMembersRequest) Filter(filter string) ApiDirectoryAdministrativeUnitsListMembersRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiDirectoryAdministrativeUnitsListMembersRequest) Count(count bool) ApiDirectoryAdministrativeUnitsListMembersRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiDirectoryAdministrativeUnitsListMembersRequest) Orderby(orderby []string) ApiDirectoryAdministrativeUnitsListMembersRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiDirectoryAdministrativeUnitsListMembersRequest) Select_(select_ []string) ApiDirectoryAdministrativeUnitsListMembersRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDirectoryAdministrativeUnitsListMembersRequest) Expand(expand []string) ApiDirectoryAdministrativeUnitsListMembersRequest {
	r.expand = &expand
	return r
}

func (r ApiDirectoryAdministrativeUnitsListMembersRequest) Execute() (CollectionOfDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.DirectoryAdministrativeUnitsListMembersExecute(r)
}

/*
DirectoryAdministrativeUnitsListMembers Get members from directory

Users and groups that are members of this administrative unit. HTTP Methods: GET (list members), POST (add members), DELETE (remove members).

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param administrativeUnitId key: id of administrativeUnit
 @return ApiDirectoryAdministrativeUnitsListMembersRequest
*/
func (a *DirectoryAdministrativeUnitApiService) DirectoryAdministrativeUnitsListMembers(ctx _context.Context, administrativeUnitId string) ApiDirectoryAdministrativeUnitsListMembersRequest {
	return ApiDirectoryAdministrativeUnitsListMembersRequest{
		ApiService: a,
		ctx: ctx,
		administrativeUnitId: administrativeUnitId,
	}
}

// Execute executes the request
//  @return CollectionOfDirectoryObject
func (a *DirectoryAdministrativeUnitApiService) DirectoryAdministrativeUnitsListMembersExecute(r ApiDirectoryAdministrativeUnitsListMembersRequest) (CollectionOfDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DirectoryAdministrativeUnitApiService.DirectoryAdministrativeUnitsListMembers")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/directory/administrativeUnits/{administrativeUnit-id}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"administrativeUnit-id"+"}", _neturl.PathEscape(parameterToString(r.administrativeUnitId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDirectoryAdministrativeUnitsListRefMembersRequest struct {
	ctx _context.Context
	ApiService *DirectoryAdministrativeUnitApiService
	administrativeUnitId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
}

// Show only the first n items
func (r ApiDirectoryAdministrativeUnitsListRefMembersRequest) Top(top int32) ApiDirectoryAdministrativeUnitsListRefMembersRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiDirectoryAdministrativeUnitsListRefMembersRequest) Skip(skip int32) ApiDirectoryAdministrativeUnitsListRefMembersRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiDirectoryAdministrativeUnitsListRefMembersRequest) Search(search string) ApiDirectoryAdministrativeUnitsListRefMembersRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiDirectoryAdministrativeUnitsListRefMembersRequest) Filter(filter string) ApiDirectoryAdministrativeUnitsListRefMembersRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiDirectoryAdministrativeUnitsListRefMembersRequest) Count(count bool) ApiDirectoryAdministrativeUnitsListRefMembersRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiDirectoryAdministrativeUnitsListRefMembersRequest) Orderby(orderby []string) ApiDirectoryAdministrativeUnitsListRefMembersRequest {
	r.orderby = &orderby
	return r
}

func (r ApiDirectoryAdministrativeUnitsListRefMembersRequest) Execute() (CollectionOfLinksOfDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.DirectoryAdministrativeUnitsListRefMembersExecute(r)
}

/*
DirectoryAdministrativeUnitsListRefMembers Get ref of members from directory

Users and groups that are members of this administrative unit. HTTP Methods: GET (list members), POST (add members), DELETE (remove members).

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param administrativeUnitId key: id of administrativeUnit
 @return ApiDirectoryAdministrativeUnitsListRefMembersRequest
*/
func (a *DirectoryAdministrativeUnitApiService) DirectoryAdministrativeUnitsListRefMembers(ctx _context.Context, administrativeUnitId string) ApiDirectoryAdministrativeUnitsListRefMembersRequest {
	return ApiDirectoryAdministrativeUnitsListRefMembersRequest{
		ApiService: a,
		ctx: ctx,
		administrativeUnitId: administrativeUnitId,
	}
}

// Execute executes the request
//  @return CollectionOfLinksOfDirectoryObject
func (a *DirectoryAdministrativeUnitApiService) DirectoryAdministrativeUnitsListRefMembersExecute(r ApiDirectoryAdministrativeUnitsListRefMembersRequest) (CollectionOfLinksOfDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfLinksOfDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DirectoryAdministrativeUnitApiService.DirectoryAdministrativeUnitsListRefMembers")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/directory/administrativeUnits/{administrativeUnit-id}/members/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"administrativeUnit-id"+"}", _neturl.PathEscape(parameterToString(r.administrativeUnitId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDirectoryAdministrativeUnitsListScopedRoleMembersRequest struct {
	ctx _context.Context
	ApiService *DirectoryAdministrativeUnitApiService
	administrativeUnitId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiDirectoryAdministrativeUnitsListScopedRoleMembersRequest) Top(top int32) ApiDirectoryAdministrativeUnitsListScopedRoleMembersRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiDirectoryAdministrativeUnitsListScopedRoleMembersRequest) Skip(skip int32) ApiDirectoryAdministrativeUnitsListScopedRoleMembersRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiDirectoryAdministrativeUnitsListScopedRoleMembersRequest) Search(search string) ApiDirectoryAdministrativeUnitsListScopedRoleMembersRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiDirectoryAdministrativeUnitsListScopedRoleMembersRequest) Filter(filter string) ApiDirectoryAdministrativeUnitsListScopedRoleMembersRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiDirectoryAdministrativeUnitsListScopedRoleMembersRequest) Count(count bool) ApiDirectoryAdministrativeUnitsListScopedRoleMembersRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiDirectoryAdministrativeUnitsListScopedRoleMembersRequest) Orderby(orderby []string) ApiDirectoryAdministrativeUnitsListScopedRoleMembersRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiDirectoryAdministrativeUnitsListScopedRoleMembersRequest) Select_(select_ []string) ApiDirectoryAdministrativeUnitsListScopedRoleMembersRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDirectoryAdministrativeUnitsListScopedRoleMembersRequest) Expand(expand []string) ApiDirectoryAdministrativeUnitsListScopedRoleMembersRequest {
	r.expand = &expand
	return r
}

func (r ApiDirectoryAdministrativeUnitsListScopedRoleMembersRequest) Execute() (CollectionOfScopedRoleMembership, *_nethttp.Response, error) {
	return r.ApiService.DirectoryAdministrativeUnitsListScopedRoleMembersExecute(r)
}

/*
DirectoryAdministrativeUnitsListScopedRoleMembers Get scopedRoleMembers from directory

Scoped-role members of this administrative unit.  HTTP Methods: GET (list scopedRoleMemberships), POST (add scopedRoleMembership), DELETE (remove scopedRoleMembership).

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param administrativeUnitId key: id of administrativeUnit
 @return ApiDirectoryAdministrativeUnitsListScopedRoleMembersRequest
*/
func (a *DirectoryAdministrativeUnitApiService) DirectoryAdministrativeUnitsListScopedRoleMembers(ctx _context.Context, administrativeUnitId string) ApiDirectoryAdministrativeUnitsListScopedRoleMembersRequest {
	return ApiDirectoryAdministrativeUnitsListScopedRoleMembersRequest{
		ApiService: a,
		ctx: ctx,
		administrativeUnitId: administrativeUnitId,
	}
}

// Execute executes the request
//  @return CollectionOfScopedRoleMembership
func (a *DirectoryAdministrativeUnitApiService) DirectoryAdministrativeUnitsListScopedRoleMembersExecute(r ApiDirectoryAdministrativeUnitsListScopedRoleMembersRequest) (CollectionOfScopedRoleMembership, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfScopedRoleMembership
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DirectoryAdministrativeUnitApiService.DirectoryAdministrativeUnitsListScopedRoleMembers")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/directory/administrativeUnits/{administrativeUnit-id}/scopedRoleMembers"
	localVarPath = strings.Replace(localVarPath, "{"+"administrativeUnit-id"+"}", _neturl.PathEscape(parameterToString(r.administrativeUnitId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDirectoryAdministrativeUnitsUpdateExtensionsRequest struct {
	ctx _context.Context
	ApiService *DirectoryAdministrativeUnitApiService
	administrativeUnitId string
	extensionId string
	microsoftGraphExtension *MicrosoftGraphExtension
}

// New navigation property values
func (r ApiDirectoryAdministrativeUnitsUpdateExtensionsRequest) MicrosoftGraphExtension(microsoftGraphExtension MicrosoftGraphExtension) ApiDirectoryAdministrativeUnitsUpdateExtensionsRequest {
	r.microsoftGraphExtension = &microsoftGraphExtension
	return r
}

func (r ApiDirectoryAdministrativeUnitsUpdateExtensionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DirectoryAdministrativeUnitsUpdateExtensionsExecute(r)
}

/*
DirectoryAdministrativeUnitsUpdateExtensions Update the navigation property extensions in directory

The collection of open extensions defined for this administrative unit. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param administrativeUnitId key: id of administrativeUnit
 @param extensionId key: id of extension
 @return ApiDirectoryAdministrativeUnitsUpdateExtensionsRequest
*/
func (a *DirectoryAdministrativeUnitApiService) DirectoryAdministrativeUnitsUpdateExtensions(ctx _context.Context, administrativeUnitId string, extensionId string) ApiDirectoryAdministrativeUnitsUpdateExtensionsRequest {
	return ApiDirectoryAdministrativeUnitsUpdateExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		administrativeUnitId: administrativeUnitId,
		extensionId: extensionId,
	}
}

// Execute executes the request
func (a *DirectoryAdministrativeUnitApiService) DirectoryAdministrativeUnitsUpdateExtensionsExecute(r ApiDirectoryAdministrativeUnitsUpdateExtensionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DirectoryAdministrativeUnitApiService.DirectoryAdministrativeUnitsUpdateExtensions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/directory/administrativeUnits/{administrativeUnit-id}/extensions/{extension-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"administrativeUnit-id"+"}", _neturl.PathEscape(parameterToString(r.administrativeUnitId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension-id"+"}", _neturl.PathEscape(parameterToString(r.extensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphExtension == nil {
		return nil, reportError("microsoftGraphExtension is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphExtension
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDirectoryAdministrativeUnitsUpdateScopedRoleMembersRequest struct {
	ctx _context.Context
	ApiService *DirectoryAdministrativeUnitApiService
	administrativeUnitId string
	scopedRoleMembershipId string
	microsoftGraphScopedRoleMembership *MicrosoftGraphScopedRoleMembership
}

// New navigation property values
func (r ApiDirectoryAdministrativeUnitsUpdateScopedRoleMembersRequest) MicrosoftGraphScopedRoleMembership(microsoftGraphScopedRoleMembership MicrosoftGraphScopedRoleMembership) ApiDirectoryAdministrativeUnitsUpdateScopedRoleMembersRequest {
	r.microsoftGraphScopedRoleMembership = &microsoftGraphScopedRoleMembership
	return r
}

func (r ApiDirectoryAdministrativeUnitsUpdateScopedRoleMembersRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DirectoryAdministrativeUnitsUpdateScopedRoleMembersExecute(r)
}

/*
DirectoryAdministrativeUnitsUpdateScopedRoleMembers Update the navigation property scopedRoleMembers in directory

Scoped-role members of this administrative unit.  HTTP Methods: GET (list scopedRoleMemberships), POST (add scopedRoleMembership), DELETE (remove scopedRoleMembership).

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param administrativeUnitId key: id of administrativeUnit
 @param scopedRoleMembershipId key: id of scopedRoleMembership
 @return ApiDirectoryAdministrativeUnitsUpdateScopedRoleMembersRequest
*/
func (a *DirectoryAdministrativeUnitApiService) DirectoryAdministrativeUnitsUpdateScopedRoleMembers(ctx _context.Context, administrativeUnitId string, scopedRoleMembershipId string) ApiDirectoryAdministrativeUnitsUpdateScopedRoleMembersRequest {
	return ApiDirectoryAdministrativeUnitsUpdateScopedRoleMembersRequest{
		ApiService: a,
		ctx: ctx,
		administrativeUnitId: administrativeUnitId,
		scopedRoleMembershipId: scopedRoleMembershipId,
	}
}

// Execute executes the request
func (a *DirectoryAdministrativeUnitApiService) DirectoryAdministrativeUnitsUpdateScopedRoleMembersExecute(r ApiDirectoryAdministrativeUnitsUpdateScopedRoleMembersRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DirectoryAdministrativeUnitApiService.DirectoryAdministrativeUnitsUpdateScopedRoleMembers")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/directory/administrativeUnits/{administrativeUnit-id}/scopedRoleMembers/{scopedRoleMembership-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"administrativeUnit-id"+"}", _neturl.PathEscape(parameterToString(r.administrativeUnitId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scopedRoleMembership-id"+"}", _neturl.PathEscape(parameterToString(r.scopedRoleMembershipId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphScopedRoleMembership == nil {
		return nil, reportError("microsoftGraphScopedRoleMembership is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphScopedRoleMembership
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDirectoryCreateAdministrativeUnitsRequest struct {
	ctx _context.Context
	ApiService *DirectoryAdministrativeUnitApiService
	microsoftGraphAdministrativeUnit *MicrosoftGraphAdministrativeUnit
}

// New navigation property
func (r ApiDirectoryCreateAdministrativeUnitsRequest) MicrosoftGraphAdministrativeUnit(microsoftGraphAdministrativeUnit MicrosoftGraphAdministrativeUnit) ApiDirectoryCreateAdministrativeUnitsRequest {
	r.microsoftGraphAdministrativeUnit = &microsoftGraphAdministrativeUnit
	return r
}

func (r ApiDirectoryCreateAdministrativeUnitsRequest) Execute() (MicrosoftGraphAdministrativeUnit, *_nethttp.Response, error) {
	return r.ApiService.DirectoryCreateAdministrativeUnitsExecute(r)
}

/*
DirectoryCreateAdministrativeUnits Create new navigation property to administrativeUnits for directory

Conceptual container for user and group directory objects.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDirectoryCreateAdministrativeUnitsRequest
*/
func (a *DirectoryAdministrativeUnitApiService) DirectoryCreateAdministrativeUnits(ctx _context.Context) ApiDirectoryCreateAdministrativeUnitsRequest {
	return ApiDirectoryCreateAdministrativeUnitsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphAdministrativeUnit
func (a *DirectoryAdministrativeUnitApiService) DirectoryCreateAdministrativeUnitsExecute(r ApiDirectoryCreateAdministrativeUnitsRequest) (MicrosoftGraphAdministrativeUnit, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphAdministrativeUnit
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DirectoryAdministrativeUnitApiService.DirectoryCreateAdministrativeUnits")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/directory/administrativeUnits"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphAdministrativeUnit == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphAdministrativeUnit is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphAdministrativeUnit
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDirectoryDeleteAdministrativeUnitsRequest struct {
	ctx _context.Context
	ApiService *DirectoryAdministrativeUnitApiService
	administrativeUnitId string
	ifMatch *string
}

// ETag
func (r ApiDirectoryDeleteAdministrativeUnitsRequest) IfMatch(ifMatch string) ApiDirectoryDeleteAdministrativeUnitsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDirectoryDeleteAdministrativeUnitsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DirectoryDeleteAdministrativeUnitsExecute(r)
}

/*
DirectoryDeleteAdministrativeUnits Delete navigation property administrativeUnits for directory

Conceptual container for user and group directory objects.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param administrativeUnitId key: id of administrativeUnit
 @return ApiDirectoryDeleteAdministrativeUnitsRequest
*/
func (a *DirectoryAdministrativeUnitApiService) DirectoryDeleteAdministrativeUnits(ctx _context.Context, administrativeUnitId string) ApiDirectoryDeleteAdministrativeUnitsRequest {
	return ApiDirectoryDeleteAdministrativeUnitsRequest{
		ApiService: a,
		ctx: ctx,
		administrativeUnitId: administrativeUnitId,
	}
}

// Execute executes the request
func (a *DirectoryAdministrativeUnitApiService) DirectoryDeleteAdministrativeUnitsExecute(r ApiDirectoryDeleteAdministrativeUnitsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DirectoryAdministrativeUnitApiService.DirectoryDeleteAdministrativeUnits")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/directory/administrativeUnits/{administrativeUnit-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"administrativeUnit-id"+"}", _neturl.PathEscape(parameterToString(r.administrativeUnitId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDirectoryGetAdministrativeUnitsRequest struct {
	ctx _context.Context
	ApiService *DirectoryAdministrativeUnitApiService
	administrativeUnitId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDirectoryGetAdministrativeUnitsRequest) Select_(select_ []string) ApiDirectoryGetAdministrativeUnitsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDirectoryGetAdministrativeUnitsRequest) Expand(expand []string) ApiDirectoryGetAdministrativeUnitsRequest {
	r.expand = &expand
	return r
}

func (r ApiDirectoryGetAdministrativeUnitsRequest) Execute() (MicrosoftGraphAdministrativeUnit, *_nethttp.Response, error) {
	return r.ApiService.DirectoryGetAdministrativeUnitsExecute(r)
}

/*
DirectoryGetAdministrativeUnits Get administrativeUnits from directory

Conceptual container for user and group directory objects.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param administrativeUnitId key: id of administrativeUnit
 @return ApiDirectoryGetAdministrativeUnitsRequest
*/
func (a *DirectoryAdministrativeUnitApiService) DirectoryGetAdministrativeUnits(ctx _context.Context, administrativeUnitId string) ApiDirectoryGetAdministrativeUnitsRequest {
	return ApiDirectoryGetAdministrativeUnitsRequest{
		ApiService: a,
		ctx: ctx,
		administrativeUnitId: administrativeUnitId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphAdministrativeUnit
func (a *DirectoryAdministrativeUnitApiService) DirectoryGetAdministrativeUnitsExecute(r ApiDirectoryGetAdministrativeUnitsRequest) (MicrosoftGraphAdministrativeUnit, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphAdministrativeUnit
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DirectoryAdministrativeUnitApiService.DirectoryGetAdministrativeUnits")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/directory/administrativeUnits/{administrativeUnit-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"administrativeUnit-id"+"}", _neturl.PathEscape(parameterToString(r.administrativeUnitId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDirectoryListAdministrativeUnitsRequest struct {
	ctx _context.Context
	ApiService *DirectoryAdministrativeUnitApiService
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiDirectoryListAdministrativeUnitsRequest) Top(top int32) ApiDirectoryListAdministrativeUnitsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiDirectoryListAdministrativeUnitsRequest) Skip(skip int32) ApiDirectoryListAdministrativeUnitsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiDirectoryListAdministrativeUnitsRequest) Search(search string) ApiDirectoryListAdministrativeUnitsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiDirectoryListAdministrativeUnitsRequest) Filter(filter string) ApiDirectoryListAdministrativeUnitsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiDirectoryListAdministrativeUnitsRequest) Count(count bool) ApiDirectoryListAdministrativeUnitsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiDirectoryListAdministrativeUnitsRequest) Orderby(orderby []string) ApiDirectoryListAdministrativeUnitsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiDirectoryListAdministrativeUnitsRequest) Select_(select_ []string) ApiDirectoryListAdministrativeUnitsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDirectoryListAdministrativeUnitsRequest) Expand(expand []string) ApiDirectoryListAdministrativeUnitsRequest {
	r.expand = &expand
	return r
}

func (r ApiDirectoryListAdministrativeUnitsRequest) Execute() (CollectionOfAdministrativeUnit, *_nethttp.Response, error) {
	return r.ApiService.DirectoryListAdministrativeUnitsExecute(r)
}

/*
DirectoryListAdministrativeUnits Get administrativeUnits from directory

Conceptual container for user and group directory objects.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDirectoryListAdministrativeUnitsRequest
*/
func (a *DirectoryAdministrativeUnitApiService) DirectoryListAdministrativeUnits(ctx _context.Context) ApiDirectoryListAdministrativeUnitsRequest {
	return ApiDirectoryListAdministrativeUnitsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionOfAdministrativeUnit
func (a *DirectoryAdministrativeUnitApiService) DirectoryListAdministrativeUnitsExecute(r ApiDirectoryListAdministrativeUnitsRequest) (CollectionOfAdministrativeUnit, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfAdministrativeUnit
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DirectoryAdministrativeUnitApiService.DirectoryListAdministrativeUnits")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/directory/administrativeUnits"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDirectoryUpdateAdministrativeUnitsRequest struct {
	ctx _context.Context
	ApiService *DirectoryAdministrativeUnitApiService
	administrativeUnitId string
	microsoftGraphAdministrativeUnit *MicrosoftGraphAdministrativeUnit
}

// New navigation property values
func (r ApiDirectoryUpdateAdministrativeUnitsRequest) MicrosoftGraphAdministrativeUnit(microsoftGraphAdministrativeUnit MicrosoftGraphAdministrativeUnit) ApiDirectoryUpdateAdministrativeUnitsRequest {
	r.microsoftGraphAdministrativeUnit = &microsoftGraphAdministrativeUnit
	return r
}

func (r ApiDirectoryUpdateAdministrativeUnitsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DirectoryUpdateAdministrativeUnitsExecute(r)
}

/*
DirectoryUpdateAdministrativeUnits Update the navigation property administrativeUnits in directory

Conceptual container for user and group directory objects.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param administrativeUnitId key: id of administrativeUnit
 @return ApiDirectoryUpdateAdministrativeUnitsRequest
*/
func (a *DirectoryAdministrativeUnitApiService) DirectoryUpdateAdministrativeUnits(ctx _context.Context, administrativeUnitId string) ApiDirectoryUpdateAdministrativeUnitsRequest {
	return ApiDirectoryUpdateAdministrativeUnitsRequest{
		ApiService: a,
		ctx: ctx,
		administrativeUnitId: administrativeUnitId,
	}
}

// Execute executes the request
func (a *DirectoryAdministrativeUnitApiService) DirectoryUpdateAdministrativeUnitsExecute(r ApiDirectoryUpdateAdministrativeUnitsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DirectoryAdministrativeUnitApiService.DirectoryUpdateAdministrativeUnits")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/directory/administrativeUnits/{administrativeUnit-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"administrativeUnit-id"+"}", _neturl.PathEscape(parameterToString(r.administrativeUnitId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphAdministrativeUnit == nil {
		return nil, reportError("microsoftGraphAdministrativeUnit is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphAdministrativeUnit
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
