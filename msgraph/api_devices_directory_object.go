/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// DevicesDirectoryObjectApiService DevicesDirectoryObjectApi service
type DevicesDirectoryObjectApiService service

type ApiDevicesCreateRefMemberOfRequest struct {
	ctx _context.Context
	ApiService *DevicesDirectoryObjectApiService
	deviceId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref value
func (r ApiDevicesCreateRefMemberOfRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiDevicesCreateRefMemberOfRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiDevicesCreateRefMemberOfRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.DevicesCreateRefMemberOfExecute(r)
}

/*
DevicesCreateRefMemberOf Create new navigation property ref to memberOf for devices

Groups that this device is a member of. Read-only. Nullable. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId key: id of device
 @return ApiDevicesCreateRefMemberOfRequest
*/
func (a *DevicesDirectoryObjectApiService) DevicesCreateRefMemberOf(ctx _context.Context, deviceId string) ApiDevicesCreateRefMemberOfRequest {
	return ApiDevicesCreateRefMemberOfRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DevicesDirectoryObjectApiService) DevicesCreateRefMemberOfExecute(r ApiDevicesCreateRefMemberOfRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevicesDirectoryObjectApiService.DevicesCreateRefMemberOf")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/devices/{device-id}/memberOf/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"device-id"+"}", _neturl.PathEscape(parameterToString(r.deviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDevicesCreateRefRegisteredOwnersRequest struct {
	ctx _context.Context
	ApiService *DevicesDirectoryObjectApiService
	deviceId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref value
func (r ApiDevicesCreateRefRegisteredOwnersRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiDevicesCreateRefRegisteredOwnersRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiDevicesCreateRefRegisteredOwnersRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.DevicesCreateRefRegisteredOwnersExecute(r)
}

/*
DevicesCreateRefRegisteredOwners Create new navigation property ref to registeredOwners for devices

The user that cloud joined the device or registered their personal device. The registered owner is set at the time of registration. Currently, there can be only one owner. Read-only. Nullable. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId key: id of device
 @return ApiDevicesCreateRefRegisteredOwnersRequest
*/
func (a *DevicesDirectoryObjectApiService) DevicesCreateRefRegisteredOwners(ctx _context.Context, deviceId string) ApiDevicesCreateRefRegisteredOwnersRequest {
	return ApiDevicesCreateRefRegisteredOwnersRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DevicesDirectoryObjectApiService) DevicesCreateRefRegisteredOwnersExecute(r ApiDevicesCreateRefRegisteredOwnersRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevicesDirectoryObjectApiService.DevicesCreateRefRegisteredOwners")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/devices/{device-id}/registeredOwners/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"device-id"+"}", _neturl.PathEscape(parameterToString(r.deviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDevicesCreateRefRegisteredUsersRequest struct {
	ctx _context.Context
	ApiService *DevicesDirectoryObjectApiService
	deviceId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref value
func (r ApiDevicesCreateRefRegisteredUsersRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiDevicesCreateRefRegisteredUsersRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiDevicesCreateRefRegisteredUsersRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.DevicesCreateRefRegisteredUsersExecute(r)
}

/*
DevicesCreateRefRegisteredUsers Create new navigation property ref to registeredUsers for devices

Collection of registered users of the device. For cloud joined devices and registered personal devices, registered users are set to the same value as registered owners at the time of registration. Read-only. Nullable. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId key: id of device
 @return ApiDevicesCreateRefRegisteredUsersRequest
*/
func (a *DevicesDirectoryObjectApiService) DevicesCreateRefRegisteredUsers(ctx _context.Context, deviceId string) ApiDevicesCreateRefRegisteredUsersRequest {
	return ApiDevicesCreateRefRegisteredUsersRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DevicesDirectoryObjectApiService) DevicesCreateRefRegisteredUsersExecute(r ApiDevicesCreateRefRegisteredUsersRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevicesDirectoryObjectApiService.DevicesCreateRefRegisteredUsers")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/devices/{device-id}/registeredUsers/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"device-id"+"}", _neturl.PathEscape(parameterToString(r.deviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDevicesCreateRefTransitiveMemberOfRequest struct {
	ctx _context.Context
	ApiService *DevicesDirectoryObjectApiService
	deviceId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref value
func (r ApiDevicesCreateRefTransitiveMemberOfRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiDevicesCreateRefTransitiveMemberOfRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiDevicesCreateRefTransitiveMemberOfRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.DevicesCreateRefTransitiveMemberOfExecute(r)
}

/*
DevicesCreateRefTransitiveMemberOf Create new navigation property ref to transitiveMemberOf for devices

Groups that the device is a member of. This operation is transitive. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId key: id of device
 @return ApiDevicesCreateRefTransitiveMemberOfRequest
*/
func (a *DevicesDirectoryObjectApiService) DevicesCreateRefTransitiveMemberOf(ctx _context.Context, deviceId string) ApiDevicesCreateRefTransitiveMemberOfRequest {
	return ApiDevicesCreateRefTransitiveMemberOfRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DevicesDirectoryObjectApiService) DevicesCreateRefTransitiveMemberOfExecute(r ApiDevicesCreateRefTransitiveMemberOfRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevicesDirectoryObjectApiService.DevicesCreateRefTransitiveMemberOf")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/devices/{device-id}/transitiveMemberOf/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"device-id"+"}", _neturl.PathEscape(parameterToString(r.deviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDevicesListMemberOfRequest struct {
	ctx _context.Context
	ApiService *DevicesDirectoryObjectApiService
	deviceId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiDevicesListMemberOfRequest) Top(top int32) ApiDevicesListMemberOfRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiDevicesListMemberOfRequest) Skip(skip int32) ApiDevicesListMemberOfRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiDevicesListMemberOfRequest) Search(search string) ApiDevicesListMemberOfRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiDevicesListMemberOfRequest) Filter(filter string) ApiDevicesListMemberOfRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiDevicesListMemberOfRequest) Count(count bool) ApiDevicesListMemberOfRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiDevicesListMemberOfRequest) Orderby(orderby []string) ApiDevicesListMemberOfRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiDevicesListMemberOfRequest) Select_(select_ []string) ApiDevicesListMemberOfRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDevicesListMemberOfRequest) Expand(expand []string) ApiDevicesListMemberOfRequest {
	r.expand = &expand
	return r
}

func (r ApiDevicesListMemberOfRequest) Execute() (CollectionOfDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.DevicesListMemberOfExecute(r)
}

/*
DevicesListMemberOf Get memberOf from devices

Groups that this device is a member of. Read-only. Nullable. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId key: id of device
 @return ApiDevicesListMemberOfRequest
*/
func (a *DevicesDirectoryObjectApiService) DevicesListMemberOf(ctx _context.Context, deviceId string) ApiDevicesListMemberOfRequest {
	return ApiDevicesListMemberOfRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return CollectionOfDirectoryObject
func (a *DevicesDirectoryObjectApiService) DevicesListMemberOfExecute(r ApiDevicesListMemberOfRequest) (CollectionOfDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevicesDirectoryObjectApiService.DevicesListMemberOf")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/devices/{device-id}/memberOf"
	localVarPath = strings.Replace(localVarPath, "{"+"device-id"+"}", _neturl.PathEscape(parameterToString(r.deviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDevicesListRefMemberOfRequest struct {
	ctx _context.Context
	ApiService *DevicesDirectoryObjectApiService
	deviceId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
}

// Show only the first n items
func (r ApiDevicesListRefMemberOfRequest) Top(top int32) ApiDevicesListRefMemberOfRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiDevicesListRefMemberOfRequest) Skip(skip int32) ApiDevicesListRefMemberOfRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiDevicesListRefMemberOfRequest) Search(search string) ApiDevicesListRefMemberOfRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiDevicesListRefMemberOfRequest) Filter(filter string) ApiDevicesListRefMemberOfRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiDevicesListRefMemberOfRequest) Count(count bool) ApiDevicesListRefMemberOfRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiDevicesListRefMemberOfRequest) Orderby(orderby []string) ApiDevicesListRefMemberOfRequest {
	r.orderby = &orderby
	return r
}

func (r ApiDevicesListRefMemberOfRequest) Execute() (CollectionOfLinksOfDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.DevicesListRefMemberOfExecute(r)
}

/*
DevicesListRefMemberOf Get ref of memberOf from devices

Groups that this device is a member of. Read-only. Nullable. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId key: id of device
 @return ApiDevicesListRefMemberOfRequest
*/
func (a *DevicesDirectoryObjectApiService) DevicesListRefMemberOf(ctx _context.Context, deviceId string) ApiDevicesListRefMemberOfRequest {
	return ApiDevicesListRefMemberOfRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return CollectionOfLinksOfDirectoryObject
func (a *DevicesDirectoryObjectApiService) DevicesListRefMemberOfExecute(r ApiDevicesListRefMemberOfRequest) (CollectionOfLinksOfDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfLinksOfDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevicesDirectoryObjectApiService.DevicesListRefMemberOf")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/devices/{device-id}/memberOf/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"device-id"+"}", _neturl.PathEscape(parameterToString(r.deviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDevicesListRefRegisteredOwnersRequest struct {
	ctx _context.Context
	ApiService *DevicesDirectoryObjectApiService
	deviceId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
}

// Show only the first n items
func (r ApiDevicesListRefRegisteredOwnersRequest) Top(top int32) ApiDevicesListRefRegisteredOwnersRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiDevicesListRefRegisteredOwnersRequest) Skip(skip int32) ApiDevicesListRefRegisteredOwnersRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiDevicesListRefRegisteredOwnersRequest) Search(search string) ApiDevicesListRefRegisteredOwnersRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiDevicesListRefRegisteredOwnersRequest) Filter(filter string) ApiDevicesListRefRegisteredOwnersRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiDevicesListRefRegisteredOwnersRequest) Count(count bool) ApiDevicesListRefRegisteredOwnersRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiDevicesListRefRegisteredOwnersRequest) Orderby(orderby []string) ApiDevicesListRefRegisteredOwnersRequest {
	r.orderby = &orderby
	return r
}

func (r ApiDevicesListRefRegisteredOwnersRequest) Execute() (CollectionOfLinksOfDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.DevicesListRefRegisteredOwnersExecute(r)
}

/*
DevicesListRefRegisteredOwners Get ref of registeredOwners from devices

The user that cloud joined the device or registered their personal device. The registered owner is set at the time of registration. Currently, there can be only one owner. Read-only. Nullable. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId key: id of device
 @return ApiDevicesListRefRegisteredOwnersRequest
*/
func (a *DevicesDirectoryObjectApiService) DevicesListRefRegisteredOwners(ctx _context.Context, deviceId string) ApiDevicesListRefRegisteredOwnersRequest {
	return ApiDevicesListRefRegisteredOwnersRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return CollectionOfLinksOfDirectoryObject
func (a *DevicesDirectoryObjectApiService) DevicesListRefRegisteredOwnersExecute(r ApiDevicesListRefRegisteredOwnersRequest) (CollectionOfLinksOfDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfLinksOfDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevicesDirectoryObjectApiService.DevicesListRefRegisteredOwners")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/devices/{device-id}/registeredOwners/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"device-id"+"}", _neturl.PathEscape(parameterToString(r.deviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDevicesListRefRegisteredUsersRequest struct {
	ctx _context.Context
	ApiService *DevicesDirectoryObjectApiService
	deviceId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
}

// Show only the first n items
func (r ApiDevicesListRefRegisteredUsersRequest) Top(top int32) ApiDevicesListRefRegisteredUsersRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiDevicesListRefRegisteredUsersRequest) Skip(skip int32) ApiDevicesListRefRegisteredUsersRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiDevicesListRefRegisteredUsersRequest) Search(search string) ApiDevicesListRefRegisteredUsersRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiDevicesListRefRegisteredUsersRequest) Filter(filter string) ApiDevicesListRefRegisteredUsersRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiDevicesListRefRegisteredUsersRequest) Count(count bool) ApiDevicesListRefRegisteredUsersRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiDevicesListRefRegisteredUsersRequest) Orderby(orderby []string) ApiDevicesListRefRegisteredUsersRequest {
	r.orderby = &orderby
	return r
}

func (r ApiDevicesListRefRegisteredUsersRequest) Execute() (CollectionOfLinksOfDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.DevicesListRefRegisteredUsersExecute(r)
}

/*
DevicesListRefRegisteredUsers Get ref of registeredUsers from devices

Collection of registered users of the device. For cloud joined devices and registered personal devices, registered users are set to the same value as registered owners at the time of registration. Read-only. Nullable. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId key: id of device
 @return ApiDevicesListRefRegisteredUsersRequest
*/
func (a *DevicesDirectoryObjectApiService) DevicesListRefRegisteredUsers(ctx _context.Context, deviceId string) ApiDevicesListRefRegisteredUsersRequest {
	return ApiDevicesListRefRegisteredUsersRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return CollectionOfLinksOfDirectoryObject
func (a *DevicesDirectoryObjectApiService) DevicesListRefRegisteredUsersExecute(r ApiDevicesListRefRegisteredUsersRequest) (CollectionOfLinksOfDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfLinksOfDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevicesDirectoryObjectApiService.DevicesListRefRegisteredUsers")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/devices/{device-id}/registeredUsers/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"device-id"+"}", _neturl.PathEscape(parameterToString(r.deviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDevicesListRefTransitiveMemberOfRequest struct {
	ctx _context.Context
	ApiService *DevicesDirectoryObjectApiService
	deviceId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
}

// Show only the first n items
func (r ApiDevicesListRefTransitiveMemberOfRequest) Top(top int32) ApiDevicesListRefTransitiveMemberOfRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiDevicesListRefTransitiveMemberOfRequest) Skip(skip int32) ApiDevicesListRefTransitiveMemberOfRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiDevicesListRefTransitiveMemberOfRequest) Search(search string) ApiDevicesListRefTransitiveMemberOfRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiDevicesListRefTransitiveMemberOfRequest) Filter(filter string) ApiDevicesListRefTransitiveMemberOfRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiDevicesListRefTransitiveMemberOfRequest) Count(count bool) ApiDevicesListRefTransitiveMemberOfRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiDevicesListRefTransitiveMemberOfRequest) Orderby(orderby []string) ApiDevicesListRefTransitiveMemberOfRequest {
	r.orderby = &orderby
	return r
}

func (r ApiDevicesListRefTransitiveMemberOfRequest) Execute() (CollectionOfLinksOfDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.DevicesListRefTransitiveMemberOfExecute(r)
}

/*
DevicesListRefTransitiveMemberOf Get ref of transitiveMemberOf from devices

Groups that the device is a member of. This operation is transitive. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId key: id of device
 @return ApiDevicesListRefTransitiveMemberOfRequest
*/
func (a *DevicesDirectoryObjectApiService) DevicesListRefTransitiveMemberOf(ctx _context.Context, deviceId string) ApiDevicesListRefTransitiveMemberOfRequest {
	return ApiDevicesListRefTransitiveMemberOfRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return CollectionOfLinksOfDirectoryObject
func (a *DevicesDirectoryObjectApiService) DevicesListRefTransitiveMemberOfExecute(r ApiDevicesListRefTransitiveMemberOfRequest) (CollectionOfLinksOfDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfLinksOfDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevicesDirectoryObjectApiService.DevicesListRefTransitiveMemberOf")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/devices/{device-id}/transitiveMemberOf/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"device-id"+"}", _neturl.PathEscape(parameterToString(r.deviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDevicesListRegisteredOwnersRequest struct {
	ctx _context.Context
	ApiService *DevicesDirectoryObjectApiService
	deviceId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiDevicesListRegisteredOwnersRequest) Top(top int32) ApiDevicesListRegisteredOwnersRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiDevicesListRegisteredOwnersRequest) Skip(skip int32) ApiDevicesListRegisteredOwnersRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiDevicesListRegisteredOwnersRequest) Search(search string) ApiDevicesListRegisteredOwnersRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiDevicesListRegisteredOwnersRequest) Filter(filter string) ApiDevicesListRegisteredOwnersRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiDevicesListRegisteredOwnersRequest) Count(count bool) ApiDevicesListRegisteredOwnersRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiDevicesListRegisteredOwnersRequest) Orderby(orderby []string) ApiDevicesListRegisteredOwnersRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiDevicesListRegisteredOwnersRequest) Select_(select_ []string) ApiDevicesListRegisteredOwnersRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDevicesListRegisteredOwnersRequest) Expand(expand []string) ApiDevicesListRegisteredOwnersRequest {
	r.expand = &expand
	return r
}

func (r ApiDevicesListRegisteredOwnersRequest) Execute() (CollectionOfDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.DevicesListRegisteredOwnersExecute(r)
}

/*
DevicesListRegisteredOwners Get registeredOwners from devices

The user that cloud joined the device or registered their personal device. The registered owner is set at the time of registration. Currently, there can be only one owner. Read-only. Nullable. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId key: id of device
 @return ApiDevicesListRegisteredOwnersRequest
*/
func (a *DevicesDirectoryObjectApiService) DevicesListRegisteredOwners(ctx _context.Context, deviceId string) ApiDevicesListRegisteredOwnersRequest {
	return ApiDevicesListRegisteredOwnersRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return CollectionOfDirectoryObject
func (a *DevicesDirectoryObjectApiService) DevicesListRegisteredOwnersExecute(r ApiDevicesListRegisteredOwnersRequest) (CollectionOfDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevicesDirectoryObjectApiService.DevicesListRegisteredOwners")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/devices/{device-id}/registeredOwners"
	localVarPath = strings.Replace(localVarPath, "{"+"device-id"+"}", _neturl.PathEscape(parameterToString(r.deviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDevicesListRegisteredUsersRequest struct {
	ctx _context.Context
	ApiService *DevicesDirectoryObjectApiService
	deviceId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiDevicesListRegisteredUsersRequest) Top(top int32) ApiDevicesListRegisteredUsersRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiDevicesListRegisteredUsersRequest) Skip(skip int32) ApiDevicesListRegisteredUsersRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiDevicesListRegisteredUsersRequest) Search(search string) ApiDevicesListRegisteredUsersRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiDevicesListRegisteredUsersRequest) Filter(filter string) ApiDevicesListRegisteredUsersRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiDevicesListRegisteredUsersRequest) Count(count bool) ApiDevicesListRegisteredUsersRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiDevicesListRegisteredUsersRequest) Orderby(orderby []string) ApiDevicesListRegisteredUsersRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiDevicesListRegisteredUsersRequest) Select_(select_ []string) ApiDevicesListRegisteredUsersRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDevicesListRegisteredUsersRequest) Expand(expand []string) ApiDevicesListRegisteredUsersRequest {
	r.expand = &expand
	return r
}

func (r ApiDevicesListRegisteredUsersRequest) Execute() (CollectionOfDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.DevicesListRegisteredUsersExecute(r)
}

/*
DevicesListRegisteredUsers Get registeredUsers from devices

Collection of registered users of the device. For cloud joined devices and registered personal devices, registered users are set to the same value as registered owners at the time of registration. Read-only. Nullable. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId key: id of device
 @return ApiDevicesListRegisteredUsersRequest
*/
func (a *DevicesDirectoryObjectApiService) DevicesListRegisteredUsers(ctx _context.Context, deviceId string) ApiDevicesListRegisteredUsersRequest {
	return ApiDevicesListRegisteredUsersRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return CollectionOfDirectoryObject
func (a *DevicesDirectoryObjectApiService) DevicesListRegisteredUsersExecute(r ApiDevicesListRegisteredUsersRequest) (CollectionOfDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevicesDirectoryObjectApiService.DevicesListRegisteredUsers")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/devices/{device-id}/registeredUsers"
	localVarPath = strings.Replace(localVarPath, "{"+"device-id"+"}", _neturl.PathEscape(parameterToString(r.deviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDevicesListTransitiveMemberOfRequest struct {
	ctx _context.Context
	ApiService *DevicesDirectoryObjectApiService
	deviceId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiDevicesListTransitiveMemberOfRequest) Top(top int32) ApiDevicesListTransitiveMemberOfRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiDevicesListTransitiveMemberOfRequest) Skip(skip int32) ApiDevicesListTransitiveMemberOfRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiDevicesListTransitiveMemberOfRequest) Search(search string) ApiDevicesListTransitiveMemberOfRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiDevicesListTransitiveMemberOfRequest) Filter(filter string) ApiDevicesListTransitiveMemberOfRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiDevicesListTransitiveMemberOfRequest) Count(count bool) ApiDevicesListTransitiveMemberOfRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiDevicesListTransitiveMemberOfRequest) Orderby(orderby []string) ApiDevicesListTransitiveMemberOfRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiDevicesListTransitiveMemberOfRequest) Select_(select_ []string) ApiDevicesListTransitiveMemberOfRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDevicesListTransitiveMemberOfRequest) Expand(expand []string) ApiDevicesListTransitiveMemberOfRequest {
	r.expand = &expand
	return r
}

func (r ApiDevicesListTransitiveMemberOfRequest) Execute() (CollectionOfDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.DevicesListTransitiveMemberOfExecute(r)
}

/*
DevicesListTransitiveMemberOf Get transitiveMemberOf from devices

Groups that the device is a member of. This operation is transitive. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId key: id of device
 @return ApiDevicesListTransitiveMemberOfRequest
*/
func (a *DevicesDirectoryObjectApiService) DevicesListTransitiveMemberOf(ctx _context.Context, deviceId string) ApiDevicesListTransitiveMemberOfRequest {
	return ApiDevicesListTransitiveMemberOfRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return CollectionOfDirectoryObject
func (a *DevicesDirectoryObjectApiService) DevicesListTransitiveMemberOfExecute(r ApiDevicesListTransitiveMemberOfRequest) (CollectionOfDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevicesDirectoryObjectApiService.DevicesListTransitiveMemberOf")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/devices/{device-id}/transitiveMemberOf"
	localVarPath = strings.Replace(localVarPath, "{"+"device-id"+"}", _neturl.PathEscape(parameterToString(r.deviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
