/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// EducationEducationUserApiService EducationEducationUserApi service
type EducationEducationUserApiService service

type ApiEducationCreateUsersRequest struct {
	ctx _context.Context
	ApiService *EducationEducationUserApiService
	microsoftGraphEducationUser *MicrosoftGraphEducationUser
}

// New navigation property
func (r ApiEducationCreateUsersRequest) MicrosoftGraphEducationUser(microsoftGraphEducationUser MicrosoftGraphEducationUser) ApiEducationCreateUsersRequest {
	r.microsoftGraphEducationUser = &microsoftGraphEducationUser
	return r
}

func (r ApiEducationCreateUsersRequest) Execute() (MicrosoftGraphEducationUser, *_nethttp.Response, error) {
	return r.ApiService.EducationCreateUsersExecute(r)
}

/*
EducationCreateUsers Create new navigation property to users for education

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEducationCreateUsersRequest
*/
func (a *EducationEducationUserApiService) EducationCreateUsers(ctx _context.Context) ApiEducationCreateUsersRequest {
	return ApiEducationCreateUsersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEducationUser
func (a *EducationEducationUserApiService) EducationCreateUsersExecute(r ApiEducationCreateUsersRequest) (MicrosoftGraphEducationUser, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEducationUser
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationUserApiService.EducationCreateUsers")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphEducationUser == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphEducationUser is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphEducationUser
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEducationDeleteMeRequest struct {
	ctx _context.Context
	ApiService *EducationEducationUserApiService
	ifMatch *string
}

// ETag
func (r ApiEducationDeleteMeRequest) IfMatch(ifMatch string) ApiEducationDeleteMeRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiEducationDeleteMeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.EducationDeleteMeExecute(r)
}

/*
EducationDeleteMe Delete navigation property me for education

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEducationDeleteMeRequest
*/
func (a *EducationEducationUserApiService) EducationDeleteMe(ctx _context.Context) ApiEducationDeleteMeRequest {
	return ApiEducationDeleteMeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EducationEducationUserApiService) EducationDeleteMeExecute(r ApiEducationDeleteMeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationUserApiService.EducationDeleteMe")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/me"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEducationDeleteUsersRequest struct {
	ctx _context.Context
	ApiService *EducationEducationUserApiService
	educationUserId string
	ifMatch *string
}

// ETag
func (r ApiEducationDeleteUsersRequest) IfMatch(ifMatch string) ApiEducationDeleteUsersRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiEducationDeleteUsersRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.EducationDeleteUsersExecute(r)
}

/*
EducationDeleteUsers Delete navigation property users for education

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param educationUserId key: id of educationUser
 @return ApiEducationDeleteUsersRequest
*/
func (a *EducationEducationUserApiService) EducationDeleteUsers(ctx _context.Context, educationUserId string) ApiEducationDeleteUsersRequest {
	return ApiEducationDeleteUsersRequest{
		ApiService: a,
		ctx: ctx,
		educationUserId: educationUserId,
	}
}

// Execute executes the request
func (a *EducationEducationUserApiService) EducationDeleteUsersExecute(r ApiEducationDeleteUsersRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationUserApiService.EducationDeleteUsers")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/users/{educationUser-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"educationUser-id"+"}", _neturl.PathEscape(parameterToString(r.educationUserId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEducationGetMeRequest struct {
	ctx _context.Context
	ApiService *EducationEducationUserApiService
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiEducationGetMeRequest) Select_(select_ []string) ApiEducationGetMeRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiEducationGetMeRequest) Expand(expand []string) ApiEducationGetMeRequest {
	r.expand = &expand
	return r
}

func (r ApiEducationGetMeRequest) Execute() (MicrosoftGraphEducationUser, *_nethttp.Response, error) {
	return r.ApiService.EducationGetMeExecute(r)
}

/*
EducationGetMe Get me from education

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEducationGetMeRequest
*/
func (a *EducationEducationUserApiService) EducationGetMe(ctx _context.Context) ApiEducationGetMeRequest {
	return ApiEducationGetMeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEducationUser
func (a *EducationEducationUserApiService) EducationGetMeExecute(r ApiEducationGetMeRequest) (MicrosoftGraphEducationUser, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEducationUser
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationUserApiService.EducationGetMe")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/me"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEducationGetUsersRequest struct {
	ctx _context.Context
	ApiService *EducationEducationUserApiService
	educationUserId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiEducationGetUsersRequest) Select_(select_ []string) ApiEducationGetUsersRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiEducationGetUsersRequest) Expand(expand []string) ApiEducationGetUsersRequest {
	r.expand = &expand
	return r
}

func (r ApiEducationGetUsersRequest) Execute() (MicrosoftGraphEducationUser, *_nethttp.Response, error) {
	return r.ApiService.EducationGetUsersExecute(r)
}

/*
EducationGetUsers Get users from education

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param educationUserId key: id of educationUser
 @return ApiEducationGetUsersRequest
*/
func (a *EducationEducationUserApiService) EducationGetUsers(ctx _context.Context, educationUserId string) ApiEducationGetUsersRequest {
	return ApiEducationGetUsersRequest{
		ApiService: a,
		ctx: ctx,
		educationUserId: educationUserId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEducationUser
func (a *EducationEducationUserApiService) EducationGetUsersExecute(r ApiEducationGetUsersRequest) (MicrosoftGraphEducationUser, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEducationUser
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationUserApiService.EducationGetUsers")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/users/{educationUser-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"educationUser-id"+"}", _neturl.PathEscape(parameterToString(r.educationUserId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEducationListUsersRequest struct {
	ctx _context.Context
	ApiService *EducationEducationUserApiService
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiEducationListUsersRequest) Top(top int32) ApiEducationListUsersRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiEducationListUsersRequest) Skip(skip int32) ApiEducationListUsersRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiEducationListUsersRequest) Search(search string) ApiEducationListUsersRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiEducationListUsersRequest) Filter(filter string) ApiEducationListUsersRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiEducationListUsersRequest) Count(count bool) ApiEducationListUsersRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiEducationListUsersRequest) Orderby(orderby []string) ApiEducationListUsersRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiEducationListUsersRequest) Select_(select_ []string) ApiEducationListUsersRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiEducationListUsersRequest) Expand(expand []string) ApiEducationListUsersRequest {
	r.expand = &expand
	return r
}

func (r ApiEducationListUsersRequest) Execute() (CollectionOfEducationUser, *_nethttp.Response, error) {
	return r.ApiService.EducationListUsersExecute(r)
}

/*
EducationListUsers Get users from education

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEducationListUsersRequest
*/
func (a *EducationEducationUserApiService) EducationListUsers(ctx _context.Context) ApiEducationListUsersRequest {
	return ApiEducationListUsersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionOfEducationUser
func (a *EducationEducationUserApiService) EducationListUsersExecute(r ApiEducationListUsersRequest) (CollectionOfEducationUser, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfEducationUser
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationUserApiService.EducationListUsers")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEducationMeCreateRefClassesRequest struct {
	ctx _context.Context
	ApiService *EducationEducationUserApiService
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref value
func (r ApiEducationMeCreateRefClassesRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiEducationMeCreateRefClassesRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiEducationMeCreateRefClassesRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.EducationMeCreateRefClassesExecute(r)
}

/*
EducationMeCreateRefClasses Create new navigation property ref to classes for education

Classes to which the user belongs. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEducationMeCreateRefClassesRequest
*/
func (a *EducationEducationUserApiService) EducationMeCreateRefClasses(ctx _context.Context) ApiEducationMeCreateRefClassesRequest {
	return ApiEducationMeCreateRefClassesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *EducationEducationUserApiService) EducationMeCreateRefClassesExecute(r ApiEducationMeCreateRefClassesRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationUserApiService.EducationMeCreateRefClasses")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/me/classes/$ref"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEducationMeCreateRefSchoolsRequest struct {
	ctx _context.Context
	ApiService *EducationEducationUserApiService
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref value
func (r ApiEducationMeCreateRefSchoolsRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiEducationMeCreateRefSchoolsRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiEducationMeCreateRefSchoolsRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.EducationMeCreateRefSchoolsExecute(r)
}

/*
EducationMeCreateRefSchools Create new navigation property ref to schools for education

Schools to which the user belongs. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEducationMeCreateRefSchoolsRequest
*/
func (a *EducationEducationUserApiService) EducationMeCreateRefSchools(ctx _context.Context) ApiEducationMeCreateRefSchoolsRequest {
	return ApiEducationMeCreateRefSchoolsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *EducationEducationUserApiService) EducationMeCreateRefSchoolsExecute(r ApiEducationMeCreateRefSchoolsRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationUserApiService.EducationMeCreateRefSchools")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/me/schools/$ref"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEducationMeCreateRefTaughtClassesRequest struct {
	ctx _context.Context
	ApiService *EducationEducationUserApiService
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref value
func (r ApiEducationMeCreateRefTaughtClassesRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiEducationMeCreateRefTaughtClassesRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiEducationMeCreateRefTaughtClassesRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.EducationMeCreateRefTaughtClassesExecute(r)
}

/*
EducationMeCreateRefTaughtClasses Create new navigation property ref to taughtClasses for education

Classes for which the user is a teacher.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEducationMeCreateRefTaughtClassesRequest
*/
func (a *EducationEducationUserApiService) EducationMeCreateRefTaughtClasses(ctx _context.Context) ApiEducationMeCreateRefTaughtClassesRequest {
	return ApiEducationMeCreateRefTaughtClassesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *EducationEducationUserApiService) EducationMeCreateRefTaughtClassesExecute(r ApiEducationMeCreateRefTaughtClassesRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationUserApiService.EducationMeCreateRefTaughtClasses")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/me/taughtClasses/$ref"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEducationMeCreateRubricsRequest struct {
	ctx _context.Context
	ApiService *EducationEducationUserApiService
	microsoftGraphEducationRubric *MicrosoftGraphEducationRubric
}

// New navigation property
func (r ApiEducationMeCreateRubricsRequest) MicrosoftGraphEducationRubric(microsoftGraphEducationRubric MicrosoftGraphEducationRubric) ApiEducationMeCreateRubricsRequest {
	r.microsoftGraphEducationRubric = &microsoftGraphEducationRubric
	return r
}

func (r ApiEducationMeCreateRubricsRequest) Execute() (MicrosoftGraphEducationRubric, *_nethttp.Response, error) {
	return r.ApiService.EducationMeCreateRubricsExecute(r)
}

/*
EducationMeCreateRubrics Create new navigation property to rubrics for education

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEducationMeCreateRubricsRequest
*/
func (a *EducationEducationUserApiService) EducationMeCreateRubrics(ctx _context.Context) ApiEducationMeCreateRubricsRequest {
	return ApiEducationMeCreateRubricsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEducationRubric
func (a *EducationEducationUserApiService) EducationMeCreateRubricsExecute(r ApiEducationMeCreateRubricsRequest) (MicrosoftGraphEducationRubric, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEducationRubric
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationUserApiService.EducationMeCreateRubrics")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/me/rubrics"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphEducationRubric == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphEducationRubric is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphEducationRubric
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEducationMeDeleteRefUserRequest struct {
	ctx _context.Context
	ApiService *EducationEducationUserApiService
	ifMatch *string
}

// ETag
func (r ApiEducationMeDeleteRefUserRequest) IfMatch(ifMatch string) ApiEducationMeDeleteRefUserRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiEducationMeDeleteRefUserRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.EducationMeDeleteRefUserExecute(r)
}

/*
EducationMeDeleteRefUser Delete ref of navigation property user for education

The directory user corresponding to this user.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEducationMeDeleteRefUserRequest
*/
func (a *EducationEducationUserApiService) EducationMeDeleteRefUser(ctx _context.Context) ApiEducationMeDeleteRefUserRequest {
	return ApiEducationMeDeleteRefUserRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EducationEducationUserApiService) EducationMeDeleteRefUserExecute(r ApiEducationMeDeleteRefUserRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationUserApiService.EducationMeDeleteRefUser")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/me/user/$ref"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEducationMeDeleteRubricsRequest struct {
	ctx _context.Context
	ApiService *EducationEducationUserApiService
	educationRubricId string
	ifMatch *string
}

// ETag
func (r ApiEducationMeDeleteRubricsRequest) IfMatch(ifMatch string) ApiEducationMeDeleteRubricsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiEducationMeDeleteRubricsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.EducationMeDeleteRubricsExecute(r)
}

/*
EducationMeDeleteRubrics Delete navigation property rubrics for education

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param educationRubricId key: id of educationRubric
 @return ApiEducationMeDeleteRubricsRequest
*/
func (a *EducationEducationUserApiService) EducationMeDeleteRubrics(ctx _context.Context, educationRubricId string) ApiEducationMeDeleteRubricsRequest {
	return ApiEducationMeDeleteRubricsRequest{
		ApiService: a,
		ctx: ctx,
		educationRubricId: educationRubricId,
	}
}

// Execute executes the request
func (a *EducationEducationUserApiService) EducationMeDeleteRubricsExecute(r ApiEducationMeDeleteRubricsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationUserApiService.EducationMeDeleteRubrics")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/me/rubrics/{educationRubric-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"educationRubric-id"+"}", _neturl.PathEscape(parameterToString(r.educationRubricId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEducationMeGetRefUserRequest struct {
	ctx _context.Context
	ApiService *EducationEducationUserApiService
}


func (r ApiEducationMeGetRefUserRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.EducationMeGetRefUserExecute(r)
}

/*
EducationMeGetRefUser Get ref of user from education

The directory user corresponding to this user.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEducationMeGetRefUserRequest
*/
func (a *EducationEducationUserApiService) EducationMeGetRefUser(ctx _context.Context) ApiEducationMeGetRefUserRequest {
	return ApiEducationMeGetRefUserRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *EducationEducationUserApiService) EducationMeGetRefUserExecute(r ApiEducationMeGetRefUserRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationUserApiService.EducationMeGetRefUser")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/me/user/$ref"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEducationMeGetRubricsRequest struct {
	ctx _context.Context
	ApiService *EducationEducationUserApiService
	educationRubricId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiEducationMeGetRubricsRequest) Select_(select_ []string) ApiEducationMeGetRubricsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiEducationMeGetRubricsRequest) Expand(expand []string) ApiEducationMeGetRubricsRequest {
	r.expand = &expand
	return r
}

func (r ApiEducationMeGetRubricsRequest) Execute() (MicrosoftGraphEducationRubric, *_nethttp.Response, error) {
	return r.ApiService.EducationMeGetRubricsExecute(r)
}

/*
EducationMeGetRubrics Get rubrics from education

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param educationRubricId key: id of educationRubric
 @return ApiEducationMeGetRubricsRequest
*/
func (a *EducationEducationUserApiService) EducationMeGetRubrics(ctx _context.Context, educationRubricId string) ApiEducationMeGetRubricsRequest {
	return ApiEducationMeGetRubricsRequest{
		ApiService: a,
		ctx: ctx,
		educationRubricId: educationRubricId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEducationRubric
func (a *EducationEducationUserApiService) EducationMeGetRubricsExecute(r ApiEducationMeGetRubricsRequest) (MicrosoftGraphEducationRubric, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEducationRubric
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationUserApiService.EducationMeGetRubrics")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/me/rubrics/{educationRubric-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"educationRubric-id"+"}", _neturl.PathEscape(parameterToString(r.educationRubricId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEducationMeGetUserRequest struct {
	ctx _context.Context
	ApiService *EducationEducationUserApiService
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiEducationMeGetUserRequest) Select_(select_ []string) ApiEducationMeGetUserRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiEducationMeGetUserRequest) Expand(expand []string) ApiEducationMeGetUserRequest {
	r.expand = &expand
	return r
}

func (r ApiEducationMeGetUserRequest) Execute() (MicrosoftGraphUser, *_nethttp.Response, error) {
	return r.ApiService.EducationMeGetUserExecute(r)
}

/*
EducationMeGetUser Get user from education

The directory user corresponding to this user.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEducationMeGetUserRequest
*/
func (a *EducationEducationUserApiService) EducationMeGetUser(ctx _context.Context) ApiEducationMeGetUserRequest {
	return ApiEducationMeGetUserRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MicrosoftGraphUser
func (a *EducationEducationUserApiService) EducationMeGetUserExecute(r ApiEducationMeGetUserRequest) (MicrosoftGraphUser, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphUser
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationUserApiService.EducationMeGetUser")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/me/user"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEducationMeListClassesRequest struct {
	ctx _context.Context
	ApiService *EducationEducationUserApiService
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiEducationMeListClassesRequest) Top(top int32) ApiEducationMeListClassesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiEducationMeListClassesRequest) Skip(skip int32) ApiEducationMeListClassesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiEducationMeListClassesRequest) Search(search string) ApiEducationMeListClassesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiEducationMeListClassesRequest) Filter(filter string) ApiEducationMeListClassesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiEducationMeListClassesRequest) Count(count bool) ApiEducationMeListClassesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiEducationMeListClassesRequest) Orderby(orderby []string) ApiEducationMeListClassesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiEducationMeListClassesRequest) Select_(select_ []string) ApiEducationMeListClassesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiEducationMeListClassesRequest) Expand(expand []string) ApiEducationMeListClassesRequest {
	r.expand = &expand
	return r
}

func (r ApiEducationMeListClassesRequest) Execute() (CollectionOfEducationClass, *_nethttp.Response, error) {
	return r.ApiService.EducationMeListClassesExecute(r)
}

/*
EducationMeListClasses Get classes from education

Classes to which the user belongs. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEducationMeListClassesRequest
*/
func (a *EducationEducationUserApiService) EducationMeListClasses(ctx _context.Context) ApiEducationMeListClassesRequest {
	return ApiEducationMeListClassesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionOfEducationClass
func (a *EducationEducationUserApiService) EducationMeListClassesExecute(r ApiEducationMeListClassesRequest) (CollectionOfEducationClass, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfEducationClass
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationUserApiService.EducationMeListClasses")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/me/classes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEducationMeListRefClassesRequest struct {
	ctx _context.Context
	ApiService *EducationEducationUserApiService
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
}

// Show only the first n items
func (r ApiEducationMeListRefClassesRequest) Top(top int32) ApiEducationMeListRefClassesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiEducationMeListRefClassesRequest) Skip(skip int32) ApiEducationMeListRefClassesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiEducationMeListRefClassesRequest) Search(search string) ApiEducationMeListRefClassesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiEducationMeListRefClassesRequest) Filter(filter string) ApiEducationMeListRefClassesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiEducationMeListRefClassesRequest) Count(count bool) ApiEducationMeListRefClassesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiEducationMeListRefClassesRequest) Orderby(orderby []string) ApiEducationMeListRefClassesRequest {
	r.orderby = &orderby
	return r
}

func (r ApiEducationMeListRefClassesRequest) Execute() (CollectionOfLinksOfEducationClass, *_nethttp.Response, error) {
	return r.ApiService.EducationMeListRefClassesExecute(r)
}

/*
EducationMeListRefClasses Get ref of classes from education

Classes to which the user belongs. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEducationMeListRefClassesRequest
*/
func (a *EducationEducationUserApiService) EducationMeListRefClasses(ctx _context.Context) ApiEducationMeListRefClassesRequest {
	return ApiEducationMeListRefClassesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionOfLinksOfEducationClass
func (a *EducationEducationUserApiService) EducationMeListRefClassesExecute(r ApiEducationMeListRefClassesRequest) (CollectionOfLinksOfEducationClass, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfLinksOfEducationClass
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationUserApiService.EducationMeListRefClasses")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/me/classes/$ref"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEducationMeListRefSchoolsRequest struct {
	ctx _context.Context
	ApiService *EducationEducationUserApiService
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
}

// Show only the first n items
func (r ApiEducationMeListRefSchoolsRequest) Top(top int32) ApiEducationMeListRefSchoolsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiEducationMeListRefSchoolsRequest) Skip(skip int32) ApiEducationMeListRefSchoolsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiEducationMeListRefSchoolsRequest) Search(search string) ApiEducationMeListRefSchoolsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiEducationMeListRefSchoolsRequest) Filter(filter string) ApiEducationMeListRefSchoolsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiEducationMeListRefSchoolsRequest) Count(count bool) ApiEducationMeListRefSchoolsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiEducationMeListRefSchoolsRequest) Orderby(orderby []string) ApiEducationMeListRefSchoolsRequest {
	r.orderby = &orderby
	return r
}

func (r ApiEducationMeListRefSchoolsRequest) Execute() (CollectionOfLinksOfEducationSchool, *_nethttp.Response, error) {
	return r.ApiService.EducationMeListRefSchoolsExecute(r)
}

/*
EducationMeListRefSchools Get ref of schools from education

Schools to which the user belongs. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEducationMeListRefSchoolsRequest
*/
func (a *EducationEducationUserApiService) EducationMeListRefSchools(ctx _context.Context) ApiEducationMeListRefSchoolsRequest {
	return ApiEducationMeListRefSchoolsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionOfLinksOfEducationSchool
func (a *EducationEducationUserApiService) EducationMeListRefSchoolsExecute(r ApiEducationMeListRefSchoolsRequest) (CollectionOfLinksOfEducationSchool, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfLinksOfEducationSchool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationUserApiService.EducationMeListRefSchools")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/me/schools/$ref"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEducationMeListRefTaughtClassesRequest struct {
	ctx _context.Context
	ApiService *EducationEducationUserApiService
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
}

// Show only the first n items
func (r ApiEducationMeListRefTaughtClassesRequest) Top(top int32) ApiEducationMeListRefTaughtClassesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiEducationMeListRefTaughtClassesRequest) Skip(skip int32) ApiEducationMeListRefTaughtClassesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiEducationMeListRefTaughtClassesRequest) Search(search string) ApiEducationMeListRefTaughtClassesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiEducationMeListRefTaughtClassesRequest) Filter(filter string) ApiEducationMeListRefTaughtClassesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiEducationMeListRefTaughtClassesRequest) Count(count bool) ApiEducationMeListRefTaughtClassesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiEducationMeListRefTaughtClassesRequest) Orderby(orderby []string) ApiEducationMeListRefTaughtClassesRequest {
	r.orderby = &orderby
	return r
}

func (r ApiEducationMeListRefTaughtClassesRequest) Execute() (CollectionOfLinksOfEducationClass, *_nethttp.Response, error) {
	return r.ApiService.EducationMeListRefTaughtClassesExecute(r)
}

/*
EducationMeListRefTaughtClasses Get ref of taughtClasses from education

Classes for which the user is a teacher.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEducationMeListRefTaughtClassesRequest
*/
func (a *EducationEducationUserApiService) EducationMeListRefTaughtClasses(ctx _context.Context) ApiEducationMeListRefTaughtClassesRequest {
	return ApiEducationMeListRefTaughtClassesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionOfLinksOfEducationClass
func (a *EducationEducationUserApiService) EducationMeListRefTaughtClassesExecute(r ApiEducationMeListRefTaughtClassesRequest) (CollectionOfLinksOfEducationClass, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfLinksOfEducationClass
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationUserApiService.EducationMeListRefTaughtClasses")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/me/taughtClasses/$ref"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEducationMeListRubricsRequest struct {
	ctx _context.Context
	ApiService *EducationEducationUserApiService
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiEducationMeListRubricsRequest) Top(top int32) ApiEducationMeListRubricsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiEducationMeListRubricsRequest) Skip(skip int32) ApiEducationMeListRubricsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiEducationMeListRubricsRequest) Search(search string) ApiEducationMeListRubricsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiEducationMeListRubricsRequest) Filter(filter string) ApiEducationMeListRubricsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiEducationMeListRubricsRequest) Count(count bool) ApiEducationMeListRubricsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiEducationMeListRubricsRequest) Orderby(orderby []string) ApiEducationMeListRubricsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiEducationMeListRubricsRequest) Select_(select_ []string) ApiEducationMeListRubricsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiEducationMeListRubricsRequest) Expand(expand []string) ApiEducationMeListRubricsRequest {
	r.expand = &expand
	return r
}

func (r ApiEducationMeListRubricsRequest) Execute() (CollectionOfEducationRubric, *_nethttp.Response, error) {
	return r.ApiService.EducationMeListRubricsExecute(r)
}

/*
EducationMeListRubrics Get rubrics from education

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEducationMeListRubricsRequest
*/
func (a *EducationEducationUserApiService) EducationMeListRubrics(ctx _context.Context) ApiEducationMeListRubricsRequest {
	return ApiEducationMeListRubricsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionOfEducationRubric
func (a *EducationEducationUserApiService) EducationMeListRubricsExecute(r ApiEducationMeListRubricsRequest) (CollectionOfEducationRubric, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfEducationRubric
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationUserApiService.EducationMeListRubrics")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/me/rubrics"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEducationMeListSchoolsRequest struct {
	ctx _context.Context
	ApiService *EducationEducationUserApiService
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiEducationMeListSchoolsRequest) Top(top int32) ApiEducationMeListSchoolsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiEducationMeListSchoolsRequest) Skip(skip int32) ApiEducationMeListSchoolsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiEducationMeListSchoolsRequest) Search(search string) ApiEducationMeListSchoolsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiEducationMeListSchoolsRequest) Filter(filter string) ApiEducationMeListSchoolsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiEducationMeListSchoolsRequest) Count(count bool) ApiEducationMeListSchoolsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiEducationMeListSchoolsRequest) Orderby(orderby []string) ApiEducationMeListSchoolsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiEducationMeListSchoolsRequest) Select_(select_ []string) ApiEducationMeListSchoolsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiEducationMeListSchoolsRequest) Expand(expand []string) ApiEducationMeListSchoolsRequest {
	r.expand = &expand
	return r
}

func (r ApiEducationMeListSchoolsRequest) Execute() (CollectionOfEducationSchool, *_nethttp.Response, error) {
	return r.ApiService.EducationMeListSchoolsExecute(r)
}

/*
EducationMeListSchools Get schools from education

Schools to which the user belongs. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEducationMeListSchoolsRequest
*/
func (a *EducationEducationUserApiService) EducationMeListSchools(ctx _context.Context) ApiEducationMeListSchoolsRequest {
	return ApiEducationMeListSchoolsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionOfEducationSchool
func (a *EducationEducationUserApiService) EducationMeListSchoolsExecute(r ApiEducationMeListSchoolsRequest) (CollectionOfEducationSchool, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfEducationSchool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationUserApiService.EducationMeListSchools")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/me/schools"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEducationMeListTaughtClassesRequest struct {
	ctx _context.Context
	ApiService *EducationEducationUserApiService
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiEducationMeListTaughtClassesRequest) Top(top int32) ApiEducationMeListTaughtClassesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiEducationMeListTaughtClassesRequest) Skip(skip int32) ApiEducationMeListTaughtClassesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiEducationMeListTaughtClassesRequest) Search(search string) ApiEducationMeListTaughtClassesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiEducationMeListTaughtClassesRequest) Filter(filter string) ApiEducationMeListTaughtClassesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiEducationMeListTaughtClassesRequest) Count(count bool) ApiEducationMeListTaughtClassesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiEducationMeListTaughtClassesRequest) Orderby(orderby []string) ApiEducationMeListTaughtClassesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiEducationMeListTaughtClassesRequest) Select_(select_ []string) ApiEducationMeListTaughtClassesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiEducationMeListTaughtClassesRequest) Expand(expand []string) ApiEducationMeListTaughtClassesRequest {
	r.expand = &expand
	return r
}

func (r ApiEducationMeListTaughtClassesRequest) Execute() (CollectionOfEducationClass, *_nethttp.Response, error) {
	return r.ApiService.EducationMeListTaughtClassesExecute(r)
}

/*
EducationMeListTaughtClasses Get taughtClasses from education

Classes for which the user is a teacher.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEducationMeListTaughtClassesRequest
*/
func (a *EducationEducationUserApiService) EducationMeListTaughtClasses(ctx _context.Context) ApiEducationMeListTaughtClassesRequest {
	return ApiEducationMeListTaughtClassesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionOfEducationClass
func (a *EducationEducationUserApiService) EducationMeListTaughtClassesExecute(r ApiEducationMeListTaughtClassesRequest) (CollectionOfEducationClass, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfEducationClass
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationUserApiService.EducationMeListTaughtClasses")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/me/taughtClasses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEducationMeUpdateRefUserRequest struct {
	ctx _context.Context
	ApiService *EducationEducationUserApiService
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiEducationMeUpdateRefUserRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiEducationMeUpdateRefUserRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiEducationMeUpdateRefUserRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.EducationMeUpdateRefUserExecute(r)
}

/*
EducationMeUpdateRefUser Update the ref of navigation property user in education

The directory user corresponding to this user.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEducationMeUpdateRefUserRequest
*/
func (a *EducationEducationUserApiService) EducationMeUpdateRefUser(ctx _context.Context) ApiEducationMeUpdateRefUserRequest {
	return ApiEducationMeUpdateRefUserRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EducationEducationUserApiService) EducationMeUpdateRefUserExecute(r ApiEducationMeUpdateRefUserRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationUserApiService.EducationMeUpdateRefUser")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/me/user/$ref"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEducationMeUpdateRubricsRequest struct {
	ctx _context.Context
	ApiService *EducationEducationUserApiService
	educationRubricId string
	microsoftGraphEducationRubric *MicrosoftGraphEducationRubric
}

// New navigation property values
func (r ApiEducationMeUpdateRubricsRequest) MicrosoftGraphEducationRubric(microsoftGraphEducationRubric MicrosoftGraphEducationRubric) ApiEducationMeUpdateRubricsRequest {
	r.microsoftGraphEducationRubric = &microsoftGraphEducationRubric
	return r
}

func (r ApiEducationMeUpdateRubricsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.EducationMeUpdateRubricsExecute(r)
}

/*
EducationMeUpdateRubrics Update the navigation property rubrics in education

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param educationRubricId key: id of educationRubric
 @return ApiEducationMeUpdateRubricsRequest
*/
func (a *EducationEducationUserApiService) EducationMeUpdateRubrics(ctx _context.Context, educationRubricId string) ApiEducationMeUpdateRubricsRequest {
	return ApiEducationMeUpdateRubricsRequest{
		ApiService: a,
		ctx: ctx,
		educationRubricId: educationRubricId,
	}
}

// Execute executes the request
func (a *EducationEducationUserApiService) EducationMeUpdateRubricsExecute(r ApiEducationMeUpdateRubricsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationUserApiService.EducationMeUpdateRubrics")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/me/rubrics/{educationRubric-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"educationRubric-id"+"}", _neturl.PathEscape(parameterToString(r.educationRubricId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphEducationRubric == nil {
		return nil, reportError("microsoftGraphEducationRubric is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphEducationRubric
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEducationUpdateMeRequest struct {
	ctx _context.Context
	ApiService *EducationEducationUserApiService
	microsoftGraphEducationUser *MicrosoftGraphEducationUser
}

// New navigation property values
func (r ApiEducationUpdateMeRequest) MicrosoftGraphEducationUser(microsoftGraphEducationUser MicrosoftGraphEducationUser) ApiEducationUpdateMeRequest {
	r.microsoftGraphEducationUser = &microsoftGraphEducationUser
	return r
}

func (r ApiEducationUpdateMeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.EducationUpdateMeExecute(r)
}

/*
EducationUpdateMe Update the navigation property me in education

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEducationUpdateMeRequest
*/
func (a *EducationEducationUserApiService) EducationUpdateMe(ctx _context.Context) ApiEducationUpdateMeRequest {
	return ApiEducationUpdateMeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EducationEducationUserApiService) EducationUpdateMeExecute(r ApiEducationUpdateMeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationUserApiService.EducationUpdateMe")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/me"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphEducationUser == nil {
		return nil, reportError("microsoftGraphEducationUser is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphEducationUser
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEducationUpdateUsersRequest struct {
	ctx _context.Context
	ApiService *EducationEducationUserApiService
	educationUserId string
	microsoftGraphEducationUser *MicrosoftGraphEducationUser
}

// New navigation property values
func (r ApiEducationUpdateUsersRequest) MicrosoftGraphEducationUser(microsoftGraphEducationUser MicrosoftGraphEducationUser) ApiEducationUpdateUsersRequest {
	r.microsoftGraphEducationUser = &microsoftGraphEducationUser
	return r
}

func (r ApiEducationUpdateUsersRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.EducationUpdateUsersExecute(r)
}

/*
EducationUpdateUsers Update the navigation property users in education

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param educationUserId key: id of educationUser
 @return ApiEducationUpdateUsersRequest
*/
func (a *EducationEducationUserApiService) EducationUpdateUsers(ctx _context.Context, educationUserId string) ApiEducationUpdateUsersRequest {
	return ApiEducationUpdateUsersRequest{
		ApiService: a,
		ctx: ctx,
		educationUserId: educationUserId,
	}
}

// Execute executes the request
func (a *EducationEducationUserApiService) EducationUpdateUsersExecute(r ApiEducationUpdateUsersRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationUserApiService.EducationUpdateUsers")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/users/{educationUser-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"educationUser-id"+"}", _neturl.PathEscape(parameterToString(r.educationUserId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphEducationUser == nil {
		return nil, reportError("microsoftGraphEducationUser is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphEducationUser
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEducationUsersCreateRefClassesRequest struct {
	ctx _context.Context
	ApiService *EducationEducationUserApiService
	educationUserId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref value
func (r ApiEducationUsersCreateRefClassesRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiEducationUsersCreateRefClassesRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiEducationUsersCreateRefClassesRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.EducationUsersCreateRefClassesExecute(r)
}

/*
EducationUsersCreateRefClasses Create new navigation property ref to classes for education

Classes to which the user belongs. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param educationUserId key: id of educationUser
 @return ApiEducationUsersCreateRefClassesRequest
*/
func (a *EducationEducationUserApiService) EducationUsersCreateRefClasses(ctx _context.Context, educationUserId string) ApiEducationUsersCreateRefClassesRequest {
	return ApiEducationUsersCreateRefClassesRequest{
		ApiService: a,
		ctx: ctx,
		educationUserId: educationUserId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *EducationEducationUserApiService) EducationUsersCreateRefClassesExecute(r ApiEducationUsersCreateRefClassesRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationUserApiService.EducationUsersCreateRefClasses")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/users/{educationUser-id}/classes/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"educationUser-id"+"}", _neturl.PathEscape(parameterToString(r.educationUserId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEducationUsersCreateRefSchoolsRequest struct {
	ctx _context.Context
	ApiService *EducationEducationUserApiService
	educationUserId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref value
func (r ApiEducationUsersCreateRefSchoolsRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiEducationUsersCreateRefSchoolsRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiEducationUsersCreateRefSchoolsRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.EducationUsersCreateRefSchoolsExecute(r)
}

/*
EducationUsersCreateRefSchools Create new navigation property ref to schools for education

Schools to which the user belongs. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param educationUserId key: id of educationUser
 @return ApiEducationUsersCreateRefSchoolsRequest
*/
func (a *EducationEducationUserApiService) EducationUsersCreateRefSchools(ctx _context.Context, educationUserId string) ApiEducationUsersCreateRefSchoolsRequest {
	return ApiEducationUsersCreateRefSchoolsRequest{
		ApiService: a,
		ctx: ctx,
		educationUserId: educationUserId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *EducationEducationUserApiService) EducationUsersCreateRefSchoolsExecute(r ApiEducationUsersCreateRefSchoolsRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationUserApiService.EducationUsersCreateRefSchools")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/users/{educationUser-id}/schools/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"educationUser-id"+"}", _neturl.PathEscape(parameterToString(r.educationUserId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEducationUsersCreateRefTaughtClassesRequest struct {
	ctx _context.Context
	ApiService *EducationEducationUserApiService
	educationUserId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref value
func (r ApiEducationUsersCreateRefTaughtClassesRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiEducationUsersCreateRefTaughtClassesRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiEducationUsersCreateRefTaughtClassesRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.EducationUsersCreateRefTaughtClassesExecute(r)
}

/*
EducationUsersCreateRefTaughtClasses Create new navigation property ref to taughtClasses for education

Classes for which the user is a teacher.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param educationUserId key: id of educationUser
 @return ApiEducationUsersCreateRefTaughtClassesRequest
*/
func (a *EducationEducationUserApiService) EducationUsersCreateRefTaughtClasses(ctx _context.Context, educationUserId string) ApiEducationUsersCreateRefTaughtClassesRequest {
	return ApiEducationUsersCreateRefTaughtClassesRequest{
		ApiService: a,
		ctx: ctx,
		educationUserId: educationUserId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *EducationEducationUserApiService) EducationUsersCreateRefTaughtClassesExecute(r ApiEducationUsersCreateRefTaughtClassesRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationUserApiService.EducationUsersCreateRefTaughtClasses")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/users/{educationUser-id}/taughtClasses/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"educationUser-id"+"}", _neturl.PathEscape(parameterToString(r.educationUserId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEducationUsersCreateRubricsRequest struct {
	ctx _context.Context
	ApiService *EducationEducationUserApiService
	educationUserId string
	microsoftGraphEducationRubric *MicrosoftGraphEducationRubric
}

// New navigation property
func (r ApiEducationUsersCreateRubricsRequest) MicrosoftGraphEducationRubric(microsoftGraphEducationRubric MicrosoftGraphEducationRubric) ApiEducationUsersCreateRubricsRequest {
	r.microsoftGraphEducationRubric = &microsoftGraphEducationRubric
	return r
}

func (r ApiEducationUsersCreateRubricsRequest) Execute() (MicrosoftGraphEducationRubric, *_nethttp.Response, error) {
	return r.ApiService.EducationUsersCreateRubricsExecute(r)
}

/*
EducationUsersCreateRubrics Create new navigation property to rubrics for education

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param educationUserId key: id of educationUser
 @return ApiEducationUsersCreateRubricsRequest
*/
func (a *EducationEducationUserApiService) EducationUsersCreateRubrics(ctx _context.Context, educationUserId string) ApiEducationUsersCreateRubricsRequest {
	return ApiEducationUsersCreateRubricsRequest{
		ApiService: a,
		ctx: ctx,
		educationUserId: educationUserId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEducationRubric
func (a *EducationEducationUserApiService) EducationUsersCreateRubricsExecute(r ApiEducationUsersCreateRubricsRequest) (MicrosoftGraphEducationRubric, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEducationRubric
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationUserApiService.EducationUsersCreateRubrics")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/users/{educationUser-id}/rubrics"
	localVarPath = strings.Replace(localVarPath, "{"+"educationUser-id"+"}", _neturl.PathEscape(parameterToString(r.educationUserId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphEducationRubric == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphEducationRubric is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphEducationRubric
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEducationUsersDeleteRefUserRequest struct {
	ctx _context.Context
	ApiService *EducationEducationUserApiService
	educationUserId string
	ifMatch *string
}

// ETag
func (r ApiEducationUsersDeleteRefUserRequest) IfMatch(ifMatch string) ApiEducationUsersDeleteRefUserRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiEducationUsersDeleteRefUserRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.EducationUsersDeleteRefUserExecute(r)
}

/*
EducationUsersDeleteRefUser Delete ref of navigation property user for education

The directory user corresponding to this user.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param educationUserId key: id of educationUser
 @return ApiEducationUsersDeleteRefUserRequest
*/
func (a *EducationEducationUserApiService) EducationUsersDeleteRefUser(ctx _context.Context, educationUserId string) ApiEducationUsersDeleteRefUserRequest {
	return ApiEducationUsersDeleteRefUserRequest{
		ApiService: a,
		ctx: ctx,
		educationUserId: educationUserId,
	}
}

// Execute executes the request
func (a *EducationEducationUserApiService) EducationUsersDeleteRefUserExecute(r ApiEducationUsersDeleteRefUserRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationUserApiService.EducationUsersDeleteRefUser")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/users/{educationUser-id}/user/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"educationUser-id"+"}", _neturl.PathEscape(parameterToString(r.educationUserId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEducationUsersDeleteRubricsRequest struct {
	ctx _context.Context
	ApiService *EducationEducationUserApiService
	educationUserId string
	educationRubricId string
	ifMatch *string
}

// ETag
func (r ApiEducationUsersDeleteRubricsRequest) IfMatch(ifMatch string) ApiEducationUsersDeleteRubricsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiEducationUsersDeleteRubricsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.EducationUsersDeleteRubricsExecute(r)
}

/*
EducationUsersDeleteRubrics Delete navigation property rubrics for education

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param educationUserId key: id of educationUser
 @param educationRubricId key: id of educationRubric
 @return ApiEducationUsersDeleteRubricsRequest
*/
func (a *EducationEducationUserApiService) EducationUsersDeleteRubrics(ctx _context.Context, educationUserId string, educationRubricId string) ApiEducationUsersDeleteRubricsRequest {
	return ApiEducationUsersDeleteRubricsRequest{
		ApiService: a,
		ctx: ctx,
		educationUserId: educationUserId,
		educationRubricId: educationRubricId,
	}
}

// Execute executes the request
func (a *EducationEducationUserApiService) EducationUsersDeleteRubricsExecute(r ApiEducationUsersDeleteRubricsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationUserApiService.EducationUsersDeleteRubrics")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/users/{educationUser-id}/rubrics/{educationRubric-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"educationUser-id"+"}", _neturl.PathEscape(parameterToString(r.educationUserId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"educationRubric-id"+"}", _neturl.PathEscape(parameterToString(r.educationRubricId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEducationUsersGetRefUserRequest struct {
	ctx _context.Context
	ApiService *EducationEducationUserApiService
	educationUserId string
}


func (r ApiEducationUsersGetRefUserRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.EducationUsersGetRefUserExecute(r)
}

/*
EducationUsersGetRefUser Get ref of user from education

The directory user corresponding to this user.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param educationUserId key: id of educationUser
 @return ApiEducationUsersGetRefUserRequest
*/
func (a *EducationEducationUserApiService) EducationUsersGetRefUser(ctx _context.Context, educationUserId string) ApiEducationUsersGetRefUserRequest {
	return ApiEducationUsersGetRefUserRequest{
		ApiService: a,
		ctx: ctx,
		educationUserId: educationUserId,
	}
}

// Execute executes the request
//  @return string
func (a *EducationEducationUserApiService) EducationUsersGetRefUserExecute(r ApiEducationUsersGetRefUserRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationUserApiService.EducationUsersGetRefUser")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/users/{educationUser-id}/user/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"educationUser-id"+"}", _neturl.PathEscape(parameterToString(r.educationUserId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEducationUsersGetRubricsRequest struct {
	ctx _context.Context
	ApiService *EducationEducationUserApiService
	educationUserId string
	educationRubricId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiEducationUsersGetRubricsRequest) Select_(select_ []string) ApiEducationUsersGetRubricsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiEducationUsersGetRubricsRequest) Expand(expand []string) ApiEducationUsersGetRubricsRequest {
	r.expand = &expand
	return r
}

func (r ApiEducationUsersGetRubricsRequest) Execute() (MicrosoftGraphEducationRubric, *_nethttp.Response, error) {
	return r.ApiService.EducationUsersGetRubricsExecute(r)
}

/*
EducationUsersGetRubrics Get rubrics from education

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param educationUserId key: id of educationUser
 @param educationRubricId key: id of educationRubric
 @return ApiEducationUsersGetRubricsRequest
*/
func (a *EducationEducationUserApiService) EducationUsersGetRubrics(ctx _context.Context, educationUserId string, educationRubricId string) ApiEducationUsersGetRubricsRequest {
	return ApiEducationUsersGetRubricsRequest{
		ApiService: a,
		ctx: ctx,
		educationUserId: educationUserId,
		educationRubricId: educationRubricId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphEducationRubric
func (a *EducationEducationUserApiService) EducationUsersGetRubricsExecute(r ApiEducationUsersGetRubricsRequest) (MicrosoftGraphEducationRubric, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphEducationRubric
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationUserApiService.EducationUsersGetRubrics")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/users/{educationUser-id}/rubrics/{educationRubric-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"educationUser-id"+"}", _neturl.PathEscape(parameterToString(r.educationUserId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"educationRubric-id"+"}", _neturl.PathEscape(parameterToString(r.educationRubricId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEducationUsersGetUserRequest struct {
	ctx _context.Context
	ApiService *EducationEducationUserApiService
	educationUserId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiEducationUsersGetUserRequest) Select_(select_ []string) ApiEducationUsersGetUserRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiEducationUsersGetUserRequest) Expand(expand []string) ApiEducationUsersGetUserRequest {
	r.expand = &expand
	return r
}

func (r ApiEducationUsersGetUserRequest) Execute() (MicrosoftGraphUser, *_nethttp.Response, error) {
	return r.ApiService.EducationUsersGetUserExecute(r)
}

/*
EducationUsersGetUser Get user from education

The directory user corresponding to this user.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param educationUserId key: id of educationUser
 @return ApiEducationUsersGetUserRequest
*/
func (a *EducationEducationUserApiService) EducationUsersGetUser(ctx _context.Context, educationUserId string) ApiEducationUsersGetUserRequest {
	return ApiEducationUsersGetUserRequest{
		ApiService: a,
		ctx: ctx,
		educationUserId: educationUserId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphUser
func (a *EducationEducationUserApiService) EducationUsersGetUserExecute(r ApiEducationUsersGetUserRequest) (MicrosoftGraphUser, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphUser
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationUserApiService.EducationUsersGetUser")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/users/{educationUser-id}/user"
	localVarPath = strings.Replace(localVarPath, "{"+"educationUser-id"+"}", _neturl.PathEscape(parameterToString(r.educationUserId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEducationUsersListClassesRequest struct {
	ctx _context.Context
	ApiService *EducationEducationUserApiService
	educationUserId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiEducationUsersListClassesRequest) Top(top int32) ApiEducationUsersListClassesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiEducationUsersListClassesRequest) Skip(skip int32) ApiEducationUsersListClassesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiEducationUsersListClassesRequest) Search(search string) ApiEducationUsersListClassesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiEducationUsersListClassesRequest) Filter(filter string) ApiEducationUsersListClassesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiEducationUsersListClassesRequest) Count(count bool) ApiEducationUsersListClassesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiEducationUsersListClassesRequest) Orderby(orderby []string) ApiEducationUsersListClassesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiEducationUsersListClassesRequest) Select_(select_ []string) ApiEducationUsersListClassesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiEducationUsersListClassesRequest) Expand(expand []string) ApiEducationUsersListClassesRequest {
	r.expand = &expand
	return r
}

func (r ApiEducationUsersListClassesRequest) Execute() (CollectionOfEducationClass, *_nethttp.Response, error) {
	return r.ApiService.EducationUsersListClassesExecute(r)
}

/*
EducationUsersListClasses Get classes from education

Classes to which the user belongs. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param educationUserId key: id of educationUser
 @return ApiEducationUsersListClassesRequest
*/
func (a *EducationEducationUserApiService) EducationUsersListClasses(ctx _context.Context, educationUserId string) ApiEducationUsersListClassesRequest {
	return ApiEducationUsersListClassesRequest{
		ApiService: a,
		ctx: ctx,
		educationUserId: educationUserId,
	}
}

// Execute executes the request
//  @return CollectionOfEducationClass
func (a *EducationEducationUserApiService) EducationUsersListClassesExecute(r ApiEducationUsersListClassesRequest) (CollectionOfEducationClass, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfEducationClass
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationUserApiService.EducationUsersListClasses")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/users/{educationUser-id}/classes"
	localVarPath = strings.Replace(localVarPath, "{"+"educationUser-id"+"}", _neturl.PathEscape(parameterToString(r.educationUserId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEducationUsersListRefClassesRequest struct {
	ctx _context.Context
	ApiService *EducationEducationUserApiService
	educationUserId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
}

// Show only the first n items
func (r ApiEducationUsersListRefClassesRequest) Top(top int32) ApiEducationUsersListRefClassesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiEducationUsersListRefClassesRequest) Skip(skip int32) ApiEducationUsersListRefClassesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiEducationUsersListRefClassesRequest) Search(search string) ApiEducationUsersListRefClassesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiEducationUsersListRefClassesRequest) Filter(filter string) ApiEducationUsersListRefClassesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiEducationUsersListRefClassesRequest) Count(count bool) ApiEducationUsersListRefClassesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiEducationUsersListRefClassesRequest) Orderby(orderby []string) ApiEducationUsersListRefClassesRequest {
	r.orderby = &orderby
	return r
}

func (r ApiEducationUsersListRefClassesRequest) Execute() (CollectionOfLinksOfEducationClass, *_nethttp.Response, error) {
	return r.ApiService.EducationUsersListRefClassesExecute(r)
}

/*
EducationUsersListRefClasses Get ref of classes from education

Classes to which the user belongs. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param educationUserId key: id of educationUser
 @return ApiEducationUsersListRefClassesRequest
*/
func (a *EducationEducationUserApiService) EducationUsersListRefClasses(ctx _context.Context, educationUserId string) ApiEducationUsersListRefClassesRequest {
	return ApiEducationUsersListRefClassesRequest{
		ApiService: a,
		ctx: ctx,
		educationUserId: educationUserId,
	}
}

// Execute executes the request
//  @return CollectionOfLinksOfEducationClass
func (a *EducationEducationUserApiService) EducationUsersListRefClassesExecute(r ApiEducationUsersListRefClassesRequest) (CollectionOfLinksOfEducationClass, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfLinksOfEducationClass
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationUserApiService.EducationUsersListRefClasses")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/users/{educationUser-id}/classes/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"educationUser-id"+"}", _neturl.PathEscape(parameterToString(r.educationUserId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEducationUsersListRefSchoolsRequest struct {
	ctx _context.Context
	ApiService *EducationEducationUserApiService
	educationUserId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
}

// Show only the first n items
func (r ApiEducationUsersListRefSchoolsRequest) Top(top int32) ApiEducationUsersListRefSchoolsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiEducationUsersListRefSchoolsRequest) Skip(skip int32) ApiEducationUsersListRefSchoolsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiEducationUsersListRefSchoolsRequest) Search(search string) ApiEducationUsersListRefSchoolsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiEducationUsersListRefSchoolsRequest) Filter(filter string) ApiEducationUsersListRefSchoolsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiEducationUsersListRefSchoolsRequest) Count(count bool) ApiEducationUsersListRefSchoolsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiEducationUsersListRefSchoolsRequest) Orderby(orderby []string) ApiEducationUsersListRefSchoolsRequest {
	r.orderby = &orderby
	return r
}

func (r ApiEducationUsersListRefSchoolsRequest) Execute() (CollectionOfLinksOfEducationSchool, *_nethttp.Response, error) {
	return r.ApiService.EducationUsersListRefSchoolsExecute(r)
}

/*
EducationUsersListRefSchools Get ref of schools from education

Schools to which the user belongs. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param educationUserId key: id of educationUser
 @return ApiEducationUsersListRefSchoolsRequest
*/
func (a *EducationEducationUserApiService) EducationUsersListRefSchools(ctx _context.Context, educationUserId string) ApiEducationUsersListRefSchoolsRequest {
	return ApiEducationUsersListRefSchoolsRequest{
		ApiService: a,
		ctx: ctx,
		educationUserId: educationUserId,
	}
}

// Execute executes the request
//  @return CollectionOfLinksOfEducationSchool
func (a *EducationEducationUserApiService) EducationUsersListRefSchoolsExecute(r ApiEducationUsersListRefSchoolsRequest) (CollectionOfLinksOfEducationSchool, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfLinksOfEducationSchool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationUserApiService.EducationUsersListRefSchools")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/users/{educationUser-id}/schools/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"educationUser-id"+"}", _neturl.PathEscape(parameterToString(r.educationUserId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEducationUsersListRefTaughtClassesRequest struct {
	ctx _context.Context
	ApiService *EducationEducationUserApiService
	educationUserId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
}

// Show only the first n items
func (r ApiEducationUsersListRefTaughtClassesRequest) Top(top int32) ApiEducationUsersListRefTaughtClassesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiEducationUsersListRefTaughtClassesRequest) Skip(skip int32) ApiEducationUsersListRefTaughtClassesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiEducationUsersListRefTaughtClassesRequest) Search(search string) ApiEducationUsersListRefTaughtClassesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiEducationUsersListRefTaughtClassesRequest) Filter(filter string) ApiEducationUsersListRefTaughtClassesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiEducationUsersListRefTaughtClassesRequest) Count(count bool) ApiEducationUsersListRefTaughtClassesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiEducationUsersListRefTaughtClassesRequest) Orderby(orderby []string) ApiEducationUsersListRefTaughtClassesRequest {
	r.orderby = &orderby
	return r
}

func (r ApiEducationUsersListRefTaughtClassesRequest) Execute() (CollectionOfLinksOfEducationClass, *_nethttp.Response, error) {
	return r.ApiService.EducationUsersListRefTaughtClassesExecute(r)
}

/*
EducationUsersListRefTaughtClasses Get ref of taughtClasses from education

Classes for which the user is a teacher.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param educationUserId key: id of educationUser
 @return ApiEducationUsersListRefTaughtClassesRequest
*/
func (a *EducationEducationUserApiService) EducationUsersListRefTaughtClasses(ctx _context.Context, educationUserId string) ApiEducationUsersListRefTaughtClassesRequest {
	return ApiEducationUsersListRefTaughtClassesRequest{
		ApiService: a,
		ctx: ctx,
		educationUserId: educationUserId,
	}
}

// Execute executes the request
//  @return CollectionOfLinksOfEducationClass
func (a *EducationEducationUserApiService) EducationUsersListRefTaughtClassesExecute(r ApiEducationUsersListRefTaughtClassesRequest) (CollectionOfLinksOfEducationClass, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfLinksOfEducationClass
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationUserApiService.EducationUsersListRefTaughtClasses")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/users/{educationUser-id}/taughtClasses/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"educationUser-id"+"}", _neturl.PathEscape(parameterToString(r.educationUserId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEducationUsersListRubricsRequest struct {
	ctx _context.Context
	ApiService *EducationEducationUserApiService
	educationUserId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiEducationUsersListRubricsRequest) Top(top int32) ApiEducationUsersListRubricsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiEducationUsersListRubricsRequest) Skip(skip int32) ApiEducationUsersListRubricsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiEducationUsersListRubricsRequest) Search(search string) ApiEducationUsersListRubricsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiEducationUsersListRubricsRequest) Filter(filter string) ApiEducationUsersListRubricsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiEducationUsersListRubricsRequest) Count(count bool) ApiEducationUsersListRubricsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiEducationUsersListRubricsRequest) Orderby(orderby []string) ApiEducationUsersListRubricsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiEducationUsersListRubricsRequest) Select_(select_ []string) ApiEducationUsersListRubricsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiEducationUsersListRubricsRequest) Expand(expand []string) ApiEducationUsersListRubricsRequest {
	r.expand = &expand
	return r
}

func (r ApiEducationUsersListRubricsRequest) Execute() (CollectionOfEducationRubric, *_nethttp.Response, error) {
	return r.ApiService.EducationUsersListRubricsExecute(r)
}

/*
EducationUsersListRubrics Get rubrics from education

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param educationUserId key: id of educationUser
 @return ApiEducationUsersListRubricsRequest
*/
func (a *EducationEducationUserApiService) EducationUsersListRubrics(ctx _context.Context, educationUserId string) ApiEducationUsersListRubricsRequest {
	return ApiEducationUsersListRubricsRequest{
		ApiService: a,
		ctx: ctx,
		educationUserId: educationUserId,
	}
}

// Execute executes the request
//  @return CollectionOfEducationRubric
func (a *EducationEducationUserApiService) EducationUsersListRubricsExecute(r ApiEducationUsersListRubricsRequest) (CollectionOfEducationRubric, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfEducationRubric
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationUserApiService.EducationUsersListRubrics")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/users/{educationUser-id}/rubrics"
	localVarPath = strings.Replace(localVarPath, "{"+"educationUser-id"+"}", _neturl.PathEscape(parameterToString(r.educationUserId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEducationUsersListSchoolsRequest struct {
	ctx _context.Context
	ApiService *EducationEducationUserApiService
	educationUserId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiEducationUsersListSchoolsRequest) Top(top int32) ApiEducationUsersListSchoolsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiEducationUsersListSchoolsRequest) Skip(skip int32) ApiEducationUsersListSchoolsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiEducationUsersListSchoolsRequest) Search(search string) ApiEducationUsersListSchoolsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiEducationUsersListSchoolsRequest) Filter(filter string) ApiEducationUsersListSchoolsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiEducationUsersListSchoolsRequest) Count(count bool) ApiEducationUsersListSchoolsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiEducationUsersListSchoolsRequest) Orderby(orderby []string) ApiEducationUsersListSchoolsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiEducationUsersListSchoolsRequest) Select_(select_ []string) ApiEducationUsersListSchoolsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiEducationUsersListSchoolsRequest) Expand(expand []string) ApiEducationUsersListSchoolsRequest {
	r.expand = &expand
	return r
}

func (r ApiEducationUsersListSchoolsRequest) Execute() (CollectionOfEducationSchool, *_nethttp.Response, error) {
	return r.ApiService.EducationUsersListSchoolsExecute(r)
}

/*
EducationUsersListSchools Get schools from education

Schools to which the user belongs. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param educationUserId key: id of educationUser
 @return ApiEducationUsersListSchoolsRequest
*/
func (a *EducationEducationUserApiService) EducationUsersListSchools(ctx _context.Context, educationUserId string) ApiEducationUsersListSchoolsRequest {
	return ApiEducationUsersListSchoolsRequest{
		ApiService: a,
		ctx: ctx,
		educationUserId: educationUserId,
	}
}

// Execute executes the request
//  @return CollectionOfEducationSchool
func (a *EducationEducationUserApiService) EducationUsersListSchoolsExecute(r ApiEducationUsersListSchoolsRequest) (CollectionOfEducationSchool, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfEducationSchool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationUserApiService.EducationUsersListSchools")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/users/{educationUser-id}/schools"
	localVarPath = strings.Replace(localVarPath, "{"+"educationUser-id"+"}", _neturl.PathEscape(parameterToString(r.educationUserId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEducationUsersListTaughtClassesRequest struct {
	ctx _context.Context
	ApiService *EducationEducationUserApiService
	educationUserId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiEducationUsersListTaughtClassesRequest) Top(top int32) ApiEducationUsersListTaughtClassesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiEducationUsersListTaughtClassesRequest) Skip(skip int32) ApiEducationUsersListTaughtClassesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiEducationUsersListTaughtClassesRequest) Search(search string) ApiEducationUsersListTaughtClassesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiEducationUsersListTaughtClassesRequest) Filter(filter string) ApiEducationUsersListTaughtClassesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiEducationUsersListTaughtClassesRequest) Count(count bool) ApiEducationUsersListTaughtClassesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiEducationUsersListTaughtClassesRequest) Orderby(orderby []string) ApiEducationUsersListTaughtClassesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiEducationUsersListTaughtClassesRequest) Select_(select_ []string) ApiEducationUsersListTaughtClassesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiEducationUsersListTaughtClassesRequest) Expand(expand []string) ApiEducationUsersListTaughtClassesRequest {
	r.expand = &expand
	return r
}

func (r ApiEducationUsersListTaughtClassesRequest) Execute() (CollectionOfEducationClass, *_nethttp.Response, error) {
	return r.ApiService.EducationUsersListTaughtClassesExecute(r)
}

/*
EducationUsersListTaughtClasses Get taughtClasses from education

Classes for which the user is a teacher.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param educationUserId key: id of educationUser
 @return ApiEducationUsersListTaughtClassesRequest
*/
func (a *EducationEducationUserApiService) EducationUsersListTaughtClasses(ctx _context.Context, educationUserId string) ApiEducationUsersListTaughtClassesRequest {
	return ApiEducationUsersListTaughtClassesRequest{
		ApiService: a,
		ctx: ctx,
		educationUserId: educationUserId,
	}
}

// Execute executes the request
//  @return CollectionOfEducationClass
func (a *EducationEducationUserApiService) EducationUsersListTaughtClassesExecute(r ApiEducationUsersListTaughtClassesRequest) (CollectionOfEducationClass, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfEducationClass
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationUserApiService.EducationUsersListTaughtClasses")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/users/{educationUser-id}/taughtClasses"
	localVarPath = strings.Replace(localVarPath, "{"+"educationUser-id"+"}", _neturl.PathEscape(parameterToString(r.educationUserId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEducationUsersUpdateRefUserRequest struct {
	ctx _context.Context
	ApiService *EducationEducationUserApiService
	educationUserId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiEducationUsersUpdateRefUserRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiEducationUsersUpdateRefUserRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiEducationUsersUpdateRefUserRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.EducationUsersUpdateRefUserExecute(r)
}

/*
EducationUsersUpdateRefUser Update the ref of navigation property user in education

The directory user corresponding to this user.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param educationUserId key: id of educationUser
 @return ApiEducationUsersUpdateRefUserRequest
*/
func (a *EducationEducationUserApiService) EducationUsersUpdateRefUser(ctx _context.Context, educationUserId string) ApiEducationUsersUpdateRefUserRequest {
	return ApiEducationUsersUpdateRefUserRequest{
		ApiService: a,
		ctx: ctx,
		educationUserId: educationUserId,
	}
}

// Execute executes the request
func (a *EducationEducationUserApiService) EducationUsersUpdateRefUserExecute(r ApiEducationUsersUpdateRefUserRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationUserApiService.EducationUsersUpdateRefUser")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/users/{educationUser-id}/user/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"educationUser-id"+"}", _neturl.PathEscape(parameterToString(r.educationUserId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEducationUsersUpdateRubricsRequest struct {
	ctx _context.Context
	ApiService *EducationEducationUserApiService
	educationUserId string
	educationRubricId string
	microsoftGraphEducationRubric *MicrosoftGraphEducationRubric
}

// New navigation property values
func (r ApiEducationUsersUpdateRubricsRequest) MicrosoftGraphEducationRubric(microsoftGraphEducationRubric MicrosoftGraphEducationRubric) ApiEducationUsersUpdateRubricsRequest {
	r.microsoftGraphEducationRubric = &microsoftGraphEducationRubric
	return r
}

func (r ApiEducationUsersUpdateRubricsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.EducationUsersUpdateRubricsExecute(r)
}

/*
EducationUsersUpdateRubrics Update the navigation property rubrics in education

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param educationUserId key: id of educationUser
 @param educationRubricId key: id of educationRubric
 @return ApiEducationUsersUpdateRubricsRequest
*/
func (a *EducationEducationUserApiService) EducationUsersUpdateRubrics(ctx _context.Context, educationUserId string, educationRubricId string) ApiEducationUsersUpdateRubricsRequest {
	return ApiEducationUsersUpdateRubricsRequest{
		ApiService: a,
		ctx: ctx,
		educationUserId: educationUserId,
		educationRubricId: educationRubricId,
	}
}

// Execute executes the request
func (a *EducationEducationUserApiService) EducationUsersUpdateRubricsExecute(r ApiEducationUsersUpdateRubricsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EducationEducationUserApiService.EducationUsersUpdateRubrics")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/education/users/{educationUser-id}/rubrics/{educationRubric-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"educationUser-id"+"}", _neturl.PathEscape(parameterToString(r.educationUserId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"educationRubric-id"+"}", _neturl.PathEscape(parameterToString(r.educationRubricId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphEducationRubric == nil {
		return nil, reportError("microsoftGraphEducationRubric is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphEducationRubric
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
