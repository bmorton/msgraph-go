/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package msgraph

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// GroupsConversationThreadApiService GroupsConversationThreadApi service
type GroupsConversationThreadApiService service

type ApiGroupsCreateThreadsRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationThreadApiService
	groupId string
	microsoftGraphConversationThread *MicrosoftGraphConversationThread
}

// New navigation property
func (r ApiGroupsCreateThreadsRequest) MicrosoftGraphConversationThread(microsoftGraphConversationThread MicrosoftGraphConversationThread) ApiGroupsCreateThreadsRequest {
	r.microsoftGraphConversationThread = &microsoftGraphConversationThread
	return r
}

func (r ApiGroupsCreateThreadsRequest) Execute() (MicrosoftGraphConversationThread, *_nethttp.Response, error) {
	return r.ApiService.GroupsCreateThreadsExecute(r)
}

/*
GroupsCreateThreads Create new navigation property to threads for groups

The group's conversation threads. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsCreateThreadsRequest
*/
func (a *GroupsConversationThreadApiService) GroupsCreateThreads(ctx _context.Context, groupId string) ApiGroupsCreateThreadsRequest {
	return ApiGroupsCreateThreadsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphConversationThread
func (a *GroupsConversationThreadApiService) GroupsCreateThreadsExecute(r ApiGroupsCreateThreadsRequest) (MicrosoftGraphConversationThread, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphConversationThread
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationThreadApiService.GroupsCreateThreads")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/threads"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphConversationThread == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphConversationThread is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphConversationThread
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsDeleteThreadsRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationThreadApiService
	groupId string
	conversationThreadId string
	ifMatch *string
}

// ETag
func (r ApiGroupsDeleteThreadsRequest) IfMatch(ifMatch string) ApiGroupsDeleteThreadsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsDeleteThreadsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsDeleteThreadsExecute(r)
}

/*
GroupsDeleteThreads Delete navigation property threads for groups

The group's conversation threads. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationThreadId key: id of conversationThread
 @return ApiGroupsDeleteThreadsRequest
*/
func (a *GroupsConversationThreadApiService) GroupsDeleteThreads(ctx _context.Context, groupId string, conversationThreadId string) ApiGroupsDeleteThreadsRequest {
	return ApiGroupsDeleteThreadsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationThreadId: conversationThreadId,
	}
}

// Execute executes the request
func (a *GroupsConversationThreadApiService) GroupsDeleteThreadsExecute(r ApiGroupsDeleteThreadsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationThreadApiService.GroupsDeleteThreads")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/threads/{conversationThread-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGetThreadsRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationThreadApiService
	groupId string
	conversationThreadId string
	select_ *[]string
}

// Select properties to be returned
func (r ApiGroupsGetThreadsRequest) Select_(select_ []string) ApiGroupsGetThreadsRequest {
	r.select_ = &select_
	return r
}

func (r ApiGroupsGetThreadsRequest) Execute() (MicrosoftGraphConversationThread, *_nethttp.Response, error) {
	return r.ApiService.GroupsGetThreadsExecute(r)
}

/*
GroupsGetThreads Get threads from groups

The group's conversation threads. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationThreadId key: id of conversationThread
 @return ApiGroupsGetThreadsRequest
*/
func (a *GroupsConversationThreadApiService) GroupsGetThreads(ctx _context.Context, groupId string, conversationThreadId string) ApiGroupsGetThreadsRequest {
	return ApiGroupsGetThreadsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationThreadId: conversationThreadId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphConversationThread
func (a *GroupsConversationThreadApiService) GroupsGetThreadsExecute(r ApiGroupsGetThreadsRequest) (MicrosoftGraphConversationThread, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphConversationThread
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationThreadApiService.GroupsGetThreads")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/threads/{conversationThread-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsListThreadsRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationThreadApiService
	groupId string
	top *int32
	skip *int32
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
}

// Show only the first n items
func (r ApiGroupsListThreadsRequest) Top(top int32) ApiGroupsListThreadsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsListThreadsRequest) Skip(skip int32) ApiGroupsListThreadsRequest {
	r.skip = &skip
	return r
}
// Filter items by property values
func (r ApiGroupsListThreadsRequest) Filter(filter string) ApiGroupsListThreadsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsListThreadsRequest) Count(count bool) ApiGroupsListThreadsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsListThreadsRequest) Orderby(orderby []string) ApiGroupsListThreadsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiGroupsListThreadsRequest) Select_(select_ []string) ApiGroupsListThreadsRequest {
	r.select_ = &select_
	return r
}

func (r ApiGroupsListThreadsRequest) Execute() (CollectionOfConversationThread, *_nethttp.Response, error) {
	return r.ApiService.GroupsListThreadsExecute(r)
}

/*
GroupsListThreads Get threads from groups

The group's conversation threads. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsListThreadsRequest
*/
func (a *GroupsConversationThreadApiService) GroupsListThreads(ctx _context.Context, groupId string) ApiGroupsListThreadsRequest {
	return ApiGroupsListThreadsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return CollectionOfConversationThread
func (a *GroupsConversationThreadApiService) GroupsListThreadsExecute(r ApiGroupsListThreadsRequest) (CollectionOfConversationThread, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfConversationThread
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationThreadApiService.GroupsListThreads")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/threads"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsThreadsCreatePostsRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationThreadApiService
	groupId string
	conversationThreadId string
	microsoftGraphPost *MicrosoftGraphPost
}

// New navigation property
func (r ApiGroupsThreadsCreatePostsRequest) MicrosoftGraphPost(microsoftGraphPost MicrosoftGraphPost) ApiGroupsThreadsCreatePostsRequest {
	r.microsoftGraphPost = &microsoftGraphPost
	return r
}

func (r ApiGroupsThreadsCreatePostsRequest) Execute() (MicrosoftGraphPost, *_nethttp.Response, error) {
	return r.ApiService.GroupsThreadsCreatePostsExecute(r)
}

/*
GroupsThreadsCreatePosts Create new navigation property to posts for groups

Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationThreadId key: id of conversationThread
 @return ApiGroupsThreadsCreatePostsRequest
*/
func (a *GroupsConversationThreadApiService) GroupsThreadsCreatePosts(ctx _context.Context, groupId string, conversationThreadId string) ApiGroupsThreadsCreatePostsRequest {
	return ApiGroupsThreadsCreatePostsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationThreadId: conversationThreadId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPost
func (a *GroupsConversationThreadApiService) GroupsThreadsCreatePostsExecute(r ApiGroupsThreadsCreatePostsRequest) (MicrosoftGraphPost, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPost
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationThreadApiService.GroupsThreadsCreatePosts")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/threads/{conversationThread-id}/posts"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPost == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphPost is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPost
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsThreadsDeletePostsRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationThreadApiService
	groupId string
	conversationThreadId string
	postId string
	ifMatch *string
}

// ETag
func (r ApiGroupsThreadsDeletePostsRequest) IfMatch(ifMatch string) ApiGroupsThreadsDeletePostsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsThreadsDeletePostsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsThreadsDeletePostsExecute(r)
}

/*
GroupsThreadsDeletePosts Delete navigation property posts for groups

Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @return ApiGroupsThreadsDeletePostsRequest
*/
func (a *GroupsConversationThreadApiService) GroupsThreadsDeletePosts(ctx _context.Context, groupId string, conversationThreadId string, postId string) ApiGroupsThreadsDeletePostsRequest {
	return ApiGroupsThreadsDeletePostsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationThreadId: conversationThreadId,
		postId: postId,
	}
}

// Execute executes the request
func (a *GroupsConversationThreadApiService) GroupsThreadsDeletePostsExecute(r ApiGroupsThreadsDeletePostsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationThreadApiService.GroupsThreadsDeletePosts")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/threads/{conversationThread-id}/posts/{post-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsThreadsGetPostsRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationThreadApiService
	groupId string
	conversationThreadId string
	postId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiGroupsThreadsGetPostsRequest) Select_(select_ []string) ApiGroupsThreadsGetPostsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsThreadsGetPostsRequest) Expand(expand []string) ApiGroupsThreadsGetPostsRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsThreadsGetPostsRequest) Execute() (MicrosoftGraphPost, *_nethttp.Response, error) {
	return r.ApiService.GroupsThreadsGetPostsExecute(r)
}

/*
GroupsThreadsGetPosts Get posts from groups

Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @return ApiGroupsThreadsGetPostsRequest
*/
func (a *GroupsConversationThreadApiService) GroupsThreadsGetPosts(ctx _context.Context, groupId string, conversationThreadId string, postId string) ApiGroupsThreadsGetPostsRequest {
	return ApiGroupsThreadsGetPostsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationThreadId: conversationThreadId,
		postId: postId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPost
func (a *GroupsConversationThreadApiService) GroupsThreadsGetPostsExecute(r ApiGroupsThreadsGetPostsRequest) (MicrosoftGraphPost, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPost
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationThreadApiService.GroupsThreadsGetPosts")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/threads/{conversationThread-id}/posts/{post-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsThreadsListPostsRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationThreadApiService
	groupId string
	conversationThreadId string
	top *int32
	skip *int32
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiGroupsThreadsListPostsRequest) Top(top int32) ApiGroupsThreadsListPostsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsThreadsListPostsRequest) Skip(skip int32) ApiGroupsThreadsListPostsRequest {
	r.skip = &skip
	return r
}
// Filter items by property values
func (r ApiGroupsThreadsListPostsRequest) Filter(filter string) ApiGroupsThreadsListPostsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsThreadsListPostsRequest) Count(count bool) ApiGroupsThreadsListPostsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsThreadsListPostsRequest) Orderby(orderby []string) ApiGroupsThreadsListPostsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiGroupsThreadsListPostsRequest) Select_(select_ []string) ApiGroupsThreadsListPostsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsThreadsListPostsRequest) Expand(expand []string) ApiGroupsThreadsListPostsRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsThreadsListPostsRequest) Execute() (CollectionOfPost, *_nethttp.Response, error) {
	return r.ApiService.GroupsThreadsListPostsExecute(r)
}

/*
GroupsThreadsListPosts Get posts from groups

Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationThreadId key: id of conversationThread
 @return ApiGroupsThreadsListPostsRequest
*/
func (a *GroupsConversationThreadApiService) GroupsThreadsListPosts(ctx _context.Context, groupId string, conversationThreadId string) ApiGroupsThreadsListPostsRequest {
	return ApiGroupsThreadsListPostsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationThreadId: conversationThreadId,
	}
}

// Execute executes the request
//  @return CollectionOfPost
func (a *GroupsConversationThreadApiService) GroupsThreadsListPostsExecute(r ApiGroupsThreadsListPostsRequest) (CollectionOfPost, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfPost
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationThreadApiService.GroupsThreadsListPosts")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/threads/{conversationThread-id}/posts"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsThreadsPostsCreateAttachmentsRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationThreadApiService
	groupId string
	conversationThreadId string
	postId string
	microsoftGraphAttachment *MicrosoftGraphAttachment
}

// New navigation property
func (r ApiGroupsThreadsPostsCreateAttachmentsRequest) MicrosoftGraphAttachment(microsoftGraphAttachment MicrosoftGraphAttachment) ApiGroupsThreadsPostsCreateAttachmentsRequest {
	r.microsoftGraphAttachment = &microsoftGraphAttachment
	return r
}

func (r ApiGroupsThreadsPostsCreateAttachmentsRequest) Execute() (MicrosoftGraphAttachment, *_nethttp.Response, error) {
	return r.ApiService.GroupsThreadsPostsCreateAttachmentsExecute(r)
}

/*
GroupsThreadsPostsCreateAttachments Create new navigation property to attachments for groups

Read-only. Nullable. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @return ApiGroupsThreadsPostsCreateAttachmentsRequest
*/
func (a *GroupsConversationThreadApiService) GroupsThreadsPostsCreateAttachments(ctx _context.Context, groupId string, conversationThreadId string, postId string) ApiGroupsThreadsPostsCreateAttachmentsRequest {
	return ApiGroupsThreadsPostsCreateAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationThreadId: conversationThreadId,
		postId: postId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphAttachment
func (a *GroupsConversationThreadApiService) GroupsThreadsPostsCreateAttachmentsExecute(r ApiGroupsThreadsPostsCreateAttachmentsRequest) (MicrosoftGraphAttachment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphAttachment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationThreadApiService.GroupsThreadsPostsCreateAttachments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/threads/{conversationThread-id}/posts/{post-id}/attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphAttachment == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphAttachment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphAttachment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsThreadsPostsCreateExtensionsRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationThreadApiService
	groupId string
	conversationThreadId string
	postId string
	microsoftGraphExtension *MicrosoftGraphExtension
}

// New navigation property
func (r ApiGroupsThreadsPostsCreateExtensionsRequest) MicrosoftGraphExtension(microsoftGraphExtension MicrosoftGraphExtension) ApiGroupsThreadsPostsCreateExtensionsRequest {
	r.microsoftGraphExtension = &microsoftGraphExtension
	return r
}

func (r ApiGroupsThreadsPostsCreateExtensionsRequest) Execute() (MicrosoftGraphExtension, *_nethttp.Response, error) {
	return r.ApiService.GroupsThreadsPostsCreateExtensionsExecute(r)
}

/*
GroupsThreadsPostsCreateExtensions Create new navigation property to extensions for groups

The collection of open extensions defined for the post. Read-only. Nullable. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @return ApiGroupsThreadsPostsCreateExtensionsRequest
*/
func (a *GroupsConversationThreadApiService) GroupsThreadsPostsCreateExtensions(ctx _context.Context, groupId string, conversationThreadId string, postId string) ApiGroupsThreadsPostsCreateExtensionsRequest {
	return ApiGroupsThreadsPostsCreateExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationThreadId: conversationThreadId,
		postId: postId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphExtension
func (a *GroupsConversationThreadApiService) GroupsThreadsPostsCreateExtensionsExecute(r ApiGroupsThreadsPostsCreateExtensionsRequest) (MicrosoftGraphExtension, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphExtension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationThreadApiService.GroupsThreadsPostsCreateExtensions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/threads/{conversationThread-id}/posts/{post-id}/extensions"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphExtension == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphExtension is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphExtension
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsThreadsPostsCreateMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationThreadApiService
	groupId string
	conversationThreadId string
	postId string
	microsoftGraphMultiValueLegacyExtendedProperty *MicrosoftGraphMultiValueLegacyExtendedProperty
}

// New navigation property
func (r ApiGroupsThreadsPostsCreateMultiValueExtendedPropertiesRequest) MicrosoftGraphMultiValueLegacyExtendedProperty(microsoftGraphMultiValueLegacyExtendedProperty MicrosoftGraphMultiValueLegacyExtendedProperty) ApiGroupsThreadsPostsCreateMultiValueExtendedPropertiesRequest {
	r.microsoftGraphMultiValueLegacyExtendedProperty = &microsoftGraphMultiValueLegacyExtendedProperty
	return r
}

func (r ApiGroupsThreadsPostsCreateMultiValueExtendedPropertiesRequest) Execute() (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.GroupsThreadsPostsCreateMultiValueExtendedPropertiesExecute(r)
}

/*
GroupsThreadsPostsCreateMultiValueExtendedProperties Create new navigation property to multiValueExtendedProperties for groups

The collection of multi-value extended properties defined for the post. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @return ApiGroupsThreadsPostsCreateMultiValueExtendedPropertiesRequest
*/
func (a *GroupsConversationThreadApiService) GroupsThreadsPostsCreateMultiValueExtendedProperties(ctx _context.Context, groupId string, conversationThreadId string, postId string) ApiGroupsThreadsPostsCreateMultiValueExtendedPropertiesRequest {
	return ApiGroupsThreadsPostsCreateMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationThreadId: conversationThreadId,
		postId: postId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphMultiValueLegacyExtendedProperty
func (a *GroupsConversationThreadApiService) GroupsThreadsPostsCreateMultiValueExtendedPropertiesExecute(r ApiGroupsThreadsPostsCreateMultiValueExtendedPropertiesRequest) (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphMultiValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationThreadApiService.GroupsThreadsPostsCreateMultiValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/threads/{conversationThread-id}/posts/{post-id}/multiValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphMultiValueLegacyExtendedProperty == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphMultiValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphMultiValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsThreadsPostsCreateSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationThreadApiService
	groupId string
	conversationThreadId string
	postId string
	microsoftGraphSingleValueLegacyExtendedProperty *MicrosoftGraphSingleValueLegacyExtendedProperty
}

// New navigation property
func (r ApiGroupsThreadsPostsCreateSingleValueExtendedPropertiesRequest) MicrosoftGraphSingleValueLegacyExtendedProperty(microsoftGraphSingleValueLegacyExtendedProperty MicrosoftGraphSingleValueLegacyExtendedProperty) ApiGroupsThreadsPostsCreateSingleValueExtendedPropertiesRequest {
	r.microsoftGraphSingleValueLegacyExtendedProperty = &microsoftGraphSingleValueLegacyExtendedProperty
	return r
}

func (r ApiGroupsThreadsPostsCreateSingleValueExtendedPropertiesRequest) Execute() (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.GroupsThreadsPostsCreateSingleValueExtendedPropertiesExecute(r)
}

/*
GroupsThreadsPostsCreateSingleValueExtendedProperties Create new navigation property to singleValueExtendedProperties for groups

The collection of single-value extended properties defined for the post. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @return ApiGroupsThreadsPostsCreateSingleValueExtendedPropertiesRequest
*/
func (a *GroupsConversationThreadApiService) GroupsThreadsPostsCreateSingleValueExtendedProperties(ctx _context.Context, groupId string, conversationThreadId string, postId string) ApiGroupsThreadsPostsCreateSingleValueExtendedPropertiesRequest {
	return ApiGroupsThreadsPostsCreateSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationThreadId: conversationThreadId,
		postId: postId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphSingleValueLegacyExtendedProperty
func (a *GroupsConversationThreadApiService) GroupsThreadsPostsCreateSingleValueExtendedPropertiesExecute(r ApiGroupsThreadsPostsCreateSingleValueExtendedPropertiesRequest) (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphSingleValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationThreadApiService.GroupsThreadsPostsCreateSingleValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/threads/{conversationThread-id}/posts/{post-id}/singleValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphSingleValueLegacyExtendedProperty == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphSingleValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphSingleValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsThreadsPostsDeleteAttachmentsRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationThreadApiService
	groupId string
	conversationThreadId string
	postId string
	attachmentId string
	ifMatch *string
}

// ETag
func (r ApiGroupsThreadsPostsDeleteAttachmentsRequest) IfMatch(ifMatch string) ApiGroupsThreadsPostsDeleteAttachmentsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsThreadsPostsDeleteAttachmentsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsThreadsPostsDeleteAttachmentsExecute(r)
}

/*
GroupsThreadsPostsDeleteAttachments Delete navigation property attachments for groups

Read-only. Nullable. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @param attachmentId key: id of attachment
 @return ApiGroupsThreadsPostsDeleteAttachmentsRequest
*/
func (a *GroupsConversationThreadApiService) GroupsThreadsPostsDeleteAttachments(ctx _context.Context, groupId string, conversationThreadId string, postId string, attachmentId string) ApiGroupsThreadsPostsDeleteAttachmentsRequest {
	return ApiGroupsThreadsPostsDeleteAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationThreadId: conversationThreadId,
		postId: postId,
		attachmentId: attachmentId,
	}
}

// Execute executes the request
func (a *GroupsConversationThreadApiService) GroupsThreadsPostsDeleteAttachmentsExecute(r ApiGroupsThreadsPostsDeleteAttachmentsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationThreadApiService.GroupsThreadsPostsDeleteAttachments")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/threads/{conversationThread-id}/posts/{post-id}/attachments/{attachment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment-id"+"}", _neturl.PathEscape(parameterToString(r.attachmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsThreadsPostsDeleteExtensionsRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationThreadApiService
	groupId string
	conversationThreadId string
	postId string
	extensionId string
	ifMatch *string
}

// ETag
func (r ApiGroupsThreadsPostsDeleteExtensionsRequest) IfMatch(ifMatch string) ApiGroupsThreadsPostsDeleteExtensionsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsThreadsPostsDeleteExtensionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsThreadsPostsDeleteExtensionsExecute(r)
}

/*
GroupsThreadsPostsDeleteExtensions Delete navigation property extensions for groups

The collection of open extensions defined for the post. Read-only. Nullable. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @param extensionId key: id of extension
 @return ApiGroupsThreadsPostsDeleteExtensionsRequest
*/
func (a *GroupsConversationThreadApiService) GroupsThreadsPostsDeleteExtensions(ctx _context.Context, groupId string, conversationThreadId string, postId string, extensionId string) ApiGroupsThreadsPostsDeleteExtensionsRequest {
	return ApiGroupsThreadsPostsDeleteExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationThreadId: conversationThreadId,
		postId: postId,
		extensionId: extensionId,
	}
}

// Execute executes the request
func (a *GroupsConversationThreadApiService) GroupsThreadsPostsDeleteExtensionsExecute(r ApiGroupsThreadsPostsDeleteExtensionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationThreadApiService.GroupsThreadsPostsDeleteExtensions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/threads/{conversationThread-id}/posts/{post-id}/extensions/{extension-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension-id"+"}", _neturl.PathEscape(parameterToString(r.extensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsThreadsPostsDeleteInReplyToRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationThreadApiService
	groupId string
	conversationThreadId string
	postId string
	ifMatch *string
}

// ETag
func (r ApiGroupsThreadsPostsDeleteInReplyToRequest) IfMatch(ifMatch string) ApiGroupsThreadsPostsDeleteInReplyToRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsThreadsPostsDeleteInReplyToRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsThreadsPostsDeleteInReplyToExecute(r)
}

/*
GroupsThreadsPostsDeleteInReplyTo Delete navigation property inReplyTo for groups

Read-only. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @return ApiGroupsThreadsPostsDeleteInReplyToRequest
*/
func (a *GroupsConversationThreadApiService) GroupsThreadsPostsDeleteInReplyTo(ctx _context.Context, groupId string, conversationThreadId string, postId string) ApiGroupsThreadsPostsDeleteInReplyToRequest {
	return ApiGroupsThreadsPostsDeleteInReplyToRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationThreadId: conversationThreadId,
		postId: postId,
	}
}

// Execute executes the request
func (a *GroupsConversationThreadApiService) GroupsThreadsPostsDeleteInReplyToExecute(r ApiGroupsThreadsPostsDeleteInReplyToRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationThreadApiService.GroupsThreadsPostsDeleteInReplyTo")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/threads/{conversationThread-id}/posts/{post-id}/inReplyTo"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsThreadsPostsDeleteMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationThreadApiService
	groupId string
	conversationThreadId string
	postId string
	multiValueLegacyExtendedPropertyId string
	ifMatch *string
}

// ETag
func (r ApiGroupsThreadsPostsDeleteMultiValueExtendedPropertiesRequest) IfMatch(ifMatch string) ApiGroupsThreadsPostsDeleteMultiValueExtendedPropertiesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsThreadsPostsDeleteMultiValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsThreadsPostsDeleteMultiValueExtendedPropertiesExecute(r)
}

/*
GroupsThreadsPostsDeleteMultiValueExtendedProperties Delete navigation property multiValueExtendedProperties for groups

The collection of multi-value extended properties defined for the post. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @param multiValueLegacyExtendedPropertyId key: id of multiValueLegacyExtendedProperty
 @return ApiGroupsThreadsPostsDeleteMultiValueExtendedPropertiesRequest
*/
func (a *GroupsConversationThreadApiService) GroupsThreadsPostsDeleteMultiValueExtendedProperties(ctx _context.Context, groupId string, conversationThreadId string, postId string, multiValueLegacyExtendedPropertyId string) ApiGroupsThreadsPostsDeleteMultiValueExtendedPropertiesRequest {
	return ApiGroupsThreadsPostsDeleteMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationThreadId: conversationThreadId,
		postId: postId,
		multiValueLegacyExtendedPropertyId: multiValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *GroupsConversationThreadApiService) GroupsThreadsPostsDeleteMultiValueExtendedPropertiesExecute(r ApiGroupsThreadsPostsDeleteMultiValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationThreadApiService.GroupsThreadsPostsDeleteMultiValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/threads/{conversationThread-id}/posts/{post-id}/multiValueExtendedProperties/{multiValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"multiValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.multiValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsThreadsPostsDeleteSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationThreadApiService
	groupId string
	conversationThreadId string
	postId string
	singleValueLegacyExtendedPropertyId string
	ifMatch *string
}

// ETag
func (r ApiGroupsThreadsPostsDeleteSingleValueExtendedPropertiesRequest) IfMatch(ifMatch string) ApiGroupsThreadsPostsDeleteSingleValueExtendedPropertiesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsThreadsPostsDeleteSingleValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsThreadsPostsDeleteSingleValueExtendedPropertiesExecute(r)
}

/*
GroupsThreadsPostsDeleteSingleValueExtendedProperties Delete navigation property singleValueExtendedProperties for groups

The collection of single-value extended properties defined for the post. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @param singleValueLegacyExtendedPropertyId key: id of singleValueLegacyExtendedProperty
 @return ApiGroupsThreadsPostsDeleteSingleValueExtendedPropertiesRequest
*/
func (a *GroupsConversationThreadApiService) GroupsThreadsPostsDeleteSingleValueExtendedProperties(ctx _context.Context, groupId string, conversationThreadId string, postId string, singleValueLegacyExtendedPropertyId string) ApiGroupsThreadsPostsDeleteSingleValueExtendedPropertiesRequest {
	return ApiGroupsThreadsPostsDeleteSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationThreadId: conversationThreadId,
		postId: postId,
		singleValueLegacyExtendedPropertyId: singleValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *GroupsConversationThreadApiService) GroupsThreadsPostsDeleteSingleValueExtendedPropertiesExecute(r ApiGroupsThreadsPostsDeleteSingleValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationThreadApiService.GroupsThreadsPostsDeleteSingleValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/threads/{conversationThread-id}/posts/{post-id}/singleValueExtendedProperties/{singleValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"singleValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.singleValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsThreadsPostsGetAttachmentsRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationThreadApiService
	groupId string
	conversationThreadId string
	postId string
	attachmentId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiGroupsThreadsPostsGetAttachmentsRequest) Select_(select_ []string) ApiGroupsThreadsPostsGetAttachmentsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsThreadsPostsGetAttachmentsRequest) Expand(expand []string) ApiGroupsThreadsPostsGetAttachmentsRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsThreadsPostsGetAttachmentsRequest) Execute() (MicrosoftGraphAttachment, *_nethttp.Response, error) {
	return r.ApiService.GroupsThreadsPostsGetAttachmentsExecute(r)
}

/*
GroupsThreadsPostsGetAttachments Get attachments from groups

Read-only. Nullable. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @param attachmentId key: id of attachment
 @return ApiGroupsThreadsPostsGetAttachmentsRequest
*/
func (a *GroupsConversationThreadApiService) GroupsThreadsPostsGetAttachments(ctx _context.Context, groupId string, conversationThreadId string, postId string, attachmentId string) ApiGroupsThreadsPostsGetAttachmentsRequest {
	return ApiGroupsThreadsPostsGetAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationThreadId: conversationThreadId,
		postId: postId,
		attachmentId: attachmentId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphAttachment
func (a *GroupsConversationThreadApiService) GroupsThreadsPostsGetAttachmentsExecute(r ApiGroupsThreadsPostsGetAttachmentsRequest) (MicrosoftGraphAttachment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphAttachment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationThreadApiService.GroupsThreadsPostsGetAttachments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/threads/{conversationThread-id}/posts/{post-id}/attachments/{attachment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment-id"+"}", _neturl.PathEscape(parameterToString(r.attachmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsThreadsPostsGetExtensionsRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationThreadApiService
	groupId string
	conversationThreadId string
	postId string
	extensionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiGroupsThreadsPostsGetExtensionsRequest) Select_(select_ []string) ApiGroupsThreadsPostsGetExtensionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsThreadsPostsGetExtensionsRequest) Expand(expand []string) ApiGroupsThreadsPostsGetExtensionsRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsThreadsPostsGetExtensionsRequest) Execute() (MicrosoftGraphExtension, *_nethttp.Response, error) {
	return r.ApiService.GroupsThreadsPostsGetExtensionsExecute(r)
}

/*
GroupsThreadsPostsGetExtensions Get extensions from groups

The collection of open extensions defined for the post. Read-only. Nullable. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @param extensionId key: id of extension
 @return ApiGroupsThreadsPostsGetExtensionsRequest
*/
func (a *GroupsConversationThreadApiService) GroupsThreadsPostsGetExtensions(ctx _context.Context, groupId string, conversationThreadId string, postId string, extensionId string) ApiGroupsThreadsPostsGetExtensionsRequest {
	return ApiGroupsThreadsPostsGetExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationThreadId: conversationThreadId,
		postId: postId,
		extensionId: extensionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphExtension
func (a *GroupsConversationThreadApiService) GroupsThreadsPostsGetExtensionsExecute(r ApiGroupsThreadsPostsGetExtensionsRequest) (MicrosoftGraphExtension, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphExtension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationThreadApiService.GroupsThreadsPostsGetExtensions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/threads/{conversationThread-id}/posts/{post-id}/extensions/{extension-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension-id"+"}", _neturl.PathEscape(parameterToString(r.extensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsThreadsPostsGetInReplyToRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationThreadApiService
	groupId string
	conversationThreadId string
	postId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiGroupsThreadsPostsGetInReplyToRequest) Select_(select_ []string) ApiGroupsThreadsPostsGetInReplyToRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsThreadsPostsGetInReplyToRequest) Expand(expand []string) ApiGroupsThreadsPostsGetInReplyToRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsThreadsPostsGetInReplyToRequest) Execute() (MicrosoftGraphPost, *_nethttp.Response, error) {
	return r.ApiService.GroupsThreadsPostsGetInReplyToExecute(r)
}

/*
GroupsThreadsPostsGetInReplyTo Get inReplyTo from groups

Read-only. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @return ApiGroupsThreadsPostsGetInReplyToRequest
*/
func (a *GroupsConversationThreadApiService) GroupsThreadsPostsGetInReplyTo(ctx _context.Context, groupId string, conversationThreadId string, postId string) ApiGroupsThreadsPostsGetInReplyToRequest {
	return ApiGroupsThreadsPostsGetInReplyToRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationThreadId: conversationThreadId,
		postId: postId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPost
func (a *GroupsConversationThreadApiService) GroupsThreadsPostsGetInReplyToExecute(r ApiGroupsThreadsPostsGetInReplyToRequest) (MicrosoftGraphPost, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPost
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationThreadApiService.GroupsThreadsPostsGetInReplyTo")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/threads/{conversationThread-id}/posts/{post-id}/inReplyTo"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsThreadsPostsGetMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationThreadApiService
	groupId string
	conversationThreadId string
	postId string
	multiValueLegacyExtendedPropertyId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiGroupsThreadsPostsGetMultiValueExtendedPropertiesRequest) Select_(select_ []string) ApiGroupsThreadsPostsGetMultiValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsThreadsPostsGetMultiValueExtendedPropertiesRequest) Expand(expand []string) ApiGroupsThreadsPostsGetMultiValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsThreadsPostsGetMultiValueExtendedPropertiesRequest) Execute() (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.GroupsThreadsPostsGetMultiValueExtendedPropertiesExecute(r)
}

/*
GroupsThreadsPostsGetMultiValueExtendedProperties Get multiValueExtendedProperties from groups

The collection of multi-value extended properties defined for the post. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @param multiValueLegacyExtendedPropertyId key: id of multiValueLegacyExtendedProperty
 @return ApiGroupsThreadsPostsGetMultiValueExtendedPropertiesRequest
*/
func (a *GroupsConversationThreadApiService) GroupsThreadsPostsGetMultiValueExtendedProperties(ctx _context.Context, groupId string, conversationThreadId string, postId string, multiValueLegacyExtendedPropertyId string) ApiGroupsThreadsPostsGetMultiValueExtendedPropertiesRequest {
	return ApiGroupsThreadsPostsGetMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationThreadId: conversationThreadId,
		postId: postId,
		multiValueLegacyExtendedPropertyId: multiValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphMultiValueLegacyExtendedProperty
func (a *GroupsConversationThreadApiService) GroupsThreadsPostsGetMultiValueExtendedPropertiesExecute(r ApiGroupsThreadsPostsGetMultiValueExtendedPropertiesRequest) (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphMultiValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationThreadApiService.GroupsThreadsPostsGetMultiValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/threads/{conversationThread-id}/posts/{post-id}/multiValueExtendedProperties/{multiValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"multiValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.multiValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsThreadsPostsGetSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationThreadApiService
	groupId string
	conversationThreadId string
	postId string
	singleValueLegacyExtendedPropertyId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiGroupsThreadsPostsGetSingleValueExtendedPropertiesRequest) Select_(select_ []string) ApiGroupsThreadsPostsGetSingleValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsThreadsPostsGetSingleValueExtendedPropertiesRequest) Expand(expand []string) ApiGroupsThreadsPostsGetSingleValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsThreadsPostsGetSingleValueExtendedPropertiesRequest) Execute() (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.GroupsThreadsPostsGetSingleValueExtendedPropertiesExecute(r)
}

/*
GroupsThreadsPostsGetSingleValueExtendedProperties Get singleValueExtendedProperties from groups

The collection of single-value extended properties defined for the post. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @param singleValueLegacyExtendedPropertyId key: id of singleValueLegacyExtendedProperty
 @return ApiGroupsThreadsPostsGetSingleValueExtendedPropertiesRequest
*/
func (a *GroupsConversationThreadApiService) GroupsThreadsPostsGetSingleValueExtendedProperties(ctx _context.Context, groupId string, conversationThreadId string, postId string, singleValueLegacyExtendedPropertyId string) ApiGroupsThreadsPostsGetSingleValueExtendedPropertiesRequest {
	return ApiGroupsThreadsPostsGetSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationThreadId: conversationThreadId,
		postId: postId,
		singleValueLegacyExtendedPropertyId: singleValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphSingleValueLegacyExtendedProperty
func (a *GroupsConversationThreadApiService) GroupsThreadsPostsGetSingleValueExtendedPropertiesExecute(r ApiGroupsThreadsPostsGetSingleValueExtendedPropertiesRequest) (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphSingleValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationThreadApiService.GroupsThreadsPostsGetSingleValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/threads/{conversationThread-id}/posts/{post-id}/singleValueExtendedProperties/{singleValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"singleValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.singleValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsThreadsPostsListAttachmentsRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationThreadApiService
	groupId string
	conversationThreadId string
	postId string
	top *int32
	skip *int32
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiGroupsThreadsPostsListAttachmentsRequest) Top(top int32) ApiGroupsThreadsPostsListAttachmentsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsThreadsPostsListAttachmentsRequest) Skip(skip int32) ApiGroupsThreadsPostsListAttachmentsRequest {
	r.skip = &skip
	return r
}
// Filter items by property values
func (r ApiGroupsThreadsPostsListAttachmentsRequest) Filter(filter string) ApiGroupsThreadsPostsListAttachmentsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsThreadsPostsListAttachmentsRequest) Count(count bool) ApiGroupsThreadsPostsListAttachmentsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsThreadsPostsListAttachmentsRequest) Orderby(orderby []string) ApiGroupsThreadsPostsListAttachmentsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiGroupsThreadsPostsListAttachmentsRequest) Select_(select_ []string) ApiGroupsThreadsPostsListAttachmentsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsThreadsPostsListAttachmentsRequest) Expand(expand []string) ApiGroupsThreadsPostsListAttachmentsRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsThreadsPostsListAttachmentsRequest) Execute() (CollectionOfAttachment, *_nethttp.Response, error) {
	return r.ApiService.GroupsThreadsPostsListAttachmentsExecute(r)
}

/*
GroupsThreadsPostsListAttachments Get attachments from groups

Read-only. Nullable. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @return ApiGroupsThreadsPostsListAttachmentsRequest
*/
func (a *GroupsConversationThreadApiService) GroupsThreadsPostsListAttachments(ctx _context.Context, groupId string, conversationThreadId string, postId string) ApiGroupsThreadsPostsListAttachmentsRequest {
	return ApiGroupsThreadsPostsListAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationThreadId: conversationThreadId,
		postId: postId,
	}
}

// Execute executes the request
//  @return CollectionOfAttachment
func (a *GroupsConversationThreadApiService) GroupsThreadsPostsListAttachmentsExecute(r ApiGroupsThreadsPostsListAttachmentsRequest) (CollectionOfAttachment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfAttachment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationThreadApiService.GroupsThreadsPostsListAttachments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/threads/{conversationThread-id}/posts/{post-id}/attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsThreadsPostsListExtensionsRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationThreadApiService
	groupId string
	conversationThreadId string
	postId string
	top *int32
	skip *int32
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiGroupsThreadsPostsListExtensionsRequest) Top(top int32) ApiGroupsThreadsPostsListExtensionsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsThreadsPostsListExtensionsRequest) Skip(skip int32) ApiGroupsThreadsPostsListExtensionsRequest {
	r.skip = &skip
	return r
}
// Filter items by property values
func (r ApiGroupsThreadsPostsListExtensionsRequest) Filter(filter string) ApiGroupsThreadsPostsListExtensionsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsThreadsPostsListExtensionsRequest) Count(count bool) ApiGroupsThreadsPostsListExtensionsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsThreadsPostsListExtensionsRequest) Orderby(orderby []string) ApiGroupsThreadsPostsListExtensionsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiGroupsThreadsPostsListExtensionsRequest) Select_(select_ []string) ApiGroupsThreadsPostsListExtensionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsThreadsPostsListExtensionsRequest) Expand(expand []string) ApiGroupsThreadsPostsListExtensionsRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsThreadsPostsListExtensionsRequest) Execute() (CollectionOfExtension, *_nethttp.Response, error) {
	return r.ApiService.GroupsThreadsPostsListExtensionsExecute(r)
}

/*
GroupsThreadsPostsListExtensions Get extensions from groups

The collection of open extensions defined for the post. Read-only. Nullable. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @return ApiGroupsThreadsPostsListExtensionsRequest
*/
func (a *GroupsConversationThreadApiService) GroupsThreadsPostsListExtensions(ctx _context.Context, groupId string, conversationThreadId string, postId string) ApiGroupsThreadsPostsListExtensionsRequest {
	return ApiGroupsThreadsPostsListExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationThreadId: conversationThreadId,
		postId: postId,
	}
}

// Execute executes the request
//  @return CollectionOfExtension
func (a *GroupsConversationThreadApiService) GroupsThreadsPostsListExtensionsExecute(r ApiGroupsThreadsPostsListExtensionsRequest) (CollectionOfExtension, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfExtension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationThreadApiService.GroupsThreadsPostsListExtensions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/threads/{conversationThread-id}/posts/{post-id}/extensions"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsThreadsPostsListMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationThreadApiService
	groupId string
	conversationThreadId string
	postId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiGroupsThreadsPostsListMultiValueExtendedPropertiesRequest) Top(top int32) ApiGroupsThreadsPostsListMultiValueExtendedPropertiesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsThreadsPostsListMultiValueExtendedPropertiesRequest) Skip(skip int32) ApiGroupsThreadsPostsListMultiValueExtendedPropertiesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiGroupsThreadsPostsListMultiValueExtendedPropertiesRequest) Search(search string) ApiGroupsThreadsPostsListMultiValueExtendedPropertiesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiGroupsThreadsPostsListMultiValueExtendedPropertiesRequest) Filter(filter string) ApiGroupsThreadsPostsListMultiValueExtendedPropertiesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsThreadsPostsListMultiValueExtendedPropertiesRequest) Count(count bool) ApiGroupsThreadsPostsListMultiValueExtendedPropertiesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsThreadsPostsListMultiValueExtendedPropertiesRequest) Orderby(orderby []string) ApiGroupsThreadsPostsListMultiValueExtendedPropertiesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiGroupsThreadsPostsListMultiValueExtendedPropertiesRequest) Select_(select_ []string) ApiGroupsThreadsPostsListMultiValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsThreadsPostsListMultiValueExtendedPropertiesRequest) Expand(expand []string) ApiGroupsThreadsPostsListMultiValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsThreadsPostsListMultiValueExtendedPropertiesRequest) Execute() (CollectionOfMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.GroupsThreadsPostsListMultiValueExtendedPropertiesExecute(r)
}

/*
GroupsThreadsPostsListMultiValueExtendedProperties Get multiValueExtendedProperties from groups

The collection of multi-value extended properties defined for the post. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @return ApiGroupsThreadsPostsListMultiValueExtendedPropertiesRequest
*/
func (a *GroupsConversationThreadApiService) GroupsThreadsPostsListMultiValueExtendedProperties(ctx _context.Context, groupId string, conversationThreadId string, postId string) ApiGroupsThreadsPostsListMultiValueExtendedPropertiesRequest {
	return ApiGroupsThreadsPostsListMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationThreadId: conversationThreadId,
		postId: postId,
	}
}

// Execute executes the request
//  @return CollectionOfMultiValueLegacyExtendedProperty
func (a *GroupsConversationThreadApiService) GroupsThreadsPostsListMultiValueExtendedPropertiesExecute(r ApiGroupsThreadsPostsListMultiValueExtendedPropertiesRequest) (CollectionOfMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfMultiValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationThreadApiService.GroupsThreadsPostsListMultiValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/threads/{conversationThread-id}/posts/{post-id}/multiValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsThreadsPostsListSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationThreadApiService
	groupId string
	conversationThreadId string
	postId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiGroupsThreadsPostsListSingleValueExtendedPropertiesRequest) Top(top int32) ApiGroupsThreadsPostsListSingleValueExtendedPropertiesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsThreadsPostsListSingleValueExtendedPropertiesRequest) Skip(skip int32) ApiGroupsThreadsPostsListSingleValueExtendedPropertiesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiGroupsThreadsPostsListSingleValueExtendedPropertiesRequest) Search(search string) ApiGroupsThreadsPostsListSingleValueExtendedPropertiesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiGroupsThreadsPostsListSingleValueExtendedPropertiesRequest) Filter(filter string) ApiGroupsThreadsPostsListSingleValueExtendedPropertiesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsThreadsPostsListSingleValueExtendedPropertiesRequest) Count(count bool) ApiGroupsThreadsPostsListSingleValueExtendedPropertiesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsThreadsPostsListSingleValueExtendedPropertiesRequest) Orderby(orderby []string) ApiGroupsThreadsPostsListSingleValueExtendedPropertiesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiGroupsThreadsPostsListSingleValueExtendedPropertiesRequest) Select_(select_ []string) ApiGroupsThreadsPostsListSingleValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsThreadsPostsListSingleValueExtendedPropertiesRequest) Expand(expand []string) ApiGroupsThreadsPostsListSingleValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsThreadsPostsListSingleValueExtendedPropertiesRequest) Execute() (CollectionOfSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.GroupsThreadsPostsListSingleValueExtendedPropertiesExecute(r)
}

/*
GroupsThreadsPostsListSingleValueExtendedProperties Get singleValueExtendedProperties from groups

The collection of single-value extended properties defined for the post. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @return ApiGroupsThreadsPostsListSingleValueExtendedPropertiesRequest
*/
func (a *GroupsConversationThreadApiService) GroupsThreadsPostsListSingleValueExtendedProperties(ctx _context.Context, groupId string, conversationThreadId string, postId string) ApiGroupsThreadsPostsListSingleValueExtendedPropertiesRequest {
	return ApiGroupsThreadsPostsListSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationThreadId: conversationThreadId,
		postId: postId,
	}
}

// Execute executes the request
//  @return CollectionOfSingleValueLegacyExtendedProperty
func (a *GroupsConversationThreadApiService) GroupsThreadsPostsListSingleValueExtendedPropertiesExecute(r ApiGroupsThreadsPostsListSingleValueExtendedPropertiesRequest) (CollectionOfSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfSingleValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationThreadApiService.GroupsThreadsPostsListSingleValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/threads/{conversationThread-id}/posts/{post-id}/singleValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsThreadsPostsUpdateAttachmentsRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationThreadApiService
	groupId string
	conversationThreadId string
	postId string
	attachmentId string
	microsoftGraphAttachment *MicrosoftGraphAttachment
}

// New navigation property values
func (r ApiGroupsThreadsPostsUpdateAttachmentsRequest) MicrosoftGraphAttachment(microsoftGraphAttachment MicrosoftGraphAttachment) ApiGroupsThreadsPostsUpdateAttachmentsRequest {
	r.microsoftGraphAttachment = &microsoftGraphAttachment
	return r
}

func (r ApiGroupsThreadsPostsUpdateAttachmentsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsThreadsPostsUpdateAttachmentsExecute(r)
}

/*
GroupsThreadsPostsUpdateAttachments Update the navigation property attachments in groups

Read-only. Nullable. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @param attachmentId key: id of attachment
 @return ApiGroupsThreadsPostsUpdateAttachmentsRequest
*/
func (a *GroupsConversationThreadApiService) GroupsThreadsPostsUpdateAttachments(ctx _context.Context, groupId string, conversationThreadId string, postId string, attachmentId string) ApiGroupsThreadsPostsUpdateAttachmentsRequest {
	return ApiGroupsThreadsPostsUpdateAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationThreadId: conversationThreadId,
		postId: postId,
		attachmentId: attachmentId,
	}
}

// Execute executes the request
func (a *GroupsConversationThreadApiService) GroupsThreadsPostsUpdateAttachmentsExecute(r ApiGroupsThreadsPostsUpdateAttachmentsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationThreadApiService.GroupsThreadsPostsUpdateAttachments")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/threads/{conversationThread-id}/posts/{post-id}/attachments/{attachment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment-id"+"}", _neturl.PathEscape(parameterToString(r.attachmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphAttachment == nil {
		return nil, reportError("microsoftGraphAttachment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphAttachment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsThreadsPostsUpdateExtensionsRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationThreadApiService
	groupId string
	conversationThreadId string
	postId string
	extensionId string
	microsoftGraphExtension *MicrosoftGraphExtension
}

// New navigation property values
func (r ApiGroupsThreadsPostsUpdateExtensionsRequest) MicrosoftGraphExtension(microsoftGraphExtension MicrosoftGraphExtension) ApiGroupsThreadsPostsUpdateExtensionsRequest {
	r.microsoftGraphExtension = &microsoftGraphExtension
	return r
}

func (r ApiGroupsThreadsPostsUpdateExtensionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsThreadsPostsUpdateExtensionsExecute(r)
}

/*
GroupsThreadsPostsUpdateExtensions Update the navigation property extensions in groups

The collection of open extensions defined for the post. Read-only. Nullable. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @param extensionId key: id of extension
 @return ApiGroupsThreadsPostsUpdateExtensionsRequest
*/
func (a *GroupsConversationThreadApiService) GroupsThreadsPostsUpdateExtensions(ctx _context.Context, groupId string, conversationThreadId string, postId string, extensionId string) ApiGroupsThreadsPostsUpdateExtensionsRequest {
	return ApiGroupsThreadsPostsUpdateExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationThreadId: conversationThreadId,
		postId: postId,
		extensionId: extensionId,
	}
}

// Execute executes the request
func (a *GroupsConversationThreadApiService) GroupsThreadsPostsUpdateExtensionsExecute(r ApiGroupsThreadsPostsUpdateExtensionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationThreadApiService.GroupsThreadsPostsUpdateExtensions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/threads/{conversationThread-id}/posts/{post-id}/extensions/{extension-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension-id"+"}", _neturl.PathEscape(parameterToString(r.extensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphExtension == nil {
		return nil, reportError("microsoftGraphExtension is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphExtension
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsThreadsPostsUpdateInReplyToRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationThreadApiService
	groupId string
	conversationThreadId string
	postId string
	microsoftGraphPost *MicrosoftGraphPost
}

// New navigation property values
func (r ApiGroupsThreadsPostsUpdateInReplyToRequest) MicrosoftGraphPost(microsoftGraphPost MicrosoftGraphPost) ApiGroupsThreadsPostsUpdateInReplyToRequest {
	r.microsoftGraphPost = &microsoftGraphPost
	return r
}

func (r ApiGroupsThreadsPostsUpdateInReplyToRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsThreadsPostsUpdateInReplyToExecute(r)
}

/*
GroupsThreadsPostsUpdateInReplyTo Update the navigation property inReplyTo in groups

Read-only. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @return ApiGroupsThreadsPostsUpdateInReplyToRequest
*/
func (a *GroupsConversationThreadApiService) GroupsThreadsPostsUpdateInReplyTo(ctx _context.Context, groupId string, conversationThreadId string, postId string) ApiGroupsThreadsPostsUpdateInReplyToRequest {
	return ApiGroupsThreadsPostsUpdateInReplyToRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationThreadId: conversationThreadId,
		postId: postId,
	}
}

// Execute executes the request
func (a *GroupsConversationThreadApiService) GroupsThreadsPostsUpdateInReplyToExecute(r ApiGroupsThreadsPostsUpdateInReplyToRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationThreadApiService.GroupsThreadsPostsUpdateInReplyTo")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/threads/{conversationThread-id}/posts/{post-id}/inReplyTo"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPost == nil {
		return nil, reportError("microsoftGraphPost is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPost
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsThreadsPostsUpdateMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationThreadApiService
	groupId string
	conversationThreadId string
	postId string
	multiValueLegacyExtendedPropertyId string
	microsoftGraphMultiValueLegacyExtendedProperty *MicrosoftGraphMultiValueLegacyExtendedProperty
}

// New navigation property values
func (r ApiGroupsThreadsPostsUpdateMultiValueExtendedPropertiesRequest) MicrosoftGraphMultiValueLegacyExtendedProperty(microsoftGraphMultiValueLegacyExtendedProperty MicrosoftGraphMultiValueLegacyExtendedProperty) ApiGroupsThreadsPostsUpdateMultiValueExtendedPropertiesRequest {
	r.microsoftGraphMultiValueLegacyExtendedProperty = &microsoftGraphMultiValueLegacyExtendedProperty
	return r
}

func (r ApiGroupsThreadsPostsUpdateMultiValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsThreadsPostsUpdateMultiValueExtendedPropertiesExecute(r)
}

/*
GroupsThreadsPostsUpdateMultiValueExtendedProperties Update the navigation property multiValueExtendedProperties in groups

The collection of multi-value extended properties defined for the post. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @param multiValueLegacyExtendedPropertyId key: id of multiValueLegacyExtendedProperty
 @return ApiGroupsThreadsPostsUpdateMultiValueExtendedPropertiesRequest
*/
func (a *GroupsConversationThreadApiService) GroupsThreadsPostsUpdateMultiValueExtendedProperties(ctx _context.Context, groupId string, conversationThreadId string, postId string, multiValueLegacyExtendedPropertyId string) ApiGroupsThreadsPostsUpdateMultiValueExtendedPropertiesRequest {
	return ApiGroupsThreadsPostsUpdateMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationThreadId: conversationThreadId,
		postId: postId,
		multiValueLegacyExtendedPropertyId: multiValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *GroupsConversationThreadApiService) GroupsThreadsPostsUpdateMultiValueExtendedPropertiesExecute(r ApiGroupsThreadsPostsUpdateMultiValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationThreadApiService.GroupsThreadsPostsUpdateMultiValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/threads/{conversationThread-id}/posts/{post-id}/multiValueExtendedProperties/{multiValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"multiValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.multiValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphMultiValueLegacyExtendedProperty == nil {
		return nil, reportError("microsoftGraphMultiValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphMultiValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsThreadsPostsUpdateSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationThreadApiService
	groupId string
	conversationThreadId string
	postId string
	singleValueLegacyExtendedPropertyId string
	microsoftGraphSingleValueLegacyExtendedProperty *MicrosoftGraphSingleValueLegacyExtendedProperty
}

// New navigation property values
func (r ApiGroupsThreadsPostsUpdateSingleValueExtendedPropertiesRequest) MicrosoftGraphSingleValueLegacyExtendedProperty(microsoftGraphSingleValueLegacyExtendedProperty MicrosoftGraphSingleValueLegacyExtendedProperty) ApiGroupsThreadsPostsUpdateSingleValueExtendedPropertiesRequest {
	r.microsoftGraphSingleValueLegacyExtendedProperty = &microsoftGraphSingleValueLegacyExtendedProperty
	return r
}

func (r ApiGroupsThreadsPostsUpdateSingleValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsThreadsPostsUpdateSingleValueExtendedPropertiesExecute(r)
}

/*
GroupsThreadsPostsUpdateSingleValueExtendedProperties Update the navigation property singleValueExtendedProperties in groups

The collection of single-value extended properties defined for the post. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @param singleValueLegacyExtendedPropertyId key: id of singleValueLegacyExtendedProperty
 @return ApiGroupsThreadsPostsUpdateSingleValueExtendedPropertiesRequest
*/
func (a *GroupsConversationThreadApiService) GroupsThreadsPostsUpdateSingleValueExtendedProperties(ctx _context.Context, groupId string, conversationThreadId string, postId string, singleValueLegacyExtendedPropertyId string) ApiGroupsThreadsPostsUpdateSingleValueExtendedPropertiesRequest {
	return ApiGroupsThreadsPostsUpdateSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationThreadId: conversationThreadId,
		postId: postId,
		singleValueLegacyExtendedPropertyId: singleValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *GroupsConversationThreadApiService) GroupsThreadsPostsUpdateSingleValueExtendedPropertiesExecute(r ApiGroupsThreadsPostsUpdateSingleValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationThreadApiService.GroupsThreadsPostsUpdateSingleValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/threads/{conversationThread-id}/posts/{post-id}/singleValueExtendedProperties/{singleValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"singleValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.singleValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphSingleValueLegacyExtendedProperty == nil {
		return nil, reportError("microsoftGraphSingleValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphSingleValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsThreadsUpdatePostsRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationThreadApiService
	groupId string
	conversationThreadId string
	postId string
	microsoftGraphPost *MicrosoftGraphPost
}

// New navigation property values
func (r ApiGroupsThreadsUpdatePostsRequest) MicrosoftGraphPost(microsoftGraphPost MicrosoftGraphPost) ApiGroupsThreadsUpdatePostsRequest {
	r.microsoftGraphPost = &microsoftGraphPost
	return r
}

func (r ApiGroupsThreadsUpdatePostsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsThreadsUpdatePostsExecute(r)
}

/*
GroupsThreadsUpdatePosts Update the navigation property posts in groups

Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @return ApiGroupsThreadsUpdatePostsRequest
*/
func (a *GroupsConversationThreadApiService) GroupsThreadsUpdatePosts(ctx _context.Context, groupId string, conversationThreadId string, postId string) ApiGroupsThreadsUpdatePostsRequest {
	return ApiGroupsThreadsUpdatePostsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationThreadId: conversationThreadId,
		postId: postId,
	}
}

// Execute executes the request
func (a *GroupsConversationThreadApiService) GroupsThreadsUpdatePostsExecute(r ApiGroupsThreadsUpdatePostsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationThreadApiService.GroupsThreadsUpdatePosts")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/threads/{conversationThread-id}/posts/{post-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPost == nil {
		return nil, reportError("microsoftGraphPost is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPost
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsUpdateThreadsRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationThreadApiService
	groupId string
	conversationThreadId string
	microsoftGraphConversationThread *MicrosoftGraphConversationThread
}

// New navigation property values
func (r ApiGroupsUpdateThreadsRequest) MicrosoftGraphConversationThread(microsoftGraphConversationThread MicrosoftGraphConversationThread) ApiGroupsUpdateThreadsRequest {
	r.microsoftGraphConversationThread = &microsoftGraphConversationThread
	return r
}

func (r ApiGroupsUpdateThreadsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsUpdateThreadsExecute(r)
}

/*
GroupsUpdateThreads Update the navigation property threads in groups

The group's conversation threads. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationThreadId key: id of conversationThread
 @return ApiGroupsUpdateThreadsRequest
*/
func (a *GroupsConversationThreadApiService) GroupsUpdateThreads(ctx _context.Context, groupId string, conversationThreadId string) ApiGroupsUpdateThreadsRequest {
	return ApiGroupsUpdateThreadsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationThreadId: conversationThreadId,
	}
}

// Execute executes the request
func (a *GroupsConversationThreadApiService) GroupsUpdateThreadsExecute(r ApiGroupsUpdateThreadsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationThreadApiService.GroupsUpdateThreads")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/threads/{conversationThread-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphConversationThread == nil {
		return nil, reportError("microsoftGraphConversationThread is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphConversationThread
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
