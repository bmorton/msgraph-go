/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package msgraph

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// MeActionsApiService MeActionsApi service
type MeActionsApiService service

type ApiMeAssignLicenseRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	inlineObject585 *InlineObject585
}

func (r ApiMeAssignLicenseRequest) InlineObject585(inlineObject585 InlineObject585) ApiMeAssignLicenseRequest {
	r.inlineObject585 = &inlineObject585
	return r
}

func (r ApiMeAssignLicenseRequest) Execute() (AnyOfmicrosoftGraphUser, *_nethttp.Response, error) {
	return r.ApiService.MeAssignLicenseExecute(r)
}

/*
MeAssignLicense Invoke action assignLicense

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMeAssignLicenseRequest
*/
func (a *MeActionsApiService) MeAssignLicense(ctx _context.Context) ApiMeAssignLicenseRequest {
	return ApiMeAssignLicenseRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphUser
func (a *MeActionsApiService) MeAssignLicenseExecute(r ApiMeAssignLicenseRequest) (AnyOfmicrosoftGraphUser, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphUser
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeAssignLicense")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/microsoft.graph.assignLicense"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject585 == nil {
		return localVarReturnValue, nil, reportError("inlineObject585 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject585
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarCalendarViewEventAcceptRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	inlineObject367 *InlineObject367
}

func (r ApiMeCalendarCalendarViewEventAcceptRequest) InlineObject367(inlineObject367 InlineObject367) ApiMeCalendarCalendarViewEventAcceptRequest {
	r.inlineObject367 = &inlineObject367
	return r
}

func (r ApiMeCalendarCalendarViewEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarCalendarViewEventAcceptExecute(r)
}

/*
MeCalendarCalendarViewEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @return ApiMeCalendarCalendarViewEventAcceptRequest
*/
func (a *MeActionsApiService) MeCalendarCalendarViewEventAccept(ctx _context.Context, eventId string) ApiMeCalendarCalendarViewEventAcceptRequest {
	return ApiMeCalendarCalendarViewEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarCalendarViewEventAcceptExecute(r ApiMeCalendarCalendarViewEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarCalendarViewEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendar/calendarView/{event-id}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject367 == nil {
		return nil, reportError("inlineObject367 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject367
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	inlineObject359 *InlineObject359
}

func (r ApiMeCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest) InlineObject359(inlineObject359 InlineObject359) ApiMeCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest {
	r.inlineObject359 = &inlineObject359
	return r
}

func (r ApiMeCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest) Execute() (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarCalendarViewEventAttachmentsCreateUploadSessionExecute(r)
}

/*
MeCalendarCalendarViewEventAttachmentsCreateUploadSession Invoke action createUploadSession

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @return ApiMeCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest
*/
func (a *MeActionsApiService) MeCalendarCalendarViewEventAttachmentsCreateUploadSession(ctx _context.Context, eventId string) ApiMeCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest {
	return ApiMeCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphUploadSession
func (a *MeActionsApiService) MeCalendarCalendarViewEventAttachmentsCreateUploadSessionExecute(r ApiMeCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest) (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphUploadSession
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarCalendarViewEventAttachmentsCreateUploadSession")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendar/calendarView/{event-id}/attachments/microsoft.graph.createUploadSession"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject359 == nil {
		return localVarReturnValue, nil, reportError("inlineObject359 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject359
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarCalendarViewEventCalendarGetScheduleRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	inlineObject360 *InlineObject360
}

func (r ApiMeCalendarCalendarViewEventCalendarGetScheduleRequest) InlineObject360(inlineObject360 InlineObject360) ApiMeCalendarCalendarViewEventCalendarGetScheduleRequest {
	r.inlineObject360 = &inlineObject360
	return r
}

func (r ApiMeCalendarCalendarViewEventCalendarGetScheduleRequest) Execute() ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarCalendarViewEventCalendarGetScheduleExecute(r)
}

/*
MeCalendarCalendarViewEventCalendarGetSchedule Invoke action getSchedule

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @return ApiMeCalendarCalendarViewEventCalendarGetScheduleRequest
*/
func (a *MeActionsApiService) MeCalendarCalendarViewEventCalendarGetSchedule(ctx _context.Context, eventId string) ApiMeCalendarCalendarViewEventCalendarGetScheduleRequest {
	return ApiMeCalendarCalendarViewEventCalendarGetScheduleRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return []*AnyOfmicrosoftGraphScheduleInformation
func (a *MeActionsApiService) MeCalendarCalendarViewEventCalendarGetScheduleExecute(r ApiMeCalendarCalendarViewEventCalendarGetScheduleRequest) ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []*AnyOfmicrosoftGraphScheduleInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarCalendarViewEventCalendarGetSchedule")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendar/calendarView/{event-id}/calendar/microsoft.graph.getSchedule"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject360 == nil {
		return localVarReturnValue, nil, reportError("inlineObject360 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject360
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarCalendarViewEventCancelRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	inlineObject368 *InlineObject368
}

func (r ApiMeCalendarCalendarViewEventCancelRequest) InlineObject368(inlineObject368 InlineObject368) ApiMeCalendarCalendarViewEventCancelRequest {
	r.inlineObject368 = &inlineObject368
	return r
}

func (r ApiMeCalendarCalendarViewEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarCalendarViewEventCancelExecute(r)
}

/*
MeCalendarCalendarViewEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @return ApiMeCalendarCalendarViewEventCancelRequest
*/
func (a *MeActionsApiService) MeCalendarCalendarViewEventCancel(ctx _context.Context, eventId string) ApiMeCalendarCalendarViewEventCancelRequest {
	return ApiMeCalendarCalendarViewEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarCalendarViewEventCancelExecute(r ApiMeCalendarCalendarViewEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarCalendarViewEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendar/calendarView/{event-id}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject368 == nil {
		return nil, reportError("inlineObject368 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject368
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarCalendarViewEventDeclineRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	inlineObject369 *InlineObject369
}

func (r ApiMeCalendarCalendarViewEventDeclineRequest) InlineObject369(inlineObject369 InlineObject369) ApiMeCalendarCalendarViewEventDeclineRequest {
	r.inlineObject369 = &inlineObject369
	return r
}

func (r ApiMeCalendarCalendarViewEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarCalendarViewEventDeclineExecute(r)
}

/*
MeCalendarCalendarViewEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @return ApiMeCalendarCalendarViewEventDeclineRequest
*/
func (a *MeActionsApiService) MeCalendarCalendarViewEventDecline(ctx _context.Context, eventId string) ApiMeCalendarCalendarViewEventDeclineRequest {
	return ApiMeCalendarCalendarViewEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarCalendarViewEventDeclineExecute(r ApiMeCalendarCalendarViewEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarCalendarViewEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendar/calendarView/{event-id}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject369 == nil {
		return nil, reportError("inlineObject369 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject369
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarCalendarViewEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
}


func (r ApiMeCalendarCalendarViewEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarCalendarViewEventDismissReminderExecute(r)
}

/*
MeCalendarCalendarViewEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @return ApiMeCalendarCalendarViewEventDismissReminderRequest
*/
func (a *MeActionsApiService) MeCalendarCalendarViewEventDismissReminder(ctx _context.Context, eventId string) ApiMeCalendarCalendarViewEventDismissReminderRequest {
	return ApiMeCalendarCalendarViewEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarCalendarViewEventDismissReminderExecute(r ApiMeCalendarCalendarViewEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarCalendarViewEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendar/calendarView/{event-id}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarCalendarViewEventForwardRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	inlineObject370 *InlineObject370
}

func (r ApiMeCalendarCalendarViewEventForwardRequest) InlineObject370(inlineObject370 InlineObject370) ApiMeCalendarCalendarViewEventForwardRequest {
	r.inlineObject370 = &inlineObject370
	return r
}

func (r ApiMeCalendarCalendarViewEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarCalendarViewEventForwardExecute(r)
}

/*
MeCalendarCalendarViewEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @return ApiMeCalendarCalendarViewEventForwardRequest
*/
func (a *MeActionsApiService) MeCalendarCalendarViewEventForward(ctx _context.Context, eventId string) ApiMeCalendarCalendarViewEventForwardRequest {
	return ApiMeCalendarCalendarViewEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarCalendarViewEventForwardExecute(r ApiMeCalendarCalendarViewEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarCalendarViewEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendar/calendarView/{event-id}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject370 == nil {
		return nil, reportError("inlineObject370 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject370
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarCalendarViewEventInstancesEventAcceptRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
	inlineObject361 *InlineObject361
}

func (r ApiMeCalendarCalendarViewEventInstancesEventAcceptRequest) InlineObject361(inlineObject361 InlineObject361) ApiMeCalendarCalendarViewEventInstancesEventAcceptRequest {
	r.inlineObject361 = &inlineObject361
	return r
}

func (r ApiMeCalendarCalendarViewEventInstancesEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarCalendarViewEventInstancesEventAcceptExecute(r)
}

/*
MeCalendarCalendarViewEventInstancesEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarCalendarViewEventInstancesEventAcceptRequest
*/
func (a *MeActionsApiService) MeCalendarCalendarViewEventInstancesEventAccept(ctx _context.Context, eventId string, eventId1 string) ApiMeCalendarCalendarViewEventInstancesEventAcceptRequest {
	return ApiMeCalendarCalendarViewEventInstancesEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarCalendarViewEventInstancesEventAcceptExecute(r ApiMeCalendarCalendarViewEventInstancesEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarCalendarViewEventInstancesEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendar/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject361 == nil {
		return nil, reportError("inlineObject361 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject361
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarCalendarViewEventInstancesEventCancelRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
	inlineObject362 *InlineObject362
}

func (r ApiMeCalendarCalendarViewEventInstancesEventCancelRequest) InlineObject362(inlineObject362 InlineObject362) ApiMeCalendarCalendarViewEventInstancesEventCancelRequest {
	r.inlineObject362 = &inlineObject362
	return r
}

func (r ApiMeCalendarCalendarViewEventInstancesEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarCalendarViewEventInstancesEventCancelExecute(r)
}

/*
MeCalendarCalendarViewEventInstancesEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarCalendarViewEventInstancesEventCancelRequest
*/
func (a *MeActionsApiService) MeCalendarCalendarViewEventInstancesEventCancel(ctx _context.Context, eventId string, eventId1 string) ApiMeCalendarCalendarViewEventInstancesEventCancelRequest {
	return ApiMeCalendarCalendarViewEventInstancesEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarCalendarViewEventInstancesEventCancelExecute(r ApiMeCalendarCalendarViewEventInstancesEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarCalendarViewEventInstancesEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendar/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject362 == nil {
		return nil, reportError("inlineObject362 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject362
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarCalendarViewEventInstancesEventDeclineRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
	inlineObject363 *InlineObject363
}

func (r ApiMeCalendarCalendarViewEventInstancesEventDeclineRequest) InlineObject363(inlineObject363 InlineObject363) ApiMeCalendarCalendarViewEventInstancesEventDeclineRequest {
	r.inlineObject363 = &inlineObject363
	return r
}

func (r ApiMeCalendarCalendarViewEventInstancesEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarCalendarViewEventInstancesEventDeclineExecute(r)
}

/*
MeCalendarCalendarViewEventInstancesEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarCalendarViewEventInstancesEventDeclineRequest
*/
func (a *MeActionsApiService) MeCalendarCalendarViewEventInstancesEventDecline(ctx _context.Context, eventId string, eventId1 string) ApiMeCalendarCalendarViewEventInstancesEventDeclineRequest {
	return ApiMeCalendarCalendarViewEventInstancesEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarCalendarViewEventInstancesEventDeclineExecute(r ApiMeCalendarCalendarViewEventInstancesEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarCalendarViewEventInstancesEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendar/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject363 == nil {
		return nil, reportError("inlineObject363 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject363
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarCalendarViewEventInstancesEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
}


func (r ApiMeCalendarCalendarViewEventInstancesEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarCalendarViewEventInstancesEventDismissReminderExecute(r)
}

/*
MeCalendarCalendarViewEventInstancesEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarCalendarViewEventInstancesEventDismissReminderRequest
*/
func (a *MeActionsApiService) MeCalendarCalendarViewEventInstancesEventDismissReminder(ctx _context.Context, eventId string, eventId1 string) ApiMeCalendarCalendarViewEventInstancesEventDismissReminderRequest {
	return ApiMeCalendarCalendarViewEventInstancesEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarCalendarViewEventInstancesEventDismissReminderExecute(r ApiMeCalendarCalendarViewEventInstancesEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarCalendarViewEventInstancesEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendar/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarCalendarViewEventInstancesEventForwardRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
	inlineObject364 *InlineObject364
}

func (r ApiMeCalendarCalendarViewEventInstancesEventForwardRequest) InlineObject364(inlineObject364 InlineObject364) ApiMeCalendarCalendarViewEventInstancesEventForwardRequest {
	r.inlineObject364 = &inlineObject364
	return r
}

func (r ApiMeCalendarCalendarViewEventInstancesEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarCalendarViewEventInstancesEventForwardExecute(r)
}

/*
MeCalendarCalendarViewEventInstancesEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarCalendarViewEventInstancesEventForwardRequest
*/
func (a *MeActionsApiService) MeCalendarCalendarViewEventInstancesEventForward(ctx _context.Context, eventId string, eventId1 string) ApiMeCalendarCalendarViewEventInstancesEventForwardRequest {
	return ApiMeCalendarCalendarViewEventInstancesEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarCalendarViewEventInstancesEventForwardExecute(r ApiMeCalendarCalendarViewEventInstancesEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarCalendarViewEventInstancesEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendar/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject364 == nil {
		return nil, reportError("inlineObject364 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject364
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarCalendarViewEventInstancesEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
	inlineObject365 *InlineObject365
}

func (r ApiMeCalendarCalendarViewEventInstancesEventSnoozeReminderRequest) InlineObject365(inlineObject365 InlineObject365) ApiMeCalendarCalendarViewEventInstancesEventSnoozeReminderRequest {
	r.inlineObject365 = &inlineObject365
	return r
}

func (r ApiMeCalendarCalendarViewEventInstancesEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarCalendarViewEventInstancesEventSnoozeReminderExecute(r)
}

/*
MeCalendarCalendarViewEventInstancesEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarCalendarViewEventInstancesEventSnoozeReminderRequest
*/
func (a *MeActionsApiService) MeCalendarCalendarViewEventInstancesEventSnoozeReminder(ctx _context.Context, eventId string, eventId1 string) ApiMeCalendarCalendarViewEventInstancesEventSnoozeReminderRequest {
	return ApiMeCalendarCalendarViewEventInstancesEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarCalendarViewEventInstancesEventSnoozeReminderExecute(r ApiMeCalendarCalendarViewEventInstancesEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarCalendarViewEventInstancesEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendar/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject365 == nil {
		return nil, reportError("inlineObject365 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject365
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
	inlineObject366 *InlineObject366
}

func (r ApiMeCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest) InlineObject366(inlineObject366 InlineObject366) ApiMeCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest {
	r.inlineObject366 = &inlineObject366
	return r
}

func (r ApiMeCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarCalendarViewEventInstancesEventTentativelyAcceptExecute(r)
}

/*
MeCalendarCalendarViewEventInstancesEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest
*/
func (a *MeActionsApiService) MeCalendarCalendarViewEventInstancesEventTentativelyAccept(ctx _context.Context, eventId string, eventId1 string) ApiMeCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest {
	return ApiMeCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarCalendarViewEventInstancesEventTentativelyAcceptExecute(r ApiMeCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarCalendarViewEventInstancesEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendar/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject366 == nil {
		return nil, reportError("inlineObject366 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject366
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarCalendarViewEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	inlineObject371 *InlineObject371
}

func (r ApiMeCalendarCalendarViewEventSnoozeReminderRequest) InlineObject371(inlineObject371 InlineObject371) ApiMeCalendarCalendarViewEventSnoozeReminderRequest {
	r.inlineObject371 = &inlineObject371
	return r
}

func (r ApiMeCalendarCalendarViewEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarCalendarViewEventSnoozeReminderExecute(r)
}

/*
MeCalendarCalendarViewEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @return ApiMeCalendarCalendarViewEventSnoozeReminderRequest
*/
func (a *MeActionsApiService) MeCalendarCalendarViewEventSnoozeReminder(ctx _context.Context, eventId string) ApiMeCalendarCalendarViewEventSnoozeReminderRequest {
	return ApiMeCalendarCalendarViewEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarCalendarViewEventSnoozeReminderExecute(r ApiMeCalendarCalendarViewEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarCalendarViewEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendar/calendarView/{event-id}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject371 == nil {
		return nil, reportError("inlineObject371 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject371
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarCalendarViewEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	inlineObject372 *InlineObject372
}

func (r ApiMeCalendarCalendarViewEventTentativelyAcceptRequest) InlineObject372(inlineObject372 InlineObject372) ApiMeCalendarCalendarViewEventTentativelyAcceptRequest {
	r.inlineObject372 = &inlineObject372
	return r
}

func (r ApiMeCalendarCalendarViewEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarCalendarViewEventTentativelyAcceptExecute(r)
}

/*
MeCalendarCalendarViewEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @return ApiMeCalendarCalendarViewEventTentativelyAcceptRequest
*/
func (a *MeActionsApiService) MeCalendarCalendarViewEventTentativelyAccept(ctx _context.Context, eventId string) ApiMeCalendarCalendarViewEventTentativelyAcceptRequest {
	return ApiMeCalendarCalendarViewEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarCalendarViewEventTentativelyAcceptExecute(r ApiMeCalendarCalendarViewEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarCalendarViewEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendar/calendarView/{event-id}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject372 == nil {
		return nil, reportError("inlineObject372 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject372
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarEventsEventAcceptRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	inlineObject381 *InlineObject381
}

func (r ApiMeCalendarEventsEventAcceptRequest) InlineObject381(inlineObject381 InlineObject381) ApiMeCalendarEventsEventAcceptRequest {
	r.inlineObject381 = &inlineObject381
	return r
}

func (r ApiMeCalendarEventsEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarEventsEventAcceptExecute(r)
}

/*
MeCalendarEventsEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @return ApiMeCalendarEventsEventAcceptRequest
*/
func (a *MeActionsApiService) MeCalendarEventsEventAccept(ctx _context.Context, eventId string) ApiMeCalendarEventsEventAcceptRequest {
	return ApiMeCalendarEventsEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarEventsEventAcceptExecute(r ApiMeCalendarEventsEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarEventsEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendar/events/{event-id}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject381 == nil {
		return nil, reportError("inlineObject381 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject381
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarEventsEventAttachmentsCreateUploadSessionRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	inlineObject373 *InlineObject373
}

func (r ApiMeCalendarEventsEventAttachmentsCreateUploadSessionRequest) InlineObject373(inlineObject373 InlineObject373) ApiMeCalendarEventsEventAttachmentsCreateUploadSessionRequest {
	r.inlineObject373 = &inlineObject373
	return r
}

func (r ApiMeCalendarEventsEventAttachmentsCreateUploadSessionRequest) Execute() (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarEventsEventAttachmentsCreateUploadSessionExecute(r)
}

/*
MeCalendarEventsEventAttachmentsCreateUploadSession Invoke action createUploadSession

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @return ApiMeCalendarEventsEventAttachmentsCreateUploadSessionRequest
*/
func (a *MeActionsApiService) MeCalendarEventsEventAttachmentsCreateUploadSession(ctx _context.Context, eventId string) ApiMeCalendarEventsEventAttachmentsCreateUploadSessionRequest {
	return ApiMeCalendarEventsEventAttachmentsCreateUploadSessionRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphUploadSession
func (a *MeActionsApiService) MeCalendarEventsEventAttachmentsCreateUploadSessionExecute(r ApiMeCalendarEventsEventAttachmentsCreateUploadSessionRequest) (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphUploadSession
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarEventsEventAttachmentsCreateUploadSession")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendar/events/{event-id}/attachments/microsoft.graph.createUploadSession"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject373 == nil {
		return localVarReturnValue, nil, reportError("inlineObject373 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject373
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarEventsEventCalendarGetScheduleRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	inlineObject374 *InlineObject374
}

func (r ApiMeCalendarEventsEventCalendarGetScheduleRequest) InlineObject374(inlineObject374 InlineObject374) ApiMeCalendarEventsEventCalendarGetScheduleRequest {
	r.inlineObject374 = &inlineObject374
	return r
}

func (r ApiMeCalendarEventsEventCalendarGetScheduleRequest) Execute() ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarEventsEventCalendarGetScheduleExecute(r)
}

/*
MeCalendarEventsEventCalendarGetSchedule Invoke action getSchedule

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @return ApiMeCalendarEventsEventCalendarGetScheduleRequest
*/
func (a *MeActionsApiService) MeCalendarEventsEventCalendarGetSchedule(ctx _context.Context, eventId string) ApiMeCalendarEventsEventCalendarGetScheduleRequest {
	return ApiMeCalendarEventsEventCalendarGetScheduleRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return []*AnyOfmicrosoftGraphScheduleInformation
func (a *MeActionsApiService) MeCalendarEventsEventCalendarGetScheduleExecute(r ApiMeCalendarEventsEventCalendarGetScheduleRequest) ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []*AnyOfmicrosoftGraphScheduleInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarEventsEventCalendarGetSchedule")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendar/events/{event-id}/calendar/microsoft.graph.getSchedule"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject374 == nil {
		return localVarReturnValue, nil, reportError("inlineObject374 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject374
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarEventsEventCancelRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	inlineObject382 *InlineObject382
}

func (r ApiMeCalendarEventsEventCancelRequest) InlineObject382(inlineObject382 InlineObject382) ApiMeCalendarEventsEventCancelRequest {
	r.inlineObject382 = &inlineObject382
	return r
}

func (r ApiMeCalendarEventsEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarEventsEventCancelExecute(r)
}

/*
MeCalendarEventsEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @return ApiMeCalendarEventsEventCancelRequest
*/
func (a *MeActionsApiService) MeCalendarEventsEventCancel(ctx _context.Context, eventId string) ApiMeCalendarEventsEventCancelRequest {
	return ApiMeCalendarEventsEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarEventsEventCancelExecute(r ApiMeCalendarEventsEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarEventsEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendar/events/{event-id}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject382 == nil {
		return nil, reportError("inlineObject382 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject382
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarEventsEventDeclineRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	inlineObject383 *InlineObject383
}

func (r ApiMeCalendarEventsEventDeclineRequest) InlineObject383(inlineObject383 InlineObject383) ApiMeCalendarEventsEventDeclineRequest {
	r.inlineObject383 = &inlineObject383
	return r
}

func (r ApiMeCalendarEventsEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarEventsEventDeclineExecute(r)
}

/*
MeCalendarEventsEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @return ApiMeCalendarEventsEventDeclineRequest
*/
func (a *MeActionsApiService) MeCalendarEventsEventDecline(ctx _context.Context, eventId string) ApiMeCalendarEventsEventDeclineRequest {
	return ApiMeCalendarEventsEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarEventsEventDeclineExecute(r ApiMeCalendarEventsEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarEventsEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendar/events/{event-id}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject383 == nil {
		return nil, reportError("inlineObject383 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject383
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarEventsEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
}


func (r ApiMeCalendarEventsEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarEventsEventDismissReminderExecute(r)
}

/*
MeCalendarEventsEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @return ApiMeCalendarEventsEventDismissReminderRequest
*/
func (a *MeActionsApiService) MeCalendarEventsEventDismissReminder(ctx _context.Context, eventId string) ApiMeCalendarEventsEventDismissReminderRequest {
	return ApiMeCalendarEventsEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarEventsEventDismissReminderExecute(r ApiMeCalendarEventsEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarEventsEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendar/events/{event-id}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarEventsEventForwardRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	inlineObject384 *InlineObject384
}

func (r ApiMeCalendarEventsEventForwardRequest) InlineObject384(inlineObject384 InlineObject384) ApiMeCalendarEventsEventForwardRequest {
	r.inlineObject384 = &inlineObject384
	return r
}

func (r ApiMeCalendarEventsEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarEventsEventForwardExecute(r)
}

/*
MeCalendarEventsEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @return ApiMeCalendarEventsEventForwardRequest
*/
func (a *MeActionsApiService) MeCalendarEventsEventForward(ctx _context.Context, eventId string) ApiMeCalendarEventsEventForwardRequest {
	return ApiMeCalendarEventsEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarEventsEventForwardExecute(r ApiMeCalendarEventsEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarEventsEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendar/events/{event-id}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject384 == nil {
		return nil, reportError("inlineObject384 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject384
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarEventsEventInstancesEventAcceptRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
	inlineObject375 *InlineObject375
}

func (r ApiMeCalendarEventsEventInstancesEventAcceptRequest) InlineObject375(inlineObject375 InlineObject375) ApiMeCalendarEventsEventInstancesEventAcceptRequest {
	r.inlineObject375 = &inlineObject375
	return r
}

func (r ApiMeCalendarEventsEventInstancesEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarEventsEventInstancesEventAcceptExecute(r)
}

/*
MeCalendarEventsEventInstancesEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarEventsEventInstancesEventAcceptRequest
*/
func (a *MeActionsApiService) MeCalendarEventsEventInstancesEventAccept(ctx _context.Context, eventId string, eventId1 string) ApiMeCalendarEventsEventInstancesEventAcceptRequest {
	return ApiMeCalendarEventsEventInstancesEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarEventsEventInstancesEventAcceptExecute(r ApiMeCalendarEventsEventInstancesEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarEventsEventInstancesEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendar/events/{event-id}/instances/{event-id1}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject375 == nil {
		return nil, reportError("inlineObject375 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject375
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarEventsEventInstancesEventCancelRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
	inlineObject376 *InlineObject376
}

func (r ApiMeCalendarEventsEventInstancesEventCancelRequest) InlineObject376(inlineObject376 InlineObject376) ApiMeCalendarEventsEventInstancesEventCancelRequest {
	r.inlineObject376 = &inlineObject376
	return r
}

func (r ApiMeCalendarEventsEventInstancesEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarEventsEventInstancesEventCancelExecute(r)
}

/*
MeCalendarEventsEventInstancesEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarEventsEventInstancesEventCancelRequest
*/
func (a *MeActionsApiService) MeCalendarEventsEventInstancesEventCancel(ctx _context.Context, eventId string, eventId1 string) ApiMeCalendarEventsEventInstancesEventCancelRequest {
	return ApiMeCalendarEventsEventInstancesEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarEventsEventInstancesEventCancelExecute(r ApiMeCalendarEventsEventInstancesEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarEventsEventInstancesEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendar/events/{event-id}/instances/{event-id1}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject376 == nil {
		return nil, reportError("inlineObject376 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject376
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarEventsEventInstancesEventDeclineRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
	inlineObject377 *InlineObject377
}

func (r ApiMeCalendarEventsEventInstancesEventDeclineRequest) InlineObject377(inlineObject377 InlineObject377) ApiMeCalendarEventsEventInstancesEventDeclineRequest {
	r.inlineObject377 = &inlineObject377
	return r
}

func (r ApiMeCalendarEventsEventInstancesEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarEventsEventInstancesEventDeclineExecute(r)
}

/*
MeCalendarEventsEventInstancesEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarEventsEventInstancesEventDeclineRequest
*/
func (a *MeActionsApiService) MeCalendarEventsEventInstancesEventDecline(ctx _context.Context, eventId string, eventId1 string) ApiMeCalendarEventsEventInstancesEventDeclineRequest {
	return ApiMeCalendarEventsEventInstancesEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarEventsEventInstancesEventDeclineExecute(r ApiMeCalendarEventsEventInstancesEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarEventsEventInstancesEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendar/events/{event-id}/instances/{event-id1}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject377 == nil {
		return nil, reportError("inlineObject377 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject377
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarEventsEventInstancesEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
}


func (r ApiMeCalendarEventsEventInstancesEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarEventsEventInstancesEventDismissReminderExecute(r)
}

/*
MeCalendarEventsEventInstancesEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarEventsEventInstancesEventDismissReminderRequest
*/
func (a *MeActionsApiService) MeCalendarEventsEventInstancesEventDismissReminder(ctx _context.Context, eventId string, eventId1 string) ApiMeCalendarEventsEventInstancesEventDismissReminderRequest {
	return ApiMeCalendarEventsEventInstancesEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarEventsEventInstancesEventDismissReminderExecute(r ApiMeCalendarEventsEventInstancesEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarEventsEventInstancesEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendar/events/{event-id}/instances/{event-id1}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarEventsEventInstancesEventForwardRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
	inlineObject378 *InlineObject378
}

func (r ApiMeCalendarEventsEventInstancesEventForwardRequest) InlineObject378(inlineObject378 InlineObject378) ApiMeCalendarEventsEventInstancesEventForwardRequest {
	r.inlineObject378 = &inlineObject378
	return r
}

func (r ApiMeCalendarEventsEventInstancesEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarEventsEventInstancesEventForwardExecute(r)
}

/*
MeCalendarEventsEventInstancesEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarEventsEventInstancesEventForwardRequest
*/
func (a *MeActionsApiService) MeCalendarEventsEventInstancesEventForward(ctx _context.Context, eventId string, eventId1 string) ApiMeCalendarEventsEventInstancesEventForwardRequest {
	return ApiMeCalendarEventsEventInstancesEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarEventsEventInstancesEventForwardExecute(r ApiMeCalendarEventsEventInstancesEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarEventsEventInstancesEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendar/events/{event-id}/instances/{event-id1}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject378 == nil {
		return nil, reportError("inlineObject378 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject378
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarEventsEventInstancesEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
	inlineObject379 *InlineObject379
}

func (r ApiMeCalendarEventsEventInstancesEventSnoozeReminderRequest) InlineObject379(inlineObject379 InlineObject379) ApiMeCalendarEventsEventInstancesEventSnoozeReminderRequest {
	r.inlineObject379 = &inlineObject379
	return r
}

func (r ApiMeCalendarEventsEventInstancesEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarEventsEventInstancesEventSnoozeReminderExecute(r)
}

/*
MeCalendarEventsEventInstancesEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarEventsEventInstancesEventSnoozeReminderRequest
*/
func (a *MeActionsApiService) MeCalendarEventsEventInstancesEventSnoozeReminder(ctx _context.Context, eventId string, eventId1 string) ApiMeCalendarEventsEventInstancesEventSnoozeReminderRequest {
	return ApiMeCalendarEventsEventInstancesEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarEventsEventInstancesEventSnoozeReminderExecute(r ApiMeCalendarEventsEventInstancesEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarEventsEventInstancesEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendar/events/{event-id}/instances/{event-id1}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject379 == nil {
		return nil, reportError("inlineObject379 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject379
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarEventsEventInstancesEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
	inlineObject380 *InlineObject380
}

func (r ApiMeCalendarEventsEventInstancesEventTentativelyAcceptRequest) InlineObject380(inlineObject380 InlineObject380) ApiMeCalendarEventsEventInstancesEventTentativelyAcceptRequest {
	r.inlineObject380 = &inlineObject380
	return r
}

func (r ApiMeCalendarEventsEventInstancesEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarEventsEventInstancesEventTentativelyAcceptExecute(r)
}

/*
MeCalendarEventsEventInstancesEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarEventsEventInstancesEventTentativelyAcceptRequest
*/
func (a *MeActionsApiService) MeCalendarEventsEventInstancesEventTentativelyAccept(ctx _context.Context, eventId string, eventId1 string) ApiMeCalendarEventsEventInstancesEventTentativelyAcceptRequest {
	return ApiMeCalendarEventsEventInstancesEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarEventsEventInstancesEventTentativelyAcceptExecute(r ApiMeCalendarEventsEventInstancesEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarEventsEventInstancesEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendar/events/{event-id}/instances/{event-id1}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject380 == nil {
		return nil, reportError("inlineObject380 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject380
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarEventsEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	inlineObject385 *InlineObject385
}

func (r ApiMeCalendarEventsEventSnoozeReminderRequest) InlineObject385(inlineObject385 InlineObject385) ApiMeCalendarEventsEventSnoozeReminderRequest {
	r.inlineObject385 = &inlineObject385
	return r
}

func (r ApiMeCalendarEventsEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarEventsEventSnoozeReminderExecute(r)
}

/*
MeCalendarEventsEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @return ApiMeCalendarEventsEventSnoozeReminderRequest
*/
func (a *MeActionsApiService) MeCalendarEventsEventSnoozeReminder(ctx _context.Context, eventId string) ApiMeCalendarEventsEventSnoozeReminderRequest {
	return ApiMeCalendarEventsEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarEventsEventSnoozeReminderExecute(r ApiMeCalendarEventsEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarEventsEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendar/events/{event-id}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject385 == nil {
		return nil, reportError("inlineObject385 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject385
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarEventsEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	inlineObject386 *InlineObject386
}

func (r ApiMeCalendarEventsEventTentativelyAcceptRequest) InlineObject386(inlineObject386 InlineObject386) ApiMeCalendarEventsEventTentativelyAcceptRequest {
	r.inlineObject386 = &inlineObject386
	return r
}

func (r ApiMeCalendarEventsEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarEventsEventTentativelyAcceptExecute(r)
}

/*
MeCalendarEventsEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @return ApiMeCalendarEventsEventTentativelyAcceptRequest
*/
func (a *MeActionsApiService) MeCalendarEventsEventTentativelyAccept(ctx _context.Context, eventId string) ApiMeCalendarEventsEventTentativelyAcceptRequest {
	return ApiMeCalendarEventsEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarEventsEventTentativelyAcceptExecute(r ApiMeCalendarEventsEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarEventsEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendar/events/{event-id}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject386 == nil {
		return nil, reportError("inlineObject386 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject386
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGetScheduleRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	inlineObject387 *InlineObject387
}

func (r ApiMeCalendarGetScheduleRequest) InlineObject387(inlineObject387 InlineObject387) ApiMeCalendarGetScheduleRequest {
	r.inlineObject387 = &inlineObject387
	return r
}

func (r ApiMeCalendarGetScheduleRequest) Execute() ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGetScheduleExecute(r)
}

/*
MeCalendarGetSchedule Invoke action getSchedule

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMeCalendarGetScheduleRequest
*/
func (a *MeActionsApiService) MeCalendarGetSchedule(ctx _context.Context) ApiMeCalendarGetScheduleRequest {
	return ApiMeCalendarGetScheduleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []*AnyOfmicrosoftGraphScheduleInformation
func (a *MeActionsApiService) MeCalendarGetScheduleExecute(r ApiMeCalendarGetScheduleRequest) ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []*AnyOfmicrosoftGraphScheduleInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarGetSchedule")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendar/microsoft.graph.getSchedule"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject387 == nil {
		return localVarReturnValue, nil, reportError("inlineObject387 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject387
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAcceptRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarGroupId string
	calendarId string
	eventId string
	inlineObject396 *InlineObject396
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAcceptRequest) InlineObject396(inlineObject396 InlineObject396) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAcceptRequest {
	r.inlineObject396 = &inlineObject396
	return r
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAcceptExecute(r)
}

/*
MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAcceptRequest
*/
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAccept(ctx _context.Context, calendarGroupId string, calendarId string, eventId string) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAcceptRequest {
	return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAcceptExecute(r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject396 == nil {
		return nil, reportError("inlineObject396 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject396
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarGroupId string
	calendarId string
	eventId string
	inlineObject388 *InlineObject388
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest) InlineObject388(inlineObject388 InlineObject388) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest {
	r.inlineObject388 = &inlineObject388
	return r
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest) Execute() (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSessionExecute(r)
}

/*
MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSession Invoke action createUploadSession

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest
*/
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSession(ctx _context.Context, calendarGroupId string, calendarId string, eventId string) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest {
	return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphUploadSession
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSessionExecute(r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest) (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphUploadSession
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSession")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/attachments/microsoft.graph.createUploadSession"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject388 == nil {
		return localVarReturnValue, nil, reportError("inlineObject388 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject388
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCalendarGetScheduleRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarGroupId string
	calendarId string
	eventId string
	inlineObject389 *InlineObject389
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCalendarGetScheduleRequest) InlineObject389(inlineObject389 InlineObject389) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCalendarGetScheduleRequest {
	r.inlineObject389 = &inlineObject389
	return r
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCalendarGetScheduleRequest) Execute() ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCalendarGetScheduleExecute(r)
}

/*
MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCalendarGetSchedule Invoke action getSchedule

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCalendarGetScheduleRequest
*/
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCalendarGetSchedule(ctx _context.Context, calendarGroupId string, calendarId string, eventId string) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCalendarGetScheduleRequest {
	return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCalendarGetScheduleRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return []*AnyOfmicrosoftGraphScheduleInformation
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCalendarGetScheduleExecute(r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCalendarGetScheduleRequest) ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []*AnyOfmicrosoftGraphScheduleInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCalendarGetSchedule")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/calendar/microsoft.graph.getSchedule"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject389 == nil {
		return localVarReturnValue, nil, reportError("inlineObject389 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject389
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCancelRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarGroupId string
	calendarId string
	eventId string
	inlineObject397 *InlineObject397
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCancelRequest) InlineObject397(inlineObject397 InlineObject397) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCancelRequest {
	r.inlineObject397 = &inlineObject397
	return r
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCancelExecute(r)
}

/*
MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCancelRequest
*/
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCancel(ctx _context.Context, calendarGroupId string, calendarId string, eventId string) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCancelRequest {
	return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCancelExecute(r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject397 == nil {
		return nil, reportError("inlineObject397 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject397
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventDeclineRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarGroupId string
	calendarId string
	eventId string
	inlineObject398 *InlineObject398
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventDeclineRequest) InlineObject398(inlineObject398 InlineObject398) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventDeclineRequest {
	r.inlineObject398 = &inlineObject398
	return r
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventDeclineExecute(r)
}

/*
MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventDeclineRequest
*/
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventDecline(ctx _context.Context, calendarGroupId string, calendarId string, eventId string) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventDeclineRequest {
	return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventDeclineExecute(r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject398 == nil {
		return nil, reportError("inlineObject398 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject398
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarGroupId string
	calendarId string
	eventId string
}


func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventDismissReminderExecute(r)
}

/*
MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventDismissReminderRequest
*/
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventDismissReminder(ctx _context.Context, calendarGroupId string, calendarId string, eventId string) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventDismissReminderRequest {
	return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventDismissReminderExecute(r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventForwardRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarGroupId string
	calendarId string
	eventId string
	inlineObject399 *InlineObject399
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventForwardRequest) InlineObject399(inlineObject399 InlineObject399) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventForwardRequest {
	r.inlineObject399 = &inlineObject399
	return r
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventForwardExecute(r)
}

/*
MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventForwardRequest
*/
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventForward(ctx _context.Context, calendarGroupId string, calendarId string, eventId string) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventForwardRequest {
	return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventForwardExecute(r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject399 == nil {
		return nil, reportError("inlineObject399 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject399
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventAcceptRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarGroupId string
	calendarId string
	eventId string
	eventId1 string
	inlineObject390 *InlineObject390
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventAcceptRequest) InlineObject390(inlineObject390 InlineObject390) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventAcceptRequest {
	r.inlineObject390 = &inlineObject390
	return r
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventAcceptExecute(r)
}

/*
MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventAcceptRequest
*/
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventAccept(ctx _context.Context, calendarGroupId string, calendarId string, eventId string, eventId1 string) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventAcceptRequest {
	return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventAcceptExecute(r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject390 == nil {
		return nil, reportError("inlineObject390 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject390
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventCancelRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarGroupId string
	calendarId string
	eventId string
	eventId1 string
	inlineObject391 *InlineObject391
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventCancelRequest) InlineObject391(inlineObject391 InlineObject391) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventCancelRequest {
	r.inlineObject391 = &inlineObject391
	return r
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventCancelExecute(r)
}

/*
MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventCancelRequest
*/
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventCancel(ctx _context.Context, calendarGroupId string, calendarId string, eventId string, eventId1 string) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventCancelRequest {
	return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventCancelExecute(r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject391 == nil {
		return nil, reportError("inlineObject391 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject391
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventDeclineRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarGroupId string
	calendarId string
	eventId string
	eventId1 string
	inlineObject392 *InlineObject392
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventDeclineRequest) InlineObject392(inlineObject392 InlineObject392) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventDeclineRequest {
	r.inlineObject392 = &inlineObject392
	return r
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventDeclineExecute(r)
}

/*
MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventDeclineRequest
*/
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventDecline(ctx _context.Context, calendarGroupId string, calendarId string, eventId string, eventId1 string) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventDeclineRequest {
	return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventDeclineExecute(r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject392 == nil {
		return nil, reportError("inlineObject392 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject392
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarGroupId string
	calendarId string
	eventId string
	eventId1 string
}


func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventDismissReminderExecute(r)
}

/*
MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventDismissReminderRequest
*/
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventDismissReminder(ctx _context.Context, calendarGroupId string, calendarId string, eventId string, eventId1 string) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventDismissReminderRequest {
	return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventDismissReminderExecute(r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventForwardRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarGroupId string
	calendarId string
	eventId string
	eventId1 string
	inlineObject393 *InlineObject393
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventForwardRequest) InlineObject393(inlineObject393 InlineObject393) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventForwardRequest {
	r.inlineObject393 = &inlineObject393
	return r
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventForwardExecute(r)
}

/*
MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventForwardRequest
*/
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventForward(ctx _context.Context, calendarGroupId string, calendarId string, eventId string, eventId1 string) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventForwardRequest {
	return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventForwardExecute(r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject393 == nil {
		return nil, reportError("inlineObject393 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject393
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarGroupId string
	calendarId string
	eventId string
	eventId1 string
	inlineObject394 *InlineObject394
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminderRequest) InlineObject394(inlineObject394 InlineObject394) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminderRequest {
	r.inlineObject394 = &inlineObject394
	return r
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminderExecute(r)
}

/*
MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminderRequest
*/
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminder(ctx _context.Context, calendarGroupId string, calendarId string, eventId string, eventId1 string) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminderRequest {
	return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminderExecute(r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject394 == nil {
		return nil, reportError("inlineObject394 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject394
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarGroupId string
	calendarId string
	eventId string
	eventId1 string
	inlineObject395 *InlineObject395
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest) InlineObject395(inlineObject395 InlineObject395) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest {
	r.inlineObject395 = &inlineObject395
	return r
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventTentativelyAcceptExecute(r)
}

/*
MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest
*/
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventTentativelyAccept(ctx _context.Context, calendarGroupId string, calendarId string, eventId string, eventId1 string) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest {
	return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventTentativelyAcceptExecute(r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventInstancesEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject395 == nil {
		return nil, reportError("inlineObject395 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject395
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarGroupId string
	calendarId string
	eventId string
	inlineObject400 *InlineObject400
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventSnoozeReminderRequest) InlineObject400(inlineObject400 InlineObject400) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventSnoozeReminderRequest {
	r.inlineObject400 = &inlineObject400
	return r
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventSnoozeReminderExecute(r)
}

/*
MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventSnoozeReminderRequest
*/
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventSnoozeReminder(ctx _context.Context, calendarGroupId string, calendarId string, eventId string) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventSnoozeReminderRequest {
	return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventSnoozeReminderExecute(r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject400 == nil {
		return nil, reportError("inlineObject400 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject400
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarGroupId string
	calendarId string
	eventId string
	inlineObject401 *InlineObject401
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventTentativelyAcceptRequest) InlineObject401(inlineObject401 InlineObject401) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventTentativelyAcceptRequest {
	r.inlineObject401 = &inlineObject401
	return r
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventTentativelyAcceptExecute(r)
}

/*
MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventTentativelyAcceptRequest
*/
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventTentativelyAccept(ctx _context.Context, calendarGroupId string, calendarId string, eventId string) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventTentativelyAcceptRequest {
	return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventTentativelyAcceptExecute(r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarCalendarViewEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/calendarView/{event-id}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject401 == nil {
		return nil, reportError("inlineObject401 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject401
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAcceptRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarGroupId string
	calendarId string
	eventId string
	inlineObject410 *InlineObject410
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAcceptRequest) InlineObject410(inlineObject410 InlineObject410) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAcceptRequest {
	r.inlineObject410 = &inlineObject410
	return r
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAcceptExecute(r)
}

/*
MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAcceptRequest
*/
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAccept(ctx _context.Context, calendarGroupId string, calendarId string, eventId string) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAcceptRequest {
	return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAcceptExecute(r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject410 == nil {
		return nil, reportError("inlineObject410 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject410
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAttachmentsCreateUploadSessionRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarGroupId string
	calendarId string
	eventId string
	inlineObject402 *InlineObject402
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAttachmentsCreateUploadSessionRequest) InlineObject402(inlineObject402 InlineObject402) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAttachmentsCreateUploadSessionRequest {
	r.inlineObject402 = &inlineObject402
	return r
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAttachmentsCreateUploadSessionRequest) Execute() (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAttachmentsCreateUploadSessionExecute(r)
}

/*
MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAttachmentsCreateUploadSession Invoke action createUploadSession

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAttachmentsCreateUploadSessionRequest
*/
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAttachmentsCreateUploadSession(ctx _context.Context, calendarGroupId string, calendarId string, eventId string) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAttachmentsCreateUploadSessionRequest {
	return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAttachmentsCreateUploadSessionRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphUploadSession
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAttachmentsCreateUploadSessionExecute(r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAttachmentsCreateUploadSessionRequest) (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphUploadSession
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventAttachmentsCreateUploadSession")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/attachments/microsoft.graph.createUploadSession"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject402 == nil {
		return localVarReturnValue, nil, reportError("inlineObject402 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject402
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCalendarGetScheduleRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarGroupId string
	calendarId string
	eventId string
	inlineObject403 *InlineObject403
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCalendarGetScheduleRequest) InlineObject403(inlineObject403 InlineObject403) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCalendarGetScheduleRequest {
	r.inlineObject403 = &inlineObject403
	return r
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCalendarGetScheduleRequest) Execute() ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCalendarGetScheduleExecute(r)
}

/*
MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCalendarGetSchedule Invoke action getSchedule

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCalendarGetScheduleRequest
*/
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCalendarGetSchedule(ctx _context.Context, calendarGroupId string, calendarId string, eventId string) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCalendarGetScheduleRequest {
	return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCalendarGetScheduleRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return []*AnyOfmicrosoftGraphScheduleInformation
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCalendarGetScheduleExecute(r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCalendarGetScheduleRequest) ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []*AnyOfmicrosoftGraphScheduleInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCalendarGetSchedule")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/calendar/microsoft.graph.getSchedule"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject403 == nil {
		return localVarReturnValue, nil, reportError("inlineObject403 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject403
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCancelRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarGroupId string
	calendarId string
	eventId string
	inlineObject411 *InlineObject411
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCancelRequest) InlineObject411(inlineObject411 InlineObject411) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCancelRequest {
	r.inlineObject411 = &inlineObject411
	return r
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCancelExecute(r)
}

/*
MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCancelRequest
*/
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCancel(ctx _context.Context, calendarGroupId string, calendarId string, eventId string) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCancelRequest {
	return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCancelExecute(r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject411 == nil {
		return nil, reportError("inlineObject411 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject411
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventDeclineRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarGroupId string
	calendarId string
	eventId string
	inlineObject412 *InlineObject412
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventDeclineRequest) InlineObject412(inlineObject412 InlineObject412) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventDeclineRequest {
	r.inlineObject412 = &inlineObject412
	return r
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventDeclineExecute(r)
}

/*
MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventDeclineRequest
*/
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventDecline(ctx _context.Context, calendarGroupId string, calendarId string, eventId string) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventDeclineRequest {
	return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventDeclineExecute(r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject412 == nil {
		return nil, reportError("inlineObject412 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject412
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarGroupId string
	calendarId string
	eventId string
}


func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventDismissReminderExecute(r)
}

/*
MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventDismissReminderRequest
*/
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventDismissReminder(ctx _context.Context, calendarGroupId string, calendarId string, eventId string) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventDismissReminderRequest {
	return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventDismissReminderExecute(r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventForwardRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarGroupId string
	calendarId string
	eventId string
	inlineObject413 *InlineObject413
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventForwardRequest) InlineObject413(inlineObject413 InlineObject413) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventForwardRequest {
	r.inlineObject413 = &inlineObject413
	return r
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventForwardExecute(r)
}

/*
MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventForwardRequest
*/
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventForward(ctx _context.Context, calendarGroupId string, calendarId string, eventId string) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventForwardRequest {
	return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventForwardExecute(r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject413 == nil {
		return nil, reportError("inlineObject413 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject413
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventAcceptRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarGroupId string
	calendarId string
	eventId string
	eventId1 string
	inlineObject404 *InlineObject404
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventAcceptRequest) InlineObject404(inlineObject404 InlineObject404) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventAcceptRequest {
	r.inlineObject404 = &inlineObject404
	return r
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventAcceptExecute(r)
}

/*
MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventAcceptRequest
*/
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventAccept(ctx _context.Context, calendarGroupId string, calendarId string, eventId string, eventId1 string) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventAcceptRequest {
	return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventAcceptExecute(r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/instances/{event-id1}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject404 == nil {
		return nil, reportError("inlineObject404 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject404
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventCancelRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarGroupId string
	calendarId string
	eventId string
	eventId1 string
	inlineObject405 *InlineObject405
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventCancelRequest) InlineObject405(inlineObject405 InlineObject405) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventCancelRequest {
	r.inlineObject405 = &inlineObject405
	return r
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventCancelExecute(r)
}

/*
MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventCancelRequest
*/
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventCancel(ctx _context.Context, calendarGroupId string, calendarId string, eventId string, eventId1 string) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventCancelRequest {
	return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventCancelExecute(r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/instances/{event-id1}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject405 == nil {
		return nil, reportError("inlineObject405 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject405
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventDeclineRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarGroupId string
	calendarId string
	eventId string
	eventId1 string
	inlineObject406 *InlineObject406
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventDeclineRequest) InlineObject406(inlineObject406 InlineObject406) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventDeclineRequest {
	r.inlineObject406 = &inlineObject406
	return r
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventDeclineExecute(r)
}

/*
MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventDeclineRequest
*/
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventDecline(ctx _context.Context, calendarGroupId string, calendarId string, eventId string, eventId1 string) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventDeclineRequest {
	return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventDeclineExecute(r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/instances/{event-id1}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject406 == nil {
		return nil, reportError("inlineObject406 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject406
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarGroupId string
	calendarId string
	eventId string
	eventId1 string
}


func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventDismissReminderExecute(r)
}

/*
MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventDismissReminderRequest
*/
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventDismissReminder(ctx _context.Context, calendarGroupId string, calendarId string, eventId string, eventId1 string) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventDismissReminderRequest {
	return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventDismissReminderExecute(r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/instances/{event-id1}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventForwardRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarGroupId string
	calendarId string
	eventId string
	eventId1 string
	inlineObject407 *InlineObject407
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventForwardRequest) InlineObject407(inlineObject407 InlineObject407) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventForwardRequest {
	r.inlineObject407 = &inlineObject407
	return r
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventForwardExecute(r)
}

/*
MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventForwardRequest
*/
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventForward(ctx _context.Context, calendarGroupId string, calendarId string, eventId string, eventId1 string) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventForwardRequest {
	return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventForwardExecute(r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/instances/{event-id1}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject407 == nil {
		return nil, reportError("inlineObject407 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject407
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarGroupId string
	calendarId string
	eventId string
	eventId1 string
	inlineObject408 *InlineObject408
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventSnoozeReminderRequest) InlineObject408(inlineObject408 InlineObject408) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventSnoozeReminderRequest {
	r.inlineObject408 = &inlineObject408
	return r
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventSnoozeReminderExecute(r)
}

/*
MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventSnoozeReminderRequest
*/
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventSnoozeReminder(ctx _context.Context, calendarGroupId string, calendarId string, eventId string, eventId1 string) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventSnoozeReminderRequest {
	return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventSnoozeReminderExecute(r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/instances/{event-id1}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject408 == nil {
		return nil, reportError("inlineObject408 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject408
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarGroupId string
	calendarId string
	eventId string
	eventId1 string
	inlineObject409 *InlineObject409
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventTentativelyAcceptRequest) InlineObject409(inlineObject409 InlineObject409) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventTentativelyAcceptRequest {
	r.inlineObject409 = &inlineObject409
	return r
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventTentativelyAcceptExecute(r)
}

/*
MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventTentativelyAcceptRequest
*/
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventTentativelyAccept(ctx _context.Context, calendarGroupId string, calendarId string, eventId string, eventId1 string) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventTentativelyAcceptRequest {
	return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventTentativelyAcceptExecute(r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventInstancesEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/instances/{event-id1}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject409 == nil {
		return nil, reportError("inlineObject409 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject409
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarGroupId string
	calendarId string
	eventId string
	inlineObject414 *InlineObject414
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventSnoozeReminderRequest) InlineObject414(inlineObject414 InlineObject414) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventSnoozeReminderRequest {
	r.inlineObject414 = &inlineObject414
	return r
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventSnoozeReminderExecute(r)
}

/*
MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventSnoozeReminderRequest
*/
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventSnoozeReminder(ctx _context.Context, calendarGroupId string, calendarId string, eventId string) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventSnoozeReminderRequest {
	return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventSnoozeReminderExecute(r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject414 == nil {
		return nil, reportError("inlineObject414 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject414
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarGroupId string
	calendarId string
	eventId string
	inlineObject415 *InlineObject415
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventTentativelyAcceptRequest) InlineObject415(inlineObject415 InlineObject415) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventTentativelyAcceptRequest {
	r.inlineObject415 = &inlineObject415
	return r
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventTentativelyAcceptExecute(r)
}

/*
MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventTentativelyAcceptRequest
*/
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventTentativelyAccept(ctx _context.Context, calendarGroupId string, calendarId string, eventId string) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventTentativelyAcceptRequest {
	return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventTentativelyAcceptExecute(r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarEventsEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/events/{event-id}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject415 == nil {
		return nil, reportError("inlineObject415 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject415
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarGroupsCalendarGroupCalendarsCalendarGetScheduleRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarGroupId string
	calendarId string
	inlineObject416 *InlineObject416
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarGetScheduleRequest) InlineObject416(inlineObject416 InlineObject416) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarGetScheduleRequest {
	r.inlineObject416 = &inlineObject416
	return r
}

func (r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarGetScheduleRequest) Execute() ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarGetScheduleExecute(r)
}

/*
MeCalendarGroupsCalendarGroupCalendarsCalendarGetSchedule Invoke action getSchedule

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarGroupId key: id of calendarGroup
 @param calendarId key: id of calendar
 @return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarGetScheduleRequest
*/
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarGetSchedule(ctx _context.Context, calendarGroupId string, calendarId string) ApiMeCalendarGroupsCalendarGroupCalendarsCalendarGetScheduleRequest {
	return ApiMeCalendarGroupsCalendarGroupCalendarsCalendarGetScheduleRequest{
		ApiService: a,
		ctx: ctx,
		calendarGroupId: calendarGroupId,
		calendarId: calendarId,
	}
}

// Execute executes the request
//  @return []*AnyOfmicrosoftGraphScheduleInformation
func (a *MeActionsApiService) MeCalendarGroupsCalendarGroupCalendarsCalendarGetScheduleExecute(r ApiMeCalendarGroupsCalendarGroupCalendarsCalendarGetScheduleRequest) ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []*AnyOfmicrosoftGraphScheduleInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarGroupsCalendarGroupCalendarsCalendarGetSchedule")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarGroups/{calendarGroup-id}/calendars/{calendar-id}/microsoft.graph.getSchedule"
	localVarPath = strings.Replace(localVarPath, "{"+"calendarGroup-id"+"}", _neturl.PathEscape(parameterToString(r.calendarGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject416 == nil {
		return localVarReturnValue, nil, reportError("inlineObject416 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject416
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarViewEventAcceptRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	inlineObject466 *InlineObject466
}

func (r ApiMeCalendarViewEventAcceptRequest) InlineObject466(inlineObject466 InlineObject466) ApiMeCalendarViewEventAcceptRequest {
	r.inlineObject466 = &inlineObject466
	return r
}

func (r ApiMeCalendarViewEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarViewEventAcceptExecute(r)
}

/*
MeCalendarViewEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @return ApiMeCalendarViewEventAcceptRequest
*/
func (a *MeActionsApiService) MeCalendarViewEventAccept(ctx _context.Context, eventId string) ApiMeCalendarViewEventAcceptRequest {
	return ApiMeCalendarViewEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarViewEventAcceptExecute(r ApiMeCalendarViewEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarViewEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarView/{event-id}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject466 == nil {
		return nil, reportError("inlineObject466 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject466
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarViewEventAttachmentsCreateUploadSessionRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	inlineObject446 *InlineObject446
}

func (r ApiMeCalendarViewEventAttachmentsCreateUploadSessionRequest) InlineObject446(inlineObject446 InlineObject446) ApiMeCalendarViewEventAttachmentsCreateUploadSessionRequest {
	r.inlineObject446 = &inlineObject446
	return r
}

func (r ApiMeCalendarViewEventAttachmentsCreateUploadSessionRequest) Execute() (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarViewEventAttachmentsCreateUploadSessionExecute(r)
}

/*
MeCalendarViewEventAttachmentsCreateUploadSession Invoke action createUploadSession

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @return ApiMeCalendarViewEventAttachmentsCreateUploadSessionRequest
*/
func (a *MeActionsApiService) MeCalendarViewEventAttachmentsCreateUploadSession(ctx _context.Context, eventId string) ApiMeCalendarViewEventAttachmentsCreateUploadSessionRequest {
	return ApiMeCalendarViewEventAttachmentsCreateUploadSessionRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphUploadSession
func (a *MeActionsApiService) MeCalendarViewEventAttachmentsCreateUploadSessionExecute(r ApiMeCalendarViewEventAttachmentsCreateUploadSessionRequest) (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphUploadSession
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarViewEventAttachmentsCreateUploadSession")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarView/{event-id}/attachments/microsoft.graph.createUploadSession"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject446 == nil {
		return localVarReturnValue, nil, reportError("inlineObject446 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject446
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarViewEventCalendarCalendarViewEventAcceptRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
	inlineObject447 *InlineObject447
}

func (r ApiMeCalendarViewEventCalendarCalendarViewEventAcceptRequest) InlineObject447(inlineObject447 InlineObject447) ApiMeCalendarViewEventCalendarCalendarViewEventAcceptRequest {
	r.inlineObject447 = &inlineObject447
	return r
}

func (r ApiMeCalendarViewEventCalendarCalendarViewEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarViewEventCalendarCalendarViewEventAcceptExecute(r)
}

/*
MeCalendarViewEventCalendarCalendarViewEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarViewEventCalendarCalendarViewEventAcceptRequest
*/
func (a *MeActionsApiService) MeCalendarViewEventCalendarCalendarViewEventAccept(ctx _context.Context, eventId string, eventId1 string) ApiMeCalendarViewEventCalendarCalendarViewEventAcceptRequest {
	return ApiMeCalendarViewEventCalendarCalendarViewEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarViewEventCalendarCalendarViewEventAcceptExecute(r ApiMeCalendarViewEventCalendarCalendarViewEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarViewEventCalendarCalendarViewEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarView/{event-id}/calendar/calendarView/{event-id1}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject447 == nil {
		return nil, reportError("inlineObject447 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject447
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarViewEventCalendarCalendarViewEventCancelRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
	inlineObject448 *InlineObject448
}

func (r ApiMeCalendarViewEventCalendarCalendarViewEventCancelRequest) InlineObject448(inlineObject448 InlineObject448) ApiMeCalendarViewEventCalendarCalendarViewEventCancelRequest {
	r.inlineObject448 = &inlineObject448
	return r
}

func (r ApiMeCalendarViewEventCalendarCalendarViewEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarViewEventCalendarCalendarViewEventCancelExecute(r)
}

/*
MeCalendarViewEventCalendarCalendarViewEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarViewEventCalendarCalendarViewEventCancelRequest
*/
func (a *MeActionsApiService) MeCalendarViewEventCalendarCalendarViewEventCancel(ctx _context.Context, eventId string, eventId1 string) ApiMeCalendarViewEventCalendarCalendarViewEventCancelRequest {
	return ApiMeCalendarViewEventCalendarCalendarViewEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarViewEventCalendarCalendarViewEventCancelExecute(r ApiMeCalendarViewEventCalendarCalendarViewEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarViewEventCalendarCalendarViewEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarView/{event-id}/calendar/calendarView/{event-id1}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject448 == nil {
		return nil, reportError("inlineObject448 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject448
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarViewEventCalendarCalendarViewEventDeclineRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
	inlineObject449 *InlineObject449
}

func (r ApiMeCalendarViewEventCalendarCalendarViewEventDeclineRequest) InlineObject449(inlineObject449 InlineObject449) ApiMeCalendarViewEventCalendarCalendarViewEventDeclineRequest {
	r.inlineObject449 = &inlineObject449
	return r
}

func (r ApiMeCalendarViewEventCalendarCalendarViewEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarViewEventCalendarCalendarViewEventDeclineExecute(r)
}

/*
MeCalendarViewEventCalendarCalendarViewEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarViewEventCalendarCalendarViewEventDeclineRequest
*/
func (a *MeActionsApiService) MeCalendarViewEventCalendarCalendarViewEventDecline(ctx _context.Context, eventId string, eventId1 string) ApiMeCalendarViewEventCalendarCalendarViewEventDeclineRequest {
	return ApiMeCalendarViewEventCalendarCalendarViewEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarViewEventCalendarCalendarViewEventDeclineExecute(r ApiMeCalendarViewEventCalendarCalendarViewEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarViewEventCalendarCalendarViewEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarView/{event-id}/calendar/calendarView/{event-id1}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject449 == nil {
		return nil, reportError("inlineObject449 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject449
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarViewEventCalendarCalendarViewEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
}


func (r ApiMeCalendarViewEventCalendarCalendarViewEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarViewEventCalendarCalendarViewEventDismissReminderExecute(r)
}

/*
MeCalendarViewEventCalendarCalendarViewEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarViewEventCalendarCalendarViewEventDismissReminderRequest
*/
func (a *MeActionsApiService) MeCalendarViewEventCalendarCalendarViewEventDismissReminder(ctx _context.Context, eventId string, eventId1 string) ApiMeCalendarViewEventCalendarCalendarViewEventDismissReminderRequest {
	return ApiMeCalendarViewEventCalendarCalendarViewEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarViewEventCalendarCalendarViewEventDismissReminderExecute(r ApiMeCalendarViewEventCalendarCalendarViewEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarViewEventCalendarCalendarViewEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarView/{event-id}/calendar/calendarView/{event-id1}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarViewEventCalendarCalendarViewEventForwardRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
	inlineObject450 *InlineObject450
}

func (r ApiMeCalendarViewEventCalendarCalendarViewEventForwardRequest) InlineObject450(inlineObject450 InlineObject450) ApiMeCalendarViewEventCalendarCalendarViewEventForwardRequest {
	r.inlineObject450 = &inlineObject450
	return r
}

func (r ApiMeCalendarViewEventCalendarCalendarViewEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarViewEventCalendarCalendarViewEventForwardExecute(r)
}

/*
MeCalendarViewEventCalendarCalendarViewEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarViewEventCalendarCalendarViewEventForwardRequest
*/
func (a *MeActionsApiService) MeCalendarViewEventCalendarCalendarViewEventForward(ctx _context.Context, eventId string, eventId1 string) ApiMeCalendarViewEventCalendarCalendarViewEventForwardRequest {
	return ApiMeCalendarViewEventCalendarCalendarViewEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarViewEventCalendarCalendarViewEventForwardExecute(r ApiMeCalendarViewEventCalendarCalendarViewEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarViewEventCalendarCalendarViewEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarView/{event-id}/calendar/calendarView/{event-id1}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject450 == nil {
		return nil, reportError("inlineObject450 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject450
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarViewEventCalendarCalendarViewEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
	inlineObject451 *InlineObject451
}

func (r ApiMeCalendarViewEventCalendarCalendarViewEventSnoozeReminderRequest) InlineObject451(inlineObject451 InlineObject451) ApiMeCalendarViewEventCalendarCalendarViewEventSnoozeReminderRequest {
	r.inlineObject451 = &inlineObject451
	return r
}

func (r ApiMeCalendarViewEventCalendarCalendarViewEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarViewEventCalendarCalendarViewEventSnoozeReminderExecute(r)
}

/*
MeCalendarViewEventCalendarCalendarViewEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarViewEventCalendarCalendarViewEventSnoozeReminderRequest
*/
func (a *MeActionsApiService) MeCalendarViewEventCalendarCalendarViewEventSnoozeReminder(ctx _context.Context, eventId string, eventId1 string) ApiMeCalendarViewEventCalendarCalendarViewEventSnoozeReminderRequest {
	return ApiMeCalendarViewEventCalendarCalendarViewEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarViewEventCalendarCalendarViewEventSnoozeReminderExecute(r ApiMeCalendarViewEventCalendarCalendarViewEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarViewEventCalendarCalendarViewEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarView/{event-id}/calendar/calendarView/{event-id1}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject451 == nil {
		return nil, reportError("inlineObject451 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject451
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarViewEventCalendarCalendarViewEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
	inlineObject452 *InlineObject452
}

func (r ApiMeCalendarViewEventCalendarCalendarViewEventTentativelyAcceptRequest) InlineObject452(inlineObject452 InlineObject452) ApiMeCalendarViewEventCalendarCalendarViewEventTentativelyAcceptRequest {
	r.inlineObject452 = &inlineObject452
	return r
}

func (r ApiMeCalendarViewEventCalendarCalendarViewEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarViewEventCalendarCalendarViewEventTentativelyAcceptExecute(r)
}

/*
MeCalendarViewEventCalendarCalendarViewEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarViewEventCalendarCalendarViewEventTentativelyAcceptRequest
*/
func (a *MeActionsApiService) MeCalendarViewEventCalendarCalendarViewEventTentativelyAccept(ctx _context.Context, eventId string, eventId1 string) ApiMeCalendarViewEventCalendarCalendarViewEventTentativelyAcceptRequest {
	return ApiMeCalendarViewEventCalendarCalendarViewEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarViewEventCalendarCalendarViewEventTentativelyAcceptExecute(r ApiMeCalendarViewEventCalendarCalendarViewEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarViewEventCalendarCalendarViewEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarView/{event-id}/calendar/calendarView/{event-id1}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject452 == nil {
		return nil, reportError("inlineObject452 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject452
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarViewEventCalendarEventsEventAcceptRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
	inlineObject453 *InlineObject453
}

func (r ApiMeCalendarViewEventCalendarEventsEventAcceptRequest) InlineObject453(inlineObject453 InlineObject453) ApiMeCalendarViewEventCalendarEventsEventAcceptRequest {
	r.inlineObject453 = &inlineObject453
	return r
}

func (r ApiMeCalendarViewEventCalendarEventsEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarViewEventCalendarEventsEventAcceptExecute(r)
}

/*
MeCalendarViewEventCalendarEventsEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarViewEventCalendarEventsEventAcceptRequest
*/
func (a *MeActionsApiService) MeCalendarViewEventCalendarEventsEventAccept(ctx _context.Context, eventId string, eventId1 string) ApiMeCalendarViewEventCalendarEventsEventAcceptRequest {
	return ApiMeCalendarViewEventCalendarEventsEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarViewEventCalendarEventsEventAcceptExecute(r ApiMeCalendarViewEventCalendarEventsEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarViewEventCalendarEventsEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarView/{event-id}/calendar/events/{event-id1}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject453 == nil {
		return nil, reportError("inlineObject453 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject453
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarViewEventCalendarEventsEventCancelRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
	inlineObject454 *InlineObject454
}

func (r ApiMeCalendarViewEventCalendarEventsEventCancelRequest) InlineObject454(inlineObject454 InlineObject454) ApiMeCalendarViewEventCalendarEventsEventCancelRequest {
	r.inlineObject454 = &inlineObject454
	return r
}

func (r ApiMeCalendarViewEventCalendarEventsEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarViewEventCalendarEventsEventCancelExecute(r)
}

/*
MeCalendarViewEventCalendarEventsEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarViewEventCalendarEventsEventCancelRequest
*/
func (a *MeActionsApiService) MeCalendarViewEventCalendarEventsEventCancel(ctx _context.Context, eventId string, eventId1 string) ApiMeCalendarViewEventCalendarEventsEventCancelRequest {
	return ApiMeCalendarViewEventCalendarEventsEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarViewEventCalendarEventsEventCancelExecute(r ApiMeCalendarViewEventCalendarEventsEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarViewEventCalendarEventsEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarView/{event-id}/calendar/events/{event-id1}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject454 == nil {
		return nil, reportError("inlineObject454 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject454
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarViewEventCalendarEventsEventDeclineRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
	inlineObject455 *InlineObject455
}

func (r ApiMeCalendarViewEventCalendarEventsEventDeclineRequest) InlineObject455(inlineObject455 InlineObject455) ApiMeCalendarViewEventCalendarEventsEventDeclineRequest {
	r.inlineObject455 = &inlineObject455
	return r
}

func (r ApiMeCalendarViewEventCalendarEventsEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarViewEventCalendarEventsEventDeclineExecute(r)
}

/*
MeCalendarViewEventCalendarEventsEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarViewEventCalendarEventsEventDeclineRequest
*/
func (a *MeActionsApiService) MeCalendarViewEventCalendarEventsEventDecline(ctx _context.Context, eventId string, eventId1 string) ApiMeCalendarViewEventCalendarEventsEventDeclineRequest {
	return ApiMeCalendarViewEventCalendarEventsEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarViewEventCalendarEventsEventDeclineExecute(r ApiMeCalendarViewEventCalendarEventsEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarViewEventCalendarEventsEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarView/{event-id}/calendar/events/{event-id1}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject455 == nil {
		return nil, reportError("inlineObject455 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject455
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarViewEventCalendarEventsEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
}


func (r ApiMeCalendarViewEventCalendarEventsEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarViewEventCalendarEventsEventDismissReminderExecute(r)
}

/*
MeCalendarViewEventCalendarEventsEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarViewEventCalendarEventsEventDismissReminderRequest
*/
func (a *MeActionsApiService) MeCalendarViewEventCalendarEventsEventDismissReminder(ctx _context.Context, eventId string, eventId1 string) ApiMeCalendarViewEventCalendarEventsEventDismissReminderRequest {
	return ApiMeCalendarViewEventCalendarEventsEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarViewEventCalendarEventsEventDismissReminderExecute(r ApiMeCalendarViewEventCalendarEventsEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarViewEventCalendarEventsEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarView/{event-id}/calendar/events/{event-id1}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarViewEventCalendarEventsEventForwardRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
	inlineObject456 *InlineObject456
}

func (r ApiMeCalendarViewEventCalendarEventsEventForwardRequest) InlineObject456(inlineObject456 InlineObject456) ApiMeCalendarViewEventCalendarEventsEventForwardRequest {
	r.inlineObject456 = &inlineObject456
	return r
}

func (r ApiMeCalendarViewEventCalendarEventsEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarViewEventCalendarEventsEventForwardExecute(r)
}

/*
MeCalendarViewEventCalendarEventsEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarViewEventCalendarEventsEventForwardRequest
*/
func (a *MeActionsApiService) MeCalendarViewEventCalendarEventsEventForward(ctx _context.Context, eventId string, eventId1 string) ApiMeCalendarViewEventCalendarEventsEventForwardRequest {
	return ApiMeCalendarViewEventCalendarEventsEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarViewEventCalendarEventsEventForwardExecute(r ApiMeCalendarViewEventCalendarEventsEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarViewEventCalendarEventsEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarView/{event-id}/calendar/events/{event-id1}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject456 == nil {
		return nil, reportError("inlineObject456 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject456
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarViewEventCalendarEventsEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
	inlineObject457 *InlineObject457
}

func (r ApiMeCalendarViewEventCalendarEventsEventSnoozeReminderRequest) InlineObject457(inlineObject457 InlineObject457) ApiMeCalendarViewEventCalendarEventsEventSnoozeReminderRequest {
	r.inlineObject457 = &inlineObject457
	return r
}

func (r ApiMeCalendarViewEventCalendarEventsEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarViewEventCalendarEventsEventSnoozeReminderExecute(r)
}

/*
MeCalendarViewEventCalendarEventsEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarViewEventCalendarEventsEventSnoozeReminderRequest
*/
func (a *MeActionsApiService) MeCalendarViewEventCalendarEventsEventSnoozeReminder(ctx _context.Context, eventId string, eventId1 string) ApiMeCalendarViewEventCalendarEventsEventSnoozeReminderRequest {
	return ApiMeCalendarViewEventCalendarEventsEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarViewEventCalendarEventsEventSnoozeReminderExecute(r ApiMeCalendarViewEventCalendarEventsEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarViewEventCalendarEventsEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarView/{event-id}/calendar/events/{event-id1}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject457 == nil {
		return nil, reportError("inlineObject457 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject457
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarViewEventCalendarEventsEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
	inlineObject458 *InlineObject458
}

func (r ApiMeCalendarViewEventCalendarEventsEventTentativelyAcceptRequest) InlineObject458(inlineObject458 InlineObject458) ApiMeCalendarViewEventCalendarEventsEventTentativelyAcceptRequest {
	r.inlineObject458 = &inlineObject458
	return r
}

func (r ApiMeCalendarViewEventCalendarEventsEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarViewEventCalendarEventsEventTentativelyAcceptExecute(r)
}

/*
MeCalendarViewEventCalendarEventsEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarViewEventCalendarEventsEventTentativelyAcceptRequest
*/
func (a *MeActionsApiService) MeCalendarViewEventCalendarEventsEventTentativelyAccept(ctx _context.Context, eventId string, eventId1 string) ApiMeCalendarViewEventCalendarEventsEventTentativelyAcceptRequest {
	return ApiMeCalendarViewEventCalendarEventsEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarViewEventCalendarEventsEventTentativelyAcceptExecute(r ApiMeCalendarViewEventCalendarEventsEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarViewEventCalendarEventsEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarView/{event-id}/calendar/events/{event-id1}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject458 == nil {
		return nil, reportError("inlineObject458 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject458
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarViewEventCalendarGetScheduleRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	inlineObject459 *InlineObject459
}

func (r ApiMeCalendarViewEventCalendarGetScheduleRequest) InlineObject459(inlineObject459 InlineObject459) ApiMeCalendarViewEventCalendarGetScheduleRequest {
	r.inlineObject459 = &inlineObject459
	return r
}

func (r ApiMeCalendarViewEventCalendarGetScheduleRequest) Execute() ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarViewEventCalendarGetScheduleExecute(r)
}

/*
MeCalendarViewEventCalendarGetSchedule Invoke action getSchedule

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @return ApiMeCalendarViewEventCalendarGetScheduleRequest
*/
func (a *MeActionsApiService) MeCalendarViewEventCalendarGetSchedule(ctx _context.Context, eventId string) ApiMeCalendarViewEventCalendarGetScheduleRequest {
	return ApiMeCalendarViewEventCalendarGetScheduleRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return []*AnyOfmicrosoftGraphScheduleInformation
func (a *MeActionsApiService) MeCalendarViewEventCalendarGetScheduleExecute(r ApiMeCalendarViewEventCalendarGetScheduleRequest) ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []*AnyOfmicrosoftGraphScheduleInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarViewEventCalendarGetSchedule")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarView/{event-id}/calendar/microsoft.graph.getSchedule"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject459 == nil {
		return localVarReturnValue, nil, reportError("inlineObject459 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject459
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarViewEventCancelRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	inlineObject467 *InlineObject467
}

func (r ApiMeCalendarViewEventCancelRequest) InlineObject467(inlineObject467 InlineObject467) ApiMeCalendarViewEventCancelRequest {
	r.inlineObject467 = &inlineObject467
	return r
}

func (r ApiMeCalendarViewEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarViewEventCancelExecute(r)
}

/*
MeCalendarViewEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @return ApiMeCalendarViewEventCancelRequest
*/
func (a *MeActionsApiService) MeCalendarViewEventCancel(ctx _context.Context, eventId string) ApiMeCalendarViewEventCancelRequest {
	return ApiMeCalendarViewEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarViewEventCancelExecute(r ApiMeCalendarViewEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarViewEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarView/{event-id}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject467 == nil {
		return nil, reportError("inlineObject467 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject467
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarViewEventDeclineRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	inlineObject468 *InlineObject468
}

func (r ApiMeCalendarViewEventDeclineRequest) InlineObject468(inlineObject468 InlineObject468) ApiMeCalendarViewEventDeclineRequest {
	r.inlineObject468 = &inlineObject468
	return r
}

func (r ApiMeCalendarViewEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarViewEventDeclineExecute(r)
}

/*
MeCalendarViewEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @return ApiMeCalendarViewEventDeclineRequest
*/
func (a *MeActionsApiService) MeCalendarViewEventDecline(ctx _context.Context, eventId string) ApiMeCalendarViewEventDeclineRequest {
	return ApiMeCalendarViewEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarViewEventDeclineExecute(r ApiMeCalendarViewEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarViewEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarView/{event-id}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject468 == nil {
		return nil, reportError("inlineObject468 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject468
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarViewEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
}


func (r ApiMeCalendarViewEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarViewEventDismissReminderExecute(r)
}

/*
MeCalendarViewEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @return ApiMeCalendarViewEventDismissReminderRequest
*/
func (a *MeActionsApiService) MeCalendarViewEventDismissReminder(ctx _context.Context, eventId string) ApiMeCalendarViewEventDismissReminderRequest {
	return ApiMeCalendarViewEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarViewEventDismissReminderExecute(r ApiMeCalendarViewEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarViewEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarView/{event-id}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarViewEventForwardRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	inlineObject469 *InlineObject469
}

func (r ApiMeCalendarViewEventForwardRequest) InlineObject469(inlineObject469 InlineObject469) ApiMeCalendarViewEventForwardRequest {
	r.inlineObject469 = &inlineObject469
	return r
}

func (r ApiMeCalendarViewEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarViewEventForwardExecute(r)
}

/*
MeCalendarViewEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @return ApiMeCalendarViewEventForwardRequest
*/
func (a *MeActionsApiService) MeCalendarViewEventForward(ctx _context.Context, eventId string) ApiMeCalendarViewEventForwardRequest {
	return ApiMeCalendarViewEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarViewEventForwardExecute(r ApiMeCalendarViewEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarViewEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarView/{event-id}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject469 == nil {
		return nil, reportError("inlineObject469 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject469
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarViewEventInstancesEventAcceptRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
	inlineObject460 *InlineObject460
}

func (r ApiMeCalendarViewEventInstancesEventAcceptRequest) InlineObject460(inlineObject460 InlineObject460) ApiMeCalendarViewEventInstancesEventAcceptRequest {
	r.inlineObject460 = &inlineObject460
	return r
}

func (r ApiMeCalendarViewEventInstancesEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarViewEventInstancesEventAcceptExecute(r)
}

/*
MeCalendarViewEventInstancesEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarViewEventInstancesEventAcceptRequest
*/
func (a *MeActionsApiService) MeCalendarViewEventInstancesEventAccept(ctx _context.Context, eventId string, eventId1 string) ApiMeCalendarViewEventInstancesEventAcceptRequest {
	return ApiMeCalendarViewEventInstancesEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarViewEventInstancesEventAcceptExecute(r ApiMeCalendarViewEventInstancesEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarViewEventInstancesEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject460 == nil {
		return nil, reportError("inlineObject460 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject460
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarViewEventInstancesEventCancelRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
	inlineObject461 *InlineObject461
}

func (r ApiMeCalendarViewEventInstancesEventCancelRequest) InlineObject461(inlineObject461 InlineObject461) ApiMeCalendarViewEventInstancesEventCancelRequest {
	r.inlineObject461 = &inlineObject461
	return r
}

func (r ApiMeCalendarViewEventInstancesEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarViewEventInstancesEventCancelExecute(r)
}

/*
MeCalendarViewEventInstancesEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarViewEventInstancesEventCancelRequest
*/
func (a *MeActionsApiService) MeCalendarViewEventInstancesEventCancel(ctx _context.Context, eventId string, eventId1 string) ApiMeCalendarViewEventInstancesEventCancelRequest {
	return ApiMeCalendarViewEventInstancesEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarViewEventInstancesEventCancelExecute(r ApiMeCalendarViewEventInstancesEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarViewEventInstancesEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject461 == nil {
		return nil, reportError("inlineObject461 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject461
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarViewEventInstancesEventDeclineRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
	inlineObject462 *InlineObject462
}

func (r ApiMeCalendarViewEventInstancesEventDeclineRequest) InlineObject462(inlineObject462 InlineObject462) ApiMeCalendarViewEventInstancesEventDeclineRequest {
	r.inlineObject462 = &inlineObject462
	return r
}

func (r ApiMeCalendarViewEventInstancesEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarViewEventInstancesEventDeclineExecute(r)
}

/*
MeCalendarViewEventInstancesEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarViewEventInstancesEventDeclineRequest
*/
func (a *MeActionsApiService) MeCalendarViewEventInstancesEventDecline(ctx _context.Context, eventId string, eventId1 string) ApiMeCalendarViewEventInstancesEventDeclineRequest {
	return ApiMeCalendarViewEventInstancesEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarViewEventInstancesEventDeclineExecute(r ApiMeCalendarViewEventInstancesEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarViewEventInstancesEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject462 == nil {
		return nil, reportError("inlineObject462 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject462
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarViewEventInstancesEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
}


func (r ApiMeCalendarViewEventInstancesEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarViewEventInstancesEventDismissReminderExecute(r)
}

/*
MeCalendarViewEventInstancesEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarViewEventInstancesEventDismissReminderRequest
*/
func (a *MeActionsApiService) MeCalendarViewEventInstancesEventDismissReminder(ctx _context.Context, eventId string, eventId1 string) ApiMeCalendarViewEventInstancesEventDismissReminderRequest {
	return ApiMeCalendarViewEventInstancesEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarViewEventInstancesEventDismissReminderExecute(r ApiMeCalendarViewEventInstancesEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarViewEventInstancesEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarViewEventInstancesEventForwardRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
	inlineObject463 *InlineObject463
}

func (r ApiMeCalendarViewEventInstancesEventForwardRequest) InlineObject463(inlineObject463 InlineObject463) ApiMeCalendarViewEventInstancesEventForwardRequest {
	r.inlineObject463 = &inlineObject463
	return r
}

func (r ApiMeCalendarViewEventInstancesEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarViewEventInstancesEventForwardExecute(r)
}

/*
MeCalendarViewEventInstancesEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarViewEventInstancesEventForwardRequest
*/
func (a *MeActionsApiService) MeCalendarViewEventInstancesEventForward(ctx _context.Context, eventId string, eventId1 string) ApiMeCalendarViewEventInstancesEventForwardRequest {
	return ApiMeCalendarViewEventInstancesEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarViewEventInstancesEventForwardExecute(r ApiMeCalendarViewEventInstancesEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarViewEventInstancesEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject463 == nil {
		return nil, reportError("inlineObject463 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject463
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarViewEventInstancesEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
	inlineObject464 *InlineObject464
}

func (r ApiMeCalendarViewEventInstancesEventSnoozeReminderRequest) InlineObject464(inlineObject464 InlineObject464) ApiMeCalendarViewEventInstancesEventSnoozeReminderRequest {
	r.inlineObject464 = &inlineObject464
	return r
}

func (r ApiMeCalendarViewEventInstancesEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarViewEventInstancesEventSnoozeReminderExecute(r)
}

/*
MeCalendarViewEventInstancesEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarViewEventInstancesEventSnoozeReminderRequest
*/
func (a *MeActionsApiService) MeCalendarViewEventInstancesEventSnoozeReminder(ctx _context.Context, eventId string, eventId1 string) ApiMeCalendarViewEventInstancesEventSnoozeReminderRequest {
	return ApiMeCalendarViewEventInstancesEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarViewEventInstancesEventSnoozeReminderExecute(r ApiMeCalendarViewEventInstancesEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarViewEventInstancesEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject464 == nil {
		return nil, reportError("inlineObject464 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject464
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarViewEventInstancesEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
	inlineObject465 *InlineObject465
}

func (r ApiMeCalendarViewEventInstancesEventTentativelyAcceptRequest) InlineObject465(inlineObject465 InlineObject465) ApiMeCalendarViewEventInstancesEventTentativelyAcceptRequest {
	r.inlineObject465 = &inlineObject465
	return r
}

func (r ApiMeCalendarViewEventInstancesEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarViewEventInstancesEventTentativelyAcceptExecute(r)
}

/*
MeCalendarViewEventInstancesEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarViewEventInstancesEventTentativelyAcceptRequest
*/
func (a *MeActionsApiService) MeCalendarViewEventInstancesEventTentativelyAccept(ctx _context.Context, eventId string, eventId1 string) ApiMeCalendarViewEventInstancesEventTentativelyAcceptRequest {
	return ApiMeCalendarViewEventInstancesEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarViewEventInstancesEventTentativelyAcceptExecute(r ApiMeCalendarViewEventInstancesEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarViewEventInstancesEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject465 == nil {
		return nil, reportError("inlineObject465 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject465
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarViewEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	inlineObject470 *InlineObject470
}

func (r ApiMeCalendarViewEventSnoozeReminderRequest) InlineObject470(inlineObject470 InlineObject470) ApiMeCalendarViewEventSnoozeReminderRequest {
	r.inlineObject470 = &inlineObject470
	return r
}

func (r ApiMeCalendarViewEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarViewEventSnoozeReminderExecute(r)
}

/*
MeCalendarViewEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @return ApiMeCalendarViewEventSnoozeReminderRequest
*/
func (a *MeActionsApiService) MeCalendarViewEventSnoozeReminder(ctx _context.Context, eventId string) ApiMeCalendarViewEventSnoozeReminderRequest {
	return ApiMeCalendarViewEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarViewEventSnoozeReminderExecute(r ApiMeCalendarViewEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarViewEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarView/{event-id}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject470 == nil {
		return nil, reportError("inlineObject470 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject470
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarViewEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	inlineObject471 *InlineObject471
}

func (r ApiMeCalendarViewEventTentativelyAcceptRequest) InlineObject471(inlineObject471 InlineObject471) ApiMeCalendarViewEventTentativelyAcceptRequest {
	r.inlineObject471 = &inlineObject471
	return r
}

func (r ApiMeCalendarViewEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarViewEventTentativelyAcceptExecute(r)
}

/*
MeCalendarViewEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @return ApiMeCalendarViewEventTentativelyAcceptRequest
*/
func (a *MeActionsApiService) MeCalendarViewEventTentativelyAccept(ctx _context.Context, eventId string) ApiMeCalendarViewEventTentativelyAcceptRequest {
	return ApiMeCalendarViewEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarViewEventTentativelyAcceptExecute(r ApiMeCalendarViewEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarViewEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendarView/{event-id}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject471 == nil {
		return nil, reportError("inlineObject471 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject471
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarsCalendarCalendarViewEventAcceptRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarId string
	eventId string
	inlineObject425 *InlineObject425
}

func (r ApiMeCalendarsCalendarCalendarViewEventAcceptRequest) InlineObject425(inlineObject425 InlineObject425) ApiMeCalendarsCalendarCalendarViewEventAcceptRequest {
	r.inlineObject425 = &inlineObject425
	return r
}

func (r ApiMeCalendarsCalendarCalendarViewEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarsCalendarCalendarViewEventAcceptExecute(r)
}

/*
MeCalendarsCalendarCalendarViewEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarsCalendarCalendarViewEventAcceptRequest
*/
func (a *MeActionsApiService) MeCalendarsCalendarCalendarViewEventAccept(ctx _context.Context, calendarId string, eventId string) ApiMeCalendarsCalendarCalendarViewEventAcceptRequest {
	return ApiMeCalendarsCalendarCalendarViewEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarsCalendarCalendarViewEventAcceptExecute(r ApiMeCalendarsCalendarCalendarViewEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarsCalendarCalendarViewEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendars/{calendar-id}/calendarView/{event-id}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject425 == nil {
		return nil, reportError("inlineObject425 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject425
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarId string
	eventId string
	inlineObject417 *InlineObject417
}

func (r ApiMeCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest) InlineObject417(inlineObject417 InlineObject417) ApiMeCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest {
	r.inlineObject417 = &inlineObject417
	return r
}

func (r ApiMeCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest) Execute() (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSessionExecute(r)
}

/*
MeCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSession Invoke action createUploadSession

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest
*/
func (a *MeActionsApiService) MeCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSession(ctx _context.Context, calendarId string, eventId string) ApiMeCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest {
	return ApiMeCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest{
		ApiService: a,
		ctx: ctx,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphUploadSession
func (a *MeActionsApiService) MeCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSessionExecute(r ApiMeCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSessionRequest) (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphUploadSession
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarsCalendarCalendarViewEventAttachmentsCreateUploadSession")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendars/{calendar-id}/calendarView/{event-id}/attachments/microsoft.graph.createUploadSession"
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject417 == nil {
		return localVarReturnValue, nil, reportError("inlineObject417 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject417
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarsCalendarCalendarViewEventCalendarGetScheduleRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarId string
	eventId string
	inlineObject418 *InlineObject418
}

func (r ApiMeCalendarsCalendarCalendarViewEventCalendarGetScheduleRequest) InlineObject418(inlineObject418 InlineObject418) ApiMeCalendarsCalendarCalendarViewEventCalendarGetScheduleRequest {
	r.inlineObject418 = &inlineObject418
	return r
}

func (r ApiMeCalendarsCalendarCalendarViewEventCalendarGetScheduleRequest) Execute() ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarsCalendarCalendarViewEventCalendarGetScheduleExecute(r)
}

/*
MeCalendarsCalendarCalendarViewEventCalendarGetSchedule Invoke action getSchedule

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarsCalendarCalendarViewEventCalendarGetScheduleRequest
*/
func (a *MeActionsApiService) MeCalendarsCalendarCalendarViewEventCalendarGetSchedule(ctx _context.Context, calendarId string, eventId string) ApiMeCalendarsCalendarCalendarViewEventCalendarGetScheduleRequest {
	return ApiMeCalendarsCalendarCalendarViewEventCalendarGetScheduleRequest{
		ApiService: a,
		ctx: ctx,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return []*AnyOfmicrosoftGraphScheduleInformation
func (a *MeActionsApiService) MeCalendarsCalendarCalendarViewEventCalendarGetScheduleExecute(r ApiMeCalendarsCalendarCalendarViewEventCalendarGetScheduleRequest) ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []*AnyOfmicrosoftGraphScheduleInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarsCalendarCalendarViewEventCalendarGetSchedule")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendars/{calendar-id}/calendarView/{event-id}/calendar/microsoft.graph.getSchedule"
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject418 == nil {
		return localVarReturnValue, nil, reportError("inlineObject418 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject418
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarsCalendarCalendarViewEventCancelRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarId string
	eventId string
	inlineObject426 *InlineObject426
}

func (r ApiMeCalendarsCalendarCalendarViewEventCancelRequest) InlineObject426(inlineObject426 InlineObject426) ApiMeCalendarsCalendarCalendarViewEventCancelRequest {
	r.inlineObject426 = &inlineObject426
	return r
}

func (r ApiMeCalendarsCalendarCalendarViewEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarsCalendarCalendarViewEventCancelExecute(r)
}

/*
MeCalendarsCalendarCalendarViewEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarsCalendarCalendarViewEventCancelRequest
*/
func (a *MeActionsApiService) MeCalendarsCalendarCalendarViewEventCancel(ctx _context.Context, calendarId string, eventId string) ApiMeCalendarsCalendarCalendarViewEventCancelRequest {
	return ApiMeCalendarsCalendarCalendarViewEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarsCalendarCalendarViewEventCancelExecute(r ApiMeCalendarsCalendarCalendarViewEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarsCalendarCalendarViewEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendars/{calendar-id}/calendarView/{event-id}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject426 == nil {
		return nil, reportError("inlineObject426 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject426
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarsCalendarCalendarViewEventDeclineRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarId string
	eventId string
	inlineObject427 *InlineObject427
}

func (r ApiMeCalendarsCalendarCalendarViewEventDeclineRequest) InlineObject427(inlineObject427 InlineObject427) ApiMeCalendarsCalendarCalendarViewEventDeclineRequest {
	r.inlineObject427 = &inlineObject427
	return r
}

func (r ApiMeCalendarsCalendarCalendarViewEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarsCalendarCalendarViewEventDeclineExecute(r)
}

/*
MeCalendarsCalendarCalendarViewEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarsCalendarCalendarViewEventDeclineRequest
*/
func (a *MeActionsApiService) MeCalendarsCalendarCalendarViewEventDecline(ctx _context.Context, calendarId string, eventId string) ApiMeCalendarsCalendarCalendarViewEventDeclineRequest {
	return ApiMeCalendarsCalendarCalendarViewEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarsCalendarCalendarViewEventDeclineExecute(r ApiMeCalendarsCalendarCalendarViewEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarsCalendarCalendarViewEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendars/{calendar-id}/calendarView/{event-id}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject427 == nil {
		return nil, reportError("inlineObject427 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject427
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarsCalendarCalendarViewEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarId string
	eventId string
}


func (r ApiMeCalendarsCalendarCalendarViewEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarsCalendarCalendarViewEventDismissReminderExecute(r)
}

/*
MeCalendarsCalendarCalendarViewEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarsCalendarCalendarViewEventDismissReminderRequest
*/
func (a *MeActionsApiService) MeCalendarsCalendarCalendarViewEventDismissReminder(ctx _context.Context, calendarId string, eventId string) ApiMeCalendarsCalendarCalendarViewEventDismissReminderRequest {
	return ApiMeCalendarsCalendarCalendarViewEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarsCalendarCalendarViewEventDismissReminderExecute(r ApiMeCalendarsCalendarCalendarViewEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarsCalendarCalendarViewEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendars/{calendar-id}/calendarView/{event-id}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarsCalendarCalendarViewEventForwardRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarId string
	eventId string
	inlineObject428 *InlineObject428
}

func (r ApiMeCalendarsCalendarCalendarViewEventForwardRequest) InlineObject428(inlineObject428 InlineObject428) ApiMeCalendarsCalendarCalendarViewEventForwardRequest {
	r.inlineObject428 = &inlineObject428
	return r
}

func (r ApiMeCalendarsCalendarCalendarViewEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarsCalendarCalendarViewEventForwardExecute(r)
}

/*
MeCalendarsCalendarCalendarViewEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarsCalendarCalendarViewEventForwardRequest
*/
func (a *MeActionsApiService) MeCalendarsCalendarCalendarViewEventForward(ctx _context.Context, calendarId string, eventId string) ApiMeCalendarsCalendarCalendarViewEventForwardRequest {
	return ApiMeCalendarsCalendarCalendarViewEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarsCalendarCalendarViewEventForwardExecute(r ApiMeCalendarsCalendarCalendarViewEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarsCalendarCalendarViewEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendars/{calendar-id}/calendarView/{event-id}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject428 == nil {
		return nil, reportError("inlineObject428 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject428
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarsCalendarCalendarViewEventInstancesEventAcceptRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarId string
	eventId string
	eventId1 string
	inlineObject419 *InlineObject419
}

func (r ApiMeCalendarsCalendarCalendarViewEventInstancesEventAcceptRequest) InlineObject419(inlineObject419 InlineObject419) ApiMeCalendarsCalendarCalendarViewEventInstancesEventAcceptRequest {
	r.inlineObject419 = &inlineObject419
	return r
}

func (r ApiMeCalendarsCalendarCalendarViewEventInstancesEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarsCalendarCalendarViewEventInstancesEventAcceptExecute(r)
}

/*
MeCalendarsCalendarCalendarViewEventInstancesEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarsCalendarCalendarViewEventInstancesEventAcceptRequest
*/
func (a *MeActionsApiService) MeCalendarsCalendarCalendarViewEventInstancesEventAccept(ctx _context.Context, calendarId string, eventId string, eventId1 string) ApiMeCalendarsCalendarCalendarViewEventInstancesEventAcceptRequest {
	return ApiMeCalendarsCalendarCalendarViewEventInstancesEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarsCalendarCalendarViewEventInstancesEventAcceptExecute(r ApiMeCalendarsCalendarCalendarViewEventInstancesEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarsCalendarCalendarViewEventInstancesEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendars/{calendar-id}/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject419 == nil {
		return nil, reportError("inlineObject419 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject419
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarsCalendarCalendarViewEventInstancesEventCancelRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarId string
	eventId string
	eventId1 string
	inlineObject420 *InlineObject420
}

func (r ApiMeCalendarsCalendarCalendarViewEventInstancesEventCancelRequest) InlineObject420(inlineObject420 InlineObject420) ApiMeCalendarsCalendarCalendarViewEventInstancesEventCancelRequest {
	r.inlineObject420 = &inlineObject420
	return r
}

func (r ApiMeCalendarsCalendarCalendarViewEventInstancesEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarsCalendarCalendarViewEventInstancesEventCancelExecute(r)
}

/*
MeCalendarsCalendarCalendarViewEventInstancesEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarsCalendarCalendarViewEventInstancesEventCancelRequest
*/
func (a *MeActionsApiService) MeCalendarsCalendarCalendarViewEventInstancesEventCancel(ctx _context.Context, calendarId string, eventId string, eventId1 string) ApiMeCalendarsCalendarCalendarViewEventInstancesEventCancelRequest {
	return ApiMeCalendarsCalendarCalendarViewEventInstancesEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarsCalendarCalendarViewEventInstancesEventCancelExecute(r ApiMeCalendarsCalendarCalendarViewEventInstancesEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarsCalendarCalendarViewEventInstancesEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendars/{calendar-id}/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject420 == nil {
		return nil, reportError("inlineObject420 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject420
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarsCalendarCalendarViewEventInstancesEventDeclineRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarId string
	eventId string
	eventId1 string
	inlineObject421 *InlineObject421
}

func (r ApiMeCalendarsCalendarCalendarViewEventInstancesEventDeclineRequest) InlineObject421(inlineObject421 InlineObject421) ApiMeCalendarsCalendarCalendarViewEventInstancesEventDeclineRequest {
	r.inlineObject421 = &inlineObject421
	return r
}

func (r ApiMeCalendarsCalendarCalendarViewEventInstancesEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarsCalendarCalendarViewEventInstancesEventDeclineExecute(r)
}

/*
MeCalendarsCalendarCalendarViewEventInstancesEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarsCalendarCalendarViewEventInstancesEventDeclineRequest
*/
func (a *MeActionsApiService) MeCalendarsCalendarCalendarViewEventInstancesEventDecline(ctx _context.Context, calendarId string, eventId string, eventId1 string) ApiMeCalendarsCalendarCalendarViewEventInstancesEventDeclineRequest {
	return ApiMeCalendarsCalendarCalendarViewEventInstancesEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarsCalendarCalendarViewEventInstancesEventDeclineExecute(r ApiMeCalendarsCalendarCalendarViewEventInstancesEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarsCalendarCalendarViewEventInstancesEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendars/{calendar-id}/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject421 == nil {
		return nil, reportError("inlineObject421 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject421
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarsCalendarCalendarViewEventInstancesEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarId string
	eventId string
	eventId1 string
}


func (r ApiMeCalendarsCalendarCalendarViewEventInstancesEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarsCalendarCalendarViewEventInstancesEventDismissReminderExecute(r)
}

/*
MeCalendarsCalendarCalendarViewEventInstancesEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarsCalendarCalendarViewEventInstancesEventDismissReminderRequest
*/
func (a *MeActionsApiService) MeCalendarsCalendarCalendarViewEventInstancesEventDismissReminder(ctx _context.Context, calendarId string, eventId string, eventId1 string) ApiMeCalendarsCalendarCalendarViewEventInstancesEventDismissReminderRequest {
	return ApiMeCalendarsCalendarCalendarViewEventInstancesEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarsCalendarCalendarViewEventInstancesEventDismissReminderExecute(r ApiMeCalendarsCalendarCalendarViewEventInstancesEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarsCalendarCalendarViewEventInstancesEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendars/{calendar-id}/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarsCalendarCalendarViewEventInstancesEventForwardRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarId string
	eventId string
	eventId1 string
	inlineObject422 *InlineObject422
}

func (r ApiMeCalendarsCalendarCalendarViewEventInstancesEventForwardRequest) InlineObject422(inlineObject422 InlineObject422) ApiMeCalendarsCalendarCalendarViewEventInstancesEventForwardRequest {
	r.inlineObject422 = &inlineObject422
	return r
}

func (r ApiMeCalendarsCalendarCalendarViewEventInstancesEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarsCalendarCalendarViewEventInstancesEventForwardExecute(r)
}

/*
MeCalendarsCalendarCalendarViewEventInstancesEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarsCalendarCalendarViewEventInstancesEventForwardRequest
*/
func (a *MeActionsApiService) MeCalendarsCalendarCalendarViewEventInstancesEventForward(ctx _context.Context, calendarId string, eventId string, eventId1 string) ApiMeCalendarsCalendarCalendarViewEventInstancesEventForwardRequest {
	return ApiMeCalendarsCalendarCalendarViewEventInstancesEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarsCalendarCalendarViewEventInstancesEventForwardExecute(r ApiMeCalendarsCalendarCalendarViewEventInstancesEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarsCalendarCalendarViewEventInstancesEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendars/{calendar-id}/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject422 == nil {
		return nil, reportError("inlineObject422 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject422
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarId string
	eventId string
	eventId1 string
	inlineObject423 *InlineObject423
}

func (r ApiMeCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminderRequest) InlineObject423(inlineObject423 InlineObject423) ApiMeCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminderRequest {
	r.inlineObject423 = &inlineObject423
	return r
}

func (r ApiMeCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminderExecute(r)
}

/*
MeCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminderRequest
*/
func (a *MeActionsApiService) MeCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminder(ctx _context.Context, calendarId string, eventId string, eventId1 string) ApiMeCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminderRequest {
	return ApiMeCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminderExecute(r ApiMeCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarsCalendarCalendarViewEventInstancesEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendars/{calendar-id}/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject423 == nil {
		return nil, reportError("inlineObject423 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject423
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarsCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarId string
	eventId string
	eventId1 string
	inlineObject424 *InlineObject424
}

func (r ApiMeCalendarsCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest) InlineObject424(inlineObject424 InlineObject424) ApiMeCalendarsCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest {
	r.inlineObject424 = &inlineObject424
	return r
}

func (r ApiMeCalendarsCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarsCalendarCalendarViewEventInstancesEventTentativelyAcceptExecute(r)
}

/*
MeCalendarsCalendarCalendarViewEventInstancesEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarsCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest
*/
func (a *MeActionsApiService) MeCalendarsCalendarCalendarViewEventInstancesEventTentativelyAccept(ctx _context.Context, calendarId string, eventId string, eventId1 string) ApiMeCalendarsCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest {
	return ApiMeCalendarsCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarsCalendarCalendarViewEventInstancesEventTentativelyAcceptExecute(r ApiMeCalendarsCalendarCalendarViewEventInstancesEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarsCalendarCalendarViewEventInstancesEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendars/{calendar-id}/calendarView/{event-id}/instances/{event-id1}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject424 == nil {
		return nil, reportError("inlineObject424 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject424
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarsCalendarCalendarViewEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarId string
	eventId string
	inlineObject429 *InlineObject429
}

func (r ApiMeCalendarsCalendarCalendarViewEventSnoozeReminderRequest) InlineObject429(inlineObject429 InlineObject429) ApiMeCalendarsCalendarCalendarViewEventSnoozeReminderRequest {
	r.inlineObject429 = &inlineObject429
	return r
}

func (r ApiMeCalendarsCalendarCalendarViewEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarsCalendarCalendarViewEventSnoozeReminderExecute(r)
}

/*
MeCalendarsCalendarCalendarViewEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarsCalendarCalendarViewEventSnoozeReminderRequest
*/
func (a *MeActionsApiService) MeCalendarsCalendarCalendarViewEventSnoozeReminder(ctx _context.Context, calendarId string, eventId string) ApiMeCalendarsCalendarCalendarViewEventSnoozeReminderRequest {
	return ApiMeCalendarsCalendarCalendarViewEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarsCalendarCalendarViewEventSnoozeReminderExecute(r ApiMeCalendarsCalendarCalendarViewEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarsCalendarCalendarViewEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendars/{calendar-id}/calendarView/{event-id}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject429 == nil {
		return nil, reportError("inlineObject429 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject429
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarsCalendarCalendarViewEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarId string
	eventId string
	inlineObject430 *InlineObject430
}

func (r ApiMeCalendarsCalendarCalendarViewEventTentativelyAcceptRequest) InlineObject430(inlineObject430 InlineObject430) ApiMeCalendarsCalendarCalendarViewEventTentativelyAcceptRequest {
	r.inlineObject430 = &inlineObject430
	return r
}

func (r ApiMeCalendarsCalendarCalendarViewEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarsCalendarCalendarViewEventTentativelyAcceptExecute(r)
}

/*
MeCalendarsCalendarCalendarViewEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarsCalendarCalendarViewEventTentativelyAcceptRequest
*/
func (a *MeActionsApiService) MeCalendarsCalendarCalendarViewEventTentativelyAccept(ctx _context.Context, calendarId string, eventId string) ApiMeCalendarsCalendarCalendarViewEventTentativelyAcceptRequest {
	return ApiMeCalendarsCalendarCalendarViewEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarsCalendarCalendarViewEventTentativelyAcceptExecute(r ApiMeCalendarsCalendarCalendarViewEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarsCalendarCalendarViewEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendars/{calendar-id}/calendarView/{event-id}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject430 == nil {
		return nil, reportError("inlineObject430 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject430
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarsCalendarEventsEventAcceptRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarId string
	eventId string
	inlineObject439 *InlineObject439
}

func (r ApiMeCalendarsCalendarEventsEventAcceptRequest) InlineObject439(inlineObject439 InlineObject439) ApiMeCalendarsCalendarEventsEventAcceptRequest {
	r.inlineObject439 = &inlineObject439
	return r
}

func (r ApiMeCalendarsCalendarEventsEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarsCalendarEventsEventAcceptExecute(r)
}

/*
MeCalendarsCalendarEventsEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarsCalendarEventsEventAcceptRequest
*/
func (a *MeActionsApiService) MeCalendarsCalendarEventsEventAccept(ctx _context.Context, calendarId string, eventId string) ApiMeCalendarsCalendarEventsEventAcceptRequest {
	return ApiMeCalendarsCalendarEventsEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarsCalendarEventsEventAcceptExecute(r ApiMeCalendarsCalendarEventsEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarsCalendarEventsEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendars/{calendar-id}/events/{event-id}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject439 == nil {
		return nil, reportError("inlineObject439 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject439
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarsCalendarEventsEventAttachmentsCreateUploadSessionRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarId string
	eventId string
	inlineObject431 *InlineObject431
}

func (r ApiMeCalendarsCalendarEventsEventAttachmentsCreateUploadSessionRequest) InlineObject431(inlineObject431 InlineObject431) ApiMeCalendarsCalendarEventsEventAttachmentsCreateUploadSessionRequest {
	r.inlineObject431 = &inlineObject431
	return r
}

func (r ApiMeCalendarsCalendarEventsEventAttachmentsCreateUploadSessionRequest) Execute() (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarsCalendarEventsEventAttachmentsCreateUploadSessionExecute(r)
}

/*
MeCalendarsCalendarEventsEventAttachmentsCreateUploadSession Invoke action createUploadSession

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarsCalendarEventsEventAttachmentsCreateUploadSessionRequest
*/
func (a *MeActionsApiService) MeCalendarsCalendarEventsEventAttachmentsCreateUploadSession(ctx _context.Context, calendarId string, eventId string) ApiMeCalendarsCalendarEventsEventAttachmentsCreateUploadSessionRequest {
	return ApiMeCalendarsCalendarEventsEventAttachmentsCreateUploadSessionRequest{
		ApiService: a,
		ctx: ctx,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphUploadSession
func (a *MeActionsApiService) MeCalendarsCalendarEventsEventAttachmentsCreateUploadSessionExecute(r ApiMeCalendarsCalendarEventsEventAttachmentsCreateUploadSessionRequest) (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphUploadSession
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarsCalendarEventsEventAttachmentsCreateUploadSession")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendars/{calendar-id}/events/{event-id}/attachments/microsoft.graph.createUploadSession"
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject431 == nil {
		return localVarReturnValue, nil, reportError("inlineObject431 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject431
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarsCalendarEventsEventCalendarGetScheduleRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarId string
	eventId string
	inlineObject432 *InlineObject432
}

func (r ApiMeCalendarsCalendarEventsEventCalendarGetScheduleRequest) InlineObject432(inlineObject432 InlineObject432) ApiMeCalendarsCalendarEventsEventCalendarGetScheduleRequest {
	r.inlineObject432 = &inlineObject432
	return r
}

func (r ApiMeCalendarsCalendarEventsEventCalendarGetScheduleRequest) Execute() ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarsCalendarEventsEventCalendarGetScheduleExecute(r)
}

/*
MeCalendarsCalendarEventsEventCalendarGetSchedule Invoke action getSchedule

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarsCalendarEventsEventCalendarGetScheduleRequest
*/
func (a *MeActionsApiService) MeCalendarsCalendarEventsEventCalendarGetSchedule(ctx _context.Context, calendarId string, eventId string) ApiMeCalendarsCalendarEventsEventCalendarGetScheduleRequest {
	return ApiMeCalendarsCalendarEventsEventCalendarGetScheduleRequest{
		ApiService: a,
		ctx: ctx,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return []*AnyOfmicrosoftGraphScheduleInformation
func (a *MeActionsApiService) MeCalendarsCalendarEventsEventCalendarGetScheduleExecute(r ApiMeCalendarsCalendarEventsEventCalendarGetScheduleRequest) ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []*AnyOfmicrosoftGraphScheduleInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarsCalendarEventsEventCalendarGetSchedule")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendars/{calendar-id}/events/{event-id}/calendar/microsoft.graph.getSchedule"
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject432 == nil {
		return localVarReturnValue, nil, reportError("inlineObject432 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject432
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCalendarsCalendarEventsEventCancelRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarId string
	eventId string
	inlineObject440 *InlineObject440
}

func (r ApiMeCalendarsCalendarEventsEventCancelRequest) InlineObject440(inlineObject440 InlineObject440) ApiMeCalendarsCalendarEventsEventCancelRequest {
	r.inlineObject440 = &inlineObject440
	return r
}

func (r ApiMeCalendarsCalendarEventsEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarsCalendarEventsEventCancelExecute(r)
}

/*
MeCalendarsCalendarEventsEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarsCalendarEventsEventCancelRequest
*/
func (a *MeActionsApiService) MeCalendarsCalendarEventsEventCancel(ctx _context.Context, calendarId string, eventId string) ApiMeCalendarsCalendarEventsEventCancelRequest {
	return ApiMeCalendarsCalendarEventsEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarsCalendarEventsEventCancelExecute(r ApiMeCalendarsCalendarEventsEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarsCalendarEventsEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendars/{calendar-id}/events/{event-id}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject440 == nil {
		return nil, reportError("inlineObject440 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject440
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarsCalendarEventsEventDeclineRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarId string
	eventId string
	inlineObject441 *InlineObject441
}

func (r ApiMeCalendarsCalendarEventsEventDeclineRequest) InlineObject441(inlineObject441 InlineObject441) ApiMeCalendarsCalendarEventsEventDeclineRequest {
	r.inlineObject441 = &inlineObject441
	return r
}

func (r ApiMeCalendarsCalendarEventsEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarsCalendarEventsEventDeclineExecute(r)
}

/*
MeCalendarsCalendarEventsEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarsCalendarEventsEventDeclineRequest
*/
func (a *MeActionsApiService) MeCalendarsCalendarEventsEventDecline(ctx _context.Context, calendarId string, eventId string) ApiMeCalendarsCalendarEventsEventDeclineRequest {
	return ApiMeCalendarsCalendarEventsEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarsCalendarEventsEventDeclineExecute(r ApiMeCalendarsCalendarEventsEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarsCalendarEventsEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendars/{calendar-id}/events/{event-id}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject441 == nil {
		return nil, reportError("inlineObject441 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject441
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarsCalendarEventsEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarId string
	eventId string
}


func (r ApiMeCalendarsCalendarEventsEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarsCalendarEventsEventDismissReminderExecute(r)
}

/*
MeCalendarsCalendarEventsEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarsCalendarEventsEventDismissReminderRequest
*/
func (a *MeActionsApiService) MeCalendarsCalendarEventsEventDismissReminder(ctx _context.Context, calendarId string, eventId string) ApiMeCalendarsCalendarEventsEventDismissReminderRequest {
	return ApiMeCalendarsCalendarEventsEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarsCalendarEventsEventDismissReminderExecute(r ApiMeCalendarsCalendarEventsEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarsCalendarEventsEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendars/{calendar-id}/events/{event-id}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarsCalendarEventsEventForwardRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarId string
	eventId string
	inlineObject442 *InlineObject442
}

func (r ApiMeCalendarsCalendarEventsEventForwardRequest) InlineObject442(inlineObject442 InlineObject442) ApiMeCalendarsCalendarEventsEventForwardRequest {
	r.inlineObject442 = &inlineObject442
	return r
}

func (r ApiMeCalendarsCalendarEventsEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarsCalendarEventsEventForwardExecute(r)
}

/*
MeCalendarsCalendarEventsEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarsCalendarEventsEventForwardRequest
*/
func (a *MeActionsApiService) MeCalendarsCalendarEventsEventForward(ctx _context.Context, calendarId string, eventId string) ApiMeCalendarsCalendarEventsEventForwardRequest {
	return ApiMeCalendarsCalendarEventsEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarsCalendarEventsEventForwardExecute(r ApiMeCalendarsCalendarEventsEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarsCalendarEventsEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendars/{calendar-id}/events/{event-id}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject442 == nil {
		return nil, reportError("inlineObject442 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject442
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarsCalendarEventsEventInstancesEventAcceptRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarId string
	eventId string
	eventId1 string
	inlineObject433 *InlineObject433
}

func (r ApiMeCalendarsCalendarEventsEventInstancesEventAcceptRequest) InlineObject433(inlineObject433 InlineObject433) ApiMeCalendarsCalendarEventsEventInstancesEventAcceptRequest {
	r.inlineObject433 = &inlineObject433
	return r
}

func (r ApiMeCalendarsCalendarEventsEventInstancesEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarsCalendarEventsEventInstancesEventAcceptExecute(r)
}

/*
MeCalendarsCalendarEventsEventInstancesEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarsCalendarEventsEventInstancesEventAcceptRequest
*/
func (a *MeActionsApiService) MeCalendarsCalendarEventsEventInstancesEventAccept(ctx _context.Context, calendarId string, eventId string, eventId1 string) ApiMeCalendarsCalendarEventsEventInstancesEventAcceptRequest {
	return ApiMeCalendarsCalendarEventsEventInstancesEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarsCalendarEventsEventInstancesEventAcceptExecute(r ApiMeCalendarsCalendarEventsEventInstancesEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarsCalendarEventsEventInstancesEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendars/{calendar-id}/events/{event-id}/instances/{event-id1}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject433 == nil {
		return nil, reportError("inlineObject433 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject433
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarsCalendarEventsEventInstancesEventCancelRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarId string
	eventId string
	eventId1 string
	inlineObject434 *InlineObject434
}

func (r ApiMeCalendarsCalendarEventsEventInstancesEventCancelRequest) InlineObject434(inlineObject434 InlineObject434) ApiMeCalendarsCalendarEventsEventInstancesEventCancelRequest {
	r.inlineObject434 = &inlineObject434
	return r
}

func (r ApiMeCalendarsCalendarEventsEventInstancesEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarsCalendarEventsEventInstancesEventCancelExecute(r)
}

/*
MeCalendarsCalendarEventsEventInstancesEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarsCalendarEventsEventInstancesEventCancelRequest
*/
func (a *MeActionsApiService) MeCalendarsCalendarEventsEventInstancesEventCancel(ctx _context.Context, calendarId string, eventId string, eventId1 string) ApiMeCalendarsCalendarEventsEventInstancesEventCancelRequest {
	return ApiMeCalendarsCalendarEventsEventInstancesEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarsCalendarEventsEventInstancesEventCancelExecute(r ApiMeCalendarsCalendarEventsEventInstancesEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarsCalendarEventsEventInstancesEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendars/{calendar-id}/events/{event-id}/instances/{event-id1}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject434 == nil {
		return nil, reportError("inlineObject434 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject434
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarsCalendarEventsEventInstancesEventDeclineRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarId string
	eventId string
	eventId1 string
	inlineObject435 *InlineObject435
}

func (r ApiMeCalendarsCalendarEventsEventInstancesEventDeclineRequest) InlineObject435(inlineObject435 InlineObject435) ApiMeCalendarsCalendarEventsEventInstancesEventDeclineRequest {
	r.inlineObject435 = &inlineObject435
	return r
}

func (r ApiMeCalendarsCalendarEventsEventInstancesEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarsCalendarEventsEventInstancesEventDeclineExecute(r)
}

/*
MeCalendarsCalendarEventsEventInstancesEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarsCalendarEventsEventInstancesEventDeclineRequest
*/
func (a *MeActionsApiService) MeCalendarsCalendarEventsEventInstancesEventDecline(ctx _context.Context, calendarId string, eventId string, eventId1 string) ApiMeCalendarsCalendarEventsEventInstancesEventDeclineRequest {
	return ApiMeCalendarsCalendarEventsEventInstancesEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarsCalendarEventsEventInstancesEventDeclineExecute(r ApiMeCalendarsCalendarEventsEventInstancesEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarsCalendarEventsEventInstancesEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendars/{calendar-id}/events/{event-id}/instances/{event-id1}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject435 == nil {
		return nil, reportError("inlineObject435 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject435
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarsCalendarEventsEventInstancesEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarId string
	eventId string
	eventId1 string
}


func (r ApiMeCalendarsCalendarEventsEventInstancesEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarsCalendarEventsEventInstancesEventDismissReminderExecute(r)
}

/*
MeCalendarsCalendarEventsEventInstancesEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarsCalendarEventsEventInstancesEventDismissReminderRequest
*/
func (a *MeActionsApiService) MeCalendarsCalendarEventsEventInstancesEventDismissReminder(ctx _context.Context, calendarId string, eventId string, eventId1 string) ApiMeCalendarsCalendarEventsEventInstancesEventDismissReminderRequest {
	return ApiMeCalendarsCalendarEventsEventInstancesEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarsCalendarEventsEventInstancesEventDismissReminderExecute(r ApiMeCalendarsCalendarEventsEventInstancesEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarsCalendarEventsEventInstancesEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendars/{calendar-id}/events/{event-id}/instances/{event-id1}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarsCalendarEventsEventInstancesEventForwardRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarId string
	eventId string
	eventId1 string
	inlineObject436 *InlineObject436
}

func (r ApiMeCalendarsCalendarEventsEventInstancesEventForwardRequest) InlineObject436(inlineObject436 InlineObject436) ApiMeCalendarsCalendarEventsEventInstancesEventForwardRequest {
	r.inlineObject436 = &inlineObject436
	return r
}

func (r ApiMeCalendarsCalendarEventsEventInstancesEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarsCalendarEventsEventInstancesEventForwardExecute(r)
}

/*
MeCalendarsCalendarEventsEventInstancesEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarsCalendarEventsEventInstancesEventForwardRequest
*/
func (a *MeActionsApiService) MeCalendarsCalendarEventsEventInstancesEventForward(ctx _context.Context, calendarId string, eventId string, eventId1 string) ApiMeCalendarsCalendarEventsEventInstancesEventForwardRequest {
	return ApiMeCalendarsCalendarEventsEventInstancesEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarsCalendarEventsEventInstancesEventForwardExecute(r ApiMeCalendarsCalendarEventsEventInstancesEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarsCalendarEventsEventInstancesEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendars/{calendar-id}/events/{event-id}/instances/{event-id1}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject436 == nil {
		return nil, reportError("inlineObject436 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject436
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarsCalendarEventsEventInstancesEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarId string
	eventId string
	eventId1 string
	inlineObject437 *InlineObject437
}

func (r ApiMeCalendarsCalendarEventsEventInstancesEventSnoozeReminderRequest) InlineObject437(inlineObject437 InlineObject437) ApiMeCalendarsCalendarEventsEventInstancesEventSnoozeReminderRequest {
	r.inlineObject437 = &inlineObject437
	return r
}

func (r ApiMeCalendarsCalendarEventsEventInstancesEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarsCalendarEventsEventInstancesEventSnoozeReminderExecute(r)
}

/*
MeCalendarsCalendarEventsEventInstancesEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarsCalendarEventsEventInstancesEventSnoozeReminderRequest
*/
func (a *MeActionsApiService) MeCalendarsCalendarEventsEventInstancesEventSnoozeReminder(ctx _context.Context, calendarId string, eventId string, eventId1 string) ApiMeCalendarsCalendarEventsEventInstancesEventSnoozeReminderRequest {
	return ApiMeCalendarsCalendarEventsEventInstancesEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarsCalendarEventsEventInstancesEventSnoozeReminderExecute(r ApiMeCalendarsCalendarEventsEventInstancesEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarsCalendarEventsEventInstancesEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendars/{calendar-id}/events/{event-id}/instances/{event-id1}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject437 == nil {
		return nil, reportError("inlineObject437 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject437
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarsCalendarEventsEventInstancesEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarId string
	eventId string
	eventId1 string
	inlineObject438 *InlineObject438
}

func (r ApiMeCalendarsCalendarEventsEventInstancesEventTentativelyAcceptRequest) InlineObject438(inlineObject438 InlineObject438) ApiMeCalendarsCalendarEventsEventInstancesEventTentativelyAcceptRequest {
	r.inlineObject438 = &inlineObject438
	return r
}

func (r ApiMeCalendarsCalendarEventsEventInstancesEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarsCalendarEventsEventInstancesEventTentativelyAcceptExecute(r)
}

/*
MeCalendarsCalendarEventsEventInstancesEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeCalendarsCalendarEventsEventInstancesEventTentativelyAcceptRequest
*/
func (a *MeActionsApiService) MeCalendarsCalendarEventsEventInstancesEventTentativelyAccept(ctx _context.Context, calendarId string, eventId string, eventId1 string) ApiMeCalendarsCalendarEventsEventInstancesEventTentativelyAcceptRequest {
	return ApiMeCalendarsCalendarEventsEventInstancesEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		calendarId: calendarId,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarsCalendarEventsEventInstancesEventTentativelyAcceptExecute(r ApiMeCalendarsCalendarEventsEventInstancesEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarsCalendarEventsEventInstancesEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendars/{calendar-id}/events/{event-id}/instances/{event-id1}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject438 == nil {
		return nil, reportError("inlineObject438 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject438
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarsCalendarEventsEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarId string
	eventId string
	inlineObject443 *InlineObject443
}

func (r ApiMeCalendarsCalendarEventsEventSnoozeReminderRequest) InlineObject443(inlineObject443 InlineObject443) ApiMeCalendarsCalendarEventsEventSnoozeReminderRequest {
	r.inlineObject443 = &inlineObject443
	return r
}

func (r ApiMeCalendarsCalendarEventsEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarsCalendarEventsEventSnoozeReminderExecute(r)
}

/*
MeCalendarsCalendarEventsEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarsCalendarEventsEventSnoozeReminderRequest
*/
func (a *MeActionsApiService) MeCalendarsCalendarEventsEventSnoozeReminder(ctx _context.Context, calendarId string, eventId string) ApiMeCalendarsCalendarEventsEventSnoozeReminderRequest {
	return ApiMeCalendarsCalendarEventsEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarsCalendarEventsEventSnoozeReminderExecute(r ApiMeCalendarsCalendarEventsEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarsCalendarEventsEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendars/{calendar-id}/events/{event-id}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject443 == nil {
		return nil, reportError("inlineObject443 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject443
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarsCalendarEventsEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarId string
	eventId string
	inlineObject444 *InlineObject444
}

func (r ApiMeCalendarsCalendarEventsEventTentativelyAcceptRequest) InlineObject444(inlineObject444 InlineObject444) ApiMeCalendarsCalendarEventsEventTentativelyAcceptRequest {
	r.inlineObject444 = &inlineObject444
	return r
}

func (r ApiMeCalendarsCalendarEventsEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeCalendarsCalendarEventsEventTentativelyAcceptExecute(r)
}

/*
MeCalendarsCalendarEventsEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarId key: id of calendar
 @param eventId key: id of event
 @return ApiMeCalendarsCalendarEventsEventTentativelyAcceptRequest
*/
func (a *MeActionsApiService) MeCalendarsCalendarEventsEventTentativelyAccept(ctx _context.Context, calendarId string, eventId string) ApiMeCalendarsCalendarEventsEventTentativelyAcceptRequest {
	return ApiMeCalendarsCalendarEventsEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		calendarId: calendarId,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeCalendarsCalendarEventsEventTentativelyAcceptExecute(r ApiMeCalendarsCalendarEventsEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarsCalendarEventsEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendars/{calendar-id}/events/{event-id}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject444 == nil {
		return nil, reportError("inlineObject444 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject444
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCalendarsCalendarGetScheduleRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	calendarId string
	inlineObject445 *InlineObject445
}

func (r ApiMeCalendarsCalendarGetScheduleRequest) InlineObject445(inlineObject445 InlineObject445) ApiMeCalendarsCalendarGetScheduleRequest {
	r.inlineObject445 = &inlineObject445
	return r
}

func (r ApiMeCalendarsCalendarGetScheduleRequest) Execute() ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	return r.ApiService.MeCalendarsCalendarGetScheduleExecute(r)
}

/*
MeCalendarsCalendarGetSchedule Invoke action getSchedule

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param calendarId key: id of calendar
 @return ApiMeCalendarsCalendarGetScheduleRequest
*/
func (a *MeActionsApiService) MeCalendarsCalendarGetSchedule(ctx _context.Context, calendarId string) ApiMeCalendarsCalendarGetScheduleRequest {
	return ApiMeCalendarsCalendarGetScheduleRequest{
		ApiService: a,
		ctx: ctx,
		calendarId: calendarId,
	}
}

// Execute executes the request
//  @return []*AnyOfmicrosoftGraphScheduleInformation
func (a *MeActionsApiService) MeCalendarsCalendarGetScheduleExecute(r ApiMeCalendarsCalendarGetScheduleRequest) ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []*AnyOfmicrosoftGraphScheduleInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCalendarsCalendarGetSchedule")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/calendars/{calendar-id}/microsoft.graph.getSchedule"
	localVarPath = strings.Replace(localVarPath, "{"+"calendar-id"+"}", _neturl.PathEscape(parameterToString(r.calendarId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject445 == nil {
		return localVarReturnValue, nil, reportError("inlineObject445 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject445
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeChangePasswordRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	inlineObject586 *InlineObject586
}

func (r ApiMeChangePasswordRequest) InlineObject586(inlineObject586 InlineObject586) ApiMeChangePasswordRequest {
	r.inlineObject586 = &inlineObject586
	return r
}

func (r ApiMeChangePasswordRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeChangePasswordExecute(r)
}

/*
MeChangePassword Invoke action changePassword

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMeChangePasswordRequest
*/
func (a *MeActionsApiService) MeChangePassword(ctx _context.Context) ApiMeChangePasswordRequest {
	return ApiMeChangePasswordRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeChangePasswordExecute(r ApiMeChangePasswordRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeChangePassword")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/microsoft.graph.changePassword"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject586 == nil {
		return nil, reportError("inlineObject586 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject586
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeCheckMemberGroupsRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	inlineObject587 *InlineObject587
}

func (r ApiMeCheckMemberGroupsRequest) InlineObject587(inlineObject587 InlineObject587) ApiMeCheckMemberGroupsRequest {
	r.inlineObject587 = &inlineObject587
	return r
}

func (r ApiMeCheckMemberGroupsRequest) Execute() ([]string, *_nethttp.Response, error) {
	return r.ApiService.MeCheckMemberGroupsExecute(r)
}

/*
MeCheckMemberGroups Invoke action checkMemberGroups

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMeCheckMemberGroupsRequest
*/
func (a *MeActionsApiService) MeCheckMemberGroups(ctx _context.Context) ApiMeCheckMemberGroupsRequest {
	return ApiMeCheckMemberGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []string
func (a *MeActionsApiService) MeCheckMemberGroupsExecute(r ApiMeCheckMemberGroupsRequest) ([]string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCheckMemberGroups")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/microsoft.graph.checkMemberGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject587 == nil {
		return localVarReturnValue, nil, reportError("inlineObject587 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject587
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeCheckMemberObjectsRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	inlineObject588 *InlineObject588
}

func (r ApiMeCheckMemberObjectsRequest) InlineObject588(inlineObject588 InlineObject588) ApiMeCheckMemberObjectsRequest {
	r.inlineObject588 = &inlineObject588
	return r
}

func (r ApiMeCheckMemberObjectsRequest) Execute() ([]string, *_nethttp.Response, error) {
	return r.ApiService.MeCheckMemberObjectsExecute(r)
}

/*
MeCheckMemberObjects Invoke action checkMemberObjects

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMeCheckMemberObjectsRequest
*/
func (a *MeActionsApiService) MeCheckMemberObjects(ctx _context.Context) ApiMeCheckMemberObjectsRequest {
	return ApiMeCheckMemberObjectsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []string
func (a *MeActionsApiService) MeCheckMemberObjectsExecute(r ApiMeCheckMemberObjectsRequest) ([]string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeCheckMemberObjects")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/microsoft.graph.checkMemberObjects"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject588 == nil {
		return localVarReturnValue, nil, reportError("inlineObject588 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject588
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeEventsEventAcceptRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	inlineObject492 *InlineObject492
}

func (r ApiMeEventsEventAcceptRequest) InlineObject492(inlineObject492 InlineObject492) ApiMeEventsEventAcceptRequest {
	r.inlineObject492 = &inlineObject492
	return r
}

func (r ApiMeEventsEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeEventsEventAcceptExecute(r)
}

/*
MeEventsEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @return ApiMeEventsEventAcceptRequest
*/
func (a *MeActionsApiService) MeEventsEventAccept(ctx _context.Context, eventId string) ApiMeEventsEventAcceptRequest {
	return ApiMeEventsEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeEventsEventAcceptExecute(r ApiMeEventsEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeEventsEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/events/{event-id}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject492 == nil {
		return nil, reportError("inlineObject492 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject492
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeEventsEventAttachmentsCreateUploadSessionRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	inlineObject472 *InlineObject472
}

func (r ApiMeEventsEventAttachmentsCreateUploadSessionRequest) InlineObject472(inlineObject472 InlineObject472) ApiMeEventsEventAttachmentsCreateUploadSessionRequest {
	r.inlineObject472 = &inlineObject472
	return r
}

func (r ApiMeEventsEventAttachmentsCreateUploadSessionRequest) Execute() (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	return r.ApiService.MeEventsEventAttachmentsCreateUploadSessionExecute(r)
}

/*
MeEventsEventAttachmentsCreateUploadSession Invoke action createUploadSession

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @return ApiMeEventsEventAttachmentsCreateUploadSessionRequest
*/
func (a *MeActionsApiService) MeEventsEventAttachmentsCreateUploadSession(ctx _context.Context, eventId string) ApiMeEventsEventAttachmentsCreateUploadSessionRequest {
	return ApiMeEventsEventAttachmentsCreateUploadSessionRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphUploadSession
func (a *MeActionsApiService) MeEventsEventAttachmentsCreateUploadSessionExecute(r ApiMeEventsEventAttachmentsCreateUploadSessionRequest) (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphUploadSession
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeEventsEventAttachmentsCreateUploadSession")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/events/{event-id}/attachments/microsoft.graph.createUploadSession"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject472 == nil {
		return localVarReturnValue, nil, reportError("inlineObject472 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject472
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeEventsEventCalendarCalendarViewEventAcceptRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
	inlineObject473 *InlineObject473
}

func (r ApiMeEventsEventCalendarCalendarViewEventAcceptRequest) InlineObject473(inlineObject473 InlineObject473) ApiMeEventsEventCalendarCalendarViewEventAcceptRequest {
	r.inlineObject473 = &inlineObject473
	return r
}

func (r ApiMeEventsEventCalendarCalendarViewEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeEventsEventCalendarCalendarViewEventAcceptExecute(r)
}

/*
MeEventsEventCalendarCalendarViewEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeEventsEventCalendarCalendarViewEventAcceptRequest
*/
func (a *MeActionsApiService) MeEventsEventCalendarCalendarViewEventAccept(ctx _context.Context, eventId string, eventId1 string) ApiMeEventsEventCalendarCalendarViewEventAcceptRequest {
	return ApiMeEventsEventCalendarCalendarViewEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeEventsEventCalendarCalendarViewEventAcceptExecute(r ApiMeEventsEventCalendarCalendarViewEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeEventsEventCalendarCalendarViewEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/events/{event-id}/calendar/calendarView/{event-id1}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject473 == nil {
		return nil, reportError("inlineObject473 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject473
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeEventsEventCalendarCalendarViewEventCancelRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
	inlineObject474 *InlineObject474
}

func (r ApiMeEventsEventCalendarCalendarViewEventCancelRequest) InlineObject474(inlineObject474 InlineObject474) ApiMeEventsEventCalendarCalendarViewEventCancelRequest {
	r.inlineObject474 = &inlineObject474
	return r
}

func (r ApiMeEventsEventCalendarCalendarViewEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeEventsEventCalendarCalendarViewEventCancelExecute(r)
}

/*
MeEventsEventCalendarCalendarViewEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeEventsEventCalendarCalendarViewEventCancelRequest
*/
func (a *MeActionsApiService) MeEventsEventCalendarCalendarViewEventCancel(ctx _context.Context, eventId string, eventId1 string) ApiMeEventsEventCalendarCalendarViewEventCancelRequest {
	return ApiMeEventsEventCalendarCalendarViewEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeEventsEventCalendarCalendarViewEventCancelExecute(r ApiMeEventsEventCalendarCalendarViewEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeEventsEventCalendarCalendarViewEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/events/{event-id}/calendar/calendarView/{event-id1}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject474 == nil {
		return nil, reportError("inlineObject474 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject474
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeEventsEventCalendarCalendarViewEventDeclineRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
	inlineObject475 *InlineObject475
}

func (r ApiMeEventsEventCalendarCalendarViewEventDeclineRequest) InlineObject475(inlineObject475 InlineObject475) ApiMeEventsEventCalendarCalendarViewEventDeclineRequest {
	r.inlineObject475 = &inlineObject475
	return r
}

func (r ApiMeEventsEventCalendarCalendarViewEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeEventsEventCalendarCalendarViewEventDeclineExecute(r)
}

/*
MeEventsEventCalendarCalendarViewEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeEventsEventCalendarCalendarViewEventDeclineRequest
*/
func (a *MeActionsApiService) MeEventsEventCalendarCalendarViewEventDecline(ctx _context.Context, eventId string, eventId1 string) ApiMeEventsEventCalendarCalendarViewEventDeclineRequest {
	return ApiMeEventsEventCalendarCalendarViewEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeEventsEventCalendarCalendarViewEventDeclineExecute(r ApiMeEventsEventCalendarCalendarViewEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeEventsEventCalendarCalendarViewEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/events/{event-id}/calendar/calendarView/{event-id1}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject475 == nil {
		return nil, reportError("inlineObject475 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject475
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeEventsEventCalendarCalendarViewEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
}


func (r ApiMeEventsEventCalendarCalendarViewEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeEventsEventCalendarCalendarViewEventDismissReminderExecute(r)
}

/*
MeEventsEventCalendarCalendarViewEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeEventsEventCalendarCalendarViewEventDismissReminderRequest
*/
func (a *MeActionsApiService) MeEventsEventCalendarCalendarViewEventDismissReminder(ctx _context.Context, eventId string, eventId1 string) ApiMeEventsEventCalendarCalendarViewEventDismissReminderRequest {
	return ApiMeEventsEventCalendarCalendarViewEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeEventsEventCalendarCalendarViewEventDismissReminderExecute(r ApiMeEventsEventCalendarCalendarViewEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeEventsEventCalendarCalendarViewEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/events/{event-id}/calendar/calendarView/{event-id1}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeEventsEventCalendarCalendarViewEventForwardRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
	inlineObject476 *InlineObject476
}

func (r ApiMeEventsEventCalendarCalendarViewEventForwardRequest) InlineObject476(inlineObject476 InlineObject476) ApiMeEventsEventCalendarCalendarViewEventForwardRequest {
	r.inlineObject476 = &inlineObject476
	return r
}

func (r ApiMeEventsEventCalendarCalendarViewEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeEventsEventCalendarCalendarViewEventForwardExecute(r)
}

/*
MeEventsEventCalendarCalendarViewEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeEventsEventCalendarCalendarViewEventForwardRequest
*/
func (a *MeActionsApiService) MeEventsEventCalendarCalendarViewEventForward(ctx _context.Context, eventId string, eventId1 string) ApiMeEventsEventCalendarCalendarViewEventForwardRequest {
	return ApiMeEventsEventCalendarCalendarViewEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeEventsEventCalendarCalendarViewEventForwardExecute(r ApiMeEventsEventCalendarCalendarViewEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeEventsEventCalendarCalendarViewEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/events/{event-id}/calendar/calendarView/{event-id1}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject476 == nil {
		return nil, reportError("inlineObject476 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject476
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeEventsEventCalendarCalendarViewEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
	inlineObject477 *InlineObject477
}

func (r ApiMeEventsEventCalendarCalendarViewEventSnoozeReminderRequest) InlineObject477(inlineObject477 InlineObject477) ApiMeEventsEventCalendarCalendarViewEventSnoozeReminderRequest {
	r.inlineObject477 = &inlineObject477
	return r
}

func (r ApiMeEventsEventCalendarCalendarViewEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeEventsEventCalendarCalendarViewEventSnoozeReminderExecute(r)
}

/*
MeEventsEventCalendarCalendarViewEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeEventsEventCalendarCalendarViewEventSnoozeReminderRequest
*/
func (a *MeActionsApiService) MeEventsEventCalendarCalendarViewEventSnoozeReminder(ctx _context.Context, eventId string, eventId1 string) ApiMeEventsEventCalendarCalendarViewEventSnoozeReminderRequest {
	return ApiMeEventsEventCalendarCalendarViewEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeEventsEventCalendarCalendarViewEventSnoozeReminderExecute(r ApiMeEventsEventCalendarCalendarViewEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeEventsEventCalendarCalendarViewEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/events/{event-id}/calendar/calendarView/{event-id1}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject477 == nil {
		return nil, reportError("inlineObject477 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject477
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeEventsEventCalendarCalendarViewEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
	inlineObject478 *InlineObject478
}

func (r ApiMeEventsEventCalendarCalendarViewEventTentativelyAcceptRequest) InlineObject478(inlineObject478 InlineObject478) ApiMeEventsEventCalendarCalendarViewEventTentativelyAcceptRequest {
	r.inlineObject478 = &inlineObject478
	return r
}

func (r ApiMeEventsEventCalendarCalendarViewEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeEventsEventCalendarCalendarViewEventTentativelyAcceptExecute(r)
}

/*
MeEventsEventCalendarCalendarViewEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeEventsEventCalendarCalendarViewEventTentativelyAcceptRequest
*/
func (a *MeActionsApiService) MeEventsEventCalendarCalendarViewEventTentativelyAccept(ctx _context.Context, eventId string, eventId1 string) ApiMeEventsEventCalendarCalendarViewEventTentativelyAcceptRequest {
	return ApiMeEventsEventCalendarCalendarViewEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeEventsEventCalendarCalendarViewEventTentativelyAcceptExecute(r ApiMeEventsEventCalendarCalendarViewEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeEventsEventCalendarCalendarViewEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/events/{event-id}/calendar/calendarView/{event-id1}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject478 == nil {
		return nil, reportError("inlineObject478 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject478
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeEventsEventCalendarEventsEventAcceptRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
	inlineObject479 *InlineObject479
}

func (r ApiMeEventsEventCalendarEventsEventAcceptRequest) InlineObject479(inlineObject479 InlineObject479) ApiMeEventsEventCalendarEventsEventAcceptRequest {
	r.inlineObject479 = &inlineObject479
	return r
}

func (r ApiMeEventsEventCalendarEventsEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeEventsEventCalendarEventsEventAcceptExecute(r)
}

/*
MeEventsEventCalendarEventsEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeEventsEventCalendarEventsEventAcceptRequest
*/
func (a *MeActionsApiService) MeEventsEventCalendarEventsEventAccept(ctx _context.Context, eventId string, eventId1 string) ApiMeEventsEventCalendarEventsEventAcceptRequest {
	return ApiMeEventsEventCalendarEventsEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeEventsEventCalendarEventsEventAcceptExecute(r ApiMeEventsEventCalendarEventsEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeEventsEventCalendarEventsEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/events/{event-id}/calendar/events/{event-id1}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject479 == nil {
		return nil, reportError("inlineObject479 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject479
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeEventsEventCalendarEventsEventCancelRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
	inlineObject480 *InlineObject480
}

func (r ApiMeEventsEventCalendarEventsEventCancelRequest) InlineObject480(inlineObject480 InlineObject480) ApiMeEventsEventCalendarEventsEventCancelRequest {
	r.inlineObject480 = &inlineObject480
	return r
}

func (r ApiMeEventsEventCalendarEventsEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeEventsEventCalendarEventsEventCancelExecute(r)
}

/*
MeEventsEventCalendarEventsEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeEventsEventCalendarEventsEventCancelRequest
*/
func (a *MeActionsApiService) MeEventsEventCalendarEventsEventCancel(ctx _context.Context, eventId string, eventId1 string) ApiMeEventsEventCalendarEventsEventCancelRequest {
	return ApiMeEventsEventCalendarEventsEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeEventsEventCalendarEventsEventCancelExecute(r ApiMeEventsEventCalendarEventsEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeEventsEventCalendarEventsEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/events/{event-id}/calendar/events/{event-id1}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject480 == nil {
		return nil, reportError("inlineObject480 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject480
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeEventsEventCalendarEventsEventDeclineRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
	inlineObject481 *InlineObject481
}

func (r ApiMeEventsEventCalendarEventsEventDeclineRequest) InlineObject481(inlineObject481 InlineObject481) ApiMeEventsEventCalendarEventsEventDeclineRequest {
	r.inlineObject481 = &inlineObject481
	return r
}

func (r ApiMeEventsEventCalendarEventsEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeEventsEventCalendarEventsEventDeclineExecute(r)
}

/*
MeEventsEventCalendarEventsEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeEventsEventCalendarEventsEventDeclineRequest
*/
func (a *MeActionsApiService) MeEventsEventCalendarEventsEventDecline(ctx _context.Context, eventId string, eventId1 string) ApiMeEventsEventCalendarEventsEventDeclineRequest {
	return ApiMeEventsEventCalendarEventsEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeEventsEventCalendarEventsEventDeclineExecute(r ApiMeEventsEventCalendarEventsEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeEventsEventCalendarEventsEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/events/{event-id}/calendar/events/{event-id1}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject481 == nil {
		return nil, reportError("inlineObject481 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject481
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeEventsEventCalendarEventsEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
}


func (r ApiMeEventsEventCalendarEventsEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeEventsEventCalendarEventsEventDismissReminderExecute(r)
}

/*
MeEventsEventCalendarEventsEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeEventsEventCalendarEventsEventDismissReminderRequest
*/
func (a *MeActionsApiService) MeEventsEventCalendarEventsEventDismissReminder(ctx _context.Context, eventId string, eventId1 string) ApiMeEventsEventCalendarEventsEventDismissReminderRequest {
	return ApiMeEventsEventCalendarEventsEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeEventsEventCalendarEventsEventDismissReminderExecute(r ApiMeEventsEventCalendarEventsEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeEventsEventCalendarEventsEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/events/{event-id}/calendar/events/{event-id1}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeEventsEventCalendarEventsEventForwardRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
	inlineObject482 *InlineObject482
}

func (r ApiMeEventsEventCalendarEventsEventForwardRequest) InlineObject482(inlineObject482 InlineObject482) ApiMeEventsEventCalendarEventsEventForwardRequest {
	r.inlineObject482 = &inlineObject482
	return r
}

func (r ApiMeEventsEventCalendarEventsEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeEventsEventCalendarEventsEventForwardExecute(r)
}

/*
MeEventsEventCalendarEventsEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeEventsEventCalendarEventsEventForwardRequest
*/
func (a *MeActionsApiService) MeEventsEventCalendarEventsEventForward(ctx _context.Context, eventId string, eventId1 string) ApiMeEventsEventCalendarEventsEventForwardRequest {
	return ApiMeEventsEventCalendarEventsEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeEventsEventCalendarEventsEventForwardExecute(r ApiMeEventsEventCalendarEventsEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeEventsEventCalendarEventsEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/events/{event-id}/calendar/events/{event-id1}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject482 == nil {
		return nil, reportError("inlineObject482 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject482
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeEventsEventCalendarEventsEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
	inlineObject483 *InlineObject483
}

func (r ApiMeEventsEventCalendarEventsEventSnoozeReminderRequest) InlineObject483(inlineObject483 InlineObject483) ApiMeEventsEventCalendarEventsEventSnoozeReminderRequest {
	r.inlineObject483 = &inlineObject483
	return r
}

func (r ApiMeEventsEventCalendarEventsEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeEventsEventCalendarEventsEventSnoozeReminderExecute(r)
}

/*
MeEventsEventCalendarEventsEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeEventsEventCalendarEventsEventSnoozeReminderRequest
*/
func (a *MeActionsApiService) MeEventsEventCalendarEventsEventSnoozeReminder(ctx _context.Context, eventId string, eventId1 string) ApiMeEventsEventCalendarEventsEventSnoozeReminderRequest {
	return ApiMeEventsEventCalendarEventsEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeEventsEventCalendarEventsEventSnoozeReminderExecute(r ApiMeEventsEventCalendarEventsEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeEventsEventCalendarEventsEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/events/{event-id}/calendar/events/{event-id1}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject483 == nil {
		return nil, reportError("inlineObject483 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject483
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeEventsEventCalendarEventsEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
	inlineObject484 *InlineObject484
}

func (r ApiMeEventsEventCalendarEventsEventTentativelyAcceptRequest) InlineObject484(inlineObject484 InlineObject484) ApiMeEventsEventCalendarEventsEventTentativelyAcceptRequest {
	r.inlineObject484 = &inlineObject484
	return r
}

func (r ApiMeEventsEventCalendarEventsEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeEventsEventCalendarEventsEventTentativelyAcceptExecute(r)
}

/*
MeEventsEventCalendarEventsEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeEventsEventCalendarEventsEventTentativelyAcceptRequest
*/
func (a *MeActionsApiService) MeEventsEventCalendarEventsEventTentativelyAccept(ctx _context.Context, eventId string, eventId1 string) ApiMeEventsEventCalendarEventsEventTentativelyAcceptRequest {
	return ApiMeEventsEventCalendarEventsEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeEventsEventCalendarEventsEventTentativelyAcceptExecute(r ApiMeEventsEventCalendarEventsEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeEventsEventCalendarEventsEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/events/{event-id}/calendar/events/{event-id1}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject484 == nil {
		return nil, reportError("inlineObject484 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject484
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeEventsEventCalendarGetScheduleRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	inlineObject485 *InlineObject485
}

func (r ApiMeEventsEventCalendarGetScheduleRequest) InlineObject485(inlineObject485 InlineObject485) ApiMeEventsEventCalendarGetScheduleRequest {
	r.inlineObject485 = &inlineObject485
	return r
}

func (r ApiMeEventsEventCalendarGetScheduleRequest) Execute() ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	return r.ApiService.MeEventsEventCalendarGetScheduleExecute(r)
}

/*
MeEventsEventCalendarGetSchedule Invoke action getSchedule

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @return ApiMeEventsEventCalendarGetScheduleRequest
*/
func (a *MeActionsApiService) MeEventsEventCalendarGetSchedule(ctx _context.Context, eventId string) ApiMeEventsEventCalendarGetScheduleRequest {
	return ApiMeEventsEventCalendarGetScheduleRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return []*AnyOfmicrosoftGraphScheduleInformation
func (a *MeActionsApiService) MeEventsEventCalendarGetScheduleExecute(r ApiMeEventsEventCalendarGetScheduleRequest) ([]*AnyOfmicrosoftGraphScheduleInformation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []*AnyOfmicrosoftGraphScheduleInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeEventsEventCalendarGetSchedule")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/events/{event-id}/calendar/microsoft.graph.getSchedule"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject485 == nil {
		return localVarReturnValue, nil, reportError("inlineObject485 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject485
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeEventsEventCancelRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	inlineObject493 *InlineObject493
}

func (r ApiMeEventsEventCancelRequest) InlineObject493(inlineObject493 InlineObject493) ApiMeEventsEventCancelRequest {
	r.inlineObject493 = &inlineObject493
	return r
}

func (r ApiMeEventsEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeEventsEventCancelExecute(r)
}

/*
MeEventsEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @return ApiMeEventsEventCancelRequest
*/
func (a *MeActionsApiService) MeEventsEventCancel(ctx _context.Context, eventId string) ApiMeEventsEventCancelRequest {
	return ApiMeEventsEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeEventsEventCancelExecute(r ApiMeEventsEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeEventsEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/events/{event-id}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject493 == nil {
		return nil, reportError("inlineObject493 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject493
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeEventsEventDeclineRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	inlineObject494 *InlineObject494
}

func (r ApiMeEventsEventDeclineRequest) InlineObject494(inlineObject494 InlineObject494) ApiMeEventsEventDeclineRequest {
	r.inlineObject494 = &inlineObject494
	return r
}

func (r ApiMeEventsEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeEventsEventDeclineExecute(r)
}

/*
MeEventsEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @return ApiMeEventsEventDeclineRequest
*/
func (a *MeActionsApiService) MeEventsEventDecline(ctx _context.Context, eventId string) ApiMeEventsEventDeclineRequest {
	return ApiMeEventsEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeEventsEventDeclineExecute(r ApiMeEventsEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeEventsEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/events/{event-id}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject494 == nil {
		return nil, reportError("inlineObject494 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject494
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeEventsEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
}


func (r ApiMeEventsEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeEventsEventDismissReminderExecute(r)
}

/*
MeEventsEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @return ApiMeEventsEventDismissReminderRequest
*/
func (a *MeActionsApiService) MeEventsEventDismissReminder(ctx _context.Context, eventId string) ApiMeEventsEventDismissReminderRequest {
	return ApiMeEventsEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeEventsEventDismissReminderExecute(r ApiMeEventsEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeEventsEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/events/{event-id}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeEventsEventForwardRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	inlineObject495 *InlineObject495
}

func (r ApiMeEventsEventForwardRequest) InlineObject495(inlineObject495 InlineObject495) ApiMeEventsEventForwardRequest {
	r.inlineObject495 = &inlineObject495
	return r
}

func (r ApiMeEventsEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeEventsEventForwardExecute(r)
}

/*
MeEventsEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @return ApiMeEventsEventForwardRequest
*/
func (a *MeActionsApiService) MeEventsEventForward(ctx _context.Context, eventId string) ApiMeEventsEventForwardRequest {
	return ApiMeEventsEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeEventsEventForwardExecute(r ApiMeEventsEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeEventsEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/events/{event-id}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject495 == nil {
		return nil, reportError("inlineObject495 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject495
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeEventsEventInstancesEventAcceptRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
	inlineObject486 *InlineObject486
}

func (r ApiMeEventsEventInstancesEventAcceptRequest) InlineObject486(inlineObject486 InlineObject486) ApiMeEventsEventInstancesEventAcceptRequest {
	r.inlineObject486 = &inlineObject486
	return r
}

func (r ApiMeEventsEventInstancesEventAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeEventsEventInstancesEventAcceptExecute(r)
}

/*
MeEventsEventInstancesEventAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeEventsEventInstancesEventAcceptRequest
*/
func (a *MeActionsApiService) MeEventsEventInstancesEventAccept(ctx _context.Context, eventId string, eventId1 string) ApiMeEventsEventInstancesEventAcceptRequest {
	return ApiMeEventsEventInstancesEventAcceptRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeEventsEventInstancesEventAcceptExecute(r ApiMeEventsEventInstancesEventAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeEventsEventInstancesEventAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/events/{event-id}/instances/{event-id1}/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject486 == nil {
		return nil, reportError("inlineObject486 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject486
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeEventsEventInstancesEventCancelRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
	inlineObject487 *InlineObject487
}

func (r ApiMeEventsEventInstancesEventCancelRequest) InlineObject487(inlineObject487 InlineObject487) ApiMeEventsEventInstancesEventCancelRequest {
	r.inlineObject487 = &inlineObject487
	return r
}

func (r ApiMeEventsEventInstancesEventCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeEventsEventInstancesEventCancelExecute(r)
}

/*
MeEventsEventInstancesEventCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeEventsEventInstancesEventCancelRequest
*/
func (a *MeActionsApiService) MeEventsEventInstancesEventCancel(ctx _context.Context, eventId string, eventId1 string) ApiMeEventsEventInstancesEventCancelRequest {
	return ApiMeEventsEventInstancesEventCancelRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeEventsEventInstancesEventCancelExecute(r ApiMeEventsEventInstancesEventCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeEventsEventInstancesEventCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/events/{event-id}/instances/{event-id1}/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject487 == nil {
		return nil, reportError("inlineObject487 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject487
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeEventsEventInstancesEventDeclineRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
	inlineObject488 *InlineObject488
}

func (r ApiMeEventsEventInstancesEventDeclineRequest) InlineObject488(inlineObject488 InlineObject488) ApiMeEventsEventInstancesEventDeclineRequest {
	r.inlineObject488 = &inlineObject488
	return r
}

func (r ApiMeEventsEventInstancesEventDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeEventsEventInstancesEventDeclineExecute(r)
}

/*
MeEventsEventInstancesEventDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeEventsEventInstancesEventDeclineRequest
*/
func (a *MeActionsApiService) MeEventsEventInstancesEventDecline(ctx _context.Context, eventId string, eventId1 string) ApiMeEventsEventInstancesEventDeclineRequest {
	return ApiMeEventsEventInstancesEventDeclineRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeEventsEventInstancesEventDeclineExecute(r ApiMeEventsEventInstancesEventDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeEventsEventInstancesEventDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/events/{event-id}/instances/{event-id1}/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject488 == nil {
		return nil, reportError("inlineObject488 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject488
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeEventsEventInstancesEventDismissReminderRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
}


func (r ApiMeEventsEventInstancesEventDismissReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeEventsEventInstancesEventDismissReminderExecute(r)
}

/*
MeEventsEventInstancesEventDismissReminder Invoke action dismissReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeEventsEventInstancesEventDismissReminderRequest
*/
func (a *MeActionsApiService) MeEventsEventInstancesEventDismissReminder(ctx _context.Context, eventId string, eventId1 string) ApiMeEventsEventInstancesEventDismissReminderRequest {
	return ApiMeEventsEventInstancesEventDismissReminderRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeEventsEventInstancesEventDismissReminderExecute(r ApiMeEventsEventInstancesEventDismissReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeEventsEventInstancesEventDismissReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/events/{event-id}/instances/{event-id1}/microsoft.graph.dismissReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeEventsEventInstancesEventForwardRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
	inlineObject489 *InlineObject489
}

func (r ApiMeEventsEventInstancesEventForwardRequest) InlineObject489(inlineObject489 InlineObject489) ApiMeEventsEventInstancesEventForwardRequest {
	r.inlineObject489 = &inlineObject489
	return r
}

func (r ApiMeEventsEventInstancesEventForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeEventsEventInstancesEventForwardExecute(r)
}

/*
MeEventsEventInstancesEventForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeEventsEventInstancesEventForwardRequest
*/
func (a *MeActionsApiService) MeEventsEventInstancesEventForward(ctx _context.Context, eventId string, eventId1 string) ApiMeEventsEventInstancesEventForwardRequest {
	return ApiMeEventsEventInstancesEventForwardRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeEventsEventInstancesEventForwardExecute(r ApiMeEventsEventInstancesEventForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeEventsEventInstancesEventForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/events/{event-id}/instances/{event-id1}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject489 == nil {
		return nil, reportError("inlineObject489 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject489
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeEventsEventInstancesEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
	inlineObject490 *InlineObject490
}

func (r ApiMeEventsEventInstancesEventSnoozeReminderRequest) InlineObject490(inlineObject490 InlineObject490) ApiMeEventsEventInstancesEventSnoozeReminderRequest {
	r.inlineObject490 = &inlineObject490
	return r
}

func (r ApiMeEventsEventInstancesEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeEventsEventInstancesEventSnoozeReminderExecute(r)
}

/*
MeEventsEventInstancesEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeEventsEventInstancesEventSnoozeReminderRequest
*/
func (a *MeActionsApiService) MeEventsEventInstancesEventSnoozeReminder(ctx _context.Context, eventId string, eventId1 string) ApiMeEventsEventInstancesEventSnoozeReminderRequest {
	return ApiMeEventsEventInstancesEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeEventsEventInstancesEventSnoozeReminderExecute(r ApiMeEventsEventInstancesEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeEventsEventInstancesEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/events/{event-id}/instances/{event-id1}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject490 == nil {
		return nil, reportError("inlineObject490 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject490
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeEventsEventInstancesEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	eventId1 string
	inlineObject491 *InlineObject491
}

func (r ApiMeEventsEventInstancesEventTentativelyAcceptRequest) InlineObject491(inlineObject491 InlineObject491) ApiMeEventsEventInstancesEventTentativelyAcceptRequest {
	r.inlineObject491 = &inlineObject491
	return r
}

func (r ApiMeEventsEventInstancesEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeEventsEventInstancesEventTentativelyAcceptExecute(r)
}

/*
MeEventsEventInstancesEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @param eventId1 key: id of event
 @return ApiMeEventsEventInstancesEventTentativelyAcceptRequest
*/
func (a *MeActionsApiService) MeEventsEventInstancesEventTentativelyAccept(ctx _context.Context, eventId string, eventId1 string) ApiMeEventsEventInstancesEventTentativelyAcceptRequest {
	return ApiMeEventsEventInstancesEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		eventId1: eventId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeEventsEventInstancesEventTentativelyAcceptExecute(r ApiMeEventsEventInstancesEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeEventsEventInstancesEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/events/{event-id}/instances/{event-id1}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event-id1"+"}", _neturl.PathEscape(parameterToString(r.eventId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject491 == nil {
		return nil, reportError("inlineObject491 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject491
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeEventsEventSnoozeReminderRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	inlineObject496 *InlineObject496
}

func (r ApiMeEventsEventSnoozeReminderRequest) InlineObject496(inlineObject496 InlineObject496) ApiMeEventsEventSnoozeReminderRequest {
	r.inlineObject496 = &inlineObject496
	return r
}

func (r ApiMeEventsEventSnoozeReminderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeEventsEventSnoozeReminderExecute(r)
}

/*
MeEventsEventSnoozeReminder Invoke action snoozeReminder

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @return ApiMeEventsEventSnoozeReminderRequest
*/
func (a *MeActionsApiService) MeEventsEventSnoozeReminder(ctx _context.Context, eventId string) ApiMeEventsEventSnoozeReminderRequest {
	return ApiMeEventsEventSnoozeReminderRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeEventsEventSnoozeReminderExecute(r ApiMeEventsEventSnoozeReminderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeEventsEventSnoozeReminder")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/events/{event-id}/microsoft.graph.snoozeReminder"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject496 == nil {
		return nil, reportError("inlineObject496 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject496
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeEventsEventTentativelyAcceptRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	eventId string
	inlineObject497 *InlineObject497
}

func (r ApiMeEventsEventTentativelyAcceptRequest) InlineObject497(inlineObject497 InlineObject497) ApiMeEventsEventTentativelyAcceptRequest {
	r.inlineObject497 = &inlineObject497
	return r
}

func (r ApiMeEventsEventTentativelyAcceptRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeEventsEventTentativelyAcceptExecute(r)
}

/*
MeEventsEventTentativelyAccept Invoke action tentativelyAccept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId key: id of event
 @return ApiMeEventsEventTentativelyAcceptRequest
*/
func (a *MeActionsApiService) MeEventsEventTentativelyAccept(ctx _context.Context, eventId string) ApiMeEventsEventTentativelyAcceptRequest {
	return ApiMeEventsEventTentativelyAcceptRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeEventsEventTentativelyAcceptExecute(r ApiMeEventsEventTentativelyAcceptRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeEventsEventTentativelyAccept")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/events/{event-id}/microsoft.graph.tentativelyAccept"
	localVarPath = strings.Replace(localVarPath, "{"+"event-id"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject497 == nil {
		return nil, reportError("inlineObject497 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject497
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeExportPersonalDataRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	inlineObject589 *InlineObject589
}

func (r ApiMeExportPersonalDataRequest) InlineObject589(inlineObject589 InlineObject589) ApiMeExportPersonalDataRequest {
	r.inlineObject589 = &inlineObject589
	return r
}

func (r ApiMeExportPersonalDataRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeExportPersonalDataExecute(r)
}

/*
MeExportPersonalData Invoke action exportPersonalData

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMeExportPersonalDataRequest
*/
func (a *MeActionsApiService) MeExportPersonalData(ctx _context.Context) ApiMeExportPersonalDataRequest {
	return ApiMeExportPersonalDataRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeExportPersonalDataExecute(r ApiMeExportPersonalDataRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeExportPersonalData")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/microsoft.graph.exportPersonalData"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject589 == nil {
		return nil, reportError("inlineObject589 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject589
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeFindMeetingTimesRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	inlineObject590 *InlineObject590
}

func (r ApiMeFindMeetingTimesRequest) InlineObject590(inlineObject590 InlineObject590) ApiMeFindMeetingTimesRequest {
	r.inlineObject590 = &inlineObject590
	return r
}

func (r ApiMeFindMeetingTimesRequest) Execute() (AnyOfmicrosoftGraphMeetingTimeSuggestionsResult, *_nethttp.Response, error) {
	return r.ApiService.MeFindMeetingTimesExecute(r)
}

/*
MeFindMeetingTimes Invoke action findMeetingTimes

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMeFindMeetingTimesRequest
*/
func (a *MeActionsApiService) MeFindMeetingTimes(ctx _context.Context) ApiMeFindMeetingTimesRequest {
	return ApiMeFindMeetingTimesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphMeetingTimeSuggestionsResult
func (a *MeActionsApiService) MeFindMeetingTimesExecute(r ApiMeFindMeetingTimesRequest) (AnyOfmicrosoftGraphMeetingTimeSuggestionsResult, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphMeetingTimeSuggestionsResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeFindMeetingTimes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/microsoft.graph.findMeetingTimes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject590 == nil {
		return localVarReturnValue, nil, reportError("inlineObject590 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject590
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeGetMailTipsRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	inlineObject591 *InlineObject591
}

func (r ApiMeGetMailTipsRequest) InlineObject591(inlineObject591 InlineObject591) ApiMeGetMailTipsRequest {
	r.inlineObject591 = &inlineObject591
	return r
}

func (r ApiMeGetMailTipsRequest) Execute() ([]MicrosoftGraphMailTips, *_nethttp.Response, error) {
	return r.ApiService.MeGetMailTipsExecute(r)
}

/*
MeGetMailTips Invoke action getMailTips

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMeGetMailTipsRequest
*/
func (a *MeActionsApiService) MeGetMailTips(ctx _context.Context) ApiMeGetMailTipsRequest {
	return ApiMeGetMailTipsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []MicrosoftGraphMailTips
func (a *MeActionsApiService) MeGetMailTipsExecute(r ApiMeGetMailTipsRequest) ([]MicrosoftGraphMailTips, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []MicrosoftGraphMailTips
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeGetMailTips")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/microsoft.graph.getMailTips"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject591 == nil {
		return localVarReturnValue, nil, reportError("inlineObject591 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject591
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeGetMemberGroupsRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	inlineObject592 *InlineObject592
}

func (r ApiMeGetMemberGroupsRequest) InlineObject592(inlineObject592 InlineObject592) ApiMeGetMemberGroupsRequest {
	r.inlineObject592 = &inlineObject592
	return r
}

func (r ApiMeGetMemberGroupsRequest) Execute() ([]string, *_nethttp.Response, error) {
	return r.ApiService.MeGetMemberGroupsExecute(r)
}

/*
MeGetMemberGroups Invoke action getMemberGroups

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMeGetMemberGroupsRequest
*/
func (a *MeActionsApiService) MeGetMemberGroups(ctx _context.Context) ApiMeGetMemberGroupsRequest {
	return ApiMeGetMemberGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []string
func (a *MeActionsApiService) MeGetMemberGroupsExecute(r ApiMeGetMemberGroupsRequest) ([]string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeGetMemberGroups")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/microsoft.graph.getMemberGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject592 == nil {
		return localVarReturnValue, nil, reportError("inlineObject592 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject592
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeGetMemberObjectsRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	inlineObject593 *InlineObject593
}

func (r ApiMeGetMemberObjectsRequest) InlineObject593(inlineObject593 InlineObject593) ApiMeGetMemberObjectsRequest {
	r.inlineObject593 = &inlineObject593
	return r
}

func (r ApiMeGetMemberObjectsRequest) Execute() ([]string, *_nethttp.Response, error) {
	return r.ApiService.MeGetMemberObjectsExecute(r)
}

/*
MeGetMemberObjects Invoke action getMemberObjects

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMeGetMemberObjectsRequest
*/
func (a *MeActionsApiService) MeGetMemberObjects(ctx _context.Context) ApiMeGetMemberObjectsRequest {
	return ApiMeGetMemberObjectsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []string
func (a *MeActionsApiService) MeGetMemberObjectsExecute(r ApiMeGetMemberObjectsRequest) ([]string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeGetMemberObjects")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/microsoft.graph.getMemberObjects"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject593 == nil {
		return localVarReturnValue, nil, reportError("inlineObject593 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject593
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphCalendarSharingMessageAcceptRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sharedInsightId string
}


func (r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphCalendarSharingMessageAcceptRequest) Execute() (MicrosoftGraphCalendar, *_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphCalendarSharingMessageAcceptExecute(r)
}

/*
MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphCalendarSharingMessageAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphCalendarSharingMessageAcceptRequest
*/
func (a *MeActionsApiService) MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphCalendarSharingMessageAccept(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphCalendarSharingMessageAcceptRequest {
	return ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphCalendarSharingMessageAcceptRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphCalendar
func (a *MeActionsApiService) MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphCalendarSharingMessageAcceptExecute(r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphCalendarSharingMessageAcceptRequest) (MicrosoftGraphCalendar, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphCalendar
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphCalendarSharingMessageAccept")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/lastSharedMethod/microsoft.graph.calendarSharingMessage/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphManagedAppProtectionTargetAppsRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sharedInsightId string
	inlineObject498 *InlineObject498
}

func (r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphManagedAppProtectionTargetAppsRequest) InlineObject498(inlineObject498 InlineObject498) ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphManagedAppProtectionTargetAppsRequest {
	r.inlineObject498 = &inlineObject498
	return r
}

func (r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphManagedAppProtectionTargetAppsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphManagedAppProtectionTargetAppsExecute(r)
}

/*
MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphManagedAppProtectionTargetApps Invoke action targetApps

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphManagedAppProtectionTargetAppsRequest
*/
func (a *MeActionsApiService) MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphManagedAppProtectionTargetApps(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphManagedAppProtectionTargetAppsRequest {
	return ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphManagedAppProtectionTargetAppsRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphManagedAppProtectionTargetAppsExecute(r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphManagedAppProtectionTargetAppsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphManagedAppProtectionTargetApps")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/lastSharedMethod/microsoft.graph.managedAppProtection/microsoft.graph.targetApps"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject498 == nil {
		return nil, reportError("inlineObject498 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject498
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphMobileAppContentFileCommitRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sharedInsightId string
	inlineObject499 *InlineObject499
}

func (r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphMobileAppContentFileCommitRequest) InlineObject499(inlineObject499 InlineObject499) ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphMobileAppContentFileCommitRequest {
	r.inlineObject499 = &inlineObject499
	return r
}

func (r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphMobileAppContentFileCommitRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphMobileAppContentFileCommitExecute(r)
}

/*
MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphMobileAppContentFileCommit Invoke action commit

Commits a file of a given app.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphMobileAppContentFileCommitRequest
*/
func (a *MeActionsApiService) MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphMobileAppContentFileCommit(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphMobileAppContentFileCommitRequest {
	return ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphMobileAppContentFileCommitRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphMobileAppContentFileCommitExecute(r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphMobileAppContentFileCommitRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphMobileAppContentFileCommit")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/lastSharedMethod/microsoft.graph.mobileAppContentFile/microsoft.graph.commit"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject499 == nil {
		return nil, reportError("inlineObject499 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject499
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphMobileAppContentFileRenewUploadRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sharedInsightId string
}


func (r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphMobileAppContentFileRenewUploadRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphMobileAppContentFileRenewUploadExecute(r)
}

/*
MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphMobileAppContentFileRenewUpload Invoke action renewUpload

Renews the SAS URI for an application file upload.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphMobileAppContentFileRenewUploadRequest
*/
func (a *MeActionsApiService) MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphMobileAppContentFileRenewUpload(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphMobileAppContentFileRenewUploadRequest {
	return ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphMobileAppContentFileRenewUploadRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphMobileAppContentFileRenewUploadExecute(r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphMobileAppContentFileRenewUploadRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphMobileAppContentFileRenewUpload")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/lastSharedMethod/microsoft.graph.mobileAppContentFile/microsoft.graph.renewUpload"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintDocumentCreateUploadSessionRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sharedInsightId string
	inlineObject500 *InlineObject500
}

func (r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintDocumentCreateUploadSessionRequest) InlineObject500(inlineObject500 InlineObject500) ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintDocumentCreateUploadSessionRequest {
	r.inlineObject500 = &inlineObject500
	return r
}

func (r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintDocumentCreateUploadSessionRequest) Execute() (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintDocumentCreateUploadSessionExecute(r)
}

/*
MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintDocumentCreateUploadSession Invoke action createUploadSession

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintDocumentCreateUploadSessionRequest
*/
func (a *MeActionsApiService) MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintDocumentCreateUploadSession(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintDocumentCreateUploadSessionRequest {
	return ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintDocumentCreateUploadSessionRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphUploadSession
func (a *MeActionsApiService) MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintDocumentCreateUploadSessionExecute(r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintDocumentCreateUploadSessionRequest) (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphUploadSession
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintDocumentCreateUploadSession")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/lastSharedMethod/microsoft.graph.printDocument/microsoft.graph.createUploadSession"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject500 == nil {
		return localVarReturnValue, nil, reportError("inlineObject500 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject500
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobAbortRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sharedInsightId string
	inlineObject501 *InlineObject501
}

func (r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobAbortRequest) InlineObject501(inlineObject501 InlineObject501) ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobAbortRequest {
	r.inlineObject501 = &inlineObject501
	return r
}

func (r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobAbortRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobAbortExecute(r)
}

/*
MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobAbort Invoke action abort

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobAbortRequest
*/
func (a *MeActionsApiService) MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobAbort(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobAbortRequest {
	return ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobAbortRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobAbortExecute(r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobAbortRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobAbort")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/lastSharedMethod/microsoft.graph.printJob/microsoft.graph.abort"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject501 == nil {
		return nil, reportError("inlineObject501 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject501
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobCancelRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sharedInsightId string
}


func (r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobCancelExecute(r)
}

/*
MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobCancelRequest
*/
func (a *MeActionsApiService) MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobCancel(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobCancelRequest {
	return ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobCancelRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobCancelExecute(r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/lastSharedMethod/microsoft.graph.printJob/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobRedirectRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sharedInsightId string
	inlineObject502 *InlineObject502
}

func (r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobRedirectRequest) InlineObject502(inlineObject502 InlineObject502) ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobRedirectRequest {
	r.inlineObject502 = &inlineObject502
	return r
}

func (r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobRedirectRequest) Execute() (AnyOfmicrosoftGraphPrintJob, *_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobRedirectExecute(r)
}

/*
MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobRedirect Invoke action redirect

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobRedirectRequest
*/
func (a *MeActionsApiService) MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobRedirect(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobRedirectRequest {
	return ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobRedirectRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphPrintJob
func (a *MeActionsApiService) MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobRedirectExecute(r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobRedirectRequest) (AnyOfmicrosoftGraphPrintJob, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphPrintJob
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobRedirect")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/lastSharedMethod/microsoft.graph.printJob/microsoft.graph.redirect"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject502 == nil {
		return localVarReturnValue, nil, reportError("inlineObject502 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject502
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobStartRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sharedInsightId string
}


func (r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobStartRequest) Execute() (AnyOfmicrosoftGraphPrintJobStatus, *_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobStartExecute(r)
}

/*
MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobStart Invoke action start

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobStartRequest
*/
func (a *MeActionsApiService) MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobStart(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobStartRequest {
	return ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobStartRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphPrintJobStatus
func (a *MeActionsApiService) MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobStartExecute(r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobStartRequest) (AnyOfmicrosoftGraphPrintJobStatus, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphPrintJobStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphPrintJobStart")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/lastSharedMethod/microsoft.graph.printJob/microsoft.graph.start"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestApproveRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sharedInsightId string
	inlineObject503 *InlineObject503
}

func (r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestApproveRequest) InlineObject503(inlineObject503 InlineObject503) ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestApproveRequest {
	r.inlineObject503 = &inlineObject503
	return r
}

func (r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestApproveRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestApproveExecute(r)
}

/*
MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestApprove Invoke action approve

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestApproveRequest
*/
func (a *MeActionsApiService) MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestApprove(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestApproveRequest {
	return ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestApproveRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestApproveExecute(r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestApproveRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestApprove")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/lastSharedMethod/microsoft.graph.scheduleChangeRequest/microsoft.graph.approve"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject503 == nil {
		return nil, reportError("inlineObject503 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject503
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestDeclineRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sharedInsightId string
	inlineObject504 *InlineObject504
}

func (r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestDeclineRequest) InlineObject504(inlineObject504 InlineObject504) ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestDeclineRequest {
	r.inlineObject504 = &inlineObject504
	return r
}

func (r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestDeclineExecute(r)
}

/*
MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestDeclineRequest
*/
func (a *MeActionsApiService) MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestDecline(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestDeclineRequest {
	return ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestDeclineRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestDeclineExecute(r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphScheduleChangeRequestDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/lastSharedMethod/microsoft.graph.scheduleChangeRequest/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject504 == nil {
		return nil, reportError("inlineObject504 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject504
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionAssignRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sharedInsightId string
	inlineObject505 *InlineObject505
}

func (r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionAssignRequest) InlineObject505(inlineObject505 InlineObject505) ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionAssignRequest {
	r.inlineObject505 = &inlineObject505
	return r
}

func (r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionAssignRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionAssignExecute(r)
}

/*
MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionAssign Invoke action assign

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionAssignRequest
*/
func (a *MeActionsApiService) MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionAssign(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionAssignRequest {
	return ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionAssignRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionAssignExecute(r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionAssignRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionAssign")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/lastSharedMethod/microsoft.graph.targetedManagedAppProtection/microsoft.graph.assign"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject505 == nil {
		return nil, reportError("inlineObject505 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject505
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sharedInsightId string
	inlineObject506 *InlineObject506
}

func (r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest) InlineObject506(inlineObject506 InlineObject506) ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest {
	r.inlineObject506 = &inlineObject506
	return r
}

func (r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionTargetAppsExecute(r)
}

/*
MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionTargetApps Invoke action targetApps

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest
*/
func (a *MeActionsApiService) MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionTargetApps(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest {
	return ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionTargetAppsExecute(r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphTargetedManagedAppProtectionTargetApps")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/lastSharedMethod/microsoft.graph.targetedManagedAppProtection/microsoft.graph.targetApps"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject506 == nil {
		return nil, reportError("inlineObject506 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject506
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWindowsInformationProtectionAssignRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sharedInsightId string
	inlineObject507 *InlineObject507
}

func (r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWindowsInformationProtectionAssignRequest) InlineObject507(inlineObject507 InlineObject507) ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWindowsInformationProtectionAssignRequest {
	r.inlineObject507 = &inlineObject507
	return r
}

func (r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWindowsInformationProtectionAssignRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWindowsInformationProtectionAssignExecute(r)
}

/*
MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWindowsInformationProtectionAssign Invoke action assign

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWindowsInformationProtectionAssignRequest
*/
func (a *MeActionsApiService) MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWindowsInformationProtectionAssign(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWindowsInformationProtectionAssignRequest {
	return ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWindowsInformationProtectionAssignRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWindowsInformationProtectionAssignExecute(r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWindowsInformationProtectionAssignRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWindowsInformationProtectionAssign")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/lastSharedMethod/microsoft.graph.windowsInformationProtection/microsoft.graph.assign"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject507 == nil {
		return nil, reportError("inlineObject507 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject507
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeClearRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sharedInsightId string
	inlineObject508 *InlineObject508
}

func (r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeClearRequest) InlineObject508(inlineObject508 InlineObject508) ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeClearRequest {
	r.inlineObject508 = &inlineObject508
	return r
}

func (r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeClearRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeClearExecute(r)
}

/*
MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeClear Invoke action clear

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeClearRequest
*/
func (a *MeActionsApiService) MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeClear(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeClearRequest {
	return ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeClearRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeClearExecute(r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeClearRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeClear")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/lastSharedMethod/microsoft.graph.workbookRange/microsoft.graph.clear"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject508 == nil {
		return nil, reportError("inlineObject508 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject508
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeDeleteRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sharedInsightId string
	inlineObject509 *InlineObject509
}

func (r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeDeleteRequest) InlineObject509(inlineObject509 InlineObject509) ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeDeleteRequest {
	r.inlineObject509 = &inlineObject509
	return r
}

func (r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeDeleteExecute(r)
}

/*
MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeDelete Invoke action delete

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeDeleteRequest
*/
func (a *MeActionsApiService) MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeDelete(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeDeleteRequest {
	return ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeDeleteRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeDeleteExecute(r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/lastSharedMethod/microsoft.graph.workbookRange/microsoft.graph.delete"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject509 == nil {
		return nil, reportError("inlineObject509 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject509
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFillClearRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sharedInsightId string
}


func (r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFillClearRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFillClearExecute(r)
}

/*
MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFillClear Invoke action clear

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFillClearRequest
*/
func (a *MeActionsApiService) MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFillClear(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFillClearRequest {
	return ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFillClearRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFillClearExecute(r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFillClearRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFillClear")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/lastSharedMethod/microsoft.graph.workbookRangeFill/microsoft.graph.clear"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFormatAutofitColumnsRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sharedInsightId string
}


func (r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFormatAutofitColumnsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFormatAutofitColumnsExecute(r)
}

/*
MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFormatAutofitColumns Invoke action autofitColumns

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFormatAutofitColumnsRequest
*/
func (a *MeActionsApiService) MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFormatAutofitColumns(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFormatAutofitColumnsRequest {
	return ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFormatAutofitColumnsRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFormatAutofitColumnsExecute(r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFormatAutofitColumnsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFormatAutofitColumns")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/lastSharedMethod/microsoft.graph.workbookRangeFormat/microsoft.graph.autofitColumns"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFormatAutofitRowsRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sharedInsightId string
}


func (r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFormatAutofitRowsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFormatAutofitRowsExecute(r)
}

/*
MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFormatAutofitRows Invoke action autofitRows

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFormatAutofitRowsRequest
*/
func (a *MeActionsApiService) MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFormatAutofitRows(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFormatAutofitRowsRequest {
	return ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFormatAutofitRowsRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFormatAutofitRowsExecute(r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFormatAutofitRowsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeFormatAutofitRows")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/lastSharedMethod/microsoft.graph.workbookRangeFormat/microsoft.graph.autofitRows"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeInsertRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sharedInsightId string
	inlineObject510 *InlineObject510
}

func (r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeInsertRequest) InlineObject510(inlineObject510 InlineObject510) ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeInsertRequest {
	r.inlineObject510 = &inlineObject510
	return r
}

func (r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeInsertRequest) Execute() (AnyOfmicrosoftGraphWorkbookRange, *_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeInsertExecute(r)
}

/*
MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeInsert Invoke action insert

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeInsertRequest
*/
func (a *MeActionsApiService) MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeInsert(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeInsertRequest {
	return ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeInsertRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphWorkbookRange
func (a *MeActionsApiService) MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeInsertExecute(r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeInsertRequest) (AnyOfmicrosoftGraphWorkbookRange, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphWorkbookRange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeInsert")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/lastSharedMethod/microsoft.graph.workbookRange/microsoft.graph.insert"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject510 == nil {
		return localVarReturnValue, nil, reportError("inlineObject510 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject510
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeMergeRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sharedInsightId string
	inlineObject511 *InlineObject511
}

func (r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeMergeRequest) InlineObject511(inlineObject511 InlineObject511) ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeMergeRequest {
	r.inlineObject511 = &inlineObject511
	return r
}

func (r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeMergeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeMergeExecute(r)
}

/*
MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeMerge Invoke action merge

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeMergeRequest
*/
func (a *MeActionsApiService) MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeMerge(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeMergeRequest {
	return ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeMergeRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeMergeExecute(r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeMergeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeMerge")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/lastSharedMethod/microsoft.graph.workbookRange/microsoft.graph.merge"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject511 == nil {
		return nil, reportError("inlineObject511 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject511
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeSortApplyRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sharedInsightId string
	inlineObject512 *InlineObject512
}

func (r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeSortApplyRequest) InlineObject512(inlineObject512 InlineObject512) ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeSortApplyRequest {
	r.inlineObject512 = &inlineObject512
	return r
}

func (r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeSortApplyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeSortApplyExecute(r)
}

/*
MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeSortApply Invoke action apply

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeSortApplyRequest
*/
func (a *MeActionsApiService) MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeSortApply(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeSortApplyRequest {
	return ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeSortApplyRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeSortApplyExecute(r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeSortApplyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeSortApply")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/lastSharedMethod/microsoft.graph.workbookRangeSort/microsoft.graph.apply"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject512 == nil {
		return nil, reportError("inlineObject512 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject512
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeUnmergeRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sharedInsightId string
}


func (r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeUnmergeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeUnmergeExecute(r)
}

/*
MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeUnmerge Invoke action unmerge

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeUnmergeRequest
*/
func (a *MeActionsApiService) MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeUnmerge(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeUnmergeRequest {
	return ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeUnmergeRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeUnmergeExecute(r ApiMeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeUnmergeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsSharedSharedInsightLastSharedMethodMicrosoftGraphWorkbookRangeUnmerge")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/lastSharedMethod/microsoft.graph.workbookRange/microsoft.graph.unmerge"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphCalendarSharingMessageAcceptRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sharedInsightId string
}


func (r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphCalendarSharingMessageAcceptRequest) Execute() (MicrosoftGraphCalendar, *_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedSharedInsightResourceMicrosoftGraphCalendarSharingMessageAcceptExecute(r)
}

/*
MeInsightsSharedSharedInsightResourceMicrosoftGraphCalendarSharingMessageAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphCalendarSharingMessageAcceptRequest
*/
func (a *MeActionsApiService) MeInsightsSharedSharedInsightResourceMicrosoftGraphCalendarSharingMessageAccept(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphCalendarSharingMessageAcceptRequest {
	return ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphCalendarSharingMessageAcceptRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphCalendar
func (a *MeActionsApiService) MeInsightsSharedSharedInsightResourceMicrosoftGraphCalendarSharingMessageAcceptExecute(r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphCalendarSharingMessageAcceptRequest) (MicrosoftGraphCalendar, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphCalendar
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsSharedSharedInsightResourceMicrosoftGraphCalendarSharingMessageAccept")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/resource/microsoft.graph.calendarSharingMessage/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphManagedAppProtectionTargetAppsRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sharedInsightId string
	inlineObject513 *InlineObject513
}

func (r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphManagedAppProtectionTargetAppsRequest) InlineObject513(inlineObject513 InlineObject513) ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphManagedAppProtectionTargetAppsRequest {
	r.inlineObject513 = &inlineObject513
	return r
}

func (r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphManagedAppProtectionTargetAppsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedSharedInsightResourceMicrosoftGraphManagedAppProtectionTargetAppsExecute(r)
}

/*
MeInsightsSharedSharedInsightResourceMicrosoftGraphManagedAppProtectionTargetApps Invoke action targetApps

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphManagedAppProtectionTargetAppsRequest
*/
func (a *MeActionsApiService) MeInsightsSharedSharedInsightResourceMicrosoftGraphManagedAppProtectionTargetApps(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphManagedAppProtectionTargetAppsRequest {
	return ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphManagedAppProtectionTargetAppsRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsSharedSharedInsightResourceMicrosoftGraphManagedAppProtectionTargetAppsExecute(r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphManagedAppProtectionTargetAppsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsSharedSharedInsightResourceMicrosoftGraphManagedAppProtectionTargetApps")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/resource/microsoft.graph.managedAppProtection/microsoft.graph.targetApps"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject513 == nil {
		return nil, reportError("inlineObject513 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject513
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphMobileAppContentFileCommitRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sharedInsightId string
	inlineObject514 *InlineObject514
}

func (r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphMobileAppContentFileCommitRequest) InlineObject514(inlineObject514 InlineObject514) ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphMobileAppContentFileCommitRequest {
	r.inlineObject514 = &inlineObject514
	return r
}

func (r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphMobileAppContentFileCommitRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedSharedInsightResourceMicrosoftGraphMobileAppContentFileCommitExecute(r)
}

/*
MeInsightsSharedSharedInsightResourceMicrosoftGraphMobileAppContentFileCommit Invoke action commit

Commits a file of a given app.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphMobileAppContentFileCommitRequest
*/
func (a *MeActionsApiService) MeInsightsSharedSharedInsightResourceMicrosoftGraphMobileAppContentFileCommit(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphMobileAppContentFileCommitRequest {
	return ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphMobileAppContentFileCommitRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsSharedSharedInsightResourceMicrosoftGraphMobileAppContentFileCommitExecute(r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphMobileAppContentFileCommitRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsSharedSharedInsightResourceMicrosoftGraphMobileAppContentFileCommit")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/resource/microsoft.graph.mobileAppContentFile/microsoft.graph.commit"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject514 == nil {
		return nil, reportError("inlineObject514 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject514
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphMobileAppContentFileRenewUploadRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sharedInsightId string
}


func (r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphMobileAppContentFileRenewUploadRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedSharedInsightResourceMicrosoftGraphMobileAppContentFileRenewUploadExecute(r)
}

/*
MeInsightsSharedSharedInsightResourceMicrosoftGraphMobileAppContentFileRenewUpload Invoke action renewUpload

Renews the SAS URI for an application file upload.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphMobileAppContentFileRenewUploadRequest
*/
func (a *MeActionsApiService) MeInsightsSharedSharedInsightResourceMicrosoftGraphMobileAppContentFileRenewUpload(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphMobileAppContentFileRenewUploadRequest {
	return ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphMobileAppContentFileRenewUploadRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsSharedSharedInsightResourceMicrosoftGraphMobileAppContentFileRenewUploadExecute(r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphMobileAppContentFileRenewUploadRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsSharedSharedInsightResourceMicrosoftGraphMobileAppContentFileRenewUpload")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/resource/microsoft.graph.mobileAppContentFile/microsoft.graph.renewUpload"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSessionRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sharedInsightId string
	inlineObject515 *InlineObject515
}

func (r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSessionRequest) InlineObject515(inlineObject515 InlineObject515) ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSessionRequest {
	r.inlineObject515 = &inlineObject515
	return r
}

func (r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSessionRequest) Execute() (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedSharedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSessionExecute(r)
}

/*
MeInsightsSharedSharedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSession Invoke action createUploadSession

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSessionRequest
*/
func (a *MeActionsApiService) MeInsightsSharedSharedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSession(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSessionRequest {
	return ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSessionRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphUploadSession
func (a *MeActionsApiService) MeInsightsSharedSharedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSessionExecute(r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSessionRequest) (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphUploadSession
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsSharedSharedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSession")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/resource/microsoft.graph.printDocument/microsoft.graph.createUploadSession"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject515 == nil {
		return localVarReturnValue, nil, reportError("inlineObject515 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject515
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobAbortRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sharedInsightId string
	inlineObject516 *InlineObject516
}

func (r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobAbortRequest) InlineObject516(inlineObject516 InlineObject516) ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobAbortRequest {
	r.inlineObject516 = &inlineObject516
	return r
}

func (r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobAbortRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobAbortExecute(r)
}

/*
MeInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobAbort Invoke action abort

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobAbortRequest
*/
func (a *MeActionsApiService) MeInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobAbort(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobAbortRequest {
	return ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobAbortRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobAbortExecute(r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobAbortRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobAbort")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/resource/microsoft.graph.printJob/microsoft.graph.abort"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject516 == nil {
		return nil, reportError("inlineObject516 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject516
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobCancelRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sharedInsightId string
}


func (r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobCancelExecute(r)
}

/*
MeInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobCancelRequest
*/
func (a *MeActionsApiService) MeInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobCancel(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobCancelRequest {
	return ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobCancelRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobCancelExecute(r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/resource/microsoft.graph.printJob/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobRedirectRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sharedInsightId string
	inlineObject517 *InlineObject517
}

func (r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobRedirectRequest) InlineObject517(inlineObject517 InlineObject517) ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobRedirectRequest {
	r.inlineObject517 = &inlineObject517
	return r
}

func (r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobRedirectRequest) Execute() (AnyOfmicrosoftGraphPrintJob, *_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobRedirectExecute(r)
}

/*
MeInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobRedirect Invoke action redirect

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobRedirectRequest
*/
func (a *MeActionsApiService) MeInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobRedirect(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobRedirectRequest {
	return ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobRedirectRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphPrintJob
func (a *MeActionsApiService) MeInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobRedirectExecute(r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobRedirectRequest) (AnyOfmicrosoftGraphPrintJob, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphPrintJob
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobRedirect")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/resource/microsoft.graph.printJob/microsoft.graph.redirect"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject517 == nil {
		return localVarReturnValue, nil, reportError("inlineObject517 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject517
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobStartRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sharedInsightId string
}


func (r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobStartRequest) Execute() (AnyOfmicrosoftGraphPrintJobStatus, *_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobStartExecute(r)
}

/*
MeInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobStart Invoke action start

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobStartRequest
*/
func (a *MeActionsApiService) MeInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobStart(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobStartRequest {
	return ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobStartRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphPrintJobStatus
func (a *MeActionsApiService) MeInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobStartExecute(r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobStartRequest) (AnyOfmicrosoftGraphPrintJobStatus, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphPrintJobStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsSharedSharedInsightResourceMicrosoftGraphPrintJobStart")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/resource/microsoft.graph.printJob/microsoft.graph.start"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestApproveRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sharedInsightId string
	inlineObject518 *InlineObject518
}

func (r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestApproveRequest) InlineObject518(inlineObject518 InlineObject518) ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestApproveRequest {
	r.inlineObject518 = &inlineObject518
	return r
}

func (r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestApproveRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestApproveExecute(r)
}

/*
MeInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestApprove Invoke action approve

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestApproveRequest
*/
func (a *MeActionsApiService) MeInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestApprove(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestApproveRequest {
	return ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestApproveRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestApproveExecute(r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestApproveRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestApprove")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/resource/microsoft.graph.scheduleChangeRequest/microsoft.graph.approve"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject518 == nil {
		return nil, reportError("inlineObject518 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject518
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestDeclineRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sharedInsightId string
	inlineObject519 *InlineObject519
}

func (r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestDeclineRequest) InlineObject519(inlineObject519 InlineObject519) ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestDeclineRequest {
	r.inlineObject519 = &inlineObject519
	return r
}

func (r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestDeclineExecute(r)
}

/*
MeInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestDeclineRequest
*/
func (a *MeActionsApiService) MeInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestDecline(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestDeclineRequest {
	return ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestDeclineRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestDeclineExecute(r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsSharedSharedInsightResourceMicrosoftGraphScheduleChangeRequestDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/resource/microsoft.graph.scheduleChangeRequest/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject519 == nil {
		return nil, reportError("inlineObject519 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject519
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssignRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sharedInsightId string
	inlineObject520 *InlineObject520
}

func (r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssignRequest) InlineObject520(inlineObject520 InlineObject520) ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssignRequest {
	r.inlineObject520 = &inlineObject520
	return r
}

func (r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssignRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssignExecute(r)
}

/*
MeInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssign Invoke action assign

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssignRequest
*/
func (a *MeActionsApiService) MeInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssign(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssignRequest {
	return ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssignRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssignExecute(r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssignRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssign")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/resource/microsoft.graph.targetedManagedAppProtection/microsoft.graph.assign"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject520 == nil {
		return nil, reportError("inlineObject520 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject520
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sharedInsightId string
	inlineObject521 *InlineObject521
}

func (r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest) InlineObject521(inlineObject521 InlineObject521) ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest {
	r.inlineObject521 = &inlineObject521
	return r
}

func (r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsExecute(r)
}

/*
MeInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetApps Invoke action targetApps

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest
*/
func (a *MeActionsApiService) MeInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetApps(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest {
	return ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsExecute(r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsSharedSharedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetApps")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/resource/microsoft.graph.targetedManagedAppProtection/microsoft.graph.targetApps"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject521 == nil {
		return nil, reportError("inlineObject521 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject521
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWindowsInformationProtectionAssignRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sharedInsightId string
	inlineObject522 *InlineObject522
}

func (r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWindowsInformationProtectionAssignRequest) InlineObject522(inlineObject522 InlineObject522) ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWindowsInformationProtectionAssignRequest {
	r.inlineObject522 = &inlineObject522
	return r
}

func (r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWindowsInformationProtectionAssignRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedSharedInsightResourceMicrosoftGraphWindowsInformationProtectionAssignExecute(r)
}

/*
MeInsightsSharedSharedInsightResourceMicrosoftGraphWindowsInformationProtectionAssign Invoke action assign

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWindowsInformationProtectionAssignRequest
*/
func (a *MeActionsApiService) MeInsightsSharedSharedInsightResourceMicrosoftGraphWindowsInformationProtectionAssign(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWindowsInformationProtectionAssignRequest {
	return ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWindowsInformationProtectionAssignRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsSharedSharedInsightResourceMicrosoftGraphWindowsInformationProtectionAssignExecute(r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWindowsInformationProtectionAssignRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsSharedSharedInsightResourceMicrosoftGraphWindowsInformationProtectionAssign")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/resource/microsoft.graph.windowsInformationProtection/microsoft.graph.assign"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject522 == nil {
		return nil, reportError("inlineObject522 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject522
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeClearRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sharedInsightId string
	inlineObject523 *InlineObject523
}

func (r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeClearRequest) InlineObject523(inlineObject523 InlineObject523) ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeClearRequest {
	r.inlineObject523 = &inlineObject523
	return r
}

func (r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeClearRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeClearExecute(r)
}

/*
MeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeClear Invoke action clear

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeClearRequest
*/
func (a *MeActionsApiService) MeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeClear(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeClearRequest {
	return ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeClearRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeClearExecute(r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeClearRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeClear")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/resource/microsoft.graph.workbookRange/microsoft.graph.clear"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject523 == nil {
		return nil, reportError("inlineObject523 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject523
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeDeleteRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sharedInsightId string
	inlineObject524 *InlineObject524
}

func (r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeDeleteRequest) InlineObject524(inlineObject524 InlineObject524) ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeDeleteRequest {
	r.inlineObject524 = &inlineObject524
	return r
}

func (r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeDeleteExecute(r)
}

/*
MeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeDelete Invoke action delete

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeDeleteRequest
*/
func (a *MeActionsApiService) MeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeDelete(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeDeleteRequest {
	return ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeDeleteRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeDeleteExecute(r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/resource/microsoft.graph.workbookRange/microsoft.graph.delete"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject524 == nil {
		return nil, reportError("inlineObject524 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject524
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFillClearRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sharedInsightId string
}


func (r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFillClearRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFillClearExecute(r)
}

/*
MeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFillClear Invoke action clear

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFillClearRequest
*/
func (a *MeActionsApiService) MeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFillClear(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFillClearRequest {
	return ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFillClearRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFillClearExecute(r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFillClearRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFillClear")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/resource/microsoft.graph.workbookRangeFill/microsoft.graph.clear"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitColumnsRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sharedInsightId string
}


func (r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitColumnsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitColumnsExecute(r)
}

/*
MeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitColumns Invoke action autofitColumns

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitColumnsRequest
*/
func (a *MeActionsApiService) MeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitColumns(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitColumnsRequest {
	return ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitColumnsRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitColumnsExecute(r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitColumnsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitColumns")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/resource/microsoft.graph.workbookRangeFormat/microsoft.graph.autofitColumns"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitRowsRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sharedInsightId string
}


func (r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitRowsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitRowsExecute(r)
}

/*
MeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitRows Invoke action autofitRows

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitRowsRequest
*/
func (a *MeActionsApiService) MeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitRows(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitRowsRequest {
	return ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitRowsRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitRowsExecute(r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitRowsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitRows")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/resource/microsoft.graph.workbookRangeFormat/microsoft.graph.autofitRows"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeInsertRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sharedInsightId string
	inlineObject525 *InlineObject525
}

func (r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeInsertRequest) InlineObject525(inlineObject525 InlineObject525) ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeInsertRequest {
	r.inlineObject525 = &inlineObject525
	return r
}

func (r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeInsertRequest) Execute() (AnyOfmicrosoftGraphWorkbookRange, *_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeInsertExecute(r)
}

/*
MeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeInsert Invoke action insert

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeInsertRequest
*/
func (a *MeActionsApiService) MeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeInsert(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeInsertRequest {
	return ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeInsertRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphWorkbookRange
func (a *MeActionsApiService) MeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeInsertExecute(r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeInsertRequest) (AnyOfmicrosoftGraphWorkbookRange, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphWorkbookRange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeInsert")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/resource/microsoft.graph.workbookRange/microsoft.graph.insert"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject525 == nil {
		return localVarReturnValue, nil, reportError("inlineObject525 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject525
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeMergeRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sharedInsightId string
	inlineObject526 *InlineObject526
}

func (r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeMergeRequest) InlineObject526(inlineObject526 InlineObject526) ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeMergeRequest {
	r.inlineObject526 = &inlineObject526
	return r
}

func (r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeMergeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeMergeExecute(r)
}

/*
MeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeMerge Invoke action merge

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeMergeRequest
*/
func (a *MeActionsApiService) MeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeMerge(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeMergeRequest {
	return ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeMergeRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeMergeExecute(r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeMergeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeMerge")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/resource/microsoft.graph.workbookRange/microsoft.graph.merge"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject526 == nil {
		return nil, reportError("inlineObject526 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject526
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeSortApplyRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sharedInsightId string
	inlineObject527 *InlineObject527
}

func (r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeSortApplyRequest) InlineObject527(inlineObject527 InlineObject527) ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeSortApplyRequest {
	r.inlineObject527 = &inlineObject527
	return r
}

func (r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeSortApplyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeSortApplyExecute(r)
}

/*
MeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeSortApply Invoke action apply

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeSortApplyRequest
*/
func (a *MeActionsApiService) MeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeSortApply(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeSortApplyRequest {
	return ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeSortApplyRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeSortApplyExecute(r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeSortApplyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeSortApply")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/resource/microsoft.graph.workbookRangeSort/microsoft.graph.apply"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject527 == nil {
		return nil, reportError("inlineObject527 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject527
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeUnmergeRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sharedInsightId string
}


func (r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeUnmergeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeUnmergeExecute(r)
}

/*
MeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeUnmerge Invoke action unmerge

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sharedInsightId key: id of sharedInsight
 @return ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeUnmergeRequest
*/
func (a *MeActionsApiService) MeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeUnmerge(ctx _context.Context, sharedInsightId string) ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeUnmergeRequest {
	return ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeUnmergeRequest{
		ApiService: a,
		ctx: ctx,
		sharedInsightId: sharedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeUnmergeExecute(r ApiMeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeUnmergeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsSharedSharedInsightResourceMicrosoftGraphWorkbookRangeUnmerge")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/shared/{sharedInsight-id}/resource/microsoft.graph.workbookRange/microsoft.graph.unmerge"
	localVarPath = strings.Replace(localVarPath, "{"+"sharedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.sharedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsTrendingTrendingResourceMicrosoftGraphCalendarSharingMessageAcceptRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	trendingId string
}


func (r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphCalendarSharingMessageAcceptRequest) Execute() (MicrosoftGraphCalendar, *_nethttp.Response, error) {
	return r.ApiService.MeInsightsTrendingTrendingResourceMicrosoftGraphCalendarSharingMessageAcceptExecute(r)
}

/*
MeInsightsTrendingTrendingResourceMicrosoftGraphCalendarSharingMessageAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param trendingId key: id of trending
 @return ApiMeInsightsTrendingTrendingResourceMicrosoftGraphCalendarSharingMessageAcceptRequest
*/
func (a *MeActionsApiService) MeInsightsTrendingTrendingResourceMicrosoftGraphCalendarSharingMessageAccept(ctx _context.Context, trendingId string) ApiMeInsightsTrendingTrendingResourceMicrosoftGraphCalendarSharingMessageAcceptRequest {
	return ApiMeInsightsTrendingTrendingResourceMicrosoftGraphCalendarSharingMessageAcceptRequest{
		ApiService: a,
		ctx: ctx,
		trendingId: trendingId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphCalendar
func (a *MeActionsApiService) MeInsightsTrendingTrendingResourceMicrosoftGraphCalendarSharingMessageAcceptExecute(r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphCalendarSharingMessageAcceptRequest) (MicrosoftGraphCalendar, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphCalendar
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsTrendingTrendingResourceMicrosoftGraphCalendarSharingMessageAccept")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/trending/{trending-id}/resource/microsoft.graph.calendarSharingMessage/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeInsightsTrendingTrendingResourceMicrosoftGraphManagedAppProtectionTargetAppsRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	trendingId string
	inlineObject528 *InlineObject528
}

func (r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphManagedAppProtectionTargetAppsRequest) InlineObject528(inlineObject528 InlineObject528) ApiMeInsightsTrendingTrendingResourceMicrosoftGraphManagedAppProtectionTargetAppsRequest {
	r.inlineObject528 = &inlineObject528
	return r
}

func (r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphManagedAppProtectionTargetAppsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsTrendingTrendingResourceMicrosoftGraphManagedAppProtectionTargetAppsExecute(r)
}

/*
MeInsightsTrendingTrendingResourceMicrosoftGraphManagedAppProtectionTargetApps Invoke action targetApps

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param trendingId key: id of trending
 @return ApiMeInsightsTrendingTrendingResourceMicrosoftGraphManagedAppProtectionTargetAppsRequest
*/
func (a *MeActionsApiService) MeInsightsTrendingTrendingResourceMicrosoftGraphManagedAppProtectionTargetApps(ctx _context.Context, trendingId string) ApiMeInsightsTrendingTrendingResourceMicrosoftGraphManagedAppProtectionTargetAppsRequest {
	return ApiMeInsightsTrendingTrendingResourceMicrosoftGraphManagedAppProtectionTargetAppsRequest{
		ApiService: a,
		ctx: ctx,
		trendingId: trendingId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsTrendingTrendingResourceMicrosoftGraphManagedAppProtectionTargetAppsExecute(r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphManagedAppProtectionTargetAppsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsTrendingTrendingResourceMicrosoftGraphManagedAppProtectionTargetApps")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/trending/{trending-id}/resource/microsoft.graph.managedAppProtection/microsoft.graph.targetApps"
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject528 == nil {
		return nil, reportError("inlineObject528 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject528
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsTrendingTrendingResourceMicrosoftGraphMobileAppContentFileCommitRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	trendingId string
	inlineObject529 *InlineObject529
}

func (r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphMobileAppContentFileCommitRequest) InlineObject529(inlineObject529 InlineObject529) ApiMeInsightsTrendingTrendingResourceMicrosoftGraphMobileAppContentFileCommitRequest {
	r.inlineObject529 = &inlineObject529
	return r
}

func (r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphMobileAppContentFileCommitRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsTrendingTrendingResourceMicrosoftGraphMobileAppContentFileCommitExecute(r)
}

/*
MeInsightsTrendingTrendingResourceMicrosoftGraphMobileAppContentFileCommit Invoke action commit

Commits a file of a given app.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param trendingId key: id of trending
 @return ApiMeInsightsTrendingTrendingResourceMicrosoftGraphMobileAppContentFileCommitRequest
*/
func (a *MeActionsApiService) MeInsightsTrendingTrendingResourceMicrosoftGraphMobileAppContentFileCommit(ctx _context.Context, trendingId string) ApiMeInsightsTrendingTrendingResourceMicrosoftGraphMobileAppContentFileCommitRequest {
	return ApiMeInsightsTrendingTrendingResourceMicrosoftGraphMobileAppContentFileCommitRequest{
		ApiService: a,
		ctx: ctx,
		trendingId: trendingId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsTrendingTrendingResourceMicrosoftGraphMobileAppContentFileCommitExecute(r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphMobileAppContentFileCommitRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsTrendingTrendingResourceMicrosoftGraphMobileAppContentFileCommit")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/trending/{trending-id}/resource/microsoft.graph.mobileAppContentFile/microsoft.graph.commit"
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject529 == nil {
		return nil, reportError("inlineObject529 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject529
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsTrendingTrendingResourceMicrosoftGraphMobileAppContentFileRenewUploadRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	trendingId string
}


func (r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphMobileAppContentFileRenewUploadRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsTrendingTrendingResourceMicrosoftGraphMobileAppContentFileRenewUploadExecute(r)
}

/*
MeInsightsTrendingTrendingResourceMicrosoftGraphMobileAppContentFileRenewUpload Invoke action renewUpload

Renews the SAS URI for an application file upload.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param trendingId key: id of trending
 @return ApiMeInsightsTrendingTrendingResourceMicrosoftGraphMobileAppContentFileRenewUploadRequest
*/
func (a *MeActionsApiService) MeInsightsTrendingTrendingResourceMicrosoftGraphMobileAppContentFileRenewUpload(ctx _context.Context, trendingId string) ApiMeInsightsTrendingTrendingResourceMicrosoftGraphMobileAppContentFileRenewUploadRequest {
	return ApiMeInsightsTrendingTrendingResourceMicrosoftGraphMobileAppContentFileRenewUploadRequest{
		ApiService: a,
		ctx: ctx,
		trendingId: trendingId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsTrendingTrendingResourceMicrosoftGraphMobileAppContentFileRenewUploadExecute(r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphMobileAppContentFileRenewUploadRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsTrendingTrendingResourceMicrosoftGraphMobileAppContentFileRenewUpload")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/trending/{trending-id}/resource/microsoft.graph.mobileAppContentFile/microsoft.graph.renewUpload"
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsTrendingTrendingResourceMicrosoftGraphPrintDocumentCreateUploadSessionRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	trendingId string
	inlineObject530 *InlineObject530
}

func (r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphPrintDocumentCreateUploadSessionRequest) InlineObject530(inlineObject530 InlineObject530) ApiMeInsightsTrendingTrendingResourceMicrosoftGraphPrintDocumentCreateUploadSessionRequest {
	r.inlineObject530 = &inlineObject530
	return r
}

func (r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphPrintDocumentCreateUploadSessionRequest) Execute() (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	return r.ApiService.MeInsightsTrendingTrendingResourceMicrosoftGraphPrintDocumentCreateUploadSessionExecute(r)
}

/*
MeInsightsTrendingTrendingResourceMicrosoftGraphPrintDocumentCreateUploadSession Invoke action createUploadSession

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param trendingId key: id of trending
 @return ApiMeInsightsTrendingTrendingResourceMicrosoftGraphPrintDocumentCreateUploadSessionRequest
*/
func (a *MeActionsApiService) MeInsightsTrendingTrendingResourceMicrosoftGraphPrintDocumentCreateUploadSession(ctx _context.Context, trendingId string) ApiMeInsightsTrendingTrendingResourceMicrosoftGraphPrintDocumentCreateUploadSessionRequest {
	return ApiMeInsightsTrendingTrendingResourceMicrosoftGraphPrintDocumentCreateUploadSessionRequest{
		ApiService: a,
		ctx: ctx,
		trendingId: trendingId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphUploadSession
func (a *MeActionsApiService) MeInsightsTrendingTrendingResourceMicrosoftGraphPrintDocumentCreateUploadSessionExecute(r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphPrintDocumentCreateUploadSessionRequest) (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphUploadSession
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsTrendingTrendingResourceMicrosoftGraphPrintDocumentCreateUploadSession")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/trending/{trending-id}/resource/microsoft.graph.printDocument/microsoft.graph.createUploadSession"
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject530 == nil {
		return localVarReturnValue, nil, reportError("inlineObject530 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject530
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeInsightsTrendingTrendingResourceMicrosoftGraphPrintJobAbortRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	trendingId string
	inlineObject531 *InlineObject531
}

func (r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphPrintJobAbortRequest) InlineObject531(inlineObject531 InlineObject531) ApiMeInsightsTrendingTrendingResourceMicrosoftGraphPrintJobAbortRequest {
	r.inlineObject531 = &inlineObject531
	return r
}

func (r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphPrintJobAbortRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsTrendingTrendingResourceMicrosoftGraphPrintJobAbortExecute(r)
}

/*
MeInsightsTrendingTrendingResourceMicrosoftGraphPrintJobAbort Invoke action abort

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param trendingId key: id of trending
 @return ApiMeInsightsTrendingTrendingResourceMicrosoftGraphPrintJobAbortRequest
*/
func (a *MeActionsApiService) MeInsightsTrendingTrendingResourceMicrosoftGraphPrintJobAbort(ctx _context.Context, trendingId string) ApiMeInsightsTrendingTrendingResourceMicrosoftGraphPrintJobAbortRequest {
	return ApiMeInsightsTrendingTrendingResourceMicrosoftGraphPrintJobAbortRequest{
		ApiService: a,
		ctx: ctx,
		trendingId: trendingId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsTrendingTrendingResourceMicrosoftGraphPrintJobAbortExecute(r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphPrintJobAbortRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsTrendingTrendingResourceMicrosoftGraphPrintJobAbort")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/trending/{trending-id}/resource/microsoft.graph.printJob/microsoft.graph.abort"
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject531 == nil {
		return nil, reportError("inlineObject531 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject531
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsTrendingTrendingResourceMicrosoftGraphPrintJobCancelRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	trendingId string
}


func (r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphPrintJobCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsTrendingTrendingResourceMicrosoftGraphPrintJobCancelExecute(r)
}

/*
MeInsightsTrendingTrendingResourceMicrosoftGraphPrintJobCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param trendingId key: id of trending
 @return ApiMeInsightsTrendingTrendingResourceMicrosoftGraphPrintJobCancelRequest
*/
func (a *MeActionsApiService) MeInsightsTrendingTrendingResourceMicrosoftGraphPrintJobCancel(ctx _context.Context, trendingId string) ApiMeInsightsTrendingTrendingResourceMicrosoftGraphPrintJobCancelRequest {
	return ApiMeInsightsTrendingTrendingResourceMicrosoftGraphPrintJobCancelRequest{
		ApiService: a,
		ctx: ctx,
		trendingId: trendingId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsTrendingTrendingResourceMicrosoftGraphPrintJobCancelExecute(r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphPrintJobCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsTrendingTrendingResourceMicrosoftGraphPrintJobCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/trending/{trending-id}/resource/microsoft.graph.printJob/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsTrendingTrendingResourceMicrosoftGraphPrintJobRedirectRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	trendingId string
	inlineObject532 *InlineObject532
}

func (r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphPrintJobRedirectRequest) InlineObject532(inlineObject532 InlineObject532) ApiMeInsightsTrendingTrendingResourceMicrosoftGraphPrintJobRedirectRequest {
	r.inlineObject532 = &inlineObject532
	return r
}

func (r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphPrintJobRedirectRequest) Execute() (AnyOfmicrosoftGraphPrintJob, *_nethttp.Response, error) {
	return r.ApiService.MeInsightsTrendingTrendingResourceMicrosoftGraphPrintJobRedirectExecute(r)
}

/*
MeInsightsTrendingTrendingResourceMicrosoftGraphPrintJobRedirect Invoke action redirect

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param trendingId key: id of trending
 @return ApiMeInsightsTrendingTrendingResourceMicrosoftGraphPrintJobRedirectRequest
*/
func (a *MeActionsApiService) MeInsightsTrendingTrendingResourceMicrosoftGraphPrintJobRedirect(ctx _context.Context, trendingId string) ApiMeInsightsTrendingTrendingResourceMicrosoftGraphPrintJobRedirectRequest {
	return ApiMeInsightsTrendingTrendingResourceMicrosoftGraphPrintJobRedirectRequest{
		ApiService: a,
		ctx: ctx,
		trendingId: trendingId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphPrintJob
func (a *MeActionsApiService) MeInsightsTrendingTrendingResourceMicrosoftGraphPrintJobRedirectExecute(r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphPrintJobRedirectRequest) (AnyOfmicrosoftGraphPrintJob, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphPrintJob
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsTrendingTrendingResourceMicrosoftGraphPrintJobRedirect")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/trending/{trending-id}/resource/microsoft.graph.printJob/microsoft.graph.redirect"
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject532 == nil {
		return localVarReturnValue, nil, reportError("inlineObject532 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject532
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeInsightsTrendingTrendingResourceMicrosoftGraphPrintJobStartRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	trendingId string
}


func (r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphPrintJobStartRequest) Execute() (AnyOfmicrosoftGraphPrintJobStatus, *_nethttp.Response, error) {
	return r.ApiService.MeInsightsTrendingTrendingResourceMicrosoftGraphPrintJobStartExecute(r)
}

/*
MeInsightsTrendingTrendingResourceMicrosoftGraphPrintJobStart Invoke action start

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param trendingId key: id of trending
 @return ApiMeInsightsTrendingTrendingResourceMicrosoftGraphPrintJobStartRequest
*/
func (a *MeActionsApiService) MeInsightsTrendingTrendingResourceMicrosoftGraphPrintJobStart(ctx _context.Context, trendingId string) ApiMeInsightsTrendingTrendingResourceMicrosoftGraphPrintJobStartRequest {
	return ApiMeInsightsTrendingTrendingResourceMicrosoftGraphPrintJobStartRequest{
		ApiService: a,
		ctx: ctx,
		trendingId: trendingId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphPrintJobStatus
func (a *MeActionsApiService) MeInsightsTrendingTrendingResourceMicrosoftGraphPrintJobStartExecute(r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphPrintJobStartRequest) (AnyOfmicrosoftGraphPrintJobStatus, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphPrintJobStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsTrendingTrendingResourceMicrosoftGraphPrintJobStart")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/trending/{trending-id}/resource/microsoft.graph.printJob/microsoft.graph.start"
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestApproveRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	trendingId string
	inlineObject533 *InlineObject533
}

func (r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestApproveRequest) InlineObject533(inlineObject533 InlineObject533) ApiMeInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestApproveRequest {
	r.inlineObject533 = &inlineObject533
	return r
}

func (r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestApproveRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestApproveExecute(r)
}

/*
MeInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestApprove Invoke action approve

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param trendingId key: id of trending
 @return ApiMeInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestApproveRequest
*/
func (a *MeActionsApiService) MeInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestApprove(ctx _context.Context, trendingId string) ApiMeInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestApproveRequest {
	return ApiMeInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestApproveRequest{
		ApiService: a,
		ctx: ctx,
		trendingId: trendingId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestApproveExecute(r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestApproveRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestApprove")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/trending/{trending-id}/resource/microsoft.graph.scheduleChangeRequest/microsoft.graph.approve"
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject533 == nil {
		return nil, reportError("inlineObject533 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject533
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestDeclineRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	trendingId string
	inlineObject534 *InlineObject534
}

func (r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestDeclineRequest) InlineObject534(inlineObject534 InlineObject534) ApiMeInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestDeclineRequest {
	r.inlineObject534 = &inlineObject534
	return r
}

func (r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestDeclineExecute(r)
}

/*
MeInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param trendingId key: id of trending
 @return ApiMeInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestDeclineRequest
*/
func (a *MeActionsApiService) MeInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestDecline(ctx _context.Context, trendingId string) ApiMeInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestDeclineRequest {
	return ApiMeInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestDeclineRequest{
		ApiService: a,
		ctx: ctx,
		trendingId: trendingId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestDeclineExecute(r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsTrendingTrendingResourceMicrosoftGraphScheduleChangeRequestDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/trending/{trending-id}/resource/microsoft.graph.scheduleChangeRequest/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject534 == nil {
		return nil, reportError("inlineObject534 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject534
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionAssignRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	trendingId string
	inlineObject535 *InlineObject535
}

func (r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionAssignRequest) InlineObject535(inlineObject535 InlineObject535) ApiMeInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionAssignRequest {
	r.inlineObject535 = &inlineObject535
	return r
}

func (r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionAssignRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionAssignExecute(r)
}

/*
MeInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionAssign Invoke action assign

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param trendingId key: id of trending
 @return ApiMeInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionAssignRequest
*/
func (a *MeActionsApiService) MeInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionAssign(ctx _context.Context, trendingId string) ApiMeInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionAssignRequest {
	return ApiMeInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionAssignRequest{
		ApiService: a,
		ctx: ctx,
		trendingId: trendingId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionAssignExecute(r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionAssignRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionAssign")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/trending/{trending-id}/resource/microsoft.graph.targetedManagedAppProtection/microsoft.graph.assign"
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject535 == nil {
		return nil, reportError("inlineObject535 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject535
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	trendingId string
	inlineObject536 *InlineObject536
}

func (r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest) InlineObject536(inlineObject536 InlineObject536) ApiMeInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest {
	r.inlineObject536 = &inlineObject536
	return r
}

func (r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsExecute(r)
}

/*
MeInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionTargetApps Invoke action targetApps

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param trendingId key: id of trending
 @return ApiMeInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest
*/
func (a *MeActionsApiService) MeInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionTargetApps(ctx _context.Context, trendingId string) ApiMeInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest {
	return ApiMeInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest{
		ApiService: a,
		ctx: ctx,
		trendingId: trendingId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsExecute(r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsTrendingTrendingResourceMicrosoftGraphTargetedManagedAppProtectionTargetApps")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/trending/{trending-id}/resource/microsoft.graph.targetedManagedAppProtection/microsoft.graph.targetApps"
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject536 == nil {
		return nil, reportError("inlineObject536 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject536
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWindowsInformationProtectionAssignRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	trendingId string
	inlineObject537 *InlineObject537
}

func (r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWindowsInformationProtectionAssignRequest) InlineObject537(inlineObject537 InlineObject537) ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWindowsInformationProtectionAssignRequest {
	r.inlineObject537 = &inlineObject537
	return r
}

func (r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWindowsInformationProtectionAssignRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsTrendingTrendingResourceMicrosoftGraphWindowsInformationProtectionAssignExecute(r)
}

/*
MeInsightsTrendingTrendingResourceMicrosoftGraphWindowsInformationProtectionAssign Invoke action assign

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param trendingId key: id of trending
 @return ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWindowsInformationProtectionAssignRequest
*/
func (a *MeActionsApiService) MeInsightsTrendingTrendingResourceMicrosoftGraphWindowsInformationProtectionAssign(ctx _context.Context, trendingId string) ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWindowsInformationProtectionAssignRequest {
	return ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWindowsInformationProtectionAssignRequest{
		ApiService: a,
		ctx: ctx,
		trendingId: trendingId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsTrendingTrendingResourceMicrosoftGraphWindowsInformationProtectionAssignExecute(r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWindowsInformationProtectionAssignRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsTrendingTrendingResourceMicrosoftGraphWindowsInformationProtectionAssign")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/trending/{trending-id}/resource/microsoft.graph.windowsInformationProtection/microsoft.graph.assign"
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject537 == nil {
		return nil, reportError("inlineObject537 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject537
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeClearRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	trendingId string
	inlineObject538 *InlineObject538
}

func (r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeClearRequest) InlineObject538(inlineObject538 InlineObject538) ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeClearRequest {
	r.inlineObject538 = &inlineObject538
	return r
}

func (r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeClearRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeClearExecute(r)
}

/*
MeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeClear Invoke action clear

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param trendingId key: id of trending
 @return ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeClearRequest
*/
func (a *MeActionsApiService) MeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeClear(ctx _context.Context, trendingId string) ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeClearRequest {
	return ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeClearRequest{
		ApiService: a,
		ctx: ctx,
		trendingId: trendingId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeClearExecute(r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeClearRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeClear")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/trending/{trending-id}/resource/microsoft.graph.workbookRange/microsoft.graph.clear"
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject538 == nil {
		return nil, reportError("inlineObject538 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject538
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeDeleteRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	trendingId string
	inlineObject539 *InlineObject539
}

func (r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeDeleteRequest) InlineObject539(inlineObject539 InlineObject539) ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeDeleteRequest {
	r.inlineObject539 = &inlineObject539
	return r
}

func (r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeDeleteExecute(r)
}

/*
MeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeDelete Invoke action delete

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param trendingId key: id of trending
 @return ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeDeleteRequest
*/
func (a *MeActionsApiService) MeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeDelete(ctx _context.Context, trendingId string) ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeDeleteRequest {
	return ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeDeleteRequest{
		ApiService: a,
		ctx: ctx,
		trendingId: trendingId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeDeleteExecute(r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/trending/{trending-id}/resource/microsoft.graph.workbookRange/microsoft.graph.delete"
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject539 == nil {
		return nil, reportError("inlineObject539 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject539
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFillClearRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	trendingId string
}


func (r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFillClearRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFillClearExecute(r)
}

/*
MeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFillClear Invoke action clear

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param trendingId key: id of trending
 @return ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFillClearRequest
*/
func (a *MeActionsApiService) MeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFillClear(ctx _context.Context, trendingId string) ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFillClearRequest {
	return ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFillClearRequest{
		ApiService: a,
		ctx: ctx,
		trendingId: trendingId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFillClearExecute(r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFillClearRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFillClear")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/trending/{trending-id}/resource/microsoft.graph.workbookRangeFill/microsoft.graph.clear"
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFormatAutofitColumnsRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	trendingId string
}


func (r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFormatAutofitColumnsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFormatAutofitColumnsExecute(r)
}

/*
MeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFormatAutofitColumns Invoke action autofitColumns

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param trendingId key: id of trending
 @return ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFormatAutofitColumnsRequest
*/
func (a *MeActionsApiService) MeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFormatAutofitColumns(ctx _context.Context, trendingId string) ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFormatAutofitColumnsRequest {
	return ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFormatAutofitColumnsRequest{
		ApiService: a,
		ctx: ctx,
		trendingId: trendingId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFormatAutofitColumnsExecute(r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFormatAutofitColumnsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFormatAutofitColumns")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/trending/{trending-id}/resource/microsoft.graph.workbookRangeFormat/microsoft.graph.autofitColumns"
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFormatAutofitRowsRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	trendingId string
}


func (r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFormatAutofitRowsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFormatAutofitRowsExecute(r)
}

/*
MeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFormatAutofitRows Invoke action autofitRows

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param trendingId key: id of trending
 @return ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFormatAutofitRowsRequest
*/
func (a *MeActionsApiService) MeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFormatAutofitRows(ctx _context.Context, trendingId string) ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFormatAutofitRowsRequest {
	return ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFormatAutofitRowsRequest{
		ApiService: a,
		ctx: ctx,
		trendingId: trendingId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFormatAutofitRowsExecute(r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFormatAutofitRowsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeFormatAutofitRows")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/trending/{trending-id}/resource/microsoft.graph.workbookRangeFormat/microsoft.graph.autofitRows"
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeInsertRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	trendingId string
	inlineObject540 *InlineObject540
}

func (r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeInsertRequest) InlineObject540(inlineObject540 InlineObject540) ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeInsertRequest {
	r.inlineObject540 = &inlineObject540
	return r
}

func (r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeInsertRequest) Execute() (AnyOfmicrosoftGraphWorkbookRange, *_nethttp.Response, error) {
	return r.ApiService.MeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeInsertExecute(r)
}

/*
MeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeInsert Invoke action insert

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param trendingId key: id of trending
 @return ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeInsertRequest
*/
func (a *MeActionsApiService) MeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeInsert(ctx _context.Context, trendingId string) ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeInsertRequest {
	return ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeInsertRequest{
		ApiService: a,
		ctx: ctx,
		trendingId: trendingId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphWorkbookRange
func (a *MeActionsApiService) MeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeInsertExecute(r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeInsertRequest) (AnyOfmicrosoftGraphWorkbookRange, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphWorkbookRange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeInsert")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/trending/{trending-id}/resource/microsoft.graph.workbookRange/microsoft.graph.insert"
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject540 == nil {
		return localVarReturnValue, nil, reportError("inlineObject540 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject540
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeMergeRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	trendingId string
	inlineObject541 *InlineObject541
}

func (r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeMergeRequest) InlineObject541(inlineObject541 InlineObject541) ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeMergeRequest {
	r.inlineObject541 = &inlineObject541
	return r
}

func (r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeMergeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeMergeExecute(r)
}

/*
MeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeMerge Invoke action merge

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param trendingId key: id of trending
 @return ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeMergeRequest
*/
func (a *MeActionsApiService) MeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeMerge(ctx _context.Context, trendingId string) ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeMergeRequest {
	return ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeMergeRequest{
		ApiService: a,
		ctx: ctx,
		trendingId: trendingId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeMergeExecute(r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeMergeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeMerge")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/trending/{trending-id}/resource/microsoft.graph.workbookRange/microsoft.graph.merge"
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject541 == nil {
		return nil, reportError("inlineObject541 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject541
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeSortApplyRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	trendingId string
	inlineObject542 *InlineObject542
}

func (r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeSortApplyRequest) InlineObject542(inlineObject542 InlineObject542) ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeSortApplyRequest {
	r.inlineObject542 = &inlineObject542
	return r
}

func (r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeSortApplyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeSortApplyExecute(r)
}

/*
MeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeSortApply Invoke action apply

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param trendingId key: id of trending
 @return ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeSortApplyRequest
*/
func (a *MeActionsApiService) MeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeSortApply(ctx _context.Context, trendingId string) ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeSortApplyRequest {
	return ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeSortApplyRequest{
		ApiService: a,
		ctx: ctx,
		trendingId: trendingId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeSortApplyExecute(r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeSortApplyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeSortApply")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/trending/{trending-id}/resource/microsoft.graph.workbookRangeSort/microsoft.graph.apply"
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject542 == nil {
		return nil, reportError("inlineObject542 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject542
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeUnmergeRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	trendingId string
}


func (r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeUnmergeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeUnmergeExecute(r)
}

/*
MeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeUnmerge Invoke action unmerge

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param trendingId key: id of trending
 @return ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeUnmergeRequest
*/
func (a *MeActionsApiService) MeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeUnmerge(ctx _context.Context, trendingId string) ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeUnmergeRequest {
	return ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeUnmergeRequest{
		ApiService: a,
		ctx: ctx,
		trendingId: trendingId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeUnmergeExecute(r ApiMeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeUnmergeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsTrendingTrendingResourceMicrosoftGraphWorkbookRangeUnmerge")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/trending/{trending-id}/resource/microsoft.graph.workbookRange/microsoft.graph.unmerge"
	localVarPath = strings.Replace(localVarPath, "{"+"trending-id"+"}", _neturl.PathEscape(parameterToString(r.trendingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphCalendarSharingMessageAcceptRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	usedInsightId string
}


func (r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphCalendarSharingMessageAcceptRequest) Execute() (MicrosoftGraphCalendar, *_nethttp.Response, error) {
	return r.ApiService.MeInsightsUsedUsedInsightResourceMicrosoftGraphCalendarSharingMessageAcceptExecute(r)
}

/*
MeInsightsUsedUsedInsightResourceMicrosoftGraphCalendarSharingMessageAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param usedInsightId key: id of usedInsight
 @return ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphCalendarSharingMessageAcceptRequest
*/
func (a *MeActionsApiService) MeInsightsUsedUsedInsightResourceMicrosoftGraphCalendarSharingMessageAccept(ctx _context.Context, usedInsightId string) ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphCalendarSharingMessageAcceptRequest {
	return ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphCalendarSharingMessageAcceptRequest{
		ApiService: a,
		ctx: ctx,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphCalendar
func (a *MeActionsApiService) MeInsightsUsedUsedInsightResourceMicrosoftGraphCalendarSharingMessageAcceptExecute(r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphCalendarSharingMessageAcceptRequest) (MicrosoftGraphCalendar, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphCalendar
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsUsedUsedInsightResourceMicrosoftGraphCalendarSharingMessageAccept")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/used/{usedInsight-id}/resource/microsoft.graph.calendarSharingMessage/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphManagedAppProtectionTargetAppsRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	usedInsightId string
	inlineObject543 *InlineObject543
}

func (r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphManagedAppProtectionTargetAppsRequest) InlineObject543(inlineObject543 InlineObject543) ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphManagedAppProtectionTargetAppsRequest {
	r.inlineObject543 = &inlineObject543
	return r
}

func (r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphManagedAppProtectionTargetAppsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsUsedUsedInsightResourceMicrosoftGraphManagedAppProtectionTargetAppsExecute(r)
}

/*
MeInsightsUsedUsedInsightResourceMicrosoftGraphManagedAppProtectionTargetApps Invoke action targetApps

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param usedInsightId key: id of usedInsight
 @return ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphManagedAppProtectionTargetAppsRequest
*/
func (a *MeActionsApiService) MeInsightsUsedUsedInsightResourceMicrosoftGraphManagedAppProtectionTargetApps(ctx _context.Context, usedInsightId string) ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphManagedAppProtectionTargetAppsRequest {
	return ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphManagedAppProtectionTargetAppsRequest{
		ApiService: a,
		ctx: ctx,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsUsedUsedInsightResourceMicrosoftGraphManagedAppProtectionTargetAppsExecute(r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphManagedAppProtectionTargetAppsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsUsedUsedInsightResourceMicrosoftGraphManagedAppProtectionTargetApps")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/used/{usedInsight-id}/resource/microsoft.graph.managedAppProtection/microsoft.graph.targetApps"
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject543 == nil {
		return nil, reportError("inlineObject543 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject543
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphMobileAppContentFileCommitRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	usedInsightId string
	inlineObject544 *InlineObject544
}

func (r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphMobileAppContentFileCommitRequest) InlineObject544(inlineObject544 InlineObject544) ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphMobileAppContentFileCommitRequest {
	r.inlineObject544 = &inlineObject544
	return r
}

func (r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphMobileAppContentFileCommitRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsUsedUsedInsightResourceMicrosoftGraphMobileAppContentFileCommitExecute(r)
}

/*
MeInsightsUsedUsedInsightResourceMicrosoftGraphMobileAppContentFileCommit Invoke action commit

Commits a file of a given app.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param usedInsightId key: id of usedInsight
 @return ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphMobileAppContentFileCommitRequest
*/
func (a *MeActionsApiService) MeInsightsUsedUsedInsightResourceMicrosoftGraphMobileAppContentFileCommit(ctx _context.Context, usedInsightId string) ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphMobileAppContentFileCommitRequest {
	return ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphMobileAppContentFileCommitRequest{
		ApiService: a,
		ctx: ctx,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsUsedUsedInsightResourceMicrosoftGraphMobileAppContentFileCommitExecute(r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphMobileAppContentFileCommitRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsUsedUsedInsightResourceMicrosoftGraphMobileAppContentFileCommit")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/used/{usedInsight-id}/resource/microsoft.graph.mobileAppContentFile/microsoft.graph.commit"
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject544 == nil {
		return nil, reportError("inlineObject544 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject544
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphMobileAppContentFileRenewUploadRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	usedInsightId string
}


func (r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphMobileAppContentFileRenewUploadRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsUsedUsedInsightResourceMicrosoftGraphMobileAppContentFileRenewUploadExecute(r)
}

/*
MeInsightsUsedUsedInsightResourceMicrosoftGraphMobileAppContentFileRenewUpload Invoke action renewUpload

Renews the SAS URI for an application file upload.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param usedInsightId key: id of usedInsight
 @return ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphMobileAppContentFileRenewUploadRequest
*/
func (a *MeActionsApiService) MeInsightsUsedUsedInsightResourceMicrosoftGraphMobileAppContentFileRenewUpload(ctx _context.Context, usedInsightId string) ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphMobileAppContentFileRenewUploadRequest {
	return ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphMobileAppContentFileRenewUploadRequest{
		ApiService: a,
		ctx: ctx,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsUsedUsedInsightResourceMicrosoftGraphMobileAppContentFileRenewUploadExecute(r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphMobileAppContentFileRenewUploadRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsUsedUsedInsightResourceMicrosoftGraphMobileAppContentFileRenewUpload")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/used/{usedInsight-id}/resource/microsoft.graph.mobileAppContentFile/microsoft.graph.renewUpload"
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSessionRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	usedInsightId string
	inlineObject545 *InlineObject545
}

func (r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSessionRequest) InlineObject545(inlineObject545 InlineObject545) ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSessionRequest {
	r.inlineObject545 = &inlineObject545
	return r
}

func (r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSessionRequest) Execute() (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	return r.ApiService.MeInsightsUsedUsedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSessionExecute(r)
}

/*
MeInsightsUsedUsedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSession Invoke action createUploadSession

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param usedInsightId key: id of usedInsight
 @return ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSessionRequest
*/
func (a *MeActionsApiService) MeInsightsUsedUsedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSession(ctx _context.Context, usedInsightId string) ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSessionRequest {
	return ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSessionRequest{
		ApiService: a,
		ctx: ctx,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphUploadSession
func (a *MeActionsApiService) MeInsightsUsedUsedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSessionExecute(r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSessionRequest) (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphUploadSession
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsUsedUsedInsightResourceMicrosoftGraphPrintDocumentCreateUploadSession")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/used/{usedInsight-id}/resource/microsoft.graph.printDocument/microsoft.graph.createUploadSession"
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject545 == nil {
		return localVarReturnValue, nil, reportError("inlineObject545 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject545
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobAbortRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	usedInsightId string
	inlineObject546 *InlineObject546
}

func (r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobAbortRequest) InlineObject546(inlineObject546 InlineObject546) ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobAbortRequest {
	r.inlineObject546 = &inlineObject546
	return r
}

func (r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobAbortRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobAbortExecute(r)
}

/*
MeInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobAbort Invoke action abort

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param usedInsightId key: id of usedInsight
 @return ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobAbortRequest
*/
func (a *MeActionsApiService) MeInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobAbort(ctx _context.Context, usedInsightId string) ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobAbortRequest {
	return ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobAbortRequest{
		ApiService: a,
		ctx: ctx,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobAbortExecute(r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobAbortRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobAbort")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/used/{usedInsight-id}/resource/microsoft.graph.printJob/microsoft.graph.abort"
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject546 == nil {
		return nil, reportError("inlineObject546 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject546
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobCancelRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	usedInsightId string
}


func (r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobCancelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobCancelExecute(r)
}

/*
MeInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobCancel Invoke action cancel

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param usedInsightId key: id of usedInsight
 @return ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobCancelRequest
*/
func (a *MeActionsApiService) MeInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobCancel(ctx _context.Context, usedInsightId string) ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobCancelRequest {
	return ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobCancelRequest{
		ApiService: a,
		ctx: ctx,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobCancelExecute(r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobCancelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobCancel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/used/{usedInsight-id}/resource/microsoft.graph.printJob/microsoft.graph.cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobRedirectRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	usedInsightId string
	inlineObject547 *InlineObject547
}

func (r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobRedirectRequest) InlineObject547(inlineObject547 InlineObject547) ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobRedirectRequest {
	r.inlineObject547 = &inlineObject547
	return r
}

func (r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobRedirectRequest) Execute() (AnyOfmicrosoftGraphPrintJob, *_nethttp.Response, error) {
	return r.ApiService.MeInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobRedirectExecute(r)
}

/*
MeInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobRedirect Invoke action redirect

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param usedInsightId key: id of usedInsight
 @return ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobRedirectRequest
*/
func (a *MeActionsApiService) MeInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobRedirect(ctx _context.Context, usedInsightId string) ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobRedirectRequest {
	return ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobRedirectRequest{
		ApiService: a,
		ctx: ctx,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphPrintJob
func (a *MeActionsApiService) MeInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobRedirectExecute(r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobRedirectRequest) (AnyOfmicrosoftGraphPrintJob, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphPrintJob
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobRedirect")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/used/{usedInsight-id}/resource/microsoft.graph.printJob/microsoft.graph.redirect"
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject547 == nil {
		return localVarReturnValue, nil, reportError("inlineObject547 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject547
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobStartRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	usedInsightId string
}


func (r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobStartRequest) Execute() (AnyOfmicrosoftGraphPrintJobStatus, *_nethttp.Response, error) {
	return r.ApiService.MeInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobStartExecute(r)
}

/*
MeInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobStart Invoke action start

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param usedInsightId key: id of usedInsight
 @return ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobStartRequest
*/
func (a *MeActionsApiService) MeInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobStart(ctx _context.Context, usedInsightId string) ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobStartRequest {
	return ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobStartRequest{
		ApiService: a,
		ctx: ctx,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphPrintJobStatus
func (a *MeActionsApiService) MeInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobStartExecute(r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobStartRequest) (AnyOfmicrosoftGraphPrintJobStatus, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphPrintJobStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsUsedUsedInsightResourceMicrosoftGraphPrintJobStart")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/used/{usedInsight-id}/resource/microsoft.graph.printJob/microsoft.graph.start"
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestApproveRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	usedInsightId string
	inlineObject548 *InlineObject548
}

func (r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestApproveRequest) InlineObject548(inlineObject548 InlineObject548) ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestApproveRequest {
	r.inlineObject548 = &inlineObject548
	return r
}

func (r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestApproveRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestApproveExecute(r)
}

/*
MeInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestApprove Invoke action approve

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param usedInsightId key: id of usedInsight
 @return ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestApproveRequest
*/
func (a *MeActionsApiService) MeInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestApprove(ctx _context.Context, usedInsightId string) ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestApproveRequest {
	return ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestApproveRequest{
		ApiService: a,
		ctx: ctx,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestApproveExecute(r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestApproveRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestApprove")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/used/{usedInsight-id}/resource/microsoft.graph.scheduleChangeRequest/microsoft.graph.approve"
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject548 == nil {
		return nil, reportError("inlineObject548 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject548
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestDeclineRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	usedInsightId string
	inlineObject549 *InlineObject549
}

func (r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestDeclineRequest) InlineObject549(inlineObject549 InlineObject549) ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestDeclineRequest {
	r.inlineObject549 = &inlineObject549
	return r
}

func (r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestDeclineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestDeclineExecute(r)
}

/*
MeInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestDecline Invoke action decline

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param usedInsightId key: id of usedInsight
 @return ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestDeclineRequest
*/
func (a *MeActionsApiService) MeInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestDecline(ctx _context.Context, usedInsightId string) ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestDeclineRequest {
	return ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestDeclineRequest{
		ApiService: a,
		ctx: ctx,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestDeclineExecute(r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestDeclineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsUsedUsedInsightResourceMicrosoftGraphScheduleChangeRequestDecline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/used/{usedInsight-id}/resource/microsoft.graph.scheduleChangeRequest/microsoft.graph.decline"
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject549 == nil {
		return nil, reportError("inlineObject549 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject549
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssignRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	usedInsightId string
	inlineObject550 *InlineObject550
}

func (r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssignRequest) InlineObject550(inlineObject550 InlineObject550) ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssignRequest {
	r.inlineObject550 = &inlineObject550
	return r
}

func (r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssignRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssignExecute(r)
}

/*
MeInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssign Invoke action assign

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param usedInsightId key: id of usedInsight
 @return ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssignRequest
*/
func (a *MeActionsApiService) MeInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssign(ctx _context.Context, usedInsightId string) ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssignRequest {
	return ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssignRequest{
		ApiService: a,
		ctx: ctx,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssignExecute(r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssignRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionAssign")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/used/{usedInsight-id}/resource/microsoft.graph.targetedManagedAppProtection/microsoft.graph.assign"
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject550 == nil {
		return nil, reportError("inlineObject550 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject550
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	usedInsightId string
	inlineObject551 *InlineObject551
}

func (r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest) InlineObject551(inlineObject551 InlineObject551) ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest {
	r.inlineObject551 = &inlineObject551
	return r
}

func (r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsExecute(r)
}

/*
MeInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetApps Invoke action targetApps

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param usedInsightId key: id of usedInsight
 @return ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest
*/
func (a *MeActionsApiService) MeInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetApps(ctx _context.Context, usedInsightId string) ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest {
	return ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest{
		ApiService: a,
		ctx: ctx,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsExecute(r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetAppsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsUsedUsedInsightResourceMicrosoftGraphTargetedManagedAppProtectionTargetApps")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/used/{usedInsight-id}/resource/microsoft.graph.targetedManagedAppProtection/microsoft.graph.targetApps"
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject551 == nil {
		return nil, reportError("inlineObject551 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject551
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWindowsInformationProtectionAssignRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	usedInsightId string
	inlineObject552 *InlineObject552
}

func (r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWindowsInformationProtectionAssignRequest) InlineObject552(inlineObject552 InlineObject552) ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWindowsInformationProtectionAssignRequest {
	r.inlineObject552 = &inlineObject552
	return r
}

func (r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWindowsInformationProtectionAssignRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsUsedUsedInsightResourceMicrosoftGraphWindowsInformationProtectionAssignExecute(r)
}

/*
MeInsightsUsedUsedInsightResourceMicrosoftGraphWindowsInformationProtectionAssign Invoke action assign

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param usedInsightId key: id of usedInsight
 @return ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWindowsInformationProtectionAssignRequest
*/
func (a *MeActionsApiService) MeInsightsUsedUsedInsightResourceMicrosoftGraphWindowsInformationProtectionAssign(ctx _context.Context, usedInsightId string) ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWindowsInformationProtectionAssignRequest {
	return ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWindowsInformationProtectionAssignRequest{
		ApiService: a,
		ctx: ctx,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsUsedUsedInsightResourceMicrosoftGraphWindowsInformationProtectionAssignExecute(r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWindowsInformationProtectionAssignRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsUsedUsedInsightResourceMicrosoftGraphWindowsInformationProtectionAssign")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/used/{usedInsight-id}/resource/microsoft.graph.windowsInformationProtection/microsoft.graph.assign"
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject552 == nil {
		return nil, reportError("inlineObject552 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject552
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeClearRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	usedInsightId string
	inlineObject553 *InlineObject553
}

func (r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeClearRequest) InlineObject553(inlineObject553 InlineObject553) ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeClearRequest {
	r.inlineObject553 = &inlineObject553
	return r
}

func (r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeClearRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeClearExecute(r)
}

/*
MeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeClear Invoke action clear

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param usedInsightId key: id of usedInsight
 @return ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeClearRequest
*/
func (a *MeActionsApiService) MeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeClear(ctx _context.Context, usedInsightId string) ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeClearRequest {
	return ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeClearRequest{
		ApiService: a,
		ctx: ctx,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeClearExecute(r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeClearRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeClear")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/used/{usedInsight-id}/resource/microsoft.graph.workbookRange/microsoft.graph.clear"
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject553 == nil {
		return nil, reportError("inlineObject553 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject553
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeDeleteRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	usedInsightId string
	inlineObject554 *InlineObject554
}

func (r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeDeleteRequest) InlineObject554(inlineObject554 InlineObject554) ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeDeleteRequest {
	r.inlineObject554 = &inlineObject554
	return r
}

func (r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeDeleteExecute(r)
}

/*
MeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeDelete Invoke action delete

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param usedInsightId key: id of usedInsight
 @return ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeDeleteRequest
*/
func (a *MeActionsApiService) MeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeDelete(ctx _context.Context, usedInsightId string) ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeDeleteRequest {
	return ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeDeleteRequest{
		ApiService: a,
		ctx: ctx,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeDeleteExecute(r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/used/{usedInsight-id}/resource/microsoft.graph.workbookRange/microsoft.graph.delete"
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject554 == nil {
		return nil, reportError("inlineObject554 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject554
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFillClearRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	usedInsightId string
}


func (r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFillClearRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFillClearExecute(r)
}

/*
MeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFillClear Invoke action clear

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param usedInsightId key: id of usedInsight
 @return ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFillClearRequest
*/
func (a *MeActionsApiService) MeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFillClear(ctx _context.Context, usedInsightId string) ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFillClearRequest {
	return ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFillClearRequest{
		ApiService: a,
		ctx: ctx,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFillClearExecute(r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFillClearRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFillClear")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/used/{usedInsight-id}/resource/microsoft.graph.workbookRangeFill/microsoft.graph.clear"
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitColumnsRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	usedInsightId string
}


func (r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitColumnsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitColumnsExecute(r)
}

/*
MeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitColumns Invoke action autofitColumns

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param usedInsightId key: id of usedInsight
 @return ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitColumnsRequest
*/
func (a *MeActionsApiService) MeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitColumns(ctx _context.Context, usedInsightId string) ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitColumnsRequest {
	return ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitColumnsRequest{
		ApiService: a,
		ctx: ctx,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitColumnsExecute(r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitColumnsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitColumns")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/used/{usedInsight-id}/resource/microsoft.graph.workbookRangeFormat/microsoft.graph.autofitColumns"
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitRowsRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	usedInsightId string
}


func (r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitRowsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitRowsExecute(r)
}

/*
MeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitRows Invoke action autofitRows

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param usedInsightId key: id of usedInsight
 @return ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitRowsRequest
*/
func (a *MeActionsApiService) MeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitRows(ctx _context.Context, usedInsightId string) ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitRowsRequest {
	return ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitRowsRequest{
		ApiService: a,
		ctx: ctx,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitRowsExecute(r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitRowsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeFormatAutofitRows")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/used/{usedInsight-id}/resource/microsoft.graph.workbookRangeFormat/microsoft.graph.autofitRows"
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeInsertRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	usedInsightId string
	inlineObject555 *InlineObject555
}

func (r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeInsertRequest) InlineObject555(inlineObject555 InlineObject555) ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeInsertRequest {
	r.inlineObject555 = &inlineObject555
	return r
}

func (r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeInsertRequest) Execute() (AnyOfmicrosoftGraphWorkbookRange, *_nethttp.Response, error) {
	return r.ApiService.MeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeInsertExecute(r)
}

/*
MeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeInsert Invoke action insert

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param usedInsightId key: id of usedInsight
 @return ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeInsertRequest
*/
func (a *MeActionsApiService) MeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeInsert(ctx _context.Context, usedInsightId string) ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeInsertRequest {
	return ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeInsertRequest{
		ApiService: a,
		ctx: ctx,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphWorkbookRange
func (a *MeActionsApiService) MeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeInsertExecute(r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeInsertRequest) (AnyOfmicrosoftGraphWorkbookRange, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphWorkbookRange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeInsert")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/used/{usedInsight-id}/resource/microsoft.graph.workbookRange/microsoft.graph.insert"
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject555 == nil {
		return localVarReturnValue, nil, reportError("inlineObject555 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject555
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeMergeRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	usedInsightId string
	inlineObject556 *InlineObject556
}

func (r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeMergeRequest) InlineObject556(inlineObject556 InlineObject556) ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeMergeRequest {
	r.inlineObject556 = &inlineObject556
	return r
}

func (r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeMergeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeMergeExecute(r)
}

/*
MeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeMerge Invoke action merge

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param usedInsightId key: id of usedInsight
 @return ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeMergeRequest
*/
func (a *MeActionsApiService) MeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeMerge(ctx _context.Context, usedInsightId string) ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeMergeRequest {
	return ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeMergeRequest{
		ApiService: a,
		ctx: ctx,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeMergeExecute(r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeMergeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeMerge")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/used/{usedInsight-id}/resource/microsoft.graph.workbookRange/microsoft.graph.merge"
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject556 == nil {
		return nil, reportError("inlineObject556 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject556
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeSortApplyRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	usedInsightId string
	inlineObject557 *InlineObject557
}

func (r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeSortApplyRequest) InlineObject557(inlineObject557 InlineObject557) ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeSortApplyRequest {
	r.inlineObject557 = &inlineObject557
	return r
}

func (r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeSortApplyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeSortApplyExecute(r)
}

/*
MeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeSortApply Invoke action apply

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param usedInsightId key: id of usedInsight
 @return ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeSortApplyRequest
*/
func (a *MeActionsApiService) MeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeSortApply(ctx _context.Context, usedInsightId string) ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeSortApplyRequest {
	return ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeSortApplyRequest{
		ApiService: a,
		ctx: ctx,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeSortApplyExecute(r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeSortApplyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeSortApply")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/used/{usedInsight-id}/resource/microsoft.graph.workbookRangeSort/microsoft.graph.apply"
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject557 == nil {
		return nil, reportError("inlineObject557 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject557
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeUnmergeRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	usedInsightId string
}


func (r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeUnmergeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeUnmergeExecute(r)
}

/*
MeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeUnmerge Invoke action unmerge

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param usedInsightId key: id of usedInsight
 @return ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeUnmergeRequest
*/
func (a *MeActionsApiService) MeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeUnmerge(ctx _context.Context, usedInsightId string) ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeUnmergeRequest {
	return ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeUnmergeRequest{
		ApiService: a,
		ctx: ctx,
		usedInsightId: usedInsightId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeUnmergeExecute(r ApiMeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeUnmergeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeInsightsUsedUsedInsightResourceMicrosoftGraphWorkbookRangeUnmerge")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/insights/used/{usedInsight-id}/resource/microsoft.graph.workbookRange/microsoft.graph.unmerge"
	localVarPath = strings.Replace(localVarPath, "{"+"usedInsight-id"+"}", _neturl.PathEscape(parameterToString(r.usedInsightId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeMailFoldersMailFolderChildFoldersMailFolderCopyRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	mailFolderId string
	mailFolderId1 string
	inlineObject558 *InlineObject558
}

func (r ApiMeMailFoldersMailFolderChildFoldersMailFolderCopyRequest) InlineObject558(inlineObject558 InlineObject558) ApiMeMailFoldersMailFolderChildFoldersMailFolderCopyRequest {
	r.inlineObject558 = &inlineObject558
	return r
}

func (r ApiMeMailFoldersMailFolderChildFoldersMailFolderCopyRequest) Execute() (AnyOfmicrosoftGraphMailFolder, *_nethttp.Response, error) {
	return r.ApiService.MeMailFoldersMailFolderChildFoldersMailFolderCopyExecute(r)
}

/*
MeMailFoldersMailFolderChildFoldersMailFolderCopy Invoke action copy

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param mailFolderId key: id of mailFolder
 @param mailFolderId1 key: id of mailFolder
 @return ApiMeMailFoldersMailFolderChildFoldersMailFolderCopyRequest
*/
func (a *MeActionsApiService) MeMailFoldersMailFolderChildFoldersMailFolderCopy(ctx _context.Context, mailFolderId string, mailFolderId1 string) ApiMeMailFoldersMailFolderChildFoldersMailFolderCopyRequest {
	return ApiMeMailFoldersMailFolderChildFoldersMailFolderCopyRequest{
		ApiService: a,
		ctx: ctx,
		mailFolderId: mailFolderId,
		mailFolderId1: mailFolderId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphMailFolder
func (a *MeActionsApiService) MeMailFoldersMailFolderChildFoldersMailFolderCopyExecute(r ApiMeMailFoldersMailFolderChildFoldersMailFolderCopyRequest) (AnyOfmicrosoftGraphMailFolder, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphMailFolder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeMailFoldersMailFolderChildFoldersMailFolderCopy")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/mailFolders/{mailFolder-id}/childFolders/{mailFolder-id1}/microsoft.graph.copy"
	localVarPath = strings.Replace(localVarPath, "{"+"mailFolder-id"+"}", _neturl.PathEscape(parameterToString(r.mailFolderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mailFolder-id1"+"}", _neturl.PathEscape(parameterToString(r.mailFolderId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject558 == nil {
		return localVarReturnValue, nil, reportError("inlineObject558 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject558
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeMailFoldersMailFolderChildFoldersMailFolderMoveRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	mailFolderId string
	mailFolderId1 string
	inlineObject559 *InlineObject559
}

func (r ApiMeMailFoldersMailFolderChildFoldersMailFolderMoveRequest) InlineObject559(inlineObject559 InlineObject559) ApiMeMailFoldersMailFolderChildFoldersMailFolderMoveRequest {
	r.inlineObject559 = &inlineObject559
	return r
}

func (r ApiMeMailFoldersMailFolderChildFoldersMailFolderMoveRequest) Execute() (AnyOfmicrosoftGraphMailFolder, *_nethttp.Response, error) {
	return r.ApiService.MeMailFoldersMailFolderChildFoldersMailFolderMoveExecute(r)
}

/*
MeMailFoldersMailFolderChildFoldersMailFolderMove Invoke action move

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param mailFolderId key: id of mailFolder
 @param mailFolderId1 key: id of mailFolder
 @return ApiMeMailFoldersMailFolderChildFoldersMailFolderMoveRequest
*/
func (a *MeActionsApiService) MeMailFoldersMailFolderChildFoldersMailFolderMove(ctx _context.Context, mailFolderId string, mailFolderId1 string) ApiMeMailFoldersMailFolderChildFoldersMailFolderMoveRequest {
	return ApiMeMailFoldersMailFolderChildFoldersMailFolderMoveRequest{
		ApiService: a,
		ctx: ctx,
		mailFolderId: mailFolderId,
		mailFolderId1: mailFolderId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphMailFolder
func (a *MeActionsApiService) MeMailFoldersMailFolderChildFoldersMailFolderMoveExecute(r ApiMeMailFoldersMailFolderChildFoldersMailFolderMoveRequest) (AnyOfmicrosoftGraphMailFolder, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphMailFolder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeMailFoldersMailFolderChildFoldersMailFolderMove")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/mailFolders/{mailFolder-id}/childFolders/{mailFolder-id1}/microsoft.graph.move"
	localVarPath = strings.Replace(localVarPath, "{"+"mailFolder-id"+"}", _neturl.PathEscape(parameterToString(r.mailFolderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mailFolder-id1"+"}", _neturl.PathEscape(parameterToString(r.mailFolderId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject559 == nil {
		return localVarReturnValue, nil, reportError("inlineObject559 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject559
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeMailFoldersMailFolderCopyRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	mailFolderId string
	inlineObject569 *InlineObject569
}

func (r ApiMeMailFoldersMailFolderCopyRequest) InlineObject569(inlineObject569 InlineObject569) ApiMeMailFoldersMailFolderCopyRequest {
	r.inlineObject569 = &inlineObject569
	return r
}

func (r ApiMeMailFoldersMailFolderCopyRequest) Execute() (AnyOfmicrosoftGraphMailFolder, *_nethttp.Response, error) {
	return r.ApiService.MeMailFoldersMailFolderCopyExecute(r)
}

/*
MeMailFoldersMailFolderCopy Invoke action copy

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param mailFolderId key: id of mailFolder
 @return ApiMeMailFoldersMailFolderCopyRequest
*/
func (a *MeActionsApiService) MeMailFoldersMailFolderCopy(ctx _context.Context, mailFolderId string) ApiMeMailFoldersMailFolderCopyRequest {
	return ApiMeMailFoldersMailFolderCopyRequest{
		ApiService: a,
		ctx: ctx,
		mailFolderId: mailFolderId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphMailFolder
func (a *MeActionsApiService) MeMailFoldersMailFolderCopyExecute(r ApiMeMailFoldersMailFolderCopyRequest) (AnyOfmicrosoftGraphMailFolder, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphMailFolder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeMailFoldersMailFolderCopy")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/mailFolders/{mailFolder-id}/microsoft.graph.copy"
	localVarPath = strings.Replace(localVarPath, "{"+"mailFolder-id"+"}", _neturl.PathEscape(parameterToString(r.mailFolderId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject569 == nil {
		return localVarReturnValue, nil, reportError("inlineObject569 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject569
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeMailFoldersMailFolderMessagesMessageAttachmentsCreateUploadSessionRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	mailFolderId string
	messageId string
	inlineObject560 *InlineObject560
}

func (r ApiMeMailFoldersMailFolderMessagesMessageAttachmentsCreateUploadSessionRequest) InlineObject560(inlineObject560 InlineObject560) ApiMeMailFoldersMailFolderMessagesMessageAttachmentsCreateUploadSessionRequest {
	r.inlineObject560 = &inlineObject560
	return r
}

func (r ApiMeMailFoldersMailFolderMessagesMessageAttachmentsCreateUploadSessionRequest) Execute() (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	return r.ApiService.MeMailFoldersMailFolderMessagesMessageAttachmentsCreateUploadSessionExecute(r)
}

/*
MeMailFoldersMailFolderMessagesMessageAttachmentsCreateUploadSession Invoke action createUploadSession

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param mailFolderId key: id of mailFolder
 @param messageId key: id of message
 @return ApiMeMailFoldersMailFolderMessagesMessageAttachmentsCreateUploadSessionRequest
*/
func (a *MeActionsApiService) MeMailFoldersMailFolderMessagesMessageAttachmentsCreateUploadSession(ctx _context.Context, mailFolderId string, messageId string) ApiMeMailFoldersMailFolderMessagesMessageAttachmentsCreateUploadSessionRequest {
	return ApiMeMailFoldersMailFolderMessagesMessageAttachmentsCreateUploadSessionRequest{
		ApiService: a,
		ctx: ctx,
		mailFolderId: mailFolderId,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphUploadSession
func (a *MeActionsApiService) MeMailFoldersMailFolderMessagesMessageAttachmentsCreateUploadSessionExecute(r ApiMeMailFoldersMailFolderMessagesMessageAttachmentsCreateUploadSessionRequest) (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphUploadSession
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeMailFoldersMailFolderMessagesMessageAttachmentsCreateUploadSession")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/mailFolders/{mailFolder-id}/messages/{message-id}/attachments/microsoft.graph.createUploadSession"
	localVarPath = strings.Replace(localVarPath, "{"+"mailFolder-id"+"}", _neturl.PathEscape(parameterToString(r.mailFolderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject560 == nil {
		return localVarReturnValue, nil, reportError("inlineObject560 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject560
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeMailFoldersMailFolderMessagesMessageCopyRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	mailFolderId string
	messageId string
	inlineObject561 *InlineObject561
}

func (r ApiMeMailFoldersMailFolderMessagesMessageCopyRequest) InlineObject561(inlineObject561 InlineObject561) ApiMeMailFoldersMailFolderMessagesMessageCopyRequest {
	r.inlineObject561 = &inlineObject561
	return r
}

func (r ApiMeMailFoldersMailFolderMessagesMessageCopyRequest) Execute() (AnyOfmicrosoftGraphMessage, *_nethttp.Response, error) {
	return r.ApiService.MeMailFoldersMailFolderMessagesMessageCopyExecute(r)
}

/*
MeMailFoldersMailFolderMessagesMessageCopy Invoke action copy

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param mailFolderId key: id of mailFolder
 @param messageId key: id of message
 @return ApiMeMailFoldersMailFolderMessagesMessageCopyRequest
*/
func (a *MeActionsApiService) MeMailFoldersMailFolderMessagesMessageCopy(ctx _context.Context, mailFolderId string, messageId string) ApiMeMailFoldersMailFolderMessagesMessageCopyRequest {
	return ApiMeMailFoldersMailFolderMessagesMessageCopyRequest{
		ApiService: a,
		ctx: ctx,
		mailFolderId: mailFolderId,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphMessage
func (a *MeActionsApiService) MeMailFoldersMailFolderMessagesMessageCopyExecute(r ApiMeMailFoldersMailFolderMessagesMessageCopyRequest) (AnyOfmicrosoftGraphMessage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeMailFoldersMailFolderMessagesMessageCopy")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/mailFolders/{mailFolder-id}/messages/{message-id}/microsoft.graph.copy"
	localVarPath = strings.Replace(localVarPath, "{"+"mailFolder-id"+"}", _neturl.PathEscape(parameterToString(r.mailFolderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject561 == nil {
		return localVarReturnValue, nil, reportError("inlineObject561 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject561
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeMailFoldersMailFolderMessagesMessageCreateForwardRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	mailFolderId string
	messageId string
	inlineObject562 *InlineObject562
}

func (r ApiMeMailFoldersMailFolderMessagesMessageCreateForwardRequest) InlineObject562(inlineObject562 InlineObject562) ApiMeMailFoldersMailFolderMessagesMessageCreateForwardRequest {
	r.inlineObject562 = &inlineObject562
	return r
}

func (r ApiMeMailFoldersMailFolderMessagesMessageCreateForwardRequest) Execute() (AnyOfmicrosoftGraphMessage, *_nethttp.Response, error) {
	return r.ApiService.MeMailFoldersMailFolderMessagesMessageCreateForwardExecute(r)
}

/*
MeMailFoldersMailFolderMessagesMessageCreateForward Invoke action createForward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param mailFolderId key: id of mailFolder
 @param messageId key: id of message
 @return ApiMeMailFoldersMailFolderMessagesMessageCreateForwardRequest
*/
func (a *MeActionsApiService) MeMailFoldersMailFolderMessagesMessageCreateForward(ctx _context.Context, mailFolderId string, messageId string) ApiMeMailFoldersMailFolderMessagesMessageCreateForwardRequest {
	return ApiMeMailFoldersMailFolderMessagesMessageCreateForwardRequest{
		ApiService: a,
		ctx: ctx,
		mailFolderId: mailFolderId,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphMessage
func (a *MeActionsApiService) MeMailFoldersMailFolderMessagesMessageCreateForwardExecute(r ApiMeMailFoldersMailFolderMessagesMessageCreateForwardRequest) (AnyOfmicrosoftGraphMessage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeMailFoldersMailFolderMessagesMessageCreateForward")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/mailFolders/{mailFolder-id}/messages/{message-id}/microsoft.graph.createForward"
	localVarPath = strings.Replace(localVarPath, "{"+"mailFolder-id"+"}", _neturl.PathEscape(parameterToString(r.mailFolderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject562 == nil {
		return localVarReturnValue, nil, reportError("inlineObject562 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject562
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeMailFoldersMailFolderMessagesMessageCreateReplyRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	mailFolderId string
	messageId string
	inlineObject563 *InlineObject563
}

func (r ApiMeMailFoldersMailFolderMessagesMessageCreateReplyRequest) InlineObject563(inlineObject563 InlineObject563) ApiMeMailFoldersMailFolderMessagesMessageCreateReplyRequest {
	r.inlineObject563 = &inlineObject563
	return r
}

func (r ApiMeMailFoldersMailFolderMessagesMessageCreateReplyRequest) Execute() (AnyOfmicrosoftGraphMessage, *_nethttp.Response, error) {
	return r.ApiService.MeMailFoldersMailFolderMessagesMessageCreateReplyExecute(r)
}

/*
MeMailFoldersMailFolderMessagesMessageCreateReply Invoke action createReply

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param mailFolderId key: id of mailFolder
 @param messageId key: id of message
 @return ApiMeMailFoldersMailFolderMessagesMessageCreateReplyRequest
*/
func (a *MeActionsApiService) MeMailFoldersMailFolderMessagesMessageCreateReply(ctx _context.Context, mailFolderId string, messageId string) ApiMeMailFoldersMailFolderMessagesMessageCreateReplyRequest {
	return ApiMeMailFoldersMailFolderMessagesMessageCreateReplyRequest{
		ApiService: a,
		ctx: ctx,
		mailFolderId: mailFolderId,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphMessage
func (a *MeActionsApiService) MeMailFoldersMailFolderMessagesMessageCreateReplyExecute(r ApiMeMailFoldersMailFolderMessagesMessageCreateReplyRequest) (AnyOfmicrosoftGraphMessage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeMailFoldersMailFolderMessagesMessageCreateReply")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/mailFolders/{mailFolder-id}/messages/{message-id}/microsoft.graph.createReply"
	localVarPath = strings.Replace(localVarPath, "{"+"mailFolder-id"+"}", _neturl.PathEscape(parameterToString(r.mailFolderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject563 == nil {
		return localVarReturnValue, nil, reportError("inlineObject563 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject563
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeMailFoldersMailFolderMessagesMessageCreateReplyAllRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	mailFolderId string
	messageId string
	inlineObject564 *InlineObject564
}

func (r ApiMeMailFoldersMailFolderMessagesMessageCreateReplyAllRequest) InlineObject564(inlineObject564 InlineObject564) ApiMeMailFoldersMailFolderMessagesMessageCreateReplyAllRequest {
	r.inlineObject564 = &inlineObject564
	return r
}

func (r ApiMeMailFoldersMailFolderMessagesMessageCreateReplyAllRequest) Execute() (AnyOfmicrosoftGraphMessage, *_nethttp.Response, error) {
	return r.ApiService.MeMailFoldersMailFolderMessagesMessageCreateReplyAllExecute(r)
}

/*
MeMailFoldersMailFolderMessagesMessageCreateReplyAll Invoke action createReplyAll

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param mailFolderId key: id of mailFolder
 @param messageId key: id of message
 @return ApiMeMailFoldersMailFolderMessagesMessageCreateReplyAllRequest
*/
func (a *MeActionsApiService) MeMailFoldersMailFolderMessagesMessageCreateReplyAll(ctx _context.Context, mailFolderId string, messageId string) ApiMeMailFoldersMailFolderMessagesMessageCreateReplyAllRequest {
	return ApiMeMailFoldersMailFolderMessagesMessageCreateReplyAllRequest{
		ApiService: a,
		ctx: ctx,
		mailFolderId: mailFolderId,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphMessage
func (a *MeActionsApiService) MeMailFoldersMailFolderMessagesMessageCreateReplyAllExecute(r ApiMeMailFoldersMailFolderMessagesMessageCreateReplyAllRequest) (AnyOfmicrosoftGraphMessage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeMailFoldersMailFolderMessagesMessageCreateReplyAll")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/mailFolders/{mailFolder-id}/messages/{message-id}/microsoft.graph.createReplyAll"
	localVarPath = strings.Replace(localVarPath, "{"+"mailFolder-id"+"}", _neturl.PathEscape(parameterToString(r.mailFolderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject564 == nil {
		return localVarReturnValue, nil, reportError("inlineObject564 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject564
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeMailFoldersMailFolderMessagesMessageForwardRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	mailFolderId string
	messageId string
	inlineObject565 *InlineObject565
}

func (r ApiMeMailFoldersMailFolderMessagesMessageForwardRequest) InlineObject565(inlineObject565 InlineObject565) ApiMeMailFoldersMailFolderMessagesMessageForwardRequest {
	r.inlineObject565 = &inlineObject565
	return r
}

func (r ApiMeMailFoldersMailFolderMessagesMessageForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeMailFoldersMailFolderMessagesMessageForwardExecute(r)
}

/*
MeMailFoldersMailFolderMessagesMessageForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param mailFolderId key: id of mailFolder
 @param messageId key: id of message
 @return ApiMeMailFoldersMailFolderMessagesMessageForwardRequest
*/
func (a *MeActionsApiService) MeMailFoldersMailFolderMessagesMessageForward(ctx _context.Context, mailFolderId string, messageId string) ApiMeMailFoldersMailFolderMessagesMessageForwardRequest {
	return ApiMeMailFoldersMailFolderMessagesMessageForwardRequest{
		ApiService: a,
		ctx: ctx,
		mailFolderId: mailFolderId,
		messageId: messageId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeMailFoldersMailFolderMessagesMessageForwardExecute(r ApiMeMailFoldersMailFolderMessagesMessageForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeMailFoldersMailFolderMessagesMessageForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/mailFolders/{mailFolder-id}/messages/{message-id}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"mailFolder-id"+"}", _neturl.PathEscape(parameterToString(r.mailFolderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject565 == nil {
		return nil, reportError("inlineObject565 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject565
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeMailFoldersMailFolderMessagesMessageMicrosoftGraphCalendarSharingMessageAcceptRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	mailFolderId string
	messageId string
}


func (r ApiMeMailFoldersMailFolderMessagesMessageMicrosoftGraphCalendarSharingMessageAcceptRequest) Execute() (MicrosoftGraphCalendar, *_nethttp.Response, error) {
	return r.ApiService.MeMailFoldersMailFolderMessagesMessageMicrosoftGraphCalendarSharingMessageAcceptExecute(r)
}

/*
MeMailFoldersMailFolderMessagesMessageMicrosoftGraphCalendarSharingMessageAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param mailFolderId key: id of mailFolder
 @param messageId key: id of message
 @return ApiMeMailFoldersMailFolderMessagesMessageMicrosoftGraphCalendarSharingMessageAcceptRequest
*/
func (a *MeActionsApiService) MeMailFoldersMailFolderMessagesMessageMicrosoftGraphCalendarSharingMessageAccept(ctx _context.Context, mailFolderId string, messageId string) ApiMeMailFoldersMailFolderMessagesMessageMicrosoftGraphCalendarSharingMessageAcceptRequest {
	return ApiMeMailFoldersMailFolderMessagesMessageMicrosoftGraphCalendarSharingMessageAcceptRequest{
		ApiService: a,
		ctx: ctx,
		mailFolderId: mailFolderId,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphCalendar
func (a *MeActionsApiService) MeMailFoldersMailFolderMessagesMessageMicrosoftGraphCalendarSharingMessageAcceptExecute(r ApiMeMailFoldersMailFolderMessagesMessageMicrosoftGraphCalendarSharingMessageAcceptRequest) (MicrosoftGraphCalendar, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphCalendar
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeMailFoldersMailFolderMessagesMessageMicrosoftGraphCalendarSharingMessageAccept")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/mailFolders/{mailFolder-id}/messages/{message-id}/microsoft.graph.calendarSharingMessage/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"mailFolder-id"+"}", _neturl.PathEscape(parameterToString(r.mailFolderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeMailFoldersMailFolderMessagesMessageMoveRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	mailFolderId string
	messageId string
	inlineObject566 *InlineObject566
}

func (r ApiMeMailFoldersMailFolderMessagesMessageMoveRequest) InlineObject566(inlineObject566 InlineObject566) ApiMeMailFoldersMailFolderMessagesMessageMoveRequest {
	r.inlineObject566 = &inlineObject566
	return r
}

func (r ApiMeMailFoldersMailFolderMessagesMessageMoveRequest) Execute() (AnyOfmicrosoftGraphMessage, *_nethttp.Response, error) {
	return r.ApiService.MeMailFoldersMailFolderMessagesMessageMoveExecute(r)
}

/*
MeMailFoldersMailFolderMessagesMessageMove Invoke action move

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param mailFolderId key: id of mailFolder
 @param messageId key: id of message
 @return ApiMeMailFoldersMailFolderMessagesMessageMoveRequest
*/
func (a *MeActionsApiService) MeMailFoldersMailFolderMessagesMessageMove(ctx _context.Context, mailFolderId string, messageId string) ApiMeMailFoldersMailFolderMessagesMessageMoveRequest {
	return ApiMeMailFoldersMailFolderMessagesMessageMoveRequest{
		ApiService: a,
		ctx: ctx,
		mailFolderId: mailFolderId,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphMessage
func (a *MeActionsApiService) MeMailFoldersMailFolderMessagesMessageMoveExecute(r ApiMeMailFoldersMailFolderMessagesMessageMoveRequest) (AnyOfmicrosoftGraphMessage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeMailFoldersMailFolderMessagesMessageMove")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/mailFolders/{mailFolder-id}/messages/{message-id}/microsoft.graph.move"
	localVarPath = strings.Replace(localVarPath, "{"+"mailFolder-id"+"}", _neturl.PathEscape(parameterToString(r.mailFolderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject566 == nil {
		return localVarReturnValue, nil, reportError("inlineObject566 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject566
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeMailFoldersMailFolderMessagesMessageReplyRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	mailFolderId string
	messageId string
	inlineObject567 *InlineObject567
}

func (r ApiMeMailFoldersMailFolderMessagesMessageReplyRequest) InlineObject567(inlineObject567 InlineObject567) ApiMeMailFoldersMailFolderMessagesMessageReplyRequest {
	r.inlineObject567 = &inlineObject567
	return r
}

func (r ApiMeMailFoldersMailFolderMessagesMessageReplyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeMailFoldersMailFolderMessagesMessageReplyExecute(r)
}

/*
MeMailFoldersMailFolderMessagesMessageReply Invoke action reply

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param mailFolderId key: id of mailFolder
 @param messageId key: id of message
 @return ApiMeMailFoldersMailFolderMessagesMessageReplyRequest
*/
func (a *MeActionsApiService) MeMailFoldersMailFolderMessagesMessageReply(ctx _context.Context, mailFolderId string, messageId string) ApiMeMailFoldersMailFolderMessagesMessageReplyRequest {
	return ApiMeMailFoldersMailFolderMessagesMessageReplyRequest{
		ApiService: a,
		ctx: ctx,
		mailFolderId: mailFolderId,
		messageId: messageId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeMailFoldersMailFolderMessagesMessageReplyExecute(r ApiMeMailFoldersMailFolderMessagesMessageReplyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeMailFoldersMailFolderMessagesMessageReply")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/mailFolders/{mailFolder-id}/messages/{message-id}/microsoft.graph.reply"
	localVarPath = strings.Replace(localVarPath, "{"+"mailFolder-id"+"}", _neturl.PathEscape(parameterToString(r.mailFolderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject567 == nil {
		return nil, reportError("inlineObject567 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject567
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeMailFoldersMailFolderMessagesMessageReplyAllRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	mailFolderId string
	messageId string
	inlineObject568 *InlineObject568
}

func (r ApiMeMailFoldersMailFolderMessagesMessageReplyAllRequest) InlineObject568(inlineObject568 InlineObject568) ApiMeMailFoldersMailFolderMessagesMessageReplyAllRequest {
	r.inlineObject568 = &inlineObject568
	return r
}

func (r ApiMeMailFoldersMailFolderMessagesMessageReplyAllRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeMailFoldersMailFolderMessagesMessageReplyAllExecute(r)
}

/*
MeMailFoldersMailFolderMessagesMessageReplyAll Invoke action replyAll

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param mailFolderId key: id of mailFolder
 @param messageId key: id of message
 @return ApiMeMailFoldersMailFolderMessagesMessageReplyAllRequest
*/
func (a *MeActionsApiService) MeMailFoldersMailFolderMessagesMessageReplyAll(ctx _context.Context, mailFolderId string, messageId string) ApiMeMailFoldersMailFolderMessagesMessageReplyAllRequest {
	return ApiMeMailFoldersMailFolderMessagesMessageReplyAllRequest{
		ApiService: a,
		ctx: ctx,
		mailFolderId: mailFolderId,
		messageId: messageId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeMailFoldersMailFolderMessagesMessageReplyAllExecute(r ApiMeMailFoldersMailFolderMessagesMessageReplyAllRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeMailFoldersMailFolderMessagesMessageReplyAll")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/mailFolders/{mailFolder-id}/messages/{message-id}/microsoft.graph.replyAll"
	localVarPath = strings.Replace(localVarPath, "{"+"mailFolder-id"+"}", _neturl.PathEscape(parameterToString(r.mailFolderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject568 == nil {
		return nil, reportError("inlineObject568 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject568
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeMailFoldersMailFolderMessagesMessageSendRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	mailFolderId string
	messageId string
}


func (r ApiMeMailFoldersMailFolderMessagesMessageSendRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeMailFoldersMailFolderMessagesMessageSendExecute(r)
}

/*
MeMailFoldersMailFolderMessagesMessageSend Invoke action send

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param mailFolderId key: id of mailFolder
 @param messageId key: id of message
 @return ApiMeMailFoldersMailFolderMessagesMessageSendRequest
*/
func (a *MeActionsApiService) MeMailFoldersMailFolderMessagesMessageSend(ctx _context.Context, mailFolderId string, messageId string) ApiMeMailFoldersMailFolderMessagesMessageSendRequest {
	return ApiMeMailFoldersMailFolderMessagesMessageSendRequest{
		ApiService: a,
		ctx: ctx,
		mailFolderId: mailFolderId,
		messageId: messageId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeMailFoldersMailFolderMessagesMessageSendExecute(r ApiMeMailFoldersMailFolderMessagesMessageSendRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeMailFoldersMailFolderMessagesMessageSend")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/mailFolders/{mailFolder-id}/messages/{message-id}/microsoft.graph.send"
	localVarPath = strings.Replace(localVarPath, "{"+"mailFolder-id"+"}", _neturl.PathEscape(parameterToString(r.mailFolderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeMailFoldersMailFolderMoveRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	mailFolderId string
	inlineObject570 *InlineObject570
}

func (r ApiMeMailFoldersMailFolderMoveRequest) InlineObject570(inlineObject570 InlineObject570) ApiMeMailFoldersMailFolderMoveRequest {
	r.inlineObject570 = &inlineObject570
	return r
}

func (r ApiMeMailFoldersMailFolderMoveRequest) Execute() (AnyOfmicrosoftGraphMailFolder, *_nethttp.Response, error) {
	return r.ApiService.MeMailFoldersMailFolderMoveExecute(r)
}

/*
MeMailFoldersMailFolderMove Invoke action move

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param mailFolderId key: id of mailFolder
 @return ApiMeMailFoldersMailFolderMoveRequest
*/
func (a *MeActionsApiService) MeMailFoldersMailFolderMove(ctx _context.Context, mailFolderId string) ApiMeMailFoldersMailFolderMoveRequest {
	return ApiMeMailFoldersMailFolderMoveRequest{
		ApiService: a,
		ctx: ctx,
		mailFolderId: mailFolderId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphMailFolder
func (a *MeActionsApiService) MeMailFoldersMailFolderMoveExecute(r ApiMeMailFoldersMailFolderMoveRequest) (AnyOfmicrosoftGraphMailFolder, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphMailFolder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeMailFoldersMailFolderMove")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/mailFolders/{mailFolder-id}/microsoft.graph.move"
	localVarPath = strings.Replace(localVarPath, "{"+"mailFolder-id"+"}", _neturl.PathEscape(parameterToString(r.mailFolderId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject570 == nil {
		return localVarReturnValue, nil, reportError("inlineObject570 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject570
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeManagedDevicesManagedDeviceBypassActivationLockRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	managedDeviceId string
}


func (r ApiMeManagedDevicesManagedDeviceBypassActivationLockRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeManagedDevicesManagedDeviceBypassActivationLockExecute(r)
}

/*
MeManagedDevicesManagedDeviceBypassActivationLock Invoke action bypassActivationLock

Bypass activation lock

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedDeviceId key: id of managedDevice
 @return ApiMeManagedDevicesManagedDeviceBypassActivationLockRequest
*/
func (a *MeActionsApiService) MeManagedDevicesManagedDeviceBypassActivationLock(ctx _context.Context, managedDeviceId string) ApiMeManagedDevicesManagedDeviceBypassActivationLockRequest {
	return ApiMeManagedDevicesManagedDeviceBypassActivationLockRequest{
		ApiService: a,
		ctx: ctx,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeManagedDevicesManagedDeviceBypassActivationLockExecute(r ApiMeManagedDevicesManagedDeviceBypassActivationLockRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeManagedDevicesManagedDeviceBypassActivationLock")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/managedDevices/{managedDevice-id}/microsoft.graph.bypassActivationLock"
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeManagedDevicesManagedDeviceCleanWindowsDeviceRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	managedDeviceId string
	inlineObject571 *InlineObject571
}

func (r ApiMeManagedDevicesManagedDeviceCleanWindowsDeviceRequest) InlineObject571(inlineObject571 InlineObject571) ApiMeManagedDevicesManagedDeviceCleanWindowsDeviceRequest {
	r.inlineObject571 = &inlineObject571
	return r
}

func (r ApiMeManagedDevicesManagedDeviceCleanWindowsDeviceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeManagedDevicesManagedDeviceCleanWindowsDeviceExecute(r)
}

/*
MeManagedDevicesManagedDeviceCleanWindowsDevice Invoke action cleanWindowsDevice

Clean Windows device

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedDeviceId key: id of managedDevice
 @return ApiMeManagedDevicesManagedDeviceCleanWindowsDeviceRequest
*/
func (a *MeActionsApiService) MeManagedDevicesManagedDeviceCleanWindowsDevice(ctx _context.Context, managedDeviceId string) ApiMeManagedDevicesManagedDeviceCleanWindowsDeviceRequest {
	return ApiMeManagedDevicesManagedDeviceCleanWindowsDeviceRequest{
		ApiService: a,
		ctx: ctx,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeManagedDevicesManagedDeviceCleanWindowsDeviceExecute(r ApiMeManagedDevicesManagedDeviceCleanWindowsDeviceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeManagedDevicesManagedDeviceCleanWindowsDevice")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/managedDevices/{managedDevice-id}/microsoft.graph.cleanWindowsDevice"
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject571 == nil {
		return nil, reportError("inlineObject571 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject571
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeManagedDevicesManagedDeviceDeleteUserFromSharedAppleDeviceRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	managedDeviceId string
	inlineObject572 *InlineObject572
}

func (r ApiMeManagedDevicesManagedDeviceDeleteUserFromSharedAppleDeviceRequest) InlineObject572(inlineObject572 InlineObject572) ApiMeManagedDevicesManagedDeviceDeleteUserFromSharedAppleDeviceRequest {
	r.inlineObject572 = &inlineObject572
	return r
}

func (r ApiMeManagedDevicesManagedDeviceDeleteUserFromSharedAppleDeviceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeManagedDevicesManagedDeviceDeleteUserFromSharedAppleDeviceExecute(r)
}

/*
MeManagedDevicesManagedDeviceDeleteUserFromSharedAppleDevice Invoke action deleteUserFromSharedAppleDevice

Delete user from shared Apple device

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedDeviceId key: id of managedDevice
 @return ApiMeManagedDevicesManagedDeviceDeleteUserFromSharedAppleDeviceRequest
*/
func (a *MeActionsApiService) MeManagedDevicesManagedDeviceDeleteUserFromSharedAppleDevice(ctx _context.Context, managedDeviceId string) ApiMeManagedDevicesManagedDeviceDeleteUserFromSharedAppleDeviceRequest {
	return ApiMeManagedDevicesManagedDeviceDeleteUserFromSharedAppleDeviceRequest{
		ApiService: a,
		ctx: ctx,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeManagedDevicesManagedDeviceDeleteUserFromSharedAppleDeviceExecute(r ApiMeManagedDevicesManagedDeviceDeleteUserFromSharedAppleDeviceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeManagedDevicesManagedDeviceDeleteUserFromSharedAppleDevice")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/managedDevices/{managedDevice-id}/microsoft.graph.deleteUserFromSharedAppleDevice"
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject572 == nil {
		return nil, reportError("inlineObject572 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject572
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeManagedDevicesManagedDeviceDisableLostModeRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	managedDeviceId string
}


func (r ApiMeManagedDevicesManagedDeviceDisableLostModeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeManagedDevicesManagedDeviceDisableLostModeExecute(r)
}

/*
MeManagedDevicesManagedDeviceDisableLostMode Invoke action disableLostMode

Disable lost mode

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedDeviceId key: id of managedDevice
 @return ApiMeManagedDevicesManagedDeviceDisableLostModeRequest
*/
func (a *MeActionsApiService) MeManagedDevicesManagedDeviceDisableLostMode(ctx _context.Context, managedDeviceId string) ApiMeManagedDevicesManagedDeviceDisableLostModeRequest {
	return ApiMeManagedDevicesManagedDeviceDisableLostModeRequest{
		ApiService: a,
		ctx: ctx,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeManagedDevicesManagedDeviceDisableLostModeExecute(r ApiMeManagedDevicesManagedDeviceDisableLostModeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeManagedDevicesManagedDeviceDisableLostMode")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/managedDevices/{managedDevice-id}/microsoft.graph.disableLostMode"
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeManagedDevicesManagedDeviceLocateDeviceRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	managedDeviceId string
}


func (r ApiMeManagedDevicesManagedDeviceLocateDeviceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeManagedDevicesManagedDeviceLocateDeviceExecute(r)
}

/*
MeManagedDevicesManagedDeviceLocateDevice Invoke action locateDevice

Locate a device

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedDeviceId key: id of managedDevice
 @return ApiMeManagedDevicesManagedDeviceLocateDeviceRequest
*/
func (a *MeActionsApiService) MeManagedDevicesManagedDeviceLocateDevice(ctx _context.Context, managedDeviceId string) ApiMeManagedDevicesManagedDeviceLocateDeviceRequest {
	return ApiMeManagedDevicesManagedDeviceLocateDeviceRequest{
		ApiService: a,
		ctx: ctx,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeManagedDevicesManagedDeviceLocateDeviceExecute(r ApiMeManagedDevicesManagedDeviceLocateDeviceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeManagedDevicesManagedDeviceLocateDevice")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/managedDevices/{managedDevice-id}/microsoft.graph.locateDevice"
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeManagedDevicesManagedDeviceLogoutSharedAppleDeviceActiveUserRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	managedDeviceId string
}


func (r ApiMeManagedDevicesManagedDeviceLogoutSharedAppleDeviceActiveUserRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeManagedDevicesManagedDeviceLogoutSharedAppleDeviceActiveUserExecute(r)
}

/*
MeManagedDevicesManagedDeviceLogoutSharedAppleDeviceActiveUser Invoke action logoutSharedAppleDeviceActiveUser

Logout shared Apple device active user

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedDeviceId key: id of managedDevice
 @return ApiMeManagedDevicesManagedDeviceLogoutSharedAppleDeviceActiveUserRequest
*/
func (a *MeActionsApiService) MeManagedDevicesManagedDeviceLogoutSharedAppleDeviceActiveUser(ctx _context.Context, managedDeviceId string) ApiMeManagedDevicesManagedDeviceLogoutSharedAppleDeviceActiveUserRequest {
	return ApiMeManagedDevicesManagedDeviceLogoutSharedAppleDeviceActiveUserRequest{
		ApiService: a,
		ctx: ctx,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeManagedDevicesManagedDeviceLogoutSharedAppleDeviceActiveUserExecute(r ApiMeManagedDevicesManagedDeviceLogoutSharedAppleDeviceActiveUserRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeManagedDevicesManagedDeviceLogoutSharedAppleDeviceActiveUser")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/managedDevices/{managedDevice-id}/microsoft.graph.logoutSharedAppleDeviceActiveUser"
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeManagedDevicesManagedDeviceRebootNowRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	managedDeviceId string
}


func (r ApiMeManagedDevicesManagedDeviceRebootNowRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeManagedDevicesManagedDeviceRebootNowExecute(r)
}

/*
MeManagedDevicesManagedDeviceRebootNow Invoke action rebootNow

Reboot device

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedDeviceId key: id of managedDevice
 @return ApiMeManagedDevicesManagedDeviceRebootNowRequest
*/
func (a *MeActionsApiService) MeManagedDevicesManagedDeviceRebootNow(ctx _context.Context, managedDeviceId string) ApiMeManagedDevicesManagedDeviceRebootNowRequest {
	return ApiMeManagedDevicesManagedDeviceRebootNowRequest{
		ApiService: a,
		ctx: ctx,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeManagedDevicesManagedDeviceRebootNowExecute(r ApiMeManagedDevicesManagedDeviceRebootNowRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeManagedDevicesManagedDeviceRebootNow")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/managedDevices/{managedDevice-id}/microsoft.graph.rebootNow"
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeManagedDevicesManagedDeviceRecoverPasscodeRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	managedDeviceId string
}


func (r ApiMeManagedDevicesManagedDeviceRecoverPasscodeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeManagedDevicesManagedDeviceRecoverPasscodeExecute(r)
}

/*
MeManagedDevicesManagedDeviceRecoverPasscode Invoke action recoverPasscode

Recover passcode

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedDeviceId key: id of managedDevice
 @return ApiMeManagedDevicesManagedDeviceRecoverPasscodeRequest
*/
func (a *MeActionsApiService) MeManagedDevicesManagedDeviceRecoverPasscode(ctx _context.Context, managedDeviceId string) ApiMeManagedDevicesManagedDeviceRecoverPasscodeRequest {
	return ApiMeManagedDevicesManagedDeviceRecoverPasscodeRequest{
		ApiService: a,
		ctx: ctx,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeManagedDevicesManagedDeviceRecoverPasscodeExecute(r ApiMeManagedDevicesManagedDeviceRecoverPasscodeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeManagedDevicesManagedDeviceRecoverPasscode")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/managedDevices/{managedDevice-id}/microsoft.graph.recoverPasscode"
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeManagedDevicesManagedDeviceRemoteLockRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	managedDeviceId string
}


func (r ApiMeManagedDevicesManagedDeviceRemoteLockRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeManagedDevicesManagedDeviceRemoteLockExecute(r)
}

/*
MeManagedDevicesManagedDeviceRemoteLock Invoke action remoteLock

Remote lock

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedDeviceId key: id of managedDevice
 @return ApiMeManagedDevicesManagedDeviceRemoteLockRequest
*/
func (a *MeActionsApiService) MeManagedDevicesManagedDeviceRemoteLock(ctx _context.Context, managedDeviceId string) ApiMeManagedDevicesManagedDeviceRemoteLockRequest {
	return ApiMeManagedDevicesManagedDeviceRemoteLockRequest{
		ApiService: a,
		ctx: ctx,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeManagedDevicesManagedDeviceRemoteLockExecute(r ApiMeManagedDevicesManagedDeviceRemoteLockRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeManagedDevicesManagedDeviceRemoteLock")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/managedDevices/{managedDevice-id}/microsoft.graph.remoteLock"
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeManagedDevicesManagedDeviceRequestRemoteAssistanceRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	managedDeviceId string
}


func (r ApiMeManagedDevicesManagedDeviceRequestRemoteAssistanceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeManagedDevicesManagedDeviceRequestRemoteAssistanceExecute(r)
}

/*
MeManagedDevicesManagedDeviceRequestRemoteAssistance Invoke action requestRemoteAssistance

Request remote assistance

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedDeviceId key: id of managedDevice
 @return ApiMeManagedDevicesManagedDeviceRequestRemoteAssistanceRequest
*/
func (a *MeActionsApiService) MeManagedDevicesManagedDeviceRequestRemoteAssistance(ctx _context.Context, managedDeviceId string) ApiMeManagedDevicesManagedDeviceRequestRemoteAssistanceRequest {
	return ApiMeManagedDevicesManagedDeviceRequestRemoteAssistanceRequest{
		ApiService: a,
		ctx: ctx,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeManagedDevicesManagedDeviceRequestRemoteAssistanceExecute(r ApiMeManagedDevicesManagedDeviceRequestRemoteAssistanceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeManagedDevicesManagedDeviceRequestRemoteAssistance")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/managedDevices/{managedDevice-id}/microsoft.graph.requestRemoteAssistance"
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeManagedDevicesManagedDeviceResetPasscodeRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	managedDeviceId string
}


func (r ApiMeManagedDevicesManagedDeviceResetPasscodeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeManagedDevicesManagedDeviceResetPasscodeExecute(r)
}

/*
MeManagedDevicesManagedDeviceResetPasscode Invoke action resetPasscode

Reset passcode

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedDeviceId key: id of managedDevice
 @return ApiMeManagedDevicesManagedDeviceResetPasscodeRequest
*/
func (a *MeActionsApiService) MeManagedDevicesManagedDeviceResetPasscode(ctx _context.Context, managedDeviceId string) ApiMeManagedDevicesManagedDeviceResetPasscodeRequest {
	return ApiMeManagedDevicesManagedDeviceResetPasscodeRequest{
		ApiService: a,
		ctx: ctx,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeManagedDevicesManagedDeviceResetPasscodeExecute(r ApiMeManagedDevicesManagedDeviceResetPasscodeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeManagedDevicesManagedDeviceResetPasscode")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/managedDevices/{managedDevice-id}/microsoft.graph.resetPasscode"
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeManagedDevicesManagedDeviceRetireRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	managedDeviceId string
}


func (r ApiMeManagedDevicesManagedDeviceRetireRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeManagedDevicesManagedDeviceRetireExecute(r)
}

/*
MeManagedDevicesManagedDeviceRetire Invoke action retire

Retire a device

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedDeviceId key: id of managedDevice
 @return ApiMeManagedDevicesManagedDeviceRetireRequest
*/
func (a *MeActionsApiService) MeManagedDevicesManagedDeviceRetire(ctx _context.Context, managedDeviceId string) ApiMeManagedDevicesManagedDeviceRetireRequest {
	return ApiMeManagedDevicesManagedDeviceRetireRequest{
		ApiService: a,
		ctx: ctx,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeManagedDevicesManagedDeviceRetireExecute(r ApiMeManagedDevicesManagedDeviceRetireRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeManagedDevicesManagedDeviceRetire")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/managedDevices/{managedDevice-id}/microsoft.graph.retire"
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeManagedDevicesManagedDeviceShutDownRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	managedDeviceId string
}


func (r ApiMeManagedDevicesManagedDeviceShutDownRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeManagedDevicesManagedDeviceShutDownExecute(r)
}

/*
MeManagedDevicesManagedDeviceShutDown Invoke action shutDown

Shut down device

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedDeviceId key: id of managedDevice
 @return ApiMeManagedDevicesManagedDeviceShutDownRequest
*/
func (a *MeActionsApiService) MeManagedDevicesManagedDeviceShutDown(ctx _context.Context, managedDeviceId string) ApiMeManagedDevicesManagedDeviceShutDownRequest {
	return ApiMeManagedDevicesManagedDeviceShutDownRequest{
		ApiService: a,
		ctx: ctx,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeManagedDevicesManagedDeviceShutDownExecute(r ApiMeManagedDevicesManagedDeviceShutDownRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeManagedDevicesManagedDeviceShutDown")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/managedDevices/{managedDevice-id}/microsoft.graph.shutDown"
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeManagedDevicesManagedDeviceSyncDeviceRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	managedDeviceId string
}


func (r ApiMeManagedDevicesManagedDeviceSyncDeviceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeManagedDevicesManagedDeviceSyncDeviceExecute(r)
}

/*
MeManagedDevicesManagedDeviceSyncDevice Invoke action syncDevice

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedDeviceId key: id of managedDevice
 @return ApiMeManagedDevicesManagedDeviceSyncDeviceRequest
*/
func (a *MeActionsApiService) MeManagedDevicesManagedDeviceSyncDevice(ctx _context.Context, managedDeviceId string) ApiMeManagedDevicesManagedDeviceSyncDeviceRequest {
	return ApiMeManagedDevicesManagedDeviceSyncDeviceRequest{
		ApiService: a,
		ctx: ctx,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeManagedDevicesManagedDeviceSyncDeviceExecute(r ApiMeManagedDevicesManagedDeviceSyncDeviceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeManagedDevicesManagedDeviceSyncDevice")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/managedDevices/{managedDevice-id}/microsoft.graph.syncDevice"
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeManagedDevicesManagedDeviceUpdateWindowsDeviceAccountRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	managedDeviceId string
	inlineObject573 *InlineObject573
}

func (r ApiMeManagedDevicesManagedDeviceUpdateWindowsDeviceAccountRequest) InlineObject573(inlineObject573 InlineObject573) ApiMeManagedDevicesManagedDeviceUpdateWindowsDeviceAccountRequest {
	r.inlineObject573 = &inlineObject573
	return r
}

func (r ApiMeManagedDevicesManagedDeviceUpdateWindowsDeviceAccountRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeManagedDevicesManagedDeviceUpdateWindowsDeviceAccountExecute(r)
}

/*
MeManagedDevicesManagedDeviceUpdateWindowsDeviceAccount Invoke action updateWindowsDeviceAccount

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedDeviceId key: id of managedDevice
 @return ApiMeManagedDevicesManagedDeviceUpdateWindowsDeviceAccountRequest
*/
func (a *MeActionsApiService) MeManagedDevicesManagedDeviceUpdateWindowsDeviceAccount(ctx _context.Context, managedDeviceId string) ApiMeManagedDevicesManagedDeviceUpdateWindowsDeviceAccountRequest {
	return ApiMeManagedDevicesManagedDeviceUpdateWindowsDeviceAccountRequest{
		ApiService: a,
		ctx: ctx,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeManagedDevicesManagedDeviceUpdateWindowsDeviceAccountExecute(r ApiMeManagedDevicesManagedDeviceUpdateWindowsDeviceAccountRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeManagedDevicesManagedDeviceUpdateWindowsDeviceAccount")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/managedDevices/{managedDevice-id}/microsoft.graph.updateWindowsDeviceAccount"
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject573 == nil {
		return nil, reportError("inlineObject573 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject573
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeManagedDevicesManagedDeviceWindowsDefenderScanRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	managedDeviceId string
	inlineObject574 *InlineObject574
}

func (r ApiMeManagedDevicesManagedDeviceWindowsDefenderScanRequest) InlineObject574(inlineObject574 InlineObject574) ApiMeManagedDevicesManagedDeviceWindowsDefenderScanRequest {
	r.inlineObject574 = &inlineObject574
	return r
}

func (r ApiMeManagedDevicesManagedDeviceWindowsDefenderScanRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeManagedDevicesManagedDeviceWindowsDefenderScanExecute(r)
}

/*
MeManagedDevicesManagedDeviceWindowsDefenderScan Invoke action windowsDefenderScan

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedDeviceId key: id of managedDevice
 @return ApiMeManagedDevicesManagedDeviceWindowsDefenderScanRequest
*/
func (a *MeActionsApiService) MeManagedDevicesManagedDeviceWindowsDefenderScan(ctx _context.Context, managedDeviceId string) ApiMeManagedDevicesManagedDeviceWindowsDefenderScanRequest {
	return ApiMeManagedDevicesManagedDeviceWindowsDefenderScanRequest{
		ApiService: a,
		ctx: ctx,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeManagedDevicesManagedDeviceWindowsDefenderScanExecute(r ApiMeManagedDevicesManagedDeviceWindowsDefenderScanRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeManagedDevicesManagedDeviceWindowsDefenderScan")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/managedDevices/{managedDevice-id}/microsoft.graph.windowsDefenderScan"
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject574 == nil {
		return nil, reportError("inlineObject574 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject574
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeManagedDevicesManagedDeviceWindowsDefenderUpdateSignaturesRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	managedDeviceId string
}


func (r ApiMeManagedDevicesManagedDeviceWindowsDefenderUpdateSignaturesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeManagedDevicesManagedDeviceWindowsDefenderUpdateSignaturesExecute(r)
}

/*
MeManagedDevicesManagedDeviceWindowsDefenderUpdateSignatures Invoke action windowsDefenderUpdateSignatures

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedDeviceId key: id of managedDevice
 @return ApiMeManagedDevicesManagedDeviceWindowsDefenderUpdateSignaturesRequest
*/
func (a *MeActionsApiService) MeManagedDevicesManagedDeviceWindowsDefenderUpdateSignatures(ctx _context.Context, managedDeviceId string) ApiMeManagedDevicesManagedDeviceWindowsDefenderUpdateSignaturesRequest {
	return ApiMeManagedDevicesManagedDeviceWindowsDefenderUpdateSignaturesRequest{
		ApiService: a,
		ctx: ctx,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeManagedDevicesManagedDeviceWindowsDefenderUpdateSignaturesExecute(r ApiMeManagedDevicesManagedDeviceWindowsDefenderUpdateSignaturesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeManagedDevicesManagedDeviceWindowsDefenderUpdateSignatures")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/managedDevices/{managedDevice-id}/microsoft.graph.windowsDefenderUpdateSignatures"
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeManagedDevicesManagedDeviceWipeRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	managedDeviceId string
	inlineObject575 *InlineObject575
}

func (r ApiMeManagedDevicesManagedDeviceWipeRequest) InlineObject575(inlineObject575 InlineObject575) ApiMeManagedDevicesManagedDeviceWipeRequest {
	r.inlineObject575 = &inlineObject575
	return r
}

func (r ApiMeManagedDevicesManagedDeviceWipeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeManagedDevicesManagedDeviceWipeExecute(r)
}

/*
MeManagedDevicesManagedDeviceWipe Invoke action wipe

Wipe a device

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param managedDeviceId key: id of managedDevice
 @return ApiMeManagedDevicesManagedDeviceWipeRequest
*/
func (a *MeActionsApiService) MeManagedDevicesManagedDeviceWipe(ctx _context.Context, managedDeviceId string) ApiMeManagedDevicesManagedDeviceWipeRequest {
	return ApiMeManagedDevicesManagedDeviceWipeRequest{
		ApiService: a,
		ctx: ctx,
		managedDeviceId: managedDeviceId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeManagedDevicesManagedDeviceWipeExecute(r ApiMeManagedDevicesManagedDeviceWipeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeManagedDevicesManagedDeviceWipe")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/managedDevices/{managedDevice-id}/microsoft.graph.wipe"
	localVarPath = strings.Replace(localVarPath, "{"+"managedDevice-id"+"}", _neturl.PathEscape(parameterToString(r.managedDeviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject575 == nil {
		return nil, reportError("inlineObject575 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject575
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeMessagesMessageAttachmentsCreateUploadSessionRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	messageId string
	inlineObject576 *InlineObject576
}

func (r ApiMeMessagesMessageAttachmentsCreateUploadSessionRequest) InlineObject576(inlineObject576 InlineObject576) ApiMeMessagesMessageAttachmentsCreateUploadSessionRequest {
	r.inlineObject576 = &inlineObject576
	return r
}

func (r ApiMeMessagesMessageAttachmentsCreateUploadSessionRequest) Execute() (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	return r.ApiService.MeMessagesMessageAttachmentsCreateUploadSessionExecute(r)
}

/*
MeMessagesMessageAttachmentsCreateUploadSession Invoke action createUploadSession

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param messageId key: id of message
 @return ApiMeMessagesMessageAttachmentsCreateUploadSessionRequest
*/
func (a *MeActionsApiService) MeMessagesMessageAttachmentsCreateUploadSession(ctx _context.Context, messageId string) ApiMeMessagesMessageAttachmentsCreateUploadSessionRequest {
	return ApiMeMessagesMessageAttachmentsCreateUploadSessionRequest{
		ApiService: a,
		ctx: ctx,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphUploadSession
func (a *MeActionsApiService) MeMessagesMessageAttachmentsCreateUploadSessionExecute(r ApiMeMessagesMessageAttachmentsCreateUploadSessionRequest) (AnyOfmicrosoftGraphUploadSession, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphUploadSession
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeMessagesMessageAttachmentsCreateUploadSession")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/messages/{message-id}/attachments/microsoft.graph.createUploadSession"
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject576 == nil {
		return localVarReturnValue, nil, reportError("inlineObject576 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject576
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeMessagesMessageCopyRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	messageId string
	inlineObject577 *InlineObject577
}

func (r ApiMeMessagesMessageCopyRequest) InlineObject577(inlineObject577 InlineObject577) ApiMeMessagesMessageCopyRequest {
	r.inlineObject577 = &inlineObject577
	return r
}

func (r ApiMeMessagesMessageCopyRequest) Execute() (AnyOfmicrosoftGraphMessage, *_nethttp.Response, error) {
	return r.ApiService.MeMessagesMessageCopyExecute(r)
}

/*
MeMessagesMessageCopy Invoke action copy

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param messageId key: id of message
 @return ApiMeMessagesMessageCopyRequest
*/
func (a *MeActionsApiService) MeMessagesMessageCopy(ctx _context.Context, messageId string) ApiMeMessagesMessageCopyRequest {
	return ApiMeMessagesMessageCopyRequest{
		ApiService: a,
		ctx: ctx,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphMessage
func (a *MeActionsApiService) MeMessagesMessageCopyExecute(r ApiMeMessagesMessageCopyRequest) (AnyOfmicrosoftGraphMessage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeMessagesMessageCopy")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/messages/{message-id}/microsoft.graph.copy"
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject577 == nil {
		return localVarReturnValue, nil, reportError("inlineObject577 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject577
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeMessagesMessageCreateForwardRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	messageId string
	inlineObject578 *InlineObject578
}

func (r ApiMeMessagesMessageCreateForwardRequest) InlineObject578(inlineObject578 InlineObject578) ApiMeMessagesMessageCreateForwardRequest {
	r.inlineObject578 = &inlineObject578
	return r
}

func (r ApiMeMessagesMessageCreateForwardRequest) Execute() (AnyOfmicrosoftGraphMessage, *_nethttp.Response, error) {
	return r.ApiService.MeMessagesMessageCreateForwardExecute(r)
}

/*
MeMessagesMessageCreateForward Invoke action createForward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param messageId key: id of message
 @return ApiMeMessagesMessageCreateForwardRequest
*/
func (a *MeActionsApiService) MeMessagesMessageCreateForward(ctx _context.Context, messageId string) ApiMeMessagesMessageCreateForwardRequest {
	return ApiMeMessagesMessageCreateForwardRequest{
		ApiService: a,
		ctx: ctx,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphMessage
func (a *MeActionsApiService) MeMessagesMessageCreateForwardExecute(r ApiMeMessagesMessageCreateForwardRequest) (AnyOfmicrosoftGraphMessage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeMessagesMessageCreateForward")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/messages/{message-id}/microsoft.graph.createForward"
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject578 == nil {
		return localVarReturnValue, nil, reportError("inlineObject578 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject578
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeMessagesMessageCreateReplyRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	messageId string
	inlineObject579 *InlineObject579
}

func (r ApiMeMessagesMessageCreateReplyRequest) InlineObject579(inlineObject579 InlineObject579) ApiMeMessagesMessageCreateReplyRequest {
	r.inlineObject579 = &inlineObject579
	return r
}

func (r ApiMeMessagesMessageCreateReplyRequest) Execute() (AnyOfmicrosoftGraphMessage, *_nethttp.Response, error) {
	return r.ApiService.MeMessagesMessageCreateReplyExecute(r)
}

/*
MeMessagesMessageCreateReply Invoke action createReply

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param messageId key: id of message
 @return ApiMeMessagesMessageCreateReplyRequest
*/
func (a *MeActionsApiService) MeMessagesMessageCreateReply(ctx _context.Context, messageId string) ApiMeMessagesMessageCreateReplyRequest {
	return ApiMeMessagesMessageCreateReplyRequest{
		ApiService: a,
		ctx: ctx,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphMessage
func (a *MeActionsApiService) MeMessagesMessageCreateReplyExecute(r ApiMeMessagesMessageCreateReplyRequest) (AnyOfmicrosoftGraphMessage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeMessagesMessageCreateReply")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/messages/{message-id}/microsoft.graph.createReply"
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject579 == nil {
		return localVarReturnValue, nil, reportError("inlineObject579 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject579
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeMessagesMessageCreateReplyAllRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	messageId string
	inlineObject580 *InlineObject580
}

func (r ApiMeMessagesMessageCreateReplyAllRequest) InlineObject580(inlineObject580 InlineObject580) ApiMeMessagesMessageCreateReplyAllRequest {
	r.inlineObject580 = &inlineObject580
	return r
}

func (r ApiMeMessagesMessageCreateReplyAllRequest) Execute() (AnyOfmicrosoftGraphMessage, *_nethttp.Response, error) {
	return r.ApiService.MeMessagesMessageCreateReplyAllExecute(r)
}

/*
MeMessagesMessageCreateReplyAll Invoke action createReplyAll

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param messageId key: id of message
 @return ApiMeMessagesMessageCreateReplyAllRequest
*/
func (a *MeActionsApiService) MeMessagesMessageCreateReplyAll(ctx _context.Context, messageId string) ApiMeMessagesMessageCreateReplyAllRequest {
	return ApiMeMessagesMessageCreateReplyAllRequest{
		ApiService: a,
		ctx: ctx,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphMessage
func (a *MeActionsApiService) MeMessagesMessageCreateReplyAllExecute(r ApiMeMessagesMessageCreateReplyAllRequest) (AnyOfmicrosoftGraphMessage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeMessagesMessageCreateReplyAll")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/messages/{message-id}/microsoft.graph.createReplyAll"
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject580 == nil {
		return localVarReturnValue, nil, reportError("inlineObject580 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject580
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeMessagesMessageForwardRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	messageId string
	inlineObject581 *InlineObject581
}

func (r ApiMeMessagesMessageForwardRequest) InlineObject581(inlineObject581 InlineObject581) ApiMeMessagesMessageForwardRequest {
	r.inlineObject581 = &inlineObject581
	return r
}

func (r ApiMeMessagesMessageForwardRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeMessagesMessageForwardExecute(r)
}

/*
MeMessagesMessageForward Invoke action forward

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param messageId key: id of message
 @return ApiMeMessagesMessageForwardRequest
*/
func (a *MeActionsApiService) MeMessagesMessageForward(ctx _context.Context, messageId string) ApiMeMessagesMessageForwardRequest {
	return ApiMeMessagesMessageForwardRequest{
		ApiService: a,
		ctx: ctx,
		messageId: messageId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeMessagesMessageForwardExecute(r ApiMeMessagesMessageForwardRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeMessagesMessageForward")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/messages/{message-id}/microsoft.graph.forward"
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject581 == nil {
		return nil, reportError("inlineObject581 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject581
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeMessagesMessageMicrosoftGraphCalendarSharingMessageAcceptRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	messageId string
}


func (r ApiMeMessagesMessageMicrosoftGraphCalendarSharingMessageAcceptRequest) Execute() (MicrosoftGraphCalendar, *_nethttp.Response, error) {
	return r.ApiService.MeMessagesMessageMicrosoftGraphCalendarSharingMessageAcceptExecute(r)
}

/*
MeMessagesMessageMicrosoftGraphCalendarSharingMessageAccept Invoke action accept

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param messageId key: id of message
 @return ApiMeMessagesMessageMicrosoftGraphCalendarSharingMessageAcceptRequest
*/
func (a *MeActionsApiService) MeMessagesMessageMicrosoftGraphCalendarSharingMessageAccept(ctx _context.Context, messageId string) ApiMeMessagesMessageMicrosoftGraphCalendarSharingMessageAcceptRequest {
	return ApiMeMessagesMessageMicrosoftGraphCalendarSharingMessageAcceptRequest{
		ApiService: a,
		ctx: ctx,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphCalendar
func (a *MeActionsApiService) MeMessagesMessageMicrosoftGraphCalendarSharingMessageAcceptExecute(r ApiMeMessagesMessageMicrosoftGraphCalendarSharingMessageAcceptRequest) (MicrosoftGraphCalendar, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphCalendar
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeMessagesMessageMicrosoftGraphCalendarSharingMessageAccept")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/messages/{message-id}/microsoft.graph.calendarSharingMessage/microsoft.graph.accept"
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeMessagesMessageMoveRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	messageId string
	inlineObject582 *InlineObject582
}

func (r ApiMeMessagesMessageMoveRequest) InlineObject582(inlineObject582 InlineObject582) ApiMeMessagesMessageMoveRequest {
	r.inlineObject582 = &inlineObject582
	return r
}

func (r ApiMeMessagesMessageMoveRequest) Execute() (AnyOfmicrosoftGraphMessage, *_nethttp.Response, error) {
	return r.ApiService.MeMessagesMessageMoveExecute(r)
}

/*
MeMessagesMessageMove Invoke action move

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param messageId key: id of message
 @return ApiMeMessagesMessageMoveRequest
*/
func (a *MeActionsApiService) MeMessagesMessageMove(ctx _context.Context, messageId string) ApiMeMessagesMessageMoveRequest {
	return ApiMeMessagesMessageMoveRequest{
		ApiService: a,
		ctx: ctx,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphMessage
func (a *MeActionsApiService) MeMessagesMessageMoveExecute(r ApiMeMessagesMessageMoveRequest) (AnyOfmicrosoftGraphMessage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeMessagesMessageMove")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/messages/{message-id}/microsoft.graph.move"
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject582 == nil {
		return localVarReturnValue, nil, reportError("inlineObject582 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject582
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeMessagesMessageReplyRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	messageId string
	inlineObject583 *InlineObject583
}

func (r ApiMeMessagesMessageReplyRequest) InlineObject583(inlineObject583 InlineObject583) ApiMeMessagesMessageReplyRequest {
	r.inlineObject583 = &inlineObject583
	return r
}

func (r ApiMeMessagesMessageReplyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeMessagesMessageReplyExecute(r)
}

/*
MeMessagesMessageReply Invoke action reply

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param messageId key: id of message
 @return ApiMeMessagesMessageReplyRequest
*/
func (a *MeActionsApiService) MeMessagesMessageReply(ctx _context.Context, messageId string) ApiMeMessagesMessageReplyRequest {
	return ApiMeMessagesMessageReplyRequest{
		ApiService: a,
		ctx: ctx,
		messageId: messageId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeMessagesMessageReplyExecute(r ApiMeMessagesMessageReplyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeMessagesMessageReply")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/messages/{message-id}/microsoft.graph.reply"
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject583 == nil {
		return nil, reportError("inlineObject583 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject583
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeMessagesMessageReplyAllRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	messageId string
	inlineObject584 *InlineObject584
}

func (r ApiMeMessagesMessageReplyAllRequest) InlineObject584(inlineObject584 InlineObject584) ApiMeMessagesMessageReplyAllRequest {
	r.inlineObject584 = &inlineObject584
	return r
}

func (r ApiMeMessagesMessageReplyAllRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeMessagesMessageReplyAllExecute(r)
}

/*
MeMessagesMessageReplyAll Invoke action replyAll

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param messageId key: id of message
 @return ApiMeMessagesMessageReplyAllRequest
*/
func (a *MeActionsApiService) MeMessagesMessageReplyAll(ctx _context.Context, messageId string) ApiMeMessagesMessageReplyAllRequest {
	return ApiMeMessagesMessageReplyAllRequest{
		ApiService: a,
		ctx: ctx,
		messageId: messageId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeMessagesMessageReplyAllExecute(r ApiMeMessagesMessageReplyAllRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeMessagesMessageReplyAll")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/messages/{message-id}/microsoft.graph.replyAll"
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject584 == nil {
		return nil, reportError("inlineObject584 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject584
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeMessagesMessageSendRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	messageId string
}


func (r ApiMeMessagesMessageSendRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeMessagesMessageSendExecute(r)
}

/*
MeMessagesMessageSend Invoke action send

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param messageId key: id of message
 @return ApiMeMessagesMessageSendRequest
*/
func (a *MeActionsApiService) MeMessagesMessageSend(ctx _context.Context, messageId string) ApiMeMessagesMessageSendRequest {
	return ApiMeMessagesMessageSendRequest{
		ApiService: a,
		ctx: ctx,
		messageId: messageId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeMessagesMessageSendExecute(r ApiMeMessagesMessageSendRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeMessagesMessageSend")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/messages/{message-id}/microsoft.graph.send"
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeOnenoteNotebooksGetNotebookFromWebUrlRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	inlineObject618 *InlineObject618
}

func (r ApiMeOnenoteNotebooksGetNotebookFromWebUrlRequest) InlineObject618(inlineObject618 InlineObject618) ApiMeOnenoteNotebooksGetNotebookFromWebUrlRequest {
	r.inlineObject618 = &inlineObject618
	return r
}

func (r ApiMeOnenoteNotebooksGetNotebookFromWebUrlRequest) Execute() (AnyOfmicrosoftGraphCopyNotebookModel, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteNotebooksGetNotebookFromWebUrlExecute(r)
}

/*
MeOnenoteNotebooksGetNotebookFromWebUrl Invoke action getNotebookFromWebUrl

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMeOnenoteNotebooksGetNotebookFromWebUrlRequest
*/
func (a *MeActionsApiService) MeOnenoteNotebooksGetNotebookFromWebUrl(ctx _context.Context) ApiMeOnenoteNotebooksGetNotebookFromWebUrlRequest {
	return ApiMeOnenoteNotebooksGetNotebookFromWebUrlRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphCopyNotebookModel
func (a *MeActionsApiService) MeOnenoteNotebooksGetNotebookFromWebUrlExecute(r ApiMeOnenoteNotebooksGetNotebookFromWebUrlRequest) (AnyOfmicrosoftGraphCopyNotebookModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphCopyNotebookModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteNotebooksGetNotebookFromWebUrl")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/notebooks/microsoft.graph.getNotebookFromWebUrl"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject618 == nil {
		return localVarReturnValue, nil, reportError("inlineObject618 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject618
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteNotebooksNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	notebookId string
	inlineObject597 *InlineObject597
}

func (r ApiMeOnenoteNotebooksNotebookCopyNotebookRequest) InlineObject597(inlineObject597 InlineObject597) ApiMeOnenoteNotebooksNotebookCopyNotebookRequest {
	r.inlineObject597 = &inlineObject597
	return r
}

func (r ApiMeOnenoteNotebooksNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteNotebooksNotebookCopyNotebookExecute(r)
}

/*
MeOnenoteNotebooksNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param notebookId key: id of notebook
 @return ApiMeOnenoteNotebooksNotebookCopyNotebookRequest
*/
func (a *MeActionsApiService) MeOnenoteNotebooksNotebookCopyNotebook(ctx _context.Context, notebookId string) ApiMeOnenoteNotebooksNotebookCopyNotebookRequest {
	return ApiMeOnenoteNotebooksNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		notebookId: notebookId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteNotebooksNotebookCopyNotebookExecute(r ApiMeOnenoteNotebooksNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteNotebooksNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/notebooks/{notebook-id}/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject597 == nil {
		return localVarReturnValue, nil, reportError("inlineObject597 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject597
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	notebookId string
	sectionGroupId string
	inlineObject598 *InlineObject598
}

func (r ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) InlineObject598(inlineObject598 InlineObject598) ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest {
	r.inlineObject598 = &inlineObject598
	return r
}

func (r ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteNotebooksNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookExecute(r)
}

/*
MeOnenoteNotebooksNotebookSectionGroupsSectionGroupParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param notebookId key: id of notebook
 @param sectionGroupId key: id of sectionGroup
 @return ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest
*/
func (a *MeActionsApiService) MeOnenoteNotebooksNotebookSectionGroupsSectionGroupParentNotebookCopyNotebook(ctx _context.Context, notebookId string, sectionGroupId string) ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest {
	return ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		notebookId: notebookId,
		sectionGroupId: sectionGroupId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteNotebooksNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookExecute(r ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteNotebooksNotebookSectionGroupsSectionGroupParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/notebooks/{notebook-id}/sectionGroups/{sectionGroup-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject598 == nil {
		return localVarReturnValue, nil, reportError("inlineObject598 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject598
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	notebookId string
	sectionGroupId string
	onenoteSectionId string
	inlineObject599 *InlineObject599
}

func (r ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) InlineObject599(inlineObject599 InlineObject599) ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject599 = &inlineObject599
	return r
}

func (r ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
MeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param notebookId key: id of notebook
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @return ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *MeActionsApiService) MeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, notebookId string, sectionGroupId string, onenoteSectionId string) ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		notebookId: notebookId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/notebooks/{notebook-id}/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject599 == nil {
		return localVarReturnValue, nil, reportError("inlineObject599 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject599
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	notebookId string
	sectionGroupId string
	onenoteSectionId string
	inlineObject600 *InlineObject600
}

func (r ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject600(inlineObject600 InlineObject600) ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject600 = &inlineObject600
	return r
}

func (r ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
MeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param notebookId key: id of notebook
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @return ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *MeActionsApiService) MeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, notebookId string, sectionGroupId string, onenoteSectionId string) ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		notebookId: notebookId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/notebooks/{notebook-id}/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject600 == nil {
		return localVarReturnValue, nil, reportError("inlineObject600 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject600
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	notebookId string
	sectionGroupId string
	onenoteSectionId string
	onenotePageId string
	inlineObject601 *InlineObject601
}

func (r ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) InlineObject601(inlineObject601 InlineObject601) ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest {
	r.inlineObject601 = &inlineObject601
	return r
}

func (r ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionExecute(r)
}

/*
MeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSection Invoke action copyToSection

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param notebookId key: id of notebook
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest
*/
func (a *MeActionsApiService) MeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSection(ctx _context.Context, notebookId string, sectionGroupId string, onenoteSectionId string, onenotePageId string) ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest {
	return ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest{
		ApiService: a,
		ctx: ctx,
		notebookId: notebookId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionExecute(r ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSection")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/notebooks/{notebook-id}/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/pages/{onenotePage-id}/microsoft.graph.copyToSection"
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject601 == nil {
		return localVarReturnValue, nil, reportError("inlineObject601 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject601
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	notebookId string
	sectionGroupId string
	onenoteSectionId string
	onenotePageId string
	inlineObject602 *InlineObject602
}

func (r ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) InlineObject602(inlineObject602 InlineObject602) ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest {
	r.inlineObject602 = &inlineObject602
	return r
}

func (r ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentExecute(r)
}

/*
MeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent Invoke action onenotePatchContent

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param notebookId key: id of notebook
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest
*/
func (a *MeActionsApiService) MeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent(ctx _context.Context, notebookId string, sectionGroupId string, onenoteSectionId string, onenotePageId string) ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest {
	return ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest{
		ApiService: a,
		ctx: ctx,
		notebookId: notebookId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentExecute(r ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/notebooks/{notebook-id}/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/pages/{onenotePage-id}/microsoft.graph.onenotePatchContent"
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject602 == nil {
		return nil, reportError("inlineObject602 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject602
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	notebookId string
	sectionGroupId string
	onenoteSectionId string
	onenotePageId string
	inlineObject603 *InlineObject603
}

func (r ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest) InlineObject603(inlineObject603 InlineObject603) ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest {
	r.inlineObject603 = &inlineObject603
	return r
}

func (r ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookExecute(r)
}

/*
MeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param notebookId key: id of notebook
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest
*/
func (a *MeActionsApiService) MeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebook(ctx _context.Context, notebookId string, sectionGroupId string, onenoteSectionId string, onenotePageId string) ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest {
	return ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		notebookId: notebookId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookExecute(r ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/notebooks/{notebook-id}/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject603 == nil {
		return localVarReturnValue, nil, reportError("inlineObject603 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject603
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	notebookId string
	sectionGroupId string
	onenoteSectionId string
	onenotePageId string
	inlineObject604 *InlineObject604
}

func (r ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest) InlineObject604(inlineObject604 InlineObject604) ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest {
	r.inlineObject604 = &inlineObject604
	return r
}

func (r ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookExecute(r)
}

/*
MeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param notebookId key: id of notebook
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest
*/
func (a *MeActionsApiService) MeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebook(ctx _context.Context, notebookId string, sectionGroupId string, onenoteSectionId string, onenotePageId string) ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest {
	return ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		notebookId: notebookId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookExecute(r ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/notebooks/{notebook-id}/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentSection/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject604 == nil {
		return localVarReturnValue, nil, reportError("inlineObject604 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject604
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	notebookId string
	sectionGroupId string
	onenoteSectionId string
	onenotePageId string
	inlineObject605 *InlineObject605
}

func (r ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest) InlineObject605(inlineObject605 InlineObject605) ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest {
	r.inlineObject605 = &inlineObject605
	return r
}

func (r ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupExecute(r)
}

/*
MeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param notebookId key: id of notebook
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest
*/
func (a *MeActionsApiService) MeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroup(ctx _context.Context, notebookId string, sectionGroupId string, onenoteSectionId string, onenotePageId string) ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest {
	return ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		notebookId: notebookId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupExecute(r ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/notebooks/{notebook-id}/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentSection/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject605 == nil {
		return localVarReturnValue, nil, reportError("inlineObject605 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject605
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	notebookId string
	sectionGroupId string
	onenoteSectionId string
	inlineObject606 *InlineObject606
}

func (r ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest) InlineObject606(inlineObject606 InlineObject606) ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest {
	r.inlineObject606 = &inlineObject606
	return r
}

func (r ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookExecute(r)
}

/*
MeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param notebookId key: id of notebook
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @return ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest
*/
func (a *MeActionsApiService) MeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebook(ctx _context.Context, notebookId string, sectionGroupId string, onenoteSectionId string) ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest {
	return ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		notebookId: notebookId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookExecute(r ApiMeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteNotebooksNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/notebooks/{notebook-id}/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject606 == nil {
		return localVarReturnValue, nil, reportError("inlineObject606 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject606
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	notebookId string
	onenoteSectionId string
	inlineObject607 *InlineObject607
}

func (r ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToNotebookRequest) InlineObject607(inlineObject607 InlineObject607) ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject607 = &inlineObject607
	return r
}

func (r ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
MeOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param notebookId key: id of notebook
 @param onenoteSectionId key: id of onenoteSection
 @return ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *MeActionsApiService) MeOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, notebookId string, onenoteSectionId string) ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		notebookId: notebookId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToNotebookExecute(r ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/notebooks/{notebook-id}/sections/{onenoteSection-id}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject607 == nil {
		return localVarReturnValue, nil, reportError("inlineObject607 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject607
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	notebookId string
	onenoteSectionId string
	inlineObject608 *InlineObject608
}

func (r ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject608(inlineObject608 InlineObject608) ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject608 = &inlineObject608
	return r
}

func (r ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
MeOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param notebookId key: id of notebook
 @param onenoteSectionId key: id of onenoteSection
 @return ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *MeActionsApiService) MeOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, notebookId string, onenoteSectionId string) ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		notebookId: notebookId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteNotebooksNotebookSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/notebooks/{notebook-id}/sections/{onenoteSection-id}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject608 == nil {
		return localVarReturnValue, nil, reportError("inlineObject608 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject608
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	notebookId string
	onenoteSectionId string
	onenotePageId string
	inlineObject609 *InlineObject609
}

func (r ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) InlineObject609(inlineObject609 InlineObject609) ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest {
	r.inlineObject609 = &inlineObject609
	return r
}

func (r ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionExecute(r)
}

/*
MeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSection Invoke action copyToSection

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param notebookId key: id of notebook
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest
*/
func (a *MeActionsApiService) MeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSection(ctx _context.Context, notebookId string, onenoteSectionId string, onenotePageId string) ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest {
	return ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest{
		ApiService: a,
		ctx: ctx,
		notebookId: notebookId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionExecute(r ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSection")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/notebooks/{notebook-id}/sections/{onenoteSection-id}/pages/{onenotePage-id}/microsoft.graph.copyToSection"
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject609 == nil {
		return localVarReturnValue, nil, reportError("inlineObject609 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject609
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	notebookId string
	onenoteSectionId string
	onenotePageId string
	inlineObject610 *InlineObject610
}

func (r ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) InlineObject610(inlineObject610 InlineObject610) ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest {
	r.inlineObject610 = &inlineObject610
	return r
}

func (r ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentExecute(r)
}

/*
MeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent Invoke action onenotePatchContent

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param notebookId key: id of notebook
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest
*/
func (a *MeActionsApiService) MeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent(ctx _context.Context, notebookId string, onenoteSectionId string, onenotePageId string) ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest {
	return ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest{
		ApiService: a,
		ctx: ctx,
		notebookId: notebookId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentExecute(r ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/notebooks/{notebook-id}/sections/{onenoteSection-id}/pages/{onenotePage-id}/microsoft.graph.onenotePatchContent"
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject610 == nil {
		return nil, reportError("inlineObject610 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject610
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	notebookId string
	onenoteSectionId string
	onenotePageId string
	inlineObject611 *InlineObject611
}

func (r ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest) InlineObject611(inlineObject611 InlineObject611) ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest {
	r.inlineObject611 = &inlineObject611
	return r
}

func (r ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookExecute(r)
}

/*
MeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param notebookId key: id of notebook
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest
*/
func (a *MeActionsApiService) MeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebook(ctx _context.Context, notebookId string, onenoteSectionId string, onenotePageId string) ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest {
	return ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		notebookId: notebookId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookExecute(r ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/notebooks/{notebook-id}/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject611 == nil {
		return localVarReturnValue, nil, reportError("inlineObject611 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject611
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	notebookId string
	onenoteSectionId string
	onenotePageId string
	inlineObject612 *InlineObject612
}

func (r ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest) InlineObject612(inlineObject612 InlineObject612) ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest {
	r.inlineObject612 = &inlineObject612
	return r
}

func (r ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookExecute(r)
}

/*
MeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param notebookId key: id of notebook
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest
*/
func (a *MeActionsApiService) MeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebook(ctx _context.Context, notebookId string, onenoteSectionId string, onenotePageId string) ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest {
	return ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		notebookId: notebookId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookExecute(r ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/notebooks/{notebook-id}/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentSection/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject612 == nil {
		return localVarReturnValue, nil, reportError("inlineObject612 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject612
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	notebookId string
	onenoteSectionId string
	onenotePageId string
	inlineObject613 *InlineObject613
}

func (r ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest) InlineObject613(inlineObject613 InlineObject613) ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest {
	r.inlineObject613 = &inlineObject613
	return r
}

func (r ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupExecute(r)
}

/*
MeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param notebookId key: id of notebook
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest
*/
func (a *MeActionsApiService) MeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroup(ctx _context.Context, notebookId string, onenoteSectionId string, onenotePageId string) ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest {
	return ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		notebookId: notebookId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupExecute(r ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteNotebooksNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/notebooks/{notebook-id}/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentSection/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject613 == nil {
		return localVarReturnValue, nil, reportError("inlineObject613 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject613
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	notebookId string
	onenoteSectionId string
	inlineObject614 *InlineObject614
}

func (r ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest) InlineObject614(inlineObject614 InlineObject614) ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest {
	r.inlineObject614 = &inlineObject614
	return r
}

func (r ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteNotebooksNotebookSectionsOnenoteSectionParentNotebookCopyNotebookExecute(r)
}

/*
MeOnenoteNotebooksNotebookSectionsOnenoteSectionParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param notebookId key: id of notebook
 @param onenoteSectionId key: id of onenoteSection
 @return ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest
*/
func (a *MeActionsApiService) MeOnenoteNotebooksNotebookSectionsOnenoteSectionParentNotebookCopyNotebook(ctx _context.Context, notebookId string, onenoteSectionId string) ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest {
	return ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		notebookId: notebookId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteNotebooksNotebookSectionsOnenoteSectionParentNotebookCopyNotebookExecute(r ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteNotebooksNotebookSectionsOnenoteSectionParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/notebooks/{notebook-id}/sections/{onenoteSection-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject614 == nil {
		return localVarReturnValue, nil, reportError("inlineObject614 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject614
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	notebookId string
	onenoteSectionId string
	inlineObject615 *InlineObject615
}

func (r ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest) InlineObject615(inlineObject615 InlineObject615) ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest {
	r.inlineObject615 = &inlineObject615
	return r
}

func (r ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookExecute(r)
}

/*
MeOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param notebookId key: id of notebook
 @param onenoteSectionId key: id of onenoteSection
 @return ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest
*/
func (a *MeActionsApiService) MeOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebook(ctx _context.Context, notebookId string, onenoteSectionId string) ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest {
	return ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		notebookId: notebookId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookExecute(r ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/notebooks/{notebook-id}/sections/{onenoteSection-id}/parentSectionGroup/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject615 == nil {
		return localVarReturnValue, nil, reportError("inlineObject615 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject615
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	notebookId string
	onenoteSectionId string
	onenoteSectionId1 string
	inlineObject616 *InlineObject616
}

func (r ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) InlineObject616(inlineObject616 InlineObject616) ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject616 = &inlineObject616
	return r
}

func (r ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
MeOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param notebookId key: id of notebook
 @param onenoteSectionId key: id of onenoteSection
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *MeActionsApiService) MeOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, notebookId string, onenoteSectionId string, onenoteSectionId1 string) ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		notebookId: notebookId,
		onenoteSectionId: onenoteSectionId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/notebooks/{notebook-id}/sections/{onenoteSection-id}/parentSectionGroup/sections/{onenoteSection-id1}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject616 == nil {
		return localVarReturnValue, nil, reportError("inlineObject616 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject616
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	notebookId string
	onenoteSectionId string
	onenoteSectionId1 string
	inlineObject617 *InlineObject617
}

func (r ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject617(inlineObject617 InlineObject617) ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject617 = &inlineObject617
	return r
}

func (r ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
MeOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param notebookId key: id of notebook
 @param onenoteSectionId key: id of onenoteSection
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *MeActionsApiService) MeOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, notebookId string, onenoteSectionId string, onenoteSectionId1 string) ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		notebookId: notebookId,
		onenoteSectionId: onenoteSectionId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiMeOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteNotebooksNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/notebooks/{notebook-id}/sections/{onenoteSection-id}/parentSectionGroup/sections/{onenoteSection-id1}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"notebook-id"+"}", _neturl.PathEscape(parameterToString(r.notebookId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject617 == nil {
		return localVarReturnValue, nil, reportError("inlineObject617 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject617
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenotePagesOnenotePageCopyToSectionRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenotePageId string
	inlineObject619 *InlineObject619
}

func (r ApiMeOnenotePagesOnenotePageCopyToSectionRequest) InlineObject619(inlineObject619 InlineObject619) ApiMeOnenotePagesOnenotePageCopyToSectionRequest {
	r.inlineObject619 = &inlineObject619
	return r
}

func (r ApiMeOnenotePagesOnenotePageCopyToSectionRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenotePagesOnenotePageCopyToSectionExecute(r)
}

/*
MeOnenotePagesOnenotePageCopyToSection Invoke action copyToSection

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenotePageId key: id of onenotePage
 @return ApiMeOnenotePagesOnenotePageCopyToSectionRequest
*/
func (a *MeActionsApiService) MeOnenotePagesOnenotePageCopyToSection(ctx _context.Context, onenotePageId string) ApiMeOnenotePagesOnenotePageCopyToSectionRequest {
	return ApiMeOnenotePagesOnenotePageCopyToSectionRequest{
		ApiService: a,
		ctx: ctx,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenotePagesOnenotePageCopyToSectionExecute(r ApiMeOnenotePagesOnenotePageCopyToSectionRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenotePagesOnenotePageCopyToSection")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/pages/{onenotePage-id}/microsoft.graph.copyToSection"
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject619 == nil {
		return localVarReturnValue, nil, reportError("inlineObject619 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject619
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenotePagesOnenotePageOnenotePatchContentRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenotePageId string
	inlineObject620 *InlineObject620
}

func (r ApiMeOnenotePagesOnenotePageOnenotePatchContentRequest) InlineObject620(inlineObject620 InlineObject620) ApiMeOnenotePagesOnenotePageOnenotePatchContentRequest {
	r.inlineObject620 = &inlineObject620
	return r
}

func (r ApiMeOnenotePagesOnenotePageOnenotePatchContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeOnenotePagesOnenotePageOnenotePatchContentExecute(r)
}

/*
MeOnenotePagesOnenotePageOnenotePatchContent Invoke action onenotePatchContent

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenotePageId key: id of onenotePage
 @return ApiMeOnenotePagesOnenotePageOnenotePatchContentRequest
*/
func (a *MeActionsApiService) MeOnenotePagesOnenotePageOnenotePatchContent(ctx _context.Context, onenotePageId string) ApiMeOnenotePagesOnenotePageOnenotePatchContentRequest {
	return ApiMeOnenotePagesOnenotePageOnenotePatchContentRequest{
		ApiService: a,
		ctx: ctx,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeOnenotePagesOnenotePageOnenotePatchContentExecute(r ApiMeOnenotePagesOnenotePageOnenotePatchContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenotePagesOnenotePageOnenotePatchContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/pages/{onenotePage-id}/microsoft.graph.onenotePatchContent"
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject620 == nil {
		return nil, reportError("inlineObject620 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject620
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeOnenotePagesOnenotePageParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenotePageId string
	inlineObject621 *InlineObject621
}

func (r ApiMeOnenotePagesOnenotePageParentNotebookCopyNotebookRequest) InlineObject621(inlineObject621 InlineObject621) ApiMeOnenotePagesOnenotePageParentNotebookCopyNotebookRequest {
	r.inlineObject621 = &inlineObject621
	return r
}

func (r ApiMeOnenotePagesOnenotePageParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenotePagesOnenotePageParentNotebookCopyNotebookExecute(r)
}

/*
MeOnenotePagesOnenotePageParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenotePageId key: id of onenotePage
 @return ApiMeOnenotePagesOnenotePageParentNotebookCopyNotebookRequest
*/
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentNotebookCopyNotebook(ctx _context.Context, onenotePageId string) ApiMeOnenotePagesOnenotePageParentNotebookCopyNotebookRequest {
	return ApiMeOnenotePagesOnenotePageParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentNotebookCopyNotebookExecute(r ApiMeOnenotePagesOnenotePageParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenotePagesOnenotePageParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/pages/{onenotePage-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject621 == nil {
		return localVarReturnValue, nil, reportError("inlineObject621 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject621
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenotePageId string
	sectionGroupId string
	inlineObject622 *InlineObject622
}

func (r ApiMeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) InlineObject622(inlineObject622 InlineObject622) ApiMeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest {
	r.inlineObject622 = &inlineObject622
	return r
}

func (r ApiMeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookExecute(r)
}

/*
MeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenotePageId key: id of onenotePage
 @param sectionGroupId key: id of sectionGroup
 @return ApiMeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest
*/
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebook(ctx _context.Context, onenotePageId string, sectionGroupId string) ApiMeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest {
	return ApiMeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		onenotePageId: onenotePageId,
		sectionGroupId: sectionGroupId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookExecute(r ApiMeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/pages/{onenotePage-id}/parentNotebook/sectionGroups/{sectionGroup-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject622 == nil {
		return localVarReturnValue, nil, reportError("inlineObject622 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject622
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenotePageId string
	sectionGroupId string
	onenoteSectionId string
	inlineObject623 *InlineObject623
}

func (r ApiMeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) InlineObject623(inlineObject623 InlineObject623) ApiMeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject623 = &inlineObject623
	return r
}

func (r ApiMeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
MeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenotePageId key: id of onenotePage
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @return ApiMeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, onenotePageId string, sectionGroupId string, onenoteSectionId string) ApiMeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiMeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		onenotePageId: onenotePageId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r ApiMeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/pages/{onenotePage-id}/parentNotebook/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject623 == nil {
		return localVarReturnValue, nil, reportError("inlineObject623 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject623
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenotePageId string
	sectionGroupId string
	onenoteSectionId string
	inlineObject624 *InlineObject624
}

func (r ApiMeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject624(inlineObject624 InlineObject624) ApiMeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject624 = &inlineObject624
	return r
}

func (r ApiMeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
MeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenotePageId key: id of onenotePage
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @return ApiMeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, onenotePageId string, sectionGroupId string, onenoteSectionId string) ApiMeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiMeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		onenotePageId: onenotePageId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiMeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/pages/{onenotePage-id}/parentNotebook/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject624 == nil {
		return localVarReturnValue, nil, reportError("inlineObject624 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject624
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenotePageId string
	sectionGroupId string
	onenoteSectionId string
	onenotePageId1 string
	inlineObject625 *InlineObject625
}

func (r ApiMeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) InlineObject625(inlineObject625 InlineObject625) ApiMeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest {
	r.inlineObject625 = &inlineObject625
	return r
}

func (r ApiMeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionExecute(r)
}

/*
MeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSection Invoke action copyToSection

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenotePageId key: id of onenotePage
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId1 key: id of onenotePage
 @return ApiMeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest
*/
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSection(ctx _context.Context, onenotePageId string, sectionGroupId string, onenoteSectionId string, onenotePageId1 string) ApiMeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest {
	return ApiMeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest{
		ApiService: a,
		ctx: ctx,
		onenotePageId: onenotePageId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId1: onenotePageId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionExecute(r ApiMeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSection")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/pages/{onenotePage-id}/parentNotebook/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/pages/{onenotePage-id1}/microsoft.graph.copyToSection"
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id1"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject625 == nil {
		return localVarReturnValue, nil, reportError("inlineObject625 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject625
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenotePageId string
	sectionGroupId string
	onenoteSectionId string
	onenotePageId1 string
	inlineObject626 *InlineObject626
}

func (r ApiMeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) InlineObject626(inlineObject626 InlineObject626) ApiMeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest {
	r.inlineObject626 = &inlineObject626
	return r
}

func (r ApiMeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentExecute(r)
}

/*
MeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent Invoke action onenotePatchContent

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenotePageId key: id of onenotePage
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId1 key: id of onenotePage
 @return ApiMeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest
*/
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent(ctx _context.Context, onenotePageId string, sectionGroupId string, onenoteSectionId string, onenotePageId1 string) ApiMeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest {
	return ApiMeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest{
		ApiService: a,
		ctx: ctx,
		onenotePageId: onenotePageId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId1: onenotePageId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentExecute(r ApiMeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/pages/{onenotePage-id}/parentNotebook/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/pages/{onenotePage-id1}/microsoft.graph.onenotePatchContent"
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id1"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject626 == nil {
		return nil, reportError("inlineObject626 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject626
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenotePageId string
	sectionGroupId string
	onenoteSectionId string
	inlineObject627 *InlineObject627
}

func (r ApiMeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest) InlineObject627(inlineObject627 InlineObject627) ApiMeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest {
	r.inlineObject627 = &inlineObject627
	return r
}

func (r ApiMeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookExecute(r)
}

/*
MeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenotePageId key: id of onenotePage
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @return ApiMeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest
*/
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebook(ctx _context.Context, onenotePageId string, sectionGroupId string, onenoteSectionId string) ApiMeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest {
	return ApiMeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		onenotePageId: onenotePageId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookExecute(r ApiMeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenotePagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/pages/{onenotePage-id}/parentNotebook/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject627 == nil {
		return localVarReturnValue, nil, reportError("inlineObject627 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject627
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenotePageId string
	onenoteSectionId string
	inlineObject628 *InlineObject628
}

func (r ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) InlineObject628(inlineObject628 InlineObject628) ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject628 = &inlineObject628
	return r
}

func (r ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
MeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId key: id of onenoteSection
 @return ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, onenotePageId string, onenoteSectionId string) ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		onenotePageId: onenotePageId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/pages/{onenotePage-id}/parentNotebook/sections/{onenoteSection-id}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject628 == nil {
		return localVarReturnValue, nil, reportError("inlineObject628 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject628
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenotePageId string
	onenoteSectionId string
	inlineObject629 *InlineObject629
}

func (r ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject629(inlineObject629 InlineObject629) ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject629 = &inlineObject629
	return r
}

func (r ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
MeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId key: id of onenoteSection
 @return ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, onenotePageId string, onenoteSectionId string) ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		onenotePageId: onenotePageId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/pages/{onenotePage-id}/parentNotebook/sections/{onenoteSection-id}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject629 == nil {
		return localVarReturnValue, nil, reportError("inlineObject629 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject629
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenotePageId string
	onenoteSectionId string
	onenotePageId1 string
	inlineObject630 *InlineObject630
}

func (r ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) InlineObject630(inlineObject630 InlineObject630) ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest {
	r.inlineObject630 = &inlineObject630
	return r
}

func (r ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionExecute(r)
}

/*
MeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSection Invoke action copyToSection

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId1 key: id of onenotePage
 @return ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest
*/
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSection(ctx _context.Context, onenotePageId string, onenoteSectionId string, onenotePageId1 string) ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest {
	return ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest{
		ApiService: a,
		ctx: ctx,
		onenotePageId: onenotePageId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId1: onenotePageId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionExecute(r ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSection")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/pages/{onenotePage-id}/parentNotebook/sections/{onenoteSection-id}/pages/{onenotePage-id1}/microsoft.graph.copyToSection"
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id1"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject630 == nil {
		return localVarReturnValue, nil, reportError("inlineObject630 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject630
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenotePageId string
	onenoteSectionId string
	onenotePageId1 string
	inlineObject631 *InlineObject631
}

func (r ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) InlineObject631(inlineObject631 InlineObject631) ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest {
	r.inlineObject631 = &inlineObject631
	return r
}

func (r ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentExecute(r)
}

/*
MeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent Invoke action onenotePatchContent

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId1 key: id of onenotePage
 @return ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest
*/
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent(ctx _context.Context, onenotePageId string, onenoteSectionId string, onenotePageId1 string) ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest {
	return ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest{
		ApiService: a,
		ctx: ctx,
		onenotePageId: onenotePageId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId1: onenotePageId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentExecute(r ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/pages/{onenotePage-id}/parentNotebook/sections/{onenoteSection-id}/pages/{onenotePage-id1}/microsoft.graph.onenotePatchContent"
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id1"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject631 == nil {
		return nil, reportError("inlineObject631 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject631
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenotePageId string
	onenoteSectionId string
	inlineObject632 *InlineObject632
}

func (r ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest) InlineObject632(inlineObject632 InlineObject632) ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest {
	r.inlineObject632 = &inlineObject632
	return r
}

func (r ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookExecute(r)
}

/*
MeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId key: id of onenoteSection
 @return ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest
*/
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebook(ctx _context.Context, onenotePageId string, onenoteSectionId string) ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest {
	return ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		onenotePageId: onenotePageId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookExecute(r ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/pages/{onenotePage-id}/parentNotebook/sections/{onenoteSection-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject632 == nil {
		return localVarReturnValue, nil, reportError("inlineObject632 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject632
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenotePageId string
	onenoteSectionId string
	inlineObject633 *InlineObject633
}

func (r ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest) InlineObject633(inlineObject633 InlineObject633) ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest {
	r.inlineObject633 = &inlineObject633
	return r
}

func (r ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookExecute(r)
}

/*
MeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId key: id of onenoteSection
 @return ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest
*/
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebook(ctx _context.Context, onenotePageId string, onenoteSectionId string) ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest {
	return ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		onenotePageId: onenotePageId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookExecute(r ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/pages/{onenotePage-id}/parentNotebook/sections/{onenoteSection-id}/parentSectionGroup/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject633 == nil {
		return localVarReturnValue, nil, reportError("inlineObject633 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject633
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenotePageId string
	onenoteSectionId string
	onenoteSectionId1 string
	inlineObject634 *InlineObject634
}

func (r ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) InlineObject634(inlineObject634 InlineObject634) ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject634 = &inlineObject634
	return r
}

func (r ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
MeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId key: id of onenoteSection
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, onenotePageId string, onenoteSectionId string, onenoteSectionId1 string) ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		onenotePageId: onenotePageId,
		onenoteSectionId: onenoteSectionId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/pages/{onenotePage-id}/parentNotebook/sections/{onenoteSection-id}/parentSectionGroup/sections/{onenoteSection-id1}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject634 == nil {
		return localVarReturnValue, nil, reportError("inlineObject634 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject634
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenotePageId string
	onenoteSectionId string
	onenoteSectionId1 string
	inlineObject635 *InlineObject635
}

func (r ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject635(inlineObject635 InlineObject635) ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject635 = &inlineObject635
	return r
}

func (r ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
MeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId key: id of onenoteSection
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, onenotePageId string, onenoteSectionId string, onenoteSectionId1 string) ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		onenotePageId: onenotePageId,
		onenoteSectionId: onenoteSectionId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiMeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenotePagesOnenotePageParentNotebookSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/pages/{onenotePage-id}/parentNotebook/sections/{onenoteSection-id}/parentSectionGroup/sections/{onenoteSection-id1}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject635 == nil {
		return localVarReturnValue, nil, reportError("inlineObject635 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject635
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenotePagesOnenotePageParentSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenotePageId string
	inlineObject636 *InlineObject636
}

func (r ApiMeOnenotePagesOnenotePageParentSectionCopyToNotebookRequest) InlineObject636(inlineObject636 InlineObject636) ApiMeOnenotePagesOnenotePageParentSectionCopyToNotebookRequest {
	r.inlineObject636 = &inlineObject636
	return r
}

func (r ApiMeOnenotePagesOnenotePageParentSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenotePagesOnenotePageParentSectionCopyToNotebookExecute(r)
}

/*
MeOnenotePagesOnenotePageParentSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenotePageId key: id of onenotePage
 @return ApiMeOnenotePagesOnenotePageParentSectionCopyToNotebookRequest
*/
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentSectionCopyToNotebook(ctx _context.Context, onenotePageId string) ApiMeOnenotePagesOnenotePageParentSectionCopyToNotebookRequest {
	return ApiMeOnenotePagesOnenotePageParentSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentSectionCopyToNotebookExecute(r ApiMeOnenotePagesOnenotePageParentSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenotePagesOnenotePageParentSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/pages/{onenotePage-id}/parentSection/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject636 == nil {
		return localVarReturnValue, nil, reportError("inlineObject636 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject636
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenotePagesOnenotePageParentSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenotePageId string
	inlineObject637 *InlineObject637
}

func (r ApiMeOnenotePagesOnenotePageParentSectionCopyToSectionGroupRequest) InlineObject637(inlineObject637 InlineObject637) ApiMeOnenotePagesOnenotePageParentSectionCopyToSectionGroupRequest {
	r.inlineObject637 = &inlineObject637
	return r
}

func (r ApiMeOnenotePagesOnenotePageParentSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenotePagesOnenotePageParentSectionCopyToSectionGroupExecute(r)
}

/*
MeOnenotePagesOnenotePageParentSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenotePageId key: id of onenotePage
 @return ApiMeOnenotePagesOnenotePageParentSectionCopyToSectionGroupRequest
*/
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentSectionCopyToSectionGroup(ctx _context.Context, onenotePageId string) ApiMeOnenotePagesOnenotePageParentSectionCopyToSectionGroupRequest {
	return ApiMeOnenotePagesOnenotePageParentSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentSectionCopyToSectionGroupExecute(r ApiMeOnenotePagesOnenotePageParentSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenotePagesOnenotePageParentSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/pages/{onenotePage-id}/parentSection/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject637 == nil {
		return localVarReturnValue, nil, reportError("inlineObject637 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject637
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenotePagesOnenotePageParentSectionPagesOnenotePageCopyToSectionRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenotePageId string
	onenotePageId1 string
	inlineObject638 *InlineObject638
}

func (r ApiMeOnenotePagesOnenotePageParentSectionPagesOnenotePageCopyToSectionRequest) InlineObject638(inlineObject638 InlineObject638) ApiMeOnenotePagesOnenotePageParentSectionPagesOnenotePageCopyToSectionRequest {
	r.inlineObject638 = &inlineObject638
	return r
}

func (r ApiMeOnenotePagesOnenotePageParentSectionPagesOnenotePageCopyToSectionRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenotePagesOnenotePageParentSectionPagesOnenotePageCopyToSectionExecute(r)
}

/*
MeOnenotePagesOnenotePageParentSectionPagesOnenotePageCopyToSection Invoke action copyToSection

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenotePageId key: id of onenotePage
 @param onenotePageId1 key: id of onenotePage
 @return ApiMeOnenotePagesOnenotePageParentSectionPagesOnenotePageCopyToSectionRequest
*/
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentSectionPagesOnenotePageCopyToSection(ctx _context.Context, onenotePageId string, onenotePageId1 string) ApiMeOnenotePagesOnenotePageParentSectionPagesOnenotePageCopyToSectionRequest {
	return ApiMeOnenotePagesOnenotePageParentSectionPagesOnenotePageCopyToSectionRequest{
		ApiService: a,
		ctx: ctx,
		onenotePageId: onenotePageId,
		onenotePageId1: onenotePageId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentSectionPagesOnenotePageCopyToSectionExecute(r ApiMeOnenotePagesOnenotePageParentSectionPagesOnenotePageCopyToSectionRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenotePagesOnenotePageParentSectionPagesOnenotePageCopyToSection")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/pages/{onenotePage-id}/parentSection/pages/{onenotePage-id1}/microsoft.graph.copyToSection"
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id1"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject638 == nil {
		return localVarReturnValue, nil, reportError("inlineObject638 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject638
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenotePagesOnenotePageParentSectionPagesOnenotePageOnenotePatchContentRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenotePageId string
	onenotePageId1 string
	inlineObject639 *InlineObject639
}

func (r ApiMeOnenotePagesOnenotePageParentSectionPagesOnenotePageOnenotePatchContentRequest) InlineObject639(inlineObject639 InlineObject639) ApiMeOnenotePagesOnenotePageParentSectionPagesOnenotePageOnenotePatchContentRequest {
	r.inlineObject639 = &inlineObject639
	return r
}

func (r ApiMeOnenotePagesOnenotePageParentSectionPagesOnenotePageOnenotePatchContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeOnenotePagesOnenotePageParentSectionPagesOnenotePageOnenotePatchContentExecute(r)
}

/*
MeOnenotePagesOnenotePageParentSectionPagesOnenotePageOnenotePatchContent Invoke action onenotePatchContent

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenotePageId key: id of onenotePage
 @param onenotePageId1 key: id of onenotePage
 @return ApiMeOnenotePagesOnenotePageParentSectionPagesOnenotePageOnenotePatchContentRequest
*/
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentSectionPagesOnenotePageOnenotePatchContent(ctx _context.Context, onenotePageId string, onenotePageId1 string) ApiMeOnenotePagesOnenotePageParentSectionPagesOnenotePageOnenotePatchContentRequest {
	return ApiMeOnenotePagesOnenotePageParentSectionPagesOnenotePageOnenotePatchContentRequest{
		ApiService: a,
		ctx: ctx,
		onenotePageId: onenotePageId,
		onenotePageId1: onenotePageId1,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentSectionPagesOnenotePageOnenotePatchContentExecute(r ApiMeOnenotePagesOnenotePageParentSectionPagesOnenotePageOnenotePatchContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenotePagesOnenotePageParentSectionPagesOnenotePageOnenotePatchContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/pages/{onenotePage-id}/parentSection/pages/{onenotePage-id1}/microsoft.graph.onenotePatchContent"
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id1"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject639 == nil {
		return nil, reportError("inlineObject639 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject639
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeOnenotePagesOnenotePageParentSectionParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenotePageId string
	inlineObject640 *InlineObject640
}

func (r ApiMeOnenotePagesOnenotePageParentSectionParentNotebookCopyNotebookRequest) InlineObject640(inlineObject640 InlineObject640) ApiMeOnenotePagesOnenotePageParentSectionParentNotebookCopyNotebookRequest {
	r.inlineObject640 = &inlineObject640
	return r
}

func (r ApiMeOnenotePagesOnenotePageParentSectionParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenotePagesOnenotePageParentSectionParentNotebookCopyNotebookExecute(r)
}

/*
MeOnenotePagesOnenotePageParentSectionParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenotePageId key: id of onenotePage
 @return ApiMeOnenotePagesOnenotePageParentSectionParentNotebookCopyNotebookRequest
*/
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentSectionParentNotebookCopyNotebook(ctx _context.Context, onenotePageId string) ApiMeOnenotePagesOnenotePageParentSectionParentNotebookCopyNotebookRequest {
	return ApiMeOnenotePagesOnenotePageParentSectionParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentSectionParentNotebookCopyNotebookExecute(r ApiMeOnenotePagesOnenotePageParentSectionParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenotePagesOnenotePageParentSectionParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/pages/{onenotePage-id}/parentSection/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject640 == nil {
		return localVarReturnValue, nil, reportError("inlineObject640 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject640
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenotePageId string
	sectionGroupId string
	inlineObject641 *InlineObject641
}

func (r ApiMeOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) InlineObject641(inlineObject641 InlineObject641) ApiMeOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest {
	r.inlineObject641 = &inlineObject641
	return r
}

func (r ApiMeOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookExecute(r)
}

/*
MeOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenotePageId key: id of onenotePage
 @param sectionGroupId key: id of sectionGroup
 @return ApiMeOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest
*/
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebook(ctx _context.Context, onenotePageId string, sectionGroupId string) ApiMeOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest {
	return ApiMeOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		onenotePageId: onenotePageId,
		sectionGroupId: sectionGroupId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookExecute(r ApiMeOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/pages/{onenotePage-id}/parentSection/parentNotebook/sectionGroups/{sectionGroup-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject641 == nil {
		return localVarReturnValue, nil, reportError("inlineObject641 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject641
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenotePageId string
	sectionGroupId string
	onenoteSectionId string
	inlineObject642 *InlineObject642
}

func (r ApiMeOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) InlineObject642(inlineObject642 InlineObject642) ApiMeOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject642 = &inlineObject642
	return r
}

func (r ApiMeOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
MeOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenotePageId key: id of onenotePage
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @return ApiMeOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, onenotePageId string, sectionGroupId string, onenoteSectionId string) ApiMeOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiMeOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		onenotePageId: onenotePageId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r ApiMeOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/pages/{onenotePage-id}/parentSection/parentNotebook/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject642 == nil {
		return localVarReturnValue, nil, reportError("inlineObject642 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject642
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenotePageId string
	sectionGroupId string
	onenoteSectionId string
	inlineObject643 *InlineObject643
}

func (r ApiMeOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject643(inlineObject643 InlineObject643) ApiMeOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject643 = &inlineObject643
	return r
}

func (r ApiMeOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
MeOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenotePageId key: id of onenotePage
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @return ApiMeOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, onenotePageId string, sectionGroupId string, onenoteSectionId string) ApiMeOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiMeOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		onenotePageId: onenotePageId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiMeOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenotePagesOnenotePageParentSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/pages/{onenotePage-id}/parentSection/parentNotebook/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject643 == nil {
		return localVarReturnValue, nil, reportError("inlineObject643 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject643
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenotePageId string
	onenoteSectionId string
	inlineObject644 *InlineObject644
}

func (r ApiMeOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) InlineObject644(inlineObject644 InlineObject644) ApiMeOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject644 = &inlineObject644
	return r
}

func (r ApiMeOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
MeOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId key: id of onenoteSection
 @return ApiMeOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, onenotePageId string, onenoteSectionId string) ApiMeOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiMeOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		onenotePageId: onenotePageId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r ApiMeOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/pages/{onenotePage-id}/parentSection/parentNotebook/sections/{onenoteSection-id}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject644 == nil {
		return localVarReturnValue, nil, reportError("inlineObject644 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject644
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenotePageId string
	onenoteSectionId string
	inlineObject645 *InlineObject645
}

func (r ApiMeOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject645(inlineObject645 InlineObject645) ApiMeOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject645 = &inlineObject645
	return r
}

func (r ApiMeOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
MeOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId key: id of onenoteSection
 @return ApiMeOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, onenotePageId string, onenoteSectionId string) ApiMeOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiMeOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		onenotePageId: onenotePageId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiMeOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenotePagesOnenotePageParentSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/pages/{onenotePage-id}/parentSection/parentNotebook/sections/{onenoteSection-id}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject645 == nil {
		return localVarReturnValue, nil, reportError("inlineObject645 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject645
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenotePageId string
	inlineObject646 *InlineObject646
}

func (r ApiMeOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookCopyNotebookRequest) InlineObject646(inlineObject646 InlineObject646) ApiMeOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookCopyNotebookRequest {
	r.inlineObject646 = &inlineObject646
	return r
}

func (r ApiMeOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookCopyNotebookExecute(r)
}

/*
MeOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenotePageId key: id of onenotePage
 @return ApiMeOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookCopyNotebookRequest
*/
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookCopyNotebook(ctx _context.Context, onenotePageId string) ApiMeOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookCopyNotebookRequest {
	return ApiMeOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookCopyNotebookExecute(r ApiMeOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/pages/{onenotePage-id}/parentSection/parentSectionGroup/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject646 == nil {
		return localVarReturnValue, nil, reportError("inlineObject646 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject646
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenotePageId string
	onenoteSectionId string
	inlineObject647 *InlineObject647
}

func (r ApiMeOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) InlineObject647(inlineObject647 InlineObject647) ApiMeOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject647 = &inlineObject647
	return r
}

func (r ApiMeOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
MeOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId key: id of onenoteSection
 @return ApiMeOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, onenotePageId string, onenoteSectionId string) ApiMeOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiMeOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		onenotePageId: onenotePageId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r ApiMeOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/pages/{onenotePage-id}/parentSection/parentSectionGroup/parentNotebook/sections/{onenoteSection-id}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject647 == nil {
		return localVarReturnValue, nil, reportError("inlineObject647 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject647
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenotePageId string
	onenoteSectionId string
	inlineObject648 *InlineObject648
}

func (r ApiMeOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject648(inlineObject648 InlineObject648) ApiMeOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject648 = &inlineObject648
	return r
}

func (r ApiMeOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
MeOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId key: id of onenoteSection
 @return ApiMeOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, onenotePageId string, onenoteSectionId string) ApiMeOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiMeOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		onenotePageId: onenotePageId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiMeOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenotePagesOnenotePageParentSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/pages/{onenotePage-id}/parentSection/parentSectionGroup/parentNotebook/sections/{onenoteSection-id}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject648 == nil {
		return localVarReturnValue, nil, reportError("inlineObject648 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject648
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenotePageId string
	onenoteSectionId string
	inlineObject649 *InlineObject649
}

func (r ApiMeOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) InlineObject649(inlineObject649 InlineObject649) ApiMeOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject649 = &inlineObject649
	return r
}

func (r ApiMeOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
MeOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId key: id of onenoteSection
 @return ApiMeOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, onenotePageId string, onenoteSectionId string) ApiMeOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiMeOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		onenotePageId: onenotePageId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r ApiMeOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/pages/{onenotePage-id}/parentSection/parentSectionGroup/sections/{onenoteSection-id}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject649 == nil {
		return localVarReturnValue, nil, reportError("inlineObject649 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject649
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenotePageId string
	onenoteSectionId string
	inlineObject650 *InlineObject650
}

func (r ApiMeOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject650(inlineObject650 InlineObject650) ApiMeOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject650 = &inlineObject650
	return r
}

func (r ApiMeOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
MeOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId key: id of onenoteSection
 @return ApiMeOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, onenotePageId string, onenoteSectionId string) ApiMeOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiMeOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		onenotePageId: onenotePageId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiMeOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenotePagesOnenotePageParentSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/pages/{onenotePage-id}/parentSection/parentSectionGroup/sections/{onenoteSection-id}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject650 == nil {
		return localVarReturnValue, nil, reportError("inlineObject650 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject650
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteSectionGroupsSectionGroupParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sectionGroupId string
	inlineObject651 *InlineObject651
}

func (r ApiMeOnenoteSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) InlineObject651(inlineObject651 InlineObject651) ApiMeOnenoteSectionGroupsSectionGroupParentNotebookCopyNotebookRequest {
	r.inlineObject651 = &inlineObject651
	return r
}

func (r ApiMeOnenoteSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteSectionGroupsSectionGroupParentNotebookCopyNotebookExecute(r)
}

/*
MeOnenoteSectionGroupsSectionGroupParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sectionGroupId key: id of sectionGroup
 @return ApiMeOnenoteSectionGroupsSectionGroupParentNotebookCopyNotebookRequest
*/
func (a *MeActionsApiService) MeOnenoteSectionGroupsSectionGroupParentNotebookCopyNotebook(ctx _context.Context, sectionGroupId string) ApiMeOnenoteSectionGroupsSectionGroupParentNotebookCopyNotebookRequest {
	return ApiMeOnenoteSectionGroupsSectionGroupParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		sectionGroupId: sectionGroupId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteSectionGroupsSectionGroupParentNotebookCopyNotebookExecute(r ApiMeOnenoteSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteSectionGroupsSectionGroupParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/sectionGroups/{sectionGroup-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject651 == nil {
		return localVarReturnValue, nil, reportError("inlineObject651 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject651
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sectionGroupId string
	onenoteSectionId string
	inlineObject652 *InlineObject652
}

func (r ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) InlineObject652(inlineObject652 InlineObject652) ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject652 = &inlineObject652
	return r
}

func (r ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
MeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @return ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *MeActionsApiService) MeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, sectionGroupId string, onenoteSectionId string) ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/sectionGroups/{sectionGroup-id}/parentNotebook/sections/{onenoteSection-id}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject652 == nil {
		return localVarReturnValue, nil, reportError("inlineObject652 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject652
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sectionGroupId string
	onenoteSectionId string
	inlineObject653 *InlineObject653
}

func (r ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject653(inlineObject653 InlineObject653) ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject653 = &inlineObject653
	return r
}

func (r ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
MeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @return ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *MeActionsApiService) MeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, sectionGroupId string, onenoteSectionId string) ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/sectionGroups/{sectionGroup-id}/parentNotebook/sections/{onenoteSection-id}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject653 == nil {
		return localVarReturnValue, nil, reportError("inlineObject653 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject653
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sectionGroupId string
	onenoteSectionId string
	onenotePageId string
	inlineObject654 *InlineObject654
}

func (r ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) InlineObject654(inlineObject654 InlineObject654) ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest {
	r.inlineObject654 = &inlineObject654
	return r
}

func (r ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionExecute(r)
}

/*
MeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSection Invoke action copyToSection

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest
*/
func (a *MeActionsApiService) MeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSection(ctx _context.Context, sectionGroupId string, onenoteSectionId string, onenotePageId string) ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest {
	return ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest{
		ApiService: a,
		ctx: ctx,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionExecute(r ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageCopyToSection")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/sectionGroups/{sectionGroup-id}/parentNotebook/sections/{onenoteSection-id}/pages/{onenotePage-id}/microsoft.graph.copyToSection"
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject654 == nil {
		return localVarReturnValue, nil, reportError("inlineObject654 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject654
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sectionGroupId string
	onenoteSectionId string
	onenotePageId string
	inlineObject655 *InlineObject655
}

func (r ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) InlineObject655(inlineObject655 InlineObject655) ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest {
	r.inlineObject655 = &inlineObject655
	return r
}

func (r ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentExecute(r)
}

/*
MeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent Invoke action onenotePatchContent

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest
*/
func (a *MeActionsApiService) MeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent(ctx _context.Context, sectionGroupId string, onenoteSectionId string, onenotePageId string) ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest {
	return ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest{
		ApiService: a,
		ctx: ctx,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentExecute(r ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/sectionGroups/{sectionGroup-id}/parentNotebook/sections/{onenoteSection-id}/pages/{onenotePage-id}/microsoft.graph.onenotePatchContent"
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject655 == nil {
		return nil, reportError("inlineObject655 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject655
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sectionGroupId string
	onenoteSectionId string
	onenotePageId string
	inlineObject656 *InlineObject656
}

func (r ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest) InlineObject656(inlineObject656 InlineObject656) ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest {
	r.inlineObject656 = &inlineObject656
	return r
}

func (r ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookExecute(r)
}

/*
MeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest
*/
func (a *MeActionsApiService) MeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebook(ctx _context.Context, sectionGroupId string, onenoteSectionId string, onenotePageId string) ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest {
	return ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookExecute(r ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/sectionGroups/{sectionGroup-id}/parentNotebook/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject656 == nil {
		return localVarReturnValue, nil, reportError("inlineObject656 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject656
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sectionGroupId string
	onenoteSectionId string
	onenotePageId string
	inlineObject657 *InlineObject657
}

func (r ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest) InlineObject657(inlineObject657 InlineObject657) ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest {
	r.inlineObject657 = &inlineObject657
	return r
}

func (r ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookExecute(r)
}

/*
MeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest
*/
func (a *MeActionsApiService) MeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebook(ctx _context.Context, sectionGroupId string, onenoteSectionId string, onenotePageId string) ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest {
	return ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookExecute(r ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/sectionGroups/{sectionGroup-id}/parentNotebook/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentSection/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject657 == nil {
		return localVarReturnValue, nil, reportError("inlineObject657 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject657
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sectionGroupId string
	onenoteSectionId string
	onenotePageId string
	inlineObject658 *InlineObject658
}

func (r ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest) InlineObject658(inlineObject658 InlineObject658) ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest {
	r.inlineObject658 = &inlineObject658
	return r
}

func (r ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupExecute(r)
}

/*
MeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest
*/
func (a *MeActionsApiService) MeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroup(ctx _context.Context, sectionGroupId string, onenoteSectionId string, onenotePageId string) ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest {
	return ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupExecute(r ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/sectionGroups/{sectionGroup-id}/parentNotebook/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentSection/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject658 == nil {
		return localVarReturnValue, nil, reportError("inlineObject658 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject658
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sectionGroupId string
	onenoteSectionId string
	inlineObject659 *InlineObject659
}

func (r ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest) InlineObject659(inlineObject659 InlineObject659) ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest {
	r.inlineObject659 = &inlineObject659
	return r
}

func (r ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookExecute(r)
}

/*
MeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @return ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest
*/
func (a *MeActionsApiService) MeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebook(ctx _context.Context, sectionGroupId string, onenoteSectionId string) ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest {
	return ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookExecute(r ApiMeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteSectionGroupsSectionGroupParentNotebookSectionsOnenoteSectionParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/sectionGroups/{sectionGroup-id}/parentNotebook/sections/{onenoteSection-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject659 == nil {
		return localVarReturnValue, nil, reportError("inlineObject659 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject659
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sectionGroupId string
	onenoteSectionId string
	inlineObject660 *InlineObject660
}

func (r ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) InlineObject660(inlineObject660 InlineObject660) ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject660 = &inlineObject660
	return r
}

func (r ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @return ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *MeActionsApiService) MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, sectionGroupId string, onenoteSectionId string) ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject660 == nil {
		return localVarReturnValue, nil, reportError("inlineObject660 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject660
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sectionGroupId string
	onenoteSectionId string
	inlineObject661 *InlineObject661
}

func (r ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject661(inlineObject661 InlineObject661) ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject661 = &inlineObject661
	return r
}

func (r ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @return ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *MeActionsApiService) MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, sectionGroupId string, onenoteSectionId string) ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject661 == nil {
		return localVarReturnValue, nil, reportError("inlineObject661 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject661
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sectionGroupId string
	onenoteSectionId string
	onenotePageId string
	inlineObject662 *InlineObject662
}

func (r ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) InlineObject662(inlineObject662 InlineObject662) ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest {
	r.inlineObject662 = &inlineObject662
	return r
}

func (r ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionExecute(r)
}

/*
MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSection Invoke action copyToSection

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest
*/
func (a *MeActionsApiService) MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSection(ctx _context.Context, sectionGroupId string, onenoteSectionId string, onenotePageId string) ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest {
	return ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest{
		ApiService: a,
		ctx: ctx,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionExecute(r ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageCopyToSection")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/pages/{onenotePage-id}/microsoft.graph.copyToSection"
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject662 == nil {
		return localVarReturnValue, nil, reportError("inlineObject662 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject662
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sectionGroupId string
	onenoteSectionId string
	onenotePageId string
	inlineObject663 *InlineObject663
}

func (r ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) InlineObject663(inlineObject663 InlineObject663) ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest {
	r.inlineObject663 = &inlineObject663
	return r
}

func (r ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentExecute(r)
}

/*
MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent Invoke action onenotePatchContent

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest
*/
func (a *MeActionsApiService) MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent(ctx _context.Context, sectionGroupId string, onenoteSectionId string, onenotePageId string) ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest {
	return ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest{
		ApiService: a,
		ctx: ctx,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentExecute(r ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/pages/{onenotePage-id}/microsoft.graph.onenotePatchContent"
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject663 == nil {
		return nil, reportError("inlineObject663 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject663
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sectionGroupId string
	onenoteSectionId string
	onenotePageId string
	inlineObject664 *InlineObject664
}

func (r ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest) InlineObject664(inlineObject664 InlineObject664) ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest {
	r.inlineObject664 = &inlineObject664
	return r
}

func (r ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookExecute(r)
}

/*
MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest
*/
func (a *MeActionsApiService) MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebook(ctx _context.Context, sectionGroupId string, onenoteSectionId string, onenotePageId string) ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest {
	return ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookExecute(r ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject664 == nil {
		return localVarReturnValue, nil, reportError("inlineObject664 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject664
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sectionGroupId string
	onenoteSectionId string
	onenotePageId string
	onenoteSectionId1 string
	inlineObject665 *InlineObject665
}

func (r ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) InlineObject665(inlineObject665 InlineObject665) ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject665 = &inlineObject665
	return r
}

func (r ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *MeActionsApiService) MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, sectionGroupId string, onenoteSectionId string, onenotePageId string, onenoteSectionId1 string) ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentNotebook/sections/{onenoteSection-id1}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject665 == nil {
		return localVarReturnValue, nil, reportError("inlineObject665 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject665
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sectionGroupId string
	onenoteSectionId string
	onenotePageId string
	onenoteSectionId1 string
	inlineObject666 *InlineObject666
}

func (r ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject666(inlineObject666 InlineObject666) ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject666 = &inlineObject666
	return r
}

func (r ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *MeActionsApiService) MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, sectionGroupId string, onenoteSectionId string, onenotePageId string, onenoteSectionId1 string) ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentNotebook/sections/{onenoteSection-id1}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject666 == nil {
		return localVarReturnValue, nil, reportError("inlineObject666 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject666
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sectionGroupId string
	onenoteSectionId string
	onenotePageId string
	inlineObject667 *InlineObject667
}

func (r ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest) InlineObject667(inlineObject667 InlineObject667) ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest {
	r.inlineObject667 = &inlineObject667
	return r
}

func (r ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookExecute(r)
}

/*
MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest
*/
func (a *MeActionsApiService) MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebook(ctx _context.Context, sectionGroupId string, onenoteSectionId string, onenotePageId string) ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest {
	return ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookExecute(r ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentSection/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject667 == nil {
		return localVarReturnValue, nil, reportError("inlineObject667 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject667
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sectionGroupId string
	onenoteSectionId string
	onenotePageId string
	inlineObject668 *InlineObject668
}

func (r ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest) InlineObject668(inlineObject668 InlineObject668) ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest {
	r.inlineObject668 = &inlineObject668
	return r
}

func (r ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupExecute(r)
}

/*
MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest
*/
func (a *MeActionsApiService) MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroup(ctx _context.Context, sectionGroupId string, onenoteSectionId string, onenotePageId string) ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest {
	return ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupExecute(r ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentSection/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject668 == nil {
		return localVarReturnValue, nil, reportError("inlineObject668 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject668
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sectionGroupId string
	onenoteSectionId string
	inlineObject669 *InlineObject669
}

func (r ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest) InlineObject669(inlineObject669 InlineObject669) ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest {
	r.inlineObject669 = &inlineObject669
	return r
}

func (r ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookExecute(r)
}

/*
MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @return ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest
*/
func (a *MeActionsApiService) MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebook(ctx _context.Context, sectionGroupId string, onenoteSectionId string) ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest {
	return ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookExecute(r ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject669 == nil {
		return localVarReturnValue, nil, reportError("inlineObject669 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject669
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sectionGroupId string
	onenoteSectionId string
	onenoteSectionId1 string
	inlineObject670 *InlineObject670
}

func (r ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) InlineObject670(inlineObject670 InlineObject670) ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject670 = &inlineObject670
	return r
}

func (r ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *MeActionsApiService) MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, sectionGroupId string, onenoteSectionId string, onenoteSectionId1 string) ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/parentNotebook/sections/{onenoteSection-id1}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject670 == nil {
		return localVarReturnValue, nil, reportError("inlineObject670 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject670
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	sectionGroupId string
	onenoteSectionId string
	onenoteSectionId1 string
	inlineObject671 *InlineObject671
}

func (r ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject671(inlineObject671 InlineObject671) ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject671 = &inlineObject671
	return r
}

func (r ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId key: id of onenoteSection
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *MeActionsApiService) MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, sectionGroupId string, onenoteSectionId string, onenoteSectionId1 string) ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		sectionGroupId: sectionGroupId,
		onenoteSectionId: onenoteSectionId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiMeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteSectionGroupsSectionGroupSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id}/parentNotebook/sections/{onenoteSection-id1}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject671 == nil {
		return localVarReturnValue, nil, reportError("inlineObject671 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject671
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenoteSectionId string
	inlineObject672 *InlineObject672
}

func (r ApiMeOnenoteSectionsOnenoteSectionCopyToNotebookRequest) InlineObject672(inlineObject672 InlineObject672) ApiMeOnenoteSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject672 = &inlineObject672
	return r
}

func (r ApiMeOnenoteSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
MeOnenoteSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenoteSectionId key: id of onenoteSection
 @return ApiMeOnenoteSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *MeActionsApiService) MeOnenoteSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, onenoteSectionId string) ApiMeOnenoteSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiMeOnenoteSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteSectionsOnenoteSectionCopyToNotebookExecute(r ApiMeOnenoteSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/sections/{onenoteSection-id}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject672 == nil {
		return localVarReturnValue, nil, reportError("inlineObject672 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject672
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenoteSectionId string
	inlineObject673 *InlineObject673
}

func (r ApiMeOnenoteSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject673(inlineObject673 InlineObject673) ApiMeOnenoteSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject673 = &inlineObject673
	return r
}

func (r ApiMeOnenoteSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
MeOnenoteSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenoteSectionId key: id of onenoteSection
 @return ApiMeOnenoteSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *MeActionsApiService) MeOnenoteSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, onenoteSectionId string) ApiMeOnenoteSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiMeOnenoteSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiMeOnenoteSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/sections/{onenoteSection-id}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject673 == nil {
		return localVarReturnValue, nil, reportError("inlineObject673 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject673
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenoteSectionId string
	onenotePageId string
	inlineObject674 *InlineObject674
}

func (r ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) InlineObject674(inlineObject674 InlineObject674) ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest {
	r.inlineObject674 = &inlineObject674
	return r
}

func (r ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteSectionsOnenoteSectionPagesOnenotePageCopyToSectionExecute(r)
}

/*
MeOnenoteSectionsOnenoteSectionPagesOnenotePageCopyToSection Invoke action copyToSection

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest
*/
func (a *MeActionsApiService) MeOnenoteSectionsOnenoteSectionPagesOnenotePageCopyToSection(ctx _context.Context, onenoteSectionId string, onenotePageId string) ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest {
	return ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest{
		ApiService: a,
		ctx: ctx,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteSectionsOnenoteSectionPagesOnenotePageCopyToSectionExecute(r ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageCopyToSectionRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteSectionsOnenoteSectionPagesOnenotePageCopyToSection")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/sections/{onenoteSection-id}/pages/{onenotePage-id}/microsoft.graph.copyToSection"
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject674 == nil {
		return localVarReturnValue, nil, reportError("inlineObject674 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject674
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenoteSectionId string
	onenotePageId string
	inlineObject675 *InlineObject675
}

func (r ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) InlineObject675(inlineObject675 InlineObject675) ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest {
	r.inlineObject675 = &inlineObject675
	return r
}

func (r ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeOnenoteSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentExecute(r)
}

/*
MeOnenoteSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent Invoke action onenotePatchContent

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest
*/
func (a *MeActionsApiService) MeOnenoteSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent(ctx _context.Context, onenoteSectionId string, onenotePageId string) ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest {
	return ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest{
		ApiService: a,
		ctx: ctx,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeOnenoteSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentExecute(r ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageOnenotePatchContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteSectionsOnenoteSectionPagesOnenotePageOnenotePatchContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/sections/{onenoteSection-id}/pages/{onenotePage-id}/microsoft.graph.onenotePatchContent"
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject675 == nil {
		return nil, reportError("inlineObject675 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject675
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenoteSectionId string
	onenotePageId string
	inlineObject676 *InlineObject676
}

func (r ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest) InlineObject676(inlineObject676 InlineObject676) ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest {
	r.inlineObject676 = &inlineObject676
	return r
}

func (r ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookExecute(r)
}

/*
MeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest
*/
func (a *MeActionsApiService) MeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebook(ctx _context.Context, onenoteSectionId string, onenotePageId string) ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest {
	return ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookExecute(r ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject676 == nil {
		return localVarReturnValue, nil, reportError("inlineObject676 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject676
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenoteSectionId string
	onenotePageId string
	sectionGroupId string
	inlineObject677 *InlineObject677
}

func (r ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) InlineObject677(inlineObject677 InlineObject677) ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest {
	r.inlineObject677 = &inlineObject677
	return r
}

func (r ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookExecute(r)
}

/*
MeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @param sectionGroupId key: id of sectionGroup
 @return ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest
*/
func (a *MeActionsApiService) MeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebook(ctx _context.Context, onenoteSectionId string, onenotePageId string, sectionGroupId string) ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest {
	return ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
		sectionGroupId: sectionGroupId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookExecute(r ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentNotebook/sectionGroups/{sectionGroup-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject677 == nil {
		return localVarReturnValue, nil, reportError("inlineObject677 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject677
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenoteSectionId string
	onenotePageId string
	sectionGroupId string
	onenoteSectionId1 string
	inlineObject678 *InlineObject678
}

func (r ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) InlineObject678(inlineObject678 InlineObject678) ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject678 = &inlineObject678
	return r
}

func (r ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
MeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *MeActionsApiService) MeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, onenoteSectionId string, onenotePageId string, sectionGroupId string, onenoteSectionId1 string) ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentNotebook/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id1}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject678 == nil {
		return localVarReturnValue, nil, reportError("inlineObject678 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject678
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenoteSectionId string
	onenotePageId string
	sectionGroupId string
	onenoteSectionId1 string
	inlineObject679 *InlineObject679
}

func (r ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject679(inlineObject679 InlineObject679) ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject679 = &inlineObject679
	return r
}

func (r ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
MeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *MeActionsApiService) MeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, onenoteSectionId string, onenotePageId string, sectionGroupId string, onenoteSectionId1 string) ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentNotebook/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id1}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject679 == nil {
		return localVarReturnValue, nil, reportError("inlineObject679 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject679
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenoteSectionId string
	onenotePageId string
	onenoteSectionId1 string
	inlineObject680 *InlineObject680
}

func (r ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) InlineObject680(inlineObject680 InlineObject680) ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject680 = &inlineObject680
	return r
}

func (r ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
MeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *MeActionsApiService) MeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, onenoteSectionId string, onenotePageId string, onenoteSectionId1 string) ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentNotebook/sections/{onenoteSection-id1}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject680 == nil {
		return localVarReturnValue, nil, reportError("inlineObject680 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject680
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenoteSectionId string
	onenotePageId string
	onenoteSectionId1 string
	inlineObject681 *InlineObject681
}

func (r ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject681(inlineObject681 InlineObject681) ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject681 = &inlineObject681
	return r
}

func (r ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
MeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *MeActionsApiService) MeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, onenoteSectionId string, onenotePageId string, onenoteSectionId1 string) ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteSectionsOnenoteSectionPagesOnenotePageParentNotebookSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentNotebook/sections/{onenoteSection-id1}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject681 == nil {
		return localVarReturnValue, nil, reportError("inlineObject681 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject681
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenoteSectionId string
	onenotePageId string
	inlineObject682 *InlineObject682
}

func (r ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest) InlineObject682(inlineObject682 InlineObject682) ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest {
	r.inlineObject682 = &inlineObject682
	return r
}

func (r ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookExecute(r)
}

/*
MeOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest
*/
func (a *MeActionsApiService) MeOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebook(ctx _context.Context, onenoteSectionId string, onenotePageId string) ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest {
	return ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookExecute(r ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentSection/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject682 == nil {
		return localVarReturnValue, nil, reportError("inlineObject682 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject682
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenoteSectionId string
	onenotePageId string
	inlineObject683 *InlineObject683
}

func (r ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest) InlineObject683(inlineObject683 InlineObject683) ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest {
	r.inlineObject683 = &inlineObject683
	return r
}

func (r ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupExecute(r)
}

/*
MeOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenoteSectionId key: id of onenoteSection
 @param onenotePageId key: id of onenotePage
 @return ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest
*/
func (a *MeActionsApiService) MeOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroup(ctx _context.Context, onenoteSectionId string, onenotePageId string) ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest {
	return ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		onenoteSectionId: onenoteSectionId,
		onenotePageId: onenotePageId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupExecute(r ApiMeOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteSectionsOnenoteSectionPagesOnenotePageParentSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/sections/{onenoteSection-id}/pages/{onenotePage-id}/parentSection/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenotePage-id"+"}", _neturl.PathEscape(parameterToString(r.onenotePageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject683 == nil {
		return localVarReturnValue, nil, reportError("inlineObject683 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject683
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteSectionsOnenoteSectionParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenoteSectionId string
	inlineObject684 *InlineObject684
}

func (r ApiMeOnenoteSectionsOnenoteSectionParentNotebookCopyNotebookRequest) InlineObject684(inlineObject684 InlineObject684) ApiMeOnenoteSectionsOnenoteSectionParentNotebookCopyNotebookRequest {
	r.inlineObject684 = &inlineObject684
	return r
}

func (r ApiMeOnenoteSectionsOnenoteSectionParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteSectionsOnenoteSectionParentNotebookCopyNotebookExecute(r)
}

/*
MeOnenoteSectionsOnenoteSectionParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenoteSectionId key: id of onenoteSection
 @return ApiMeOnenoteSectionsOnenoteSectionParentNotebookCopyNotebookRequest
*/
func (a *MeActionsApiService) MeOnenoteSectionsOnenoteSectionParentNotebookCopyNotebook(ctx _context.Context, onenoteSectionId string) ApiMeOnenoteSectionsOnenoteSectionParentNotebookCopyNotebookRequest {
	return ApiMeOnenoteSectionsOnenoteSectionParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteSectionsOnenoteSectionParentNotebookCopyNotebookExecute(r ApiMeOnenoteSectionsOnenoteSectionParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteSectionsOnenoteSectionParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/sections/{onenoteSection-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject684 == nil {
		return localVarReturnValue, nil, reportError("inlineObject684 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject684
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenoteSectionId string
	sectionGroupId string
	inlineObject685 *InlineObject685
}

func (r ApiMeOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) InlineObject685(inlineObject685 InlineObject685) ApiMeOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest {
	r.inlineObject685 = &inlineObject685
	return r
}

func (r ApiMeOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookExecute(r)
}

/*
MeOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenoteSectionId key: id of onenoteSection
 @param sectionGroupId key: id of sectionGroup
 @return ApiMeOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest
*/
func (a *MeActionsApiService) MeOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebook(ctx _context.Context, onenoteSectionId string, sectionGroupId string) ApiMeOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest {
	return ApiMeOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		onenoteSectionId: onenoteSectionId,
		sectionGroupId: sectionGroupId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookExecute(r ApiMeOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/sections/{onenoteSection-id}/parentNotebook/sectionGroups/{sectionGroup-id}/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject685 == nil {
		return localVarReturnValue, nil, reportError("inlineObject685 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject685
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenoteSectionId string
	sectionGroupId string
	onenoteSectionId1 string
	inlineObject686 *InlineObject686
}

func (r ApiMeOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) InlineObject686(inlineObject686 InlineObject686) ApiMeOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject686 = &inlineObject686
	return r
}

func (r ApiMeOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
MeOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenoteSectionId key: id of onenoteSection
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiMeOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *MeActionsApiService) MeOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, onenoteSectionId string, sectionGroupId string, onenoteSectionId1 string) ApiMeOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiMeOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		onenoteSectionId: onenoteSectionId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r ApiMeOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/sections/{onenoteSection-id}/parentNotebook/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id1}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject686 == nil {
		return localVarReturnValue, nil, reportError("inlineObject686 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject686
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenoteSectionId string
	sectionGroupId string
	onenoteSectionId1 string
	inlineObject687 *InlineObject687
}

func (r ApiMeOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject687(inlineObject687 InlineObject687) ApiMeOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject687 = &inlineObject687
	return r
}

func (r ApiMeOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
MeOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenoteSectionId key: id of onenoteSection
 @param sectionGroupId key: id of sectionGroup
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiMeOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *MeActionsApiService) MeOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, onenoteSectionId string, sectionGroupId string, onenoteSectionId1 string) ApiMeOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiMeOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		onenoteSectionId: onenoteSectionId,
		sectionGroupId: sectionGroupId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiMeOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteSectionsOnenoteSectionParentNotebookSectionGroupsSectionGroupSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/sections/{onenoteSection-id}/parentNotebook/sectionGroups/{sectionGroup-id}/sections/{onenoteSection-id1}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sectionGroup-id"+"}", _neturl.PathEscape(parameterToString(r.sectionGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject687 == nil {
		return localVarReturnValue, nil, reportError("inlineObject687 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject687
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenoteSectionId string
	onenoteSectionId1 string
	inlineObject688 *InlineObject688
}

func (r ApiMeOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) InlineObject688(inlineObject688 InlineObject688) ApiMeOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject688 = &inlineObject688
	return r
}

func (r ApiMeOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
MeOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenoteSectionId key: id of onenoteSection
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiMeOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *MeActionsApiService) MeOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, onenoteSectionId string, onenoteSectionId1 string) ApiMeOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiMeOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		onenoteSectionId: onenoteSectionId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r ApiMeOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/sections/{onenoteSection-id}/parentNotebook/sections/{onenoteSection-id1}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject688 == nil {
		return localVarReturnValue, nil, reportError("inlineObject688 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject688
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenoteSectionId string
	onenoteSectionId1 string
	inlineObject689 *InlineObject689
}

func (r ApiMeOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject689(inlineObject689 InlineObject689) ApiMeOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject689 = &inlineObject689
	return r
}

func (r ApiMeOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
MeOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenoteSectionId key: id of onenoteSection
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiMeOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *MeActionsApiService) MeOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, onenoteSectionId string, onenoteSectionId1 string) ApiMeOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiMeOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		onenoteSectionId: onenoteSectionId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiMeOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteSectionsOnenoteSectionParentNotebookSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/sections/{onenoteSection-id}/parentNotebook/sections/{onenoteSection-id1}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject689 == nil {
		return localVarReturnValue, nil, reportError("inlineObject689 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject689
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenoteSectionId string
	inlineObject690 *InlineObject690
}

func (r ApiMeOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest) InlineObject690(inlineObject690 InlineObject690) ApiMeOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest {
	r.inlineObject690 = &inlineObject690
	return r
}

func (r ApiMeOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookExecute(r)
}

/*
MeOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebook Invoke action copyNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenoteSectionId key: id of onenoteSection
 @return ApiMeOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest
*/
func (a *MeActionsApiService) MeOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebook(ctx _context.Context, onenoteSectionId string) ApiMeOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest {
	return ApiMeOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest{
		ApiService: a,
		ctx: ctx,
		onenoteSectionId: onenoteSectionId,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookExecute(r ApiMeOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookCopyNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/sections/{onenoteSection-id}/parentSectionGroup/parentNotebook/microsoft.graph.copyNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject690 == nil {
		return localVarReturnValue, nil, reportError("inlineObject690 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject690
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenoteSectionId string
	onenoteSectionId1 string
	inlineObject691 *InlineObject691
}

func (r ApiMeOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) InlineObject691(inlineObject691 InlineObject691) ApiMeOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject691 = &inlineObject691
	return r
}

func (r ApiMeOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
MeOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenoteSectionId key: id of onenoteSection
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiMeOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *MeActionsApiService) MeOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, onenoteSectionId string, onenoteSectionId1 string) ApiMeOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiMeOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		onenoteSectionId: onenoteSectionId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookExecute(r ApiMeOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/sections/{onenoteSection-id}/parentSectionGroup/parentNotebook/sections/{onenoteSection-id1}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject691 == nil {
		return localVarReturnValue, nil, reportError("inlineObject691 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject691
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenoteSectionId string
	onenoteSectionId1 string
	inlineObject692 *InlineObject692
}

func (r ApiMeOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject692(inlineObject692 InlineObject692) ApiMeOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject692 = &inlineObject692
	return r
}

func (r ApiMeOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
MeOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenoteSectionId key: id of onenoteSection
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiMeOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *MeActionsApiService) MeOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, onenoteSectionId string, onenoteSectionId1 string) ApiMeOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiMeOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		onenoteSectionId: onenoteSectionId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiMeOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteSectionsOnenoteSectionParentSectionGroupParentNotebookSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/sections/{onenoteSection-id}/parentSectionGroup/parentNotebook/sections/{onenoteSection-id1}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject692 == nil {
		return localVarReturnValue, nil, reportError("inlineObject692 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject692
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenoteSectionId string
	onenoteSectionId1 string
	inlineObject693 *InlineObject693
}

func (r ApiMeOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) InlineObject693(inlineObject693 InlineObject693) ApiMeOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	r.inlineObject693 = &inlineObject693
	return r
}

func (r ApiMeOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r)
}

/*
MeOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebook Invoke action copyToNotebook

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenoteSectionId key: id of onenoteSection
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiMeOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest
*/
func (a *MeActionsApiService) MeOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebook(ctx _context.Context, onenoteSectionId string, onenoteSectionId1 string) ApiMeOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest {
	return ApiMeOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest{
		ApiService: a,
		ctx: ctx,
		onenoteSectionId: onenoteSectionId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookExecute(r ApiMeOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebookRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToNotebook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/sections/{onenoteSection-id}/parentSectionGroup/sections/{onenoteSection-id1}/microsoft.graph.copyToNotebook"
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject693 == nil {
		return localVarReturnValue, nil, reportError("inlineObject693 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject693
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	onenoteSectionId string
	onenoteSectionId1 string
	inlineObject694 *InlineObject694
}

func (r ApiMeOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) InlineObject694(inlineObject694 InlineObject694) ApiMeOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	r.inlineObject694 = &inlineObject694
	return r
}

func (r ApiMeOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) Execute() (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	return r.ApiService.MeOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r)
}

/*
MeOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroup Invoke action copyToSectionGroup

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param onenoteSectionId key: id of onenoteSection
 @param onenoteSectionId1 key: id of onenoteSection
 @return ApiMeOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest
*/
func (a *MeActionsApiService) MeOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroup(ctx _context.Context, onenoteSectionId string, onenoteSectionId1 string) ApiMeOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest {
	return ApiMeOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		onenoteSectionId: onenoteSectionId,
		onenoteSectionId1: onenoteSectionId1,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnenoteOperation
func (a *MeActionsApiService) MeOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupExecute(r ApiMeOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroupRequest) (AnyOfmicrosoftGraphOnenoteOperation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnenoteOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnenoteSectionsOnenoteSectionParentSectionGroupSectionsOnenoteSectionCopyToSectionGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onenote/sections/{onenoteSection-id}/parentSectionGroup/sections/{onenoteSection-id1}/microsoft.graph.copyToSectionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"onenoteSection-id1"+"}", _neturl.PathEscape(parameterToString(r.onenoteSectionId1, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject694 == nil {
		return localVarReturnValue, nil, reportError("inlineObject694 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject694
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeOnlineMeetingsCreateOrGetRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	inlineObject695 *InlineObject695
}

func (r ApiMeOnlineMeetingsCreateOrGetRequest) InlineObject695(inlineObject695 InlineObject695) ApiMeOnlineMeetingsCreateOrGetRequest {
	r.inlineObject695 = &inlineObject695
	return r
}

func (r ApiMeOnlineMeetingsCreateOrGetRequest) Execute() (AnyOfmicrosoftGraphOnlineMeeting, *_nethttp.Response, error) {
	return r.ApiService.MeOnlineMeetingsCreateOrGetExecute(r)
}

/*
MeOnlineMeetingsCreateOrGet Invoke action createOrGet

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMeOnlineMeetingsCreateOrGetRequest
*/
func (a *MeActionsApiService) MeOnlineMeetingsCreateOrGet(ctx _context.Context) ApiMeOnlineMeetingsCreateOrGetRequest {
	return ApiMeOnlineMeetingsCreateOrGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphOnlineMeeting
func (a *MeActionsApiService) MeOnlineMeetingsCreateOrGetExecute(r ApiMeOnlineMeetingsCreateOrGetRequest) (AnyOfmicrosoftGraphOnlineMeeting, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphOnlineMeeting
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeOnlineMeetingsCreateOrGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/onlineMeetings/microsoft.graph.createOrGet"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject695 == nil {
		return localVarReturnValue, nil, reportError("inlineObject695 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject695
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMePresenceClearPresenceRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	inlineObject696 *InlineObject696
}

func (r ApiMePresenceClearPresenceRequest) InlineObject696(inlineObject696 InlineObject696) ApiMePresenceClearPresenceRequest {
	r.inlineObject696 = &inlineObject696
	return r
}

func (r ApiMePresenceClearPresenceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MePresenceClearPresenceExecute(r)
}

/*
MePresenceClearPresence Invoke action clearPresence

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMePresenceClearPresenceRequest
*/
func (a *MeActionsApiService) MePresenceClearPresence(ctx _context.Context) ApiMePresenceClearPresenceRequest {
	return ApiMePresenceClearPresenceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MePresenceClearPresenceExecute(r ApiMePresenceClearPresenceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MePresenceClearPresence")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/presence/microsoft.graph.clearPresence"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject696 == nil {
		return nil, reportError("inlineObject696 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject696
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMePresenceSetPresenceRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	inlineObject697 *InlineObject697
}

func (r ApiMePresenceSetPresenceRequest) InlineObject697(inlineObject697 InlineObject697) ApiMePresenceSetPresenceRequest {
	r.inlineObject697 = &inlineObject697
	return r
}

func (r ApiMePresenceSetPresenceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MePresenceSetPresenceExecute(r)
}

/*
MePresenceSetPresence Invoke action setPresence

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMePresenceSetPresenceRequest
*/
func (a *MeActionsApiService) MePresenceSetPresence(ctx _context.Context) ApiMePresenceSetPresenceRequest {
	return ApiMePresenceSetPresenceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MePresenceSetPresenceExecute(r ApiMePresenceSetPresenceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MePresenceSetPresence")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/presence/microsoft.graph.setPresence"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject697 == nil {
		return nil, reportError("inlineObject697 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject697
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeRemoveAllDevicesFromManagementRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
}


func (r ApiMeRemoveAllDevicesFromManagementRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeRemoveAllDevicesFromManagementExecute(r)
}

/*
MeRemoveAllDevicesFromManagement Invoke action removeAllDevicesFromManagement

Retire all devices from management for this user

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMeRemoveAllDevicesFromManagementRequest
*/
func (a *MeActionsApiService) MeRemoveAllDevicesFromManagement(ctx _context.Context) ApiMeRemoveAllDevicesFromManagementRequest {
	return ApiMeRemoveAllDevicesFromManagementRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeRemoveAllDevicesFromManagementExecute(r ApiMeRemoveAllDevicesFromManagementRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeRemoveAllDevicesFromManagement")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/microsoft.graph.removeAllDevicesFromManagement"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeReprocessLicenseAssignmentRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
}


func (r ApiMeReprocessLicenseAssignmentRequest) Execute() (AnyOfmicrosoftGraphUser, *_nethttp.Response, error) {
	return r.ApiService.MeReprocessLicenseAssignmentExecute(r)
}

/*
MeReprocessLicenseAssignment Invoke action reprocessLicenseAssignment

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMeReprocessLicenseAssignmentRequest
*/
func (a *MeActionsApiService) MeReprocessLicenseAssignment(ctx _context.Context) ApiMeReprocessLicenseAssignmentRequest {
	return ApiMeReprocessLicenseAssignmentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphUser
func (a *MeActionsApiService) MeReprocessLicenseAssignmentExecute(r ApiMeReprocessLicenseAssignmentRequest) (AnyOfmicrosoftGraphUser, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphUser
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeReprocessLicenseAssignment")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/microsoft.graph.reprocessLicenseAssignment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeRestoreRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
}


func (r ApiMeRestoreRequest) Execute() (AnyOfmicrosoftGraphDirectoryObject, *_nethttp.Response, error) {
	return r.ApiService.MeRestoreExecute(r)
}

/*
MeRestore Invoke action restore

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMeRestoreRequest
*/
func (a *MeActionsApiService) MeRestore(ctx _context.Context) ApiMeRestoreRequest {
	return ApiMeRestoreRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AnyOfmicrosoftGraphDirectoryObject
func (a *MeActionsApiService) MeRestoreExecute(r ApiMeRestoreRequest) (AnyOfmicrosoftGraphDirectoryObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnyOfmicrosoftGraphDirectoryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeRestore")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/microsoft.graph.restore"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeRevokeSignInSessionsRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
}


func (r ApiMeRevokeSignInSessionsRequest) Execute() (bool, *_nethttp.Response, error) {
	return r.ApiService.MeRevokeSignInSessionsExecute(r)
}

/*
MeRevokeSignInSessions Invoke action revokeSignInSessions

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMeRevokeSignInSessionsRequest
*/
func (a *MeActionsApiService) MeRevokeSignInSessions(ctx _context.Context) ApiMeRevokeSignInSessionsRequest {
	return ApiMeRevokeSignInSessionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return bool
func (a *MeActionsApiService) MeRevokeSignInSessionsExecute(r ApiMeRevokeSignInSessionsRequest) (bool, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  bool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeRevokeSignInSessions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/microsoft.graph.revokeSignInSessions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeSendMailRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	inlineObject594 *InlineObject594
}

func (r ApiMeSendMailRequest) InlineObject594(inlineObject594 InlineObject594) ApiMeSendMailRequest {
	r.inlineObject594 = &inlineObject594
	return r
}

func (r ApiMeSendMailRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeSendMailExecute(r)
}

/*
MeSendMail Invoke action sendMail

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMeSendMailRequest
*/
func (a *MeActionsApiService) MeSendMail(ctx _context.Context) ApiMeSendMailRequest {
	return ApiMeSendMailRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeSendMailExecute(r ApiMeSendMailRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeSendMail")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/microsoft.graph.sendMail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject594 == nil {
		return nil, reportError("inlineObject594 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject594
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeTeamworkSendActivityNotificationRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	inlineObject698 *InlineObject698
}

func (r ApiMeTeamworkSendActivityNotificationRequest) InlineObject698(inlineObject698 InlineObject698) ApiMeTeamworkSendActivityNotificationRequest {
	r.inlineObject698 = &inlineObject698
	return r
}

func (r ApiMeTeamworkSendActivityNotificationRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeTeamworkSendActivityNotificationExecute(r)
}

/*
MeTeamworkSendActivityNotification Invoke action sendActivityNotification

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMeTeamworkSendActivityNotificationRequest
*/
func (a *MeActionsApiService) MeTeamworkSendActivityNotification(ctx _context.Context) ApiMeTeamworkSendActivityNotificationRequest {
	return ApiMeTeamworkSendActivityNotificationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeTeamworkSendActivityNotificationExecute(r ApiMeTeamworkSendActivityNotificationRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeTeamworkSendActivityNotification")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/teamwork/microsoft.graph.sendActivityNotification"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject698 == nil {
		return nil, reportError("inlineObject698 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject698
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMeTranslateExchangeIdsRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	inlineObject595 *InlineObject595
}

func (r ApiMeTranslateExchangeIdsRequest) InlineObject595(inlineObject595 InlineObject595) ApiMeTranslateExchangeIdsRequest {
	r.inlineObject595 = &inlineObject595
	return r
}

func (r ApiMeTranslateExchangeIdsRequest) Execute() ([]MicrosoftGraphConvertIdResult, *_nethttp.Response, error) {
	return r.ApiService.MeTranslateExchangeIdsExecute(r)
}

/*
MeTranslateExchangeIds Invoke action translateExchangeIds

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMeTranslateExchangeIdsRequest
*/
func (a *MeActionsApiService) MeTranslateExchangeIds(ctx _context.Context) ApiMeTranslateExchangeIdsRequest {
	return ApiMeTranslateExchangeIdsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []MicrosoftGraphConvertIdResult
func (a *MeActionsApiService) MeTranslateExchangeIdsExecute(r ApiMeTranslateExchangeIdsRequest) ([]MicrosoftGraphConvertIdResult, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []MicrosoftGraphConvertIdResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeTranslateExchangeIds")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/microsoft.graph.translateExchangeIds"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject595 == nil {
		return localVarReturnValue, nil, reportError("inlineObject595 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject595
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMeWipeManagedAppRegistrationsByDeviceTagRequest struct {
	ctx _context.Context
	ApiService *MeActionsApiService
	inlineObject596 *InlineObject596
}

func (r ApiMeWipeManagedAppRegistrationsByDeviceTagRequest) InlineObject596(inlineObject596 InlineObject596) ApiMeWipeManagedAppRegistrationsByDeviceTagRequest {
	r.inlineObject596 = &inlineObject596
	return r
}

func (r ApiMeWipeManagedAppRegistrationsByDeviceTagRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.MeWipeManagedAppRegistrationsByDeviceTagExecute(r)
}

/*
MeWipeManagedAppRegistrationsByDeviceTag Invoke action wipeManagedAppRegistrationsByDeviceTag

Issues a wipe operation on an app registration with specified device tag.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMeWipeManagedAppRegistrationsByDeviceTagRequest
*/
func (a *MeActionsApiService) MeWipeManagedAppRegistrationsByDeviceTag(ctx _context.Context) ApiMeWipeManagedAppRegistrationsByDeviceTagRequest {
	return ApiMeWipeManagedAppRegistrationsByDeviceTagRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MeActionsApiService) MeWipeManagedAppRegistrationsByDeviceTagExecute(r ApiMeWipeManagedAppRegistrationsByDeviceTagRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeActionsApiService.MeWipeManagedAppRegistrationsByDeviceTag")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/microsoft.graph.wipeManagedAppRegistrationsByDeviceTag"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.inlineObject596 == nil {
		return nil, reportError("inlineObject596 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inlineObject596
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
