/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package msgraph

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"os"
)

// Linger please
var (
	_ _context.Context
)

// DrivesListApiService DrivesListApi service
type DrivesListApiService service

type ApiDrivesDeleteListRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	ifMatch *string
}

// ETag
func (r ApiDrivesDeleteListRequest) IfMatch(ifMatch string) ApiDrivesDeleteListRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDrivesDeleteListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DrivesDeleteListExecute(r)
}

/*
DrivesDeleteList Delete navigation property list for drives

For drives in SharePoint, the underlying document library list. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @return ApiDrivesDeleteListRequest
*/
func (a *DrivesListApiService) DrivesDeleteList(ctx _context.Context, driveId string) ApiDrivesDeleteListRequest {
	return ApiDrivesDeleteListRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
	}
}

// Execute executes the request
func (a *DrivesListApiService) DrivesDeleteListExecute(r ApiDrivesDeleteListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesDeleteList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDrivesGetListRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDrivesGetListRequest) Select_(select_ []string) ApiDrivesGetListRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDrivesGetListRequest) Expand(expand []string) ApiDrivesGetListRequest {
	r.expand = &expand
	return r
}

func (r ApiDrivesGetListRequest) Execute() (MicrosoftGraphList, *_nethttp.Response, error) {
	return r.ApiService.DrivesGetListExecute(r)
}

/*
DrivesGetList Get list from drives

For drives in SharePoint, the underlying document library list. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @return ApiDrivesGetListRequest
*/
func (a *DrivesListApiService) DrivesGetList(ctx _context.Context, driveId string) ApiDrivesGetListRequest {
	return ApiDrivesGetListRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphList
func (a *DrivesListApiService) DrivesGetListExecute(r ApiDrivesGetListRequest) (MicrosoftGraphList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesGetList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesListColumnsDeleteRefSourceColumnRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	columnDefinitionId string
	ifMatch *string
}

// ETag
func (r ApiDrivesListColumnsDeleteRefSourceColumnRequest) IfMatch(ifMatch string) ApiDrivesListColumnsDeleteRefSourceColumnRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDrivesListColumnsDeleteRefSourceColumnRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DrivesListColumnsDeleteRefSourceColumnExecute(r)
}

/*
DrivesListColumnsDeleteRefSourceColumn Delete ref of navigation property sourceColumn for drives

The source column for the content type column.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param columnDefinitionId key: id of columnDefinition
 @return ApiDrivesListColumnsDeleteRefSourceColumnRequest
*/
func (a *DrivesListApiService) DrivesListColumnsDeleteRefSourceColumn(ctx _context.Context, driveId string, columnDefinitionId string) ApiDrivesListColumnsDeleteRefSourceColumnRequest {
	return ApiDrivesListColumnsDeleteRefSourceColumnRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
func (a *DrivesListApiService) DrivesListColumnsDeleteRefSourceColumnExecute(r ApiDrivesListColumnsDeleteRefSourceColumnRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListColumnsDeleteRefSourceColumn")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/columns/{columnDefinition-id}/sourceColumn/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDrivesListColumnsGetRefSourceColumnRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	columnDefinitionId string
}


func (r ApiDrivesListColumnsGetRefSourceColumnRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.DrivesListColumnsGetRefSourceColumnExecute(r)
}

/*
DrivesListColumnsGetRefSourceColumn Get ref of sourceColumn from drives

The source column for the content type column.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param columnDefinitionId key: id of columnDefinition
 @return ApiDrivesListColumnsGetRefSourceColumnRequest
*/
func (a *DrivesListApiService) DrivesListColumnsGetRefSourceColumn(ctx _context.Context, driveId string, columnDefinitionId string) ApiDrivesListColumnsGetRefSourceColumnRequest {
	return ApiDrivesListColumnsGetRefSourceColumnRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
//  @return string
func (a *DrivesListApiService) DrivesListColumnsGetRefSourceColumnExecute(r ApiDrivesListColumnsGetRefSourceColumnRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListColumnsGetRefSourceColumn")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/columns/{columnDefinition-id}/sourceColumn/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesListColumnsGetSourceColumnRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	columnDefinitionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDrivesListColumnsGetSourceColumnRequest) Select_(select_ []string) ApiDrivesListColumnsGetSourceColumnRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDrivesListColumnsGetSourceColumnRequest) Expand(expand []string) ApiDrivesListColumnsGetSourceColumnRequest {
	r.expand = &expand
	return r
}

func (r ApiDrivesListColumnsGetSourceColumnRequest) Execute() (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.DrivesListColumnsGetSourceColumnExecute(r)
}

/*
DrivesListColumnsGetSourceColumn Get sourceColumn from drives

The source column for the content type column.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param columnDefinitionId key: id of columnDefinition
 @return ApiDrivesListColumnsGetSourceColumnRequest
*/
func (a *DrivesListApiService) DrivesListColumnsGetSourceColumn(ctx _context.Context, driveId string, columnDefinitionId string) ApiDrivesListColumnsGetSourceColumnRequest {
	return ApiDrivesListColumnsGetSourceColumnRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphColumnDefinition
func (a *DrivesListApiService) DrivesListColumnsGetSourceColumnExecute(r ApiDrivesListColumnsGetSourceColumnRequest) (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListColumnsGetSourceColumn")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/columns/{columnDefinition-id}/sourceColumn"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesListColumnsUpdateRefSourceColumnRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	columnDefinitionId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiDrivesListColumnsUpdateRefSourceColumnRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiDrivesListColumnsUpdateRefSourceColumnRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiDrivesListColumnsUpdateRefSourceColumnRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DrivesListColumnsUpdateRefSourceColumnExecute(r)
}

/*
DrivesListColumnsUpdateRefSourceColumn Update the ref of navigation property sourceColumn in drives

The source column for the content type column.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param columnDefinitionId key: id of columnDefinition
 @return ApiDrivesListColumnsUpdateRefSourceColumnRequest
*/
func (a *DrivesListApiService) DrivesListColumnsUpdateRefSourceColumn(ctx _context.Context, driveId string, columnDefinitionId string) ApiDrivesListColumnsUpdateRefSourceColumnRequest {
	return ApiDrivesListColumnsUpdateRefSourceColumnRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
func (a *DrivesListApiService) DrivesListColumnsUpdateRefSourceColumnExecute(r ApiDrivesListColumnsUpdateRefSourceColumnRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListColumnsUpdateRefSourceColumn")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/columns/{columnDefinition-id}/sourceColumn/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDrivesListContentTypesColumnsDeleteRefSourceColumnRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	contentTypeId string
	columnDefinitionId string
	ifMatch *string
}

// ETag
func (r ApiDrivesListContentTypesColumnsDeleteRefSourceColumnRequest) IfMatch(ifMatch string) ApiDrivesListContentTypesColumnsDeleteRefSourceColumnRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDrivesListContentTypesColumnsDeleteRefSourceColumnRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DrivesListContentTypesColumnsDeleteRefSourceColumnExecute(r)
}

/*
DrivesListContentTypesColumnsDeleteRefSourceColumn Delete ref of navigation property sourceColumn for drives

The source column for the content type column.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param contentTypeId key: id of contentType
 @param columnDefinitionId key: id of columnDefinition
 @return ApiDrivesListContentTypesColumnsDeleteRefSourceColumnRequest
*/
func (a *DrivesListApiService) DrivesListContentTypesColumnsDeleteRefSourceColumn(ctx _context.Context, driveId string, contentTypeId string, columnDefinitionId string) ApiDrivesListContentTypesColumnsDeleteRefSourceColumnRequest {
	return ApiDrivesListContentTypesColumnsDeleteRefSourceColumnRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		contentTypeId: contentTypeId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
func (a *DrivesListApiService) DrivesListContentTypesColumnsDeleteRefSourceColumnExecute(r ApiDrivesListContentTypesColumnsDeleteRefSourceColumnRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListContentTypesColumnsDeleteRefSourceColumn")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/contentTypes/{contentType-id}/columns/{columnDefinition-id}/sourceColumn/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDrivesListContentTypesColumnsGetRefSourceColumnRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	contentTypeId string
	columnDefinitionId string
}


func (r ApiDrivesListContentTypesColumnsGetRefSourceColumnRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.DrivesListContentTypesColumnsGetRefSourceColumnExecute(r)
}

/*
DrivesListContentTypesColumnsGetRefSourceColumn Get ref of sourceColumn from drives

The source column for the content type column.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param contentTypeId key: id of contentType
 @param columnDefinitionId key: id of columnDefinition
 @return ApiDrivesListContentTypesColumnsGetRefSourceColumnRequest
*/
func (a *DrivesListApiService) DrivesListContentTypesColumnsGetRefSourceColumn(ctx _context.Context, driveId string, contentTypeId string, columnDefinitionId string) ApiDrivesListContentTypesColumnsGetRefSourceColumnRequest {
	return ApiDrivesListContentTypesColumnsGetRefSourceColumnRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		contentTypeId: contentTypeId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
//  @return string
func (a *DrivesListApiService) DrivesListContentTypesColumnsGetRefSourceColumnExecute(r ApiDrivesListContentTypesColumnsGetRefSourceColumnRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListContentTypesColumnsGetRefSourceColumn")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/contentTypes/{contentType-id}/columns/{columnDefinition-id}/sourceColumn/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesListContentTypesColumnsGetSourceColumnRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	contentTypeId string
	columnDefinitionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDrivesListContentTypesColumnsGetSourceColumnRequest) Select_(select_ []string) ApiDrivesListContentTypesColumnsGetSourceColumnRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDrivesListContentTypesColumnsGetSourceColumnRequest) Expand(expand []string) ApiDrivesListContentTypesColumnsGetSourceColumnRequest {
	r.expand = &expand
	return r
}

func (r ApiDrivesListContentTypesColumnsGetSourceColumnRequest) Execute() (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.DrivesListContentTypesColumnsGetSourceColumnExecute(r)
}

/*
DrivesListContentTypesColumnsGetSourceColumn Get sourceColumn from drives

The source column for the content type column.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param contentTypeId key: id of contentType
 @param columnDefinitionId key: id of columnDefinition
 @return ApiDrivesListContentTypesColumnsGetSourceColumnRequest
*/
func (a *DrivesListApiService) DrivesListContentTypesColumnsGetSourceColumn(ctx _context.Context, driveId string, contentTypeId string, columnDefinitionId string) ApiDrivesListContentTypesColumnsGetSourceColumnRequest {
	return ApiDrivesListContentTypesColumnsGetSourceColumnRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		contentTypeId: contentTypeId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphColumnDefinition
func (a *DrivesListApiService) DrivesListContentTypesColumnsGetSourceColumnExecute(r ApiDrivesListContentTypesColumnsGetSourceColumnRequest) (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListContentTypesColumnsGetSourceColumn")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/contentTypes/{contentType-id}/columns/{columnDefinition-id}/sourceColumn"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesListContentTypesColumnsUpdateRefSourceColumnRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	contentTypeId string
	columnDefinitionId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiDrivesListContentTypesColumnsUpdateRefSourceColumnRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiDrivesListContentTypesColumnsUpdateRefSourceColumnRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiDrivesListContentTypesColumnsUpdateRefSourceColumnRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DrivesListContentTypesColumnsUpdateRefSourceColumnExecute(r)
}

/*
DrivesListContentTypesColumnsUpdateRefSourceColumn Update the ref of navigation property sourceColumn in drives

The source column for the content type column.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param contentTypeId key: id of contentType
 @param columnDefinitionId key: id of columnDefinition
 @return ApiDrivesListContentTypesColumnsUpdateRefSourceColumnRequest
*/
func (a *DrivesListApiService) DrivesListContentTypesColumnsUpdateRefSourceColumn(ctx _context.Context, driveId string, contentTypeId string, columnDefinitionId string) ApiDrivesListContentTypesColumnsUpdateRefSourceColumnRequest {
	return ApiDrivesListContentTypesColumnsUpdateRefSourceColumnRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		contentTypeId: contentTypeId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
func (a *DrivesListApiService) DrivesListContentTypesColumnsUpdateRefSourceColumnExecute(r ApiDrivesListContentTypesColumnsUpdateRefSourceColumnRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListContentTypesColumnsUpdateRefSourceColumn")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/contentTypes/{contentType-id}/columns/{columnDefinition-id}/sourceColumn/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDrivesListContentTypesCreateColumnLinksRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	contentTypeId string
	microsoftGraphColumnLink *MicrosoftGraphColumnLink
}

// New navigation property
func (r ApiDrivesListContentTypesCreateColumnLinksRequest) MicrosoftGraphColumnLink(microsoftGraphColumnLink MicrosoftGraphColumnLink) ApiDrivesListContentTypesCreateColumnLinksRequest {
	r.microsoftGraphColumnLink = &microsoftGraphColumnLink
	return r
}

func (r ApiDrivesListContentTypesCreateColumnLinksRequest) Execute() (MicrosoftGraphColumnLink, *_nethttp.Response, error) {
	return r.ApiService.DrivesListContentTypesCreateColumnLinksExecute(r)
}

/*
DrivesListContentTypesCreateColumnLinks Create new navigation property to columnLinks for drives

The collection of columns that are required by this content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param contentTypeId key: id of contentType
 @return ApiDrivesListContentTypesCreateColumnLinksRequest
*/
func (a *DrivesListApiService) DrivesListContentTypesCreateColumnLinks(ctx _context.Context, driveId string, contentTypeId string) ApiDrivesListContentTypesCreateColumnLinksRequest {
	return ApiDrivesListContentTypesCreateColumnLinksRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphColumnLink
func (a *DrivesListApiService) DrivesListContentTypesCreateColumnLinksExecute(r ApiDrivesListContentTypesCreateColumnLinksRequest) (MicrosoftGraphColumnLink, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphColumnLink
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListContentTypesCreateColumnLinks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/contentTypes/{contentType-id}/columnLinks"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphColumnLink == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphColumnLink is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphColumnLink
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesListContentTypesCreateColumnsRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	contentTypeId string
	microsoftGraphColumnDefinition *MicrosoftGraphColumnDefinition
}

// New navigation property
func (r ApiDrivesListContentTypesCreateColumnsRequest) MicrosoftGraphColumnDefinition(microsoftGraphColumnDefinition MicrosoftGraphColumnDefinition) ApiDrivesListContentTypesCreateColumnsRequest {
	r.microsoftGraphColumnDefinition = &microsoftGraphColumnDefinition
	return r
}

func (r ApiDrivesListContentTypesCreateColumnsRequest) Execute() (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.DrivesListContentTypesCreateColumnsExecute(r)
}

/*
DrivesListContentTypesCreateColumns Create new navigation property to columns for drives

The collection of column definitions for this contentType.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param contentTypeId key: id of contentType
 @return ApiDrivesListContentTypesCreateColumnsRequest
*/
func (a *DrivesListApiService) DrivesListContentTypesCreateColumns(ctx _context.Context, driveId string, contentTypeId string) ApiDrivesListContentTypesCreateColumnsRequest {
	return ApiDrivesListContentTypesCreateColumnsRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphColumnDefinition
func (a *DrivesListApiService) DrivesListContentTypesCreateColumnsExecute(r ApiDrivesListContentTypesCreateColumnsRequest) (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListContentTypesCreateColumns")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/contentTypes/{contentType-id}/columns"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphColumnDefinition == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphColumnDefinition is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphColumnDefinition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesListContentTypesCreateRefBaseTypesRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	contentTypeId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref value
func (r ApiDrivesListContentTypesCreateRefBaseTypesRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiDrivesListContentTypesCreateRefBaseTypesRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiDrivesListContentTypesCreateRefBaseTypesRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.DrivesListContentTypesCreateRefBaseTypesExecute(r)
}

/*
DrivesListContentTypesCreateRefBaseTypes Create new navigation property ref to baseTypes for drives

The collection of content types that are ancestors of this content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param contentTypeId key: id of contentType
 @return ApiDrivesListContentTypesCreateRefBaseTypesRequest
*/
func (a *DrivesListApiService) DrivesListContentTypesCreateRefBaseTypes(ctx _context.Context, driveId string, contentTypeId string) ApiDrivesListContentTypesCreateRefBaseTypesRequest {
	return ApiDrivesListContentTypesCreateRefBaseTypesRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DrivesListApiService) DrivesListContentTypesCreateRefBaseTypesExecute(r ApiDrivesListContentTypesCreateRefBaseTypesRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListContentTypesCreateRefBaseTypes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/contentTypes/{contentType-id}/baseTypes/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesListContentTypesCreateRefColumnPositionsRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	contentTypeId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref value
func (r ApiDrivesListContentTypesCreateRefColumnPositionsRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiDrivesListContentTypesCreateRefColumnPositionsRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiDrivesListContentTypesCreateRefColumnPositionsRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.DrivesListContentTypesCreateRefColumnPositionsExecute(r)
}

/*
DrivesListContentTypesCreateRefColumnPositions Create new navigation property ref to columnPositions for drives

Column order information in a content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param contentTypeId key: id of contentType
 @return ApiDrivesListContentTypesCreateRefColumnPositionsRequest
*/
func (a *DrivesListApiService) DrivesListContentTypesCreateRefColumnPositions(ctx _context.Context, driveId string, contentTypeId string) ApiDrivesListContentTypesCreateRefColumnPositionsRequest {
	return ApiDrivesListContentTypesCreateRefColumnPositionsRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DrivesListApiService) DrivesListContentTypesCreateRefColumnPositionsExecute(r ApiDrivesListContentTypesCreateRefColumnPositionsRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListContentTypesCreateRefColumnPositions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/contentTypes/{contentType-id}/columnPositions/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesListContentTypesDeleteColumnLinksRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	contentTypeId string
	columnLinkId string
	ifMatch *string
}

// ETag
func (r ApiDrivesListContentTypesDeleteColumnLinksRequest) IfMatch(ifMatch string) ApiDrivesListContentTypesDeleteColumnLinksRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDrivesListContentTypesDeleteColumnLinksRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DrivesListContentTypesDeleteColumnLinksExecute(r)
}

/*
DrivesListContentTypesDeleteColumnLinks Delete navigation property columnLinks for drives

The collection of columns that are required by this content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param contentTypeId key: id of contentType
 @param columnLinkId key: id of columnLink
 @return ApiDrivesListContentTypesDeleteColumnLinksRequest
*/
func (a *DrivesListApiService) DrivesListContentTypesDeleteColumnLinks(ctx _context.Context, driveId string, contentTypeId string, columnLinkId string) ApiDrivesListContentTypesDeleteColumnLinksRequest {
	return ApiDrivesListContentTypesDeleteColumnLinksRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		contentTypeId: contentTypeId,
		columnLinkId: columnLinkId,
	}
}

// Execute executes the request
func (a *DrivesListApiService) DrivesListContentTypesDeleteColumnLinksExecute(r ApiDrivesListContentTypesDeleteColumnLinksRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListContentTypesDeleteColumnLinks")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/contentTypes/{contentType-id}/columnLinks/{columnLink-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnLink-id"+"}", _neturl.PathEscape(parameterToString(r.columnLinkId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDrivesListContentTypesDeleteColumnsRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	contentTypeId string
	columnDefinitionId string
	ifMatch *string
}

// ETag
func (r ApiDrivesListContentTypesDeleteColumnsRequest) IfMatch(ifMatch string) ApiDrivesListContentTypesDeleteColumnsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDrivesListContentTypesDeleteColumnsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DrivesListContentTypesDeleteColumnsExecute(r)
}

/*
DrivesListContentTypesDeleteColumns Delete navigation property columns for drives

The collection of column definitions for this contentType.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param contentTypeId key: id of contentType
 @param columnDefinitionId key: id of columnDefinition
 @return ApiDrivesListContentTypesDeleteColumnsRequest
*/
func (a *DrivesListApiService) DrivesListContentTypesDeleteColumns(ctx _context.Context, driveId string, contentTypeId string, columnDefinitionId string) ApiDrivesListContentTypesDeleteColumnsRequest {
	return ApiDrivesListContentTypesDeleteColumnsRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		contentTypeId: contentTypeId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
func (a *DrivesListApiService) DrivesListContentTypesDeleteColumnsExecute(r ApiDrivesListContentTypesDeleteColumnsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListContentTypesDeleteColumns")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/contentTypes/{contentType-id}/columns/{columnDefinition-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDrivesListContentTypesDeleteRefBaseRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	contentTypeId string
	ifMatch *string
}

// ETag
func (r ApiDrivesListContentTypesDeleteRefBaseRequest) IfMatch(ifMatch string) ApiDrivesListContentTypesDeleteRefBaseRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDrivesListContentTypesDeleteRefBaseRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DrivesListContentTypesDeleteRefBaseExecute(r)
}

/*
DrivesListContentTypesDeleteRefBase Delete ref of navigation property base for drives

Parent contentType from which this content type is derived.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param contentTypeId key: id of contentType
 @return ApiDrivesListContentTypesDeleteRefBaseRequest
*/
func (a *DrivesListApiService) DrivesListContentTypesDeleteRefBase(ctx _context.Context, driveId string, contentTypeId string) ApiDrivesListContentTypesDeleteRefBaseRequest {
	return ApiDrivesListContentTypesDeleteRefBaseRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
func (a *DrivesListApiService) DrivesListContentTypesDeleteRefBaseExecute(r ApiDrivesListContentTypesDeleteRefBaseRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListContentTypesDeleteRefBase")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/contentTypes/{contentType-id}/base/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDrivesListContentTypesGetBaseRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	contentTypeId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDrivesListContentTypesGetBaseRequest) Select_(select_ []string) ApiDrivesListContentTypesGetBaseRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDrivesListContentTypesGetBaseRequest) Expand(expand []string) ApiDrivesListContentTypesGetBaseRequest {
	r.expand = &expand
	return r
}

func (r ApiDrivesListContentTypesGetBaseRequest) Execute() (MicrosoftGraphContentType, *_nethttp.Response, error) {
	return r.ApiService.DrivesListContentTypesGetBaseExecute(r)
}

/*
DrivesListContentTypesGetBase Get base from drives

Parent contentType from which this content type is derived.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param contentTypeId key: id of contentType
 @return ApiDrivesListContentTypesGetBaseRequest
*/
func (a *DrivesListApiService) DrivesListContentTypesGetBase(ctx _context.Context, driveId string, contentTypeId string) ApiDrivesListContentTypesGetBaseRequest {
	return ApiDrivesListContentTypesGetBaseRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphContentType
func (a *DrivesListApiService) DrivesListContentTypesGetBaseExecute(r ApiDrivesListContentTypesGetBaseRequest) (MicrosoftGraphContentType, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphContentType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListContentTypesGetBase")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/contentTypes/{contentType-id}/base"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesListContentTypesGetColumnLinksRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	contentTypeId string
	columnLinkId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDrivesListContentTypesGetColumnLinksRequest) Select_(select_ []string) ApiDrivesListContentTypesGetColumnLinksRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDrivesListContentTypesGetColumnLinksRequest) Expand(expand []string) ApiDrivesListContentTypesGetColumnLinksRequest {
	r.expand = &expand
	return r
}

func (r ApiDrivesListContentTypesGetColumnLinksRequest) Execute() (MicrosoftGraphColumnLink, *_nethttp.Response, error) {
	return r.ApiService.DrivesListContentTypesGetColumnLinksExecute(r)
}

/*
DrivesListContentTypesGetColumnLinks Get columnLinks from drives

The collection of columns that are required by this content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param contentTypeId key: id of contentType
 @param columnLinkId key: id of columnLink
 @return ApiDrivesListContentTypesGetColumnLinksRequest
*/
func (a *DrivesListApiService) DrivesListContentTypesGetColumnLinks(ctx _context.Context, driveId string, contentTypeId string, columnLinkId string) ApiDrivesListContentTypesGetColumnLinksRequest {
	return ApiDrivesListContentTypesGetColumnLinksRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		contentTypeId: contentTypeId,
		columnLinkId: columnLinkId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphColumnLink
func (a *DrivesListApiService) DrivesListContentTypesGetColumnLinksExecute(r ApiDrivesListContentTypesGetColumnLinksRequest) (MicrosoftGraphColumnLink, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphColumnLink
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListContentTypesGetColumnLinks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/contentTypes/{contentType-id}/columnLinks/{columnLink-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnLink-id"+"}", _neturl.PathEscape(parameterToString(r.columnLinkId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesListContentTypesGetColumnsRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	contentTypeId string
	columnDefinitionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDrivesListContentTypesGetColumnsRequest) Select_(select_ []string) ApiDrivesListContentTypesGetColumnsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDrivesListContentTypesGetColumnsRequest) Expand(expand []string) ApiDrivesListContentTypesGetColumnsRequest {
	r.expand = &expand
	return r
}

func (r ApiDrivesListContentTypesGetColumnsRequest) Execute() (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.DrivesListContentTypesGetColumnsExecute(r)
}

/*
DrivesListContentTypesGetColumns Get columns from drives

The collection of column definitions for this contentType.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param contentTypeId key: id of contentType
 @param columnDefinitionId key: id of columnDefinition
 @return ApiDrivesListContentTypesGetColumnsRequest
*/
func (a *DrivesListApiService) DrivesListContentTypesGetColumns(ctx _context.Context, driveId string, contentTypeId string, columnDefinitionId string) ApiDrivesListContentTypesGetColumnsRequest {
	return ApiDrivesListContentTypesGetColumnsRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		contentTypeId: contentTypeId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphColumnDefinition
func (a *DrivesListApiService) DrivesListContentTypesGetColumnsExecute(r ApiDrivesListContentTypesGetColumnsRequest) (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListContentTypesGetColumns")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/contentTypes/{contentType-id}/columns/{columnDefinition-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesListContentTypesGetRefBaseRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	contentTypeId string
}


func (r ApiDrivesListContentTypesGetRefBaseRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.DrivesListContentTypesGetRefBaseExecute(r)
}

/*
DrivesListContentTypesGetRefBase Get ref of base from drives

Parent contentType from which this content type is derived.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param contentTypeId key: id of contentType
 @return ApiDrivesListContentTypesGetRefBaseRequest
*/
func (a *DrivesListApiService) DrivesListContentTypesGetRefBase(ctx _context.Context, driveId string, contentTypeId string) ApiDrivesListContentTypesGetRefBaseRequest {
	return ApiDrivesListContentTypesGetRefBaseRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return string
func (a *DrivesListApiService) DrivesListContentTypesGetRefBaseExecute(r ApiDrivesListContentTypesGetRefBaseRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListContentTypesGetRefBase")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/contentTypes/{contentType-id}/base/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesListContentTypesListBaseTypesRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	contentTypeId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiDrivesListContentTypesListBaseTypesRequest) Top(top int32) ApiDrivesListContentTypesListBaseTypesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiDrivesListContentTypesListBaseTypesRequest) Skip(skip int32) ApiDrivesListContentTypesListBaseTypesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiDrivesListContentTypesListBaseTypesRequest) Search(search string) ApiDrivesListContentTypesListBaseTypesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiDrivesListContentTypesListBaseTypesRequest) Filter(filter string) ApiDrivesListContentTypesListBaseTypesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiDrivesListContentTypesListBaseTypesRequest) Count(count bool) ApiDrivesListContentTypesListBaseTypesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiDrivesListContentTypesListBaseTypesRequest) Orderby(orderby []string) ApiDrivesListContentTypesListBaseTypesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiDrivesListContentTypesListBaseTypesRequest) Select_(select_ []string) ApiDrivesListContentTypesListBaseTypesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDrivesListContentTypesListBaseTypesRequest) Expand(expand []string) ApiDrivesListContentTypesListBaseTypesRequest {
	r.expand = &expand
	return r
}

func (r ApiDrivesListContentTypesListBaseTypesRequest) Execute() (CollectionOfContentType, *_nethttp.Response, error) {
	return r.ApiService.DrivesListContentTypesListBaseTypesExecute(r)
}

/*
DrivesListContentTypesListBaseTypes Get baseTypes from drives

The collection of content types that are ancestors of this content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param contentTypeId key: id of contentType
 @return ApiDrivesListContentTypesListBaseTypesRequest
*/
func (a *DrivesListApiService) DrivesListContentTypesListBaseTypes(ctx _context.Context, driveId string, contentTypeId string) ApiDrivesListContentTypesListBaseTypesRequest {
	return ApiDrivesListContentTypesListBaseTypesRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return CollectionOfContentType
func (a *DrivesListApiService) DrivesListContentTypesListBaseTypesExecute(r ApiDrivesListContentTypesListBaseTypesRequest) (CollectionOfContentType, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfContentType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListContentTypesListBaseTypes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/contentTypes/{contentType-id}/baseTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesListContentTypesListColumnLinksRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	contentTypeId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiDrivesListContentTypesListColumnLinksRequest) Top(top int32) ApiDrivesListContentTypesListColumnLinksRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiDrivesListContentTypesListColumnLinksRequest) Skip(skip int32) ApiDrivesListContentTypesListColumnLinksRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiDrivesListContentTypesListColumnLinksRequest) Search(search string) ApiDrivesListContentTypesListColumnLinksRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiDrivesListContentTypesListColumnLinksRequest) Filter(filter string) ApiDrivesListContentTypesListColumnLinksRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiDrivesListContentTypesListColumnLinksRequest) Count(count bool) ApiDrivesListContentTypesListColumnLinksRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiDrivesListContentTypesListColumnLinksRequest) Orderby(orderby []string) ApiDrivesListContentTypesListColumnLinksRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiDrivesListContentTypesListColumnLinksRequest) Select_(select_ []string) ApiDrivesListContentTypesListColumnLinksRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDrivesListContentTypesListColumnLinksRequest) Expand(expand []string) ApiDrivesListContentTypesListColumnLinksRequest {
	r.expand = &expand
	return r
}

func (r ApiDrivesListContentTypesListColumnLinksRequest) Execute() (CollectionOfColumnLink, *_nethttp.Response, error) {
	return r.ApiService.DrivesListContentTypesListColumnLinksExecute(r)
}

/*
DrivesListContentTypesListColumnLinks Get columnLinks from drives

The collection of columns that are required by this content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param contentTypeId key: id of contentType
 @return ApiDrivesListContentTypesListColumnLinksRequest
*/
func (a *DrivesListApiService) DrivesListContentTypesListColumnLinks(ctx _context.Context, driveId string, contentTypeId string) ApiDrivesListContentTypesListColumnLinksRequest {
	return ApiDrivesListContentTypesListColumnLinksRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return CollectionOfColumnLink
func (a *DrivesListApiService) DrivesListContentTypesListColumnLinksExecute(r ApiDrivesListContentTypesListColumnLinksRequest) (CollectionOfColumnLink, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfColumnLink
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListContentTypesListColumnLinks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/contentTypes/{contentType-id}/columnLinks"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesListContentTypesListColumnPositionsRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	contentTypeId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiDrivesListContentTypesListColumnPositionsRequest) Top(top int32) ApiDrivesListContentTypesListColumnPositionsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiDrivesListContentTypesListColumnPositionsRequest) Skip(skip int32) ApiDrivesListContentTypesListColumnPositionsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiDrivesListContentTypesListColumnPositionsRequest) Search(search string) ApiDrivesListContentTypesListColumnPositionsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiDrivesListContentTypesListColumnPositionsRequest) Filter(filter string) ApiDrivesListContentTypesListColumnPositionsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiDrivesListContentTypesListColumnPositionsRequest) Count(count bool) ApiDrivesListContentTypesListColumnPositionsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiDrivesListContentTypesListColumnPositionsRequest) Orderby(orderby []string) ApiDrivesListContentTypesListColumnPositionsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiDrivesListContentTypesListColumnPositionsRequest) Select_(select_ []string) ApiDrivesListContentTypesListColumnPositionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDrivesListContentTypesListColumnPositionsRequest) Expand(expand []string) ApiDrivesListContentTypesListColumnPositionsRequest {
	r.expand = &expand
	return r
}

func (r ApiDrivesListContentTypesListColumnPositionsRequest) Execute() (CollectionOfColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.DrivesListContentTypesListColumnPositionsExecute(r)
}

/*
DrivesListContentTypesListColumnPositions Get columnPositions from drives

Column order information in a content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param contentTypeId key: id of contentType
 @return ApiDrivesListContentTypesListColumnPositionsRequest
*/
func (a *DrivesListApiService) DrivesListContentTypesListColumnPositions(ctx _context.Context, driveId string, contentTypeId string) ApiDrivesListContentTypesListColumnPositionsRequest {
	return ApiDrivesListContentTypesListColumnPositionsRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return CollectionOfColumnDefinition
func (a *DrivesListApiService) DrivesListContentTypesListColumnPositionsExecute(r ApiDrivesListContentTypesListColumnPositionsRequest) (CollectionOfColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListContentTypesListColumnPositions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/contentTypes/{contentType-id}/columnPositions"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesListContentTypesListColumnsRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	contentTypeId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiDrivesListContentTypesListColumnsRequest) Top(top int32) ApiDrivesListContentTypesListColumnsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiDrivesListContentTypesListColumnsRequest) Skip(skip int32) ApiDrivesListContentTypesListColumnsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiDrivesListContentTypesListColumnsRequest) Search(search string) ApiDrivesListContentTypesListColumnsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiDrivesListContentTypesListColumnsRequest) Filter(filter string) ApiDrivesListContentTypesListColumnsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiDrivesListContentTypesListColumnsRequest) Count(count bool) ApiDrivesListContentTypesListColumnsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiDrivesListContentTypesListColumnsRequest) Orderby(orderby []string) ApiDrivesListContentTypesListColumnsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiDrivesListContentTypesListColumnsRequest) Select_(select_ []string) ApiDrivesListContentTypesListColumnsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDrivesListContentTypesListColumnsRequest) Expand(expand []string) ApiDrivesListContentTypesListColumnsRequest {
	r.expand = &expand
	return r
}

func (r ApiDrivesListContentTypesListColumnsRequest) Execute() (CollectionOfColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.DrivesListContentTypesListColumnsExecute(r)
}

/*
DrivesListContentTypesListColumns Get columns from drives

The collection of column definitions for this contentType.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param contentTypeId key: id of contentType
 @return ApiDrivesListContentTypesListColumnsRequest
*/
func (a *DrivesListApiService) DrivesListContentTypesListColumns(ctx _context.Context, driveId string, contentTypeId string) ApiDrivesListContentTypesListColumnsRequest {
	return ApiDrivesListContentTypesListColumnsRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return CollectionOfColumnDefinition
func (a *DrivesListApiService) DrivesListContentTypesListColumnsExecute(r ApiDrivesListContentTypesListColumnsRequest) (CollectionOfColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListContentTypesListColumns")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/contentTypes/{contentType-id}/columns"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesListContentTypesListRefBaseTypesRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	contentTypeId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
}

// Show only the first n items
func (r ApiDrivesListContentTypesListRefBaseTypesRequest) Top(top int32) ApiDrivesListContentTypesListRefBaseTypesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiDrivesListContentTypesListRefBaseTypesRequest) Skip(skip int32) ApiDrivesListContentTypesListRefBaseTypesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiDrivesListContentTypesListRefBaseTypesRequest) Search(search string) ApiDrivesListContentTypesListRefBaseTypesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiDrivesListContentTypesListRefBaseTypesRequest) Filter(filter string) ApiDrivesListContentTypesListRefBaseTypesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiDrivesListContentTypesListRefBaseTypesRequest) Count(count bool) ApiDrivesListContentTypesListRefBaseTypesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiDrivesListContentTypesListRefBaseTypesRequest) Orderby(orderby []string) ApiDrivesListContentTypesListRefBaseTypesRequest {
	r.orderby = &orderby
	return r
}

func (r ApiDrivesListContentTypesListRefBaseTypesRequest) Execute() (CollectionOfLinksOfContentType, *_nethttp.Response, error) {
	return r.ApiService.DrivesListContentTypesListRefBaseTypesExecute(r)
}

/*
DrivesListContentTypesListRefBaseTypes Get ref of baseTypes from drives

The collection of content types that are ancestors of this content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param contentTypeId key: id of contentType
 @return ApiDrivesListContentTypesListRefBaseTypesRequest
*/
func (a *DrivesListApiService) DrivesListContentTypesListRefBaseTypes(ctx _context.Context, driveId string, contentTypeId string) ApiDrivesListContentTypesListRefBaseTypesRequest {
	return ApiDrivesListContentTypesListRefBaseTypesRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return CollectionOfLinksOfContentType
func (a *DrivesListApiService) DrivesListContentTypesListRefBaseTypesExecute(r ApiDrivesListContentTypesListRefBaseTypesRequest) (CollectionOfLinksOfContentType, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfLinksOfContentType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListContentTypesListRefBaseTypes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/contentTypes/{contentType-id}/baseTypes/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesListContentTypesListRefColumnPositionsRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	contentTypeId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
}

// Show only the first n items
func (r ApiDrivesListContentTypesListRefColumnPositionsRequest) Top(top int32) ApiDrivesListContentTypesListRefColumnPositionsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiDrivesListContentTypesListRefColumnPositionsRequest) Skip(skip int32) ApiDrivesListContentTypesListRefColumnPositionsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiDrivesListContentTypesListRefColumnPositionsRequest) Search(search string) ApiDrivesListContentTypesListRefColumnPositionsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiDrivesListContentTypesListRefColumnPositionsRequest) Filter(filter string) ApiDrivesListContentTypesListRefColumnPositionsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiDrivesListContentTypesListRefColumnPositionsRequest) Count(count bool) ApiDrivesListContentTypesListRefColumnPositionsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiDrivesListContentTypesListRefColumnPositionsRequest) Orderby(orderby []string) ApiDrivesListContentTypesListRefColumnPositionsRequest {
	r.orderby = &orderby
	return r
}

func (r ApiDrivesListContentTypesListRefColumnPositionsRequest) Execute() (CollectionOfLinksOfColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.DrivesListContentTypesListRefColumnPositionsExecute(r)
}

/*
DrivesListContentTypesListRefColumnPositions Get ref of columnPositions from drives

Column order information in a content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param contentTypeId key: id of contentType
 @return ApiDrivesListContentTypesListRefColumnPositionsRequest
*/
func (a *DrivesListApiService) DrivesListContentTypesListRefColumnPositions(ctx _context.Context, driveId string, contentTypeId string) ApiDrivesListContentTypesListRefColumnPositionsRequest {
	return ApiDrivesListContentTypesListRefColumnPositionsRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return CollectionOfLinksOfColumnDefinition
func (a *DrivesListApiService) DrivesListContentTypesListRefColumnPositionsExecute(r ApiDrivesListContentTypesListRefColumnPositionsRequest) (CollectionOfLinksOfColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfLinksOfColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListContentTypesListRefColumnPositions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/contentTypes/{contentType-id}/columnPositions/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesListContentTypesUpdateColumnLinksRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	contentTypeId string
	columnLinkId string
	microsoftGraphColumnLink *MicrosoftGraphColumnLink
}

// New navigation property values
func (r ApiDrivesListContentTypesUpdateColumnLinksRequest) MicrosoftGraphColumnLink(microsoftGraphColumnLink MicrosoftGraphColumnLink) ApiDrivesListContentTypesUpdateColumnLinksRequest {
	r.microsoftGraphColumnLink = &microsoftGraphColumnLink
	return r
}

func (r ApiDrivesListContentTypesUpdateColumnLinksRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DrivesListContentTypesUpdateColumnLinksExecute(r)
}

/*
DrivesListContentTypesUpdateColumnLinks Update the navigation property columnLinks in drives

The collection of columns that are required by this content type.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param contentTypeId key: id of contentType
 @param columnLinkId key: id of columnLink
 @return ApiDrivesListContentTypesUpdateColumnLinksRequest
*/
func (a *DrivesListApiService) DrivesListContentTypesUpdateColumnLinks(ctx _context.Context, driveId string, contentTypeId string, columnLinkId string) ApiDrivesListContentTypesUpdateColumnLinksRequest {
	return ApiDrivesListContentTypesUpdateColumnLinksRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		contentTypeId: contentTypeId,
		columnLinkId: columnLinkId,
	}
}

// Execute executes the request
func (a *DrivesListApiService) DrivesListContentTypesUpdateColumnLinksExecute(r ApiDrivesListContentTypesUpdateColumnLinksRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListContentTypesUpdateColumnLinks")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/contentTypes/{contentType-id}/columnLinks/{columnLink-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnLink-id"+"}", _neturl.PathEscape(parameterToString(r.columnLinkId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphColumnLink == nil {
		return nil, reportError("microsoftGraphColumnLink is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphColumnLink
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDrivesListContentTypesUpdateColumnsRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	contentTypeId string
	columnDefinitionId string
	microsoftGraphColumnDefinition *MicrosoftGraphColumnDefinition
}

// New navigation property values
func (r ApiDrivesListContentTypesUpdateColumnsRequest) MicrosoftGraphColumnDefinition(microsoftGraphColumnDefinition MicrosoftGraphColumnDefinition) ApiDrivesListContentTypesUpdateColumnsRequest {
	r.microsoftGraphColumnDefinition = &microsoftGraphColumnDefinition
	return r
}

func (r ApiDrivesListContentTypesUpdateColumnsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DrivesListContentTypesUpdateColumnsExecute(r)
}

/*
DrivesListContentTypesUpdateColumns Update the navigation property columns in drives

The collection of column definitions for this contentType.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param contentTypeId key: id of contentType
 @param columnDefinitionId key: id of columnDefinition
 @return ApiDrivesListContentTypesUpdateColumnsRequest
*/
func (a *DrivesListApiService) DrivesListContentTypesUpdateColumns(ctx _context.Context, driveId string, contentTypeId string, columnDefinitionId string) ApiDrivesListContentTypesUpdateColumnsRequest {
	return ApiDrivesListContentTypesUpdateColumnsRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		contentTypeId: contentTypeId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
func (a *DrivesListApiService) DrivesListContentTypesUpdateColumnsExecute(r ApiDrivesListContentTypesUpdateColumnsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListContentTypesUpdateColumns")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/contentTypes/{contentType-id}/columns/{columnDefinition-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphColumnDefinition == nil {
		return nil, reportError("microsoftGraphColumnDefinition is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphColumnDefinition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDrivesListContentTypesUpdateRefBaseRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	contentTypeId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiDrivesListContentTypesUpdateRefBaseRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiDrivesListContentTypesUpdateRefBaseRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiDrivesListContentTypesUpdateRefBaseRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DrivesListContentTypesUpdateRefBaseExecute(r)
}

/*
DrivesListContentTypesUpdateRefBase Update the ref of navigation property base in drives

Parent contentType from which this content type is derived.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param contentTypeId key: id of contentType
 @return ApiDrivesListContentTypesUpdateRefBaseRequest
*/
func (a *DrivesListApiService) DrivesListContentTypesUpdateRefBase(ctx _context.Context, driveId string, contentTypeId string) ApiDrivesListContentTypesUpdateRefBaseRequest {
	return ApiDrivesListContentTypesUpdateRefBaseRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
func (a *DrivesListApiService) DrivesListContentTypesUpdateRefBaseExecute(r ApiDrivesListContentTypesUpdateRefBaseRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListContentTypesUpdateRefBase")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/contentTypes/{contentType-id}/base/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDrivesListCreateColumnsRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	microsoftGraphColumnDefinition *MicrosoftGraphColumnDefinition
}

// New navigation property
func (r ApiDrivesListCreateColumnsRequest) MicrosoftGraphColumnDefinition(microsoftGraphColumnDefinition MicrosoftGraphColumnDefinition) ApiDrivesListCreateColumnsRequest {
	r.microsoftGraphColumnDefinition = &microsoftGraphColumnDefinition
	return r
}

func (r ApiDrivesListCreateColumnsRequest) Execute() (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.DrivesListCreateColumnsExecute(r)
}

/*
DrivesListCreateColumns Create new navigation property to columns for drives

The collection of field definitions for this list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @return ApiDrivesListCreateColumnsRequest
*/
func (a *DrivesListApiService) DrivesListCreateColumns(ctx _context.Context, driveId string) ApiDrivesListCreateColumnsRequest {
	return ApiDrivesListCreateColumnsRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphColumnDefinition
func (a *DrivesListApiService) DrivesListCreateColumnsExecute(r ApiDrivesListCreateColumnsRequest) (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListCreateColumns")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/columns"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphColumnDefinition == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphColumnDefinition is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphColumnDefinition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesListCreateContentTypesRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	microsoftGraphContentType *MicrosoftGraphContentType
}

// New navigation property
func (r ApiDrivesListCreateContentTypesRequest) MicrosoftGraphContentType(microsoftGraphContentType MicrosoftGraphContentType) ApiDrivesListCreateContentTypesRequest {
	r.microsoftGraphContentType = &microsoftGraphContentType
	return r
}

func (r ApiDrivesListCreateContentTypesRequest) Execute() (MicrosoftGraphContentType, *_nethttp.Response, error) {
	return r.ApiService.DrivesListCreateContentTypesExecute(r)
}

/*
DrivesListCreateContentTypes Create new navigation property to contentTypes for drives

The collection of content types present in this list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @return ApiDrivesListCreateContentTypesRequest
*/
func (a *DrivesListApiService) DrivesListCreateContentTypes(ctx _context.Context, driveId string) ApiDrivesListCreateContentTypesRequest {
	return ApiDrivesListCreateContentTypesRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphContentType
func (a *DrivesListApiService) DrivesListCreateContentTypesExecute(r ApiDrivesListCreateContentTypesRequest) (MicrosoftGraphContentType, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphContentType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListCreateContentTypes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/contentTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphContentType == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphContentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphContentType
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesListCreateItemsRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	microsoftGraphListItem *MicrosoftGraphListItem
}

// New navigation property
func (r ApiDrivesListCreateItemsRequest) MicrosoftGraphListItem(microsoftGraphListItem MicrosoftGraphListItem) ApiDrivesListCreateItemsRequest {
	r.microsoftGraphListItem = &microsoftGraphListItem
	return r
}

func (r ApiDrivesListCreateItemsRequest) Execute() (MicrosoftGraphListItem, *_nethttp.Response, error) {
	return r.ApiService.DrivesListCreateItemsExecute(r)
}

/*
DrivesListCreateItems Create new navigation property to items for drives

All items contained in the list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @return ApiDrivesListCreateItemsRequest
*/
func (a *DrivesListApiService) DrivesListCreateItems(ctx _context.Context, driveId string) ApiDrivesListCreateItemsRequest {
	return ApiDrivesListCreateItemsRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphListItem
func (a *DrivesListApiService) DrivesListCreateItemsExecute(r ApiDrivesListCreateItemsRequest) (MicrosoftGraphListItem, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphListItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListCreateItems")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/items"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphListItem == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphListItem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphListItem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesListCreateSubscriptionsRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	microsoftGraphSubscription *MicrosoftGraphSubscription
}

// New navigation property
func (r ApiDrivesListCreateSubscriptionsRequest) MicrosoftGraphSubscription(microsoftGraphSubscription MicrosoftGraphSubscription) ApiDrivesListCreateSubscriptionsRequest {
	r.microsoftGraphSubscription = &microsoftGraphSubscription
	return r
}

func (r ApiDrivesListCreateSubscriptionsRequest) Execute() (MicrosoftGraphSubscription, *_nethttp.Response, error) {
	return r.ApiService.DrivesListCreateSubscriptionsExecute(r)
}

/*
DrivesListCreateSubscriptions Create new navigation property to subscriptions for drives

The set of subscriptions on the list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @return ApiDrivesListCreateSubscriptionsRequest
*/
func (a *DrivesListApiService) DrivesListCreateSubscriptions(ctx _context.Context, driveId string) ApiDrivesListCreateSubscriptionsRequest {
	return ApiDrivesListCreateSubscriptionsRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphSubscription
func (a *DrivesListApiService) DrivesListCreateSubscriptionsExecute(r ApiDrivesListCreateSubscriptionsRequest) (MicrosoftGraphSubscription, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphSubscription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListCreateSubscriptions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/subscriptions"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphSubscription == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphSubscription is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphSubscription
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesListDeleteColumnsRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	columnDefinitionId string
	ifMatch *string
}

// ETag
func (r ApiDrivesListDeleteColumnsRequest) IfMatch(ifMatch string) ApiDrivesListDeleteColumnsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDrivesListDeleteColumnsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DrivesListDeleteColumnsExecute(r)
}

/*
DrivesListDeleteColumns Delete navigation property columns for drives

The collection of field definitions for this list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param columnDefinitionId key: id of columnDefinition
 @return ApiDrivesListDeleteColumnsRequest
*/
func (a *DrivesListApiService) DrivesListDeleteColumns(ctx _context.Context, driveId string, columnDefinitionId string) ApiDrivesListDeleteColumnsRequest {
	return ApiDrivesListDeleteColumnsRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
func (a *DrivesListApiService) DrivesListDeleteColumnsExecute(r ApiDrivesListDeleteColumnsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListDeleteColumns")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/columns/{columnDefinition-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDrivesListDeleteContentTypesRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	contentTypeId string
	ifMatch *string
}

// ETag
func (r ApiDrivesListDeleteContentTypesRequest) IfMatch(ifMatch string) ApiDrivesListDeleteContentTypesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDrivesListDeleteContentTypesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DrivesListDeleteContentTypesExecute(r)
}

/*
DrivesListDeleteContentTypes Delete navigation property contentTypes for drives

The collection of content types present in this list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param contentTypeId key: id of contentType
 @return ApiDrivesListDeleteContentTypesRequest
*/
func (a *DrivesListApiService) DrivesListDeleteContentTypes(ctx _context.Context, driveId string, contentTypeId string) ApiDrivesListDeleteContentTypesRequest {
	return ApiDrivesListDeleteContentTypesRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
func (a *DrivesListApiService) DrivesListDeleteContentTypesExecute(r ApiDrivesListDeleteContentTypesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListDeleteContentTypes")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/contentTypes/{contentType-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDrivesListDeleteDriveRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	ifMatch *string
}

// ETag
func (r ApiDrivesListDeleteDriveRequest) IfMatch(ifMatch string) ApiDrivesListDeleteDriveRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDrivesListDeleteDriveRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DrivesListDeleteDriveExecute(r)
}

/*
DrivesListDeleteDrive Delete navigation property drive for drives

Only present on document libraries. Allows access to the list as a [drive][] resource with [driveItems][driveItem].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @return ApiDrivesListDeleteDriveRequest
*/
func (a *DrivesListApiService) DrivesListDeleteDrive(ctx _context.Context, driveId string) ApiDrivesListDeleteDriveRequest {
	return ApiDrivesListDeleteDriveRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
	}
}

// Execute executes the request
func (a *DrivesListApiService) DrivesListDeleteDriveExecute(r ApiDrivesListDeleteDriveRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListDeleteDrive")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/drive"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDrivesListDeleteItemsRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	listItemId string
	ifMatch *string
}

// ETag
func (r ApiDrivesListDeleteItemsRequest) IfMatch(ifMatch string) ApiDrivesListDeleteItemsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDrivesListDeleteItemsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DrivesListDeleteItemsExecute(r)
}

/*
DrivesListDeleteItems Delete navigation property items for drives

All items contained in the list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param listItemId key: id of listItem
 @return ApiDrivesListDeleteItemsRequest
*/
func (a *DrivesListApiService) DrivesListDeleteItems(ctx _context.Context, driveId string, listItemId string) ApiDrivesListDeleteItemsRequest {
	return ApiDrivesListDeleteItemsRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		listItemId: listItemId,
	}
}

// Execute executes the request
func (a *DrivesListApiService) DrivesListDeleteItemsExecute(r ApiDrivesListDeleteItemsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListDeleteItems")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/items/{listItem-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDrivesListDeleteSubscriptionsRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	subscriptionId string
	ifMatch *string
}

// ETag
func (r ApiDrivesListDeleteSubscriptionsRequest) IfMatch(ifMatch string) ApiDrivesListDeleteSubscriptionsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDrivesListDeleteSubscriptionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DrivesListDeleteSubscriptionsExecute(r)
}

/*
DrivesListDeleteSubscriptions Delete navigation property subscriptions for drives

The set of subscriptions on the list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param subscriptionId key: id of subscription
 @return ApiDrivesListDeleteSubscriptionsRequest
*/
func (a *DrivesListApiService) DrivesListDeleteSubscriptions(ctx _context.Context, driveId string, subscriptionId string) ApiDrivesListDeleteSubscriptionsRequest {
	return ApiDrivesListDeleteSubscriptionsRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		subscriptionId: subscriptionId,
	}
}

// Execute executes the request
func (a *DrivesListApiService) DrivesListDeleteSubscriptionsExecute(r ApiDrivesListDeleteSubscriptionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListDeleteSubscriptions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/subscriptions/{subscription-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscription-id"+"}", _neturl.PathEscape(parameterToString(r.subscriptionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDrivesListGetColumnsRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	columnDefinitionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDrivesListGetColumnsRequest) Select_(select_ []string) ApiDrivesListGetColumnsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDrivesListGetColumnsRequest) Expand(expand []string) ApiDrivesListGetColumnsRequest {
	r.expand = &expand
	return r
}

func (r ApiDrivesListGetColumnsRequest) Execute() (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.DrivesListGetColumnsExecute(r)
}

/*
DrivesListGetColumns Get columns from drives

The collection of field definitions for this list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param columnDefinitionId key: id of columnDefinition
 @return ApiDrivesListGetColumnsRequest
*/
func (a *DrivesListApiService) DrivesListGetColumns(ctx _context.Context, driveId string, columnDefinitionId string) ApiDrivesListGetColumnsRequest {
	return ApiDrivesListGetColumnsRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphColumnDefinition
func (a *DrivesListApiService) DrivesListGetColumnsExecute(r ApiDrivesListGetColumnsRequest) (MicrosoftGraphColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListGetColumns")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/columns/{columnDefinition-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesListGetContentTypesRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	contentTypeId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDrivesListGetContentTypesRequest) Select_(select_ []string) ApiDrivesListGetContentTypesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDrivesListGetContentTypesRequest) Expand(expand []string) ApiDrivesListGetContentTypesRequest {
	r.expand = &expand
	return r
}

func (r ApiDrivesListGetContentTypesRequest) Execute() (MicrosoftGraphContentType, *_nethttp.Response, error) {
	return r.ApiService.DrivesListGetContentTypesExecute(r)
}

/*
DrivesListGetContentTypes Get contentTypes from drives

The collection of content types present in this list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param contentTypeId key: id of contentType
 @return ApiDrivesListGetContentTypesRequest
*/
func (a *DrivesListApiService) DrivesListGetContentTypes(ctx _context.Context, driveId string, contentTypeId string) ApiDrivesListGetContentTypesRequest {
	return ApiDrivesListGetContentTypesRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphContentType
func (a *DrivesListApiService) DrivesListGetContentTypesExecute(r ApiDrivesListGetContentTypesRequest) (MicrosoftGraphContentType, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphContentType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListGetContentTypes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/contentTypes/{contentType-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesListGetDriveRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDrivesListGetDriveRequest) Select_(select_ []string) ApiDrivesListGetDriveRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDrivesListGetDriveRequest) Expand(expand []string) ApiDrivesListGetDriveRequest {
	r.expand = &expand
	return r
}

func (r ApiDrivesListGetDriveRequest) Execute() (MicrosoftGraphDrive, *_nethttp.Response, error) {
	return r.ApiService.DrivesListGetDriveExecute(r)
}

/*
DrivesListGetDrive Get drive from drives

Only present on document libraries. Allows access to the list as a [drive][] resource with [driveItems][driveItem].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @return ApiDrivesListGetDriveRequest
*/
func (a *DrivesListApiService) DrivesListGetDrive(ctx _context.Context, driveId string) ApiDrivesListGetDriveRequest {
	return ApiDrivesListGetDriveRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphDrive
func (a *DrivesListApiService) DrivesListGetDriveExecute(r ApiDrivesListGetDriveRequest) (MicrosoftGraphDrive, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphDrive
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListGetDrive")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/drive"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesListGetItemsRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	listItemId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDrivesListGetItemsRequest) Select_(select_ []string) ApiDrivesListGetItemsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDrivesListGetItemsRequest) Expand(expand []string) ApiDrivesListGetItemsRequest {
	r.expand = &expand
	return r
}

func (r ApiDrivesListGetItemsRequest) Execute() (MicrosoftGraphListItem, *_nethttp.Response, error) {
	return r.ApiService.DrivesListGetItemsExecute(r)
}

/*
DrivesListGetItems Get items from drives

All items contained in the list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param listItemId key: id of listItem
 @return ApiDrivesListGetItemsRequest
*/
func (a *DrivesListApiService) DrivesListGetItems(ctx _context.Context, driveId string, listItemId string) ApiDrivesListGetItemsRequest {
	return ApiDrivesListGetItemsRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		listItemId: listItemId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphListItem
func (a *DrivesListApiService) DrivesListGetItemsExecute(r ApiDrivesListGetItemsRequest) (MicrosoftGraphListItem, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphListItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListGetItems")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/items/{listItem-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesListGetSubscriptionsRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	subscriptionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDrivesListGetSubscriptionsRequest) Select_(select_ []string) ApiDrivesListGetSubscriptionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDrivesListGetSubscriptionsRequest) Expand(expand []string) ApiDrivesListGetSubscriptionsRequest {
	r.expand = &expand
	return r
}

func (r ApiDrivesListGetSubscriptionsRequest) Execute() (MicrosoftGraphSubscription, *_nethttp.Response, error) {
	return r.ApiService.DrivesListGetSubscriptionsExecute(r)
}

/*
DrivesListGetSubscriptions Get subscriptions from drives

The set of subscriptions on the list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param subscriptionId key: id of subscription
 @return ApiDrivesListGetSubscriptionsRequest
*/
func (a *DrivesListApiService) DrivesListGetSubscriptions(ctx _context.Context, driveId string, subscriptionId string) ApiDrivesListGetSubscriptionsRequest {
	return ApiDrivesListGetSubscriptionsRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		subscriptionId: subscriptionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphSubscription
func (a *DrivesListApiService) DrivesListGetSubscriptionsExecute(r ApiDrivesListGetSubscriptionsRequest) (MicrosoftGraphSubscription, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphSubscription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListGetSubscriptions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/subscriptions/{subscription-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscription-id"+"}", _neturl.PathEscape(parameterToString(r.subscriptionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesListItemsCreateVersionsRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	listItemId string
	microsoftGraphListItemVersion *MicrosoftGraphListItemVersion
}

// New navigation property
func (r ApiDrivesListItemsCreateVersionsRequest) MicrosoftGraphListItemVersion(microsoftGraphListItemVersion MicrosoftGraphListItemVersion) ApiDrivesListItemsCreateVersionsRequest {
	r.microsoftGraphListItemVersion = &microsoftGraphListItemVersion
	return r
}

func (r ApiDrivesListItemsCreateVersionsRequest) Execute() (MicrosoftGraphListItemVersion, *_nethttp.Response, error) {
	return r.ApiService.DrivesListItemsCreateVersionsExecute(r)
}

/*
DrivesListItemsCreateVersions Create new navigation property to versions for drives

The list of previous versions of the list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param listItemId key: id of listItem
 @return ApiDrivesListItemsCreateVersionsRequest
*/
func (a *DrivesListApiService) DrivesListItemsCreateVersions(ctx _context.Context, driveId string, listItemId string) ApiDrivesListItemsCreateVersionsRequest {
	return ApiDrivesListItemsCreateVersionsRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		listItemId: listItemId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphListItemVersion
func (a *DrivesListApiService) DrivesListItemsCreateVersionsExecute(r ApiDrivesListItemsCreateVersionsRequest) (MicrosoftGraphListItemVersion, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphListItemVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListItemsCreateVersions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/items/{listItem-id}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphListItemVersion == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphListItemVersion is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphListItemVersion
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesListItemsDeleteDriveItemRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	listItemId string
	ifMatch *string
}

// ETag
func (r ApiDrivesListItemsDeleteDriveItemRequest) IfMatch(ifMatch string) ApiDrivesListItemsDeleteDriveItemRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDrivesListItemsDeleteDriveItemRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DrivesListItemsDeleteDriveItemExecute(r)
}

/*
DrivesListItemsDeleteDriveItem Delete navigation property driveItem for drives

For document libraries, the driveItem relationship exposes the listItem as a [driveItem][]

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param listItemId key: id of listItem
 @return ApiDrivesListItemsDeleteDriveItemRequest
*/
func (a *DrivesListApiService) DrivesListItemsDeleteDriveItem(ctx _context.Context, driveId string, listItemId string) ApiDrivesListItemsDeleteDriveItemRequest {
	return ApiDrivesListItemsDeleteDriveItemRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		listItemId: listItemId,
	}
}

// Execute executes the request
func (a *DrivesListApiService) DrivesListItemsDeleteDriveItemExecute(r ApiDrivesListItemsDeleteDriveItemRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListItemsDeleteDriveItem")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/items/{listItem-id}/driveItem"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDrivesListItemsDeleteFieldsRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	listItemId string
	ifMatch *string
}

// ETag
func (r ApiDrivesListItemsDeleteFieldsRequest) IfMatch(ifMatch string) ApiDrivesListItemsDeleteFieldsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDrivesListItemsDeleteFieldsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DrivesListItemsDeleteFieldsExecute(r)
}

/*
DrivesListItemsDeleteFields Delete navigation property fields for drives

The values of the columns set on this list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param listItemId key: id of listItem
 @return ApiDrivesListItemsDeleteFieldsRequest
*/
func (a *DrivesListApiService) DrivesListItemsDeleteFields(ctx _context.Context, driveId string, listItemId string) ApiDrivesListItemsDeleteFieldsRequest {
	return ApiDrivesListItemsDeleteFieldsRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		listItemId: listItemId,
	}
}

// Execute executes the request
func (a *DrivesListApiService) DrivesListItemsDeleteFieldsExecute(r ApiDrivesListItemsDeleteFieldsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListItemsDeleteFields")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/items/{listItem-id}/fields"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDrivesListItemsDeleteRefAnalyticsRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	listItemId string
	ifMatch *string
}

// ETag
func (r ApiDrivesListItemsDeleteRefAnalyticsRequest) IfMatch(ifMatch string) ApiDrivesListItemsDeleteRefAnalyticsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDrivesListItemsDeleteRefAnalyticsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DrivesListItemsDeleteRefAnalyticsExecute(r)
}

/*
DrivesListItemsDeleteRefAnalytics Delete ref of navigation property analytics for drives

Analytics about the view activities that took place on this item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param listItemId key: id of listItem
 @return ApiDrivesListItemsDeleteRefAnalyticsRequest
*/
func (a *DrivesListApiService) DrivesListItemsDeleteRefAnalytics(ctx _context.Context, driveId string, listItemId string) ApiDrivesListItemsDeleteRefAnalyticsRequest {
	return ApiDrivesListItemsDeleteRefAnalyticsRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		listItemId: listItemId,
	}
}

// Execute executes the request
func (a *DrivesListApiService) DrivesListItemsDeleteRefAnalyticsExecute(r ApiDrivesListItemsDeleteRefAnalyticsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListItemsDeleteRefAnalytics")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/items/{listItem-id}/analytics/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDrivesListItemsDeleteVersionsRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	listItemId string
	listItemVersionId string
	ifMatch *string
}

// ETag
func (r ApiDrivesListItemsDeleteVersionsRequest) IfMatch(ifMatch string) ApiDrivesListItemsDeleteVersionsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDrivesListItemsDeleteVersionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DrivesListItemsDeleteVersionsExecute(r)
}

/*
DrivesListItemsDeleteVersions Delete navigation property versions for drives

The list of previous versions of the list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param listItemId key: id of listItem
 @param listItemVersionId key: id of listItemVersion
 @return ApiDrivesListItemsDeleteVersionsRequest
*/
func (a *DrivesListApiService) DrivesListItemsDeleteVersions(ctx _context.Context, driveId string, listItemId string, listItemVersionId string) ApiDrivesListItemsDeleteVersionsRequest {
	return ApiDrivesListItemsDeleteVersionsRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		listItemId: listItemId,
		listItemVersionId: listItemVersionId,
	}
}

// Execute executes the request
func (a *DrivesListApiService) DrivesListItemsDeleteVersionsExecute(r ApiDrivesListItemsDeleteVersionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListItemsDeleteVersions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/items/{listItem-id}/versions/{listItemVersion-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItemVersion-id"+"}", _neturl.PathEscape(parameterToString(r.listItemVersionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDrivesListItemsGetAnalyticsRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	listItemId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDrivesListItemsGetAnalyticsRequest) Select_(select_ []string) ApiDrivesListItemsGetAnalyticsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDrivesListItemsGetAnalyticsRequest) Expand(expand []string) ApiDrivesListItemsGetAnalyticsRequest {
	r.expand = &expand
	return r
}

func (r ApiDrivesListItemsGetAnalyticsRequest) Execute() (MicrosoftGraphItemAnalytics, *_nethttp.Response, error) {
	return r.ApiService.DrivesListItemsGetAnalyticsExecute(r)
}

/*
DrivesListItemsGetAnalytics Get analytics from drives

Analytics about the view activities that took place on this item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param listItemId key: id of listItem
 @return ApiDrivesListItemsGetAnalyticsRequest
*/
func (a *DrivesListApiService) DrivesListItemsGetAnalytics(ctx _context.Context, driveId string, listItemId string) ApiDrivesListItemsGetAnalyticsRequest {
	return ApiDrivesListItemsGetAnalyticsRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		listItemId: listItemId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphItemAnalytics
func (a *DrivesListApiService) DrivesListItemsGetAnalyticsExecute(r ApiDrivesListItemsGetAnalyticsRequest) (MicrosoftGraphItemAnalytics, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphItemAnalytics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListItemsGetAnalytics")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/items/{listItem-id}/analytics"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesListItemsGetDriveItemRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	listItemId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDrivesListItemsGetDriveItemRequest) Select_(select_ []string) ApiDrivesListItemsGetDriveItemRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDrivesListItemsGetDriveItemRequest) Expand(expand []string) ApiDrivesListItemsGetDriveItemRequest {
	r.expand = &expand
	return r
}

func (r ApiDrivesListItemsGetDriveItemRequest) Execute() (MicrosoftGraphDriveItem, *_nethttp.Response, error) {
	return r.ApiService.DrivesListItemsGetDriveItemExecute(r)
}

/*
DrivesListItemsGetDriveItem Get driveItem from drives

For document libraries, the driveItem relationship exposes the listItem as a [driveItem][]

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param listItemId key: id of listItem
 @return ApiDrivesListItemsGetDriveItemRequest
*/
func (a *DrivesListApiService) DrivesListItemsGetDriveItem(ctx _context.Context, driveId string, listItemId string) ApiDrivesListItemsGetDriveItemRequest {
	return ApiDrivesListItemsGetDriveItemRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		listItemId: listItemId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphDriveItem
func (a *DrivesListApiService) DrivesListItemsGetDriveItemExecute(r ApiDrivesListItemsGetDriveItemRequest) (MicrosoftGraphDriveItem, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphDriveItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListItemsGetDriveItem")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/items/{listItem-id}/driveItem"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesListItemsGetDriveItemContentRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	listItemId string
}


func (r ApiDrivesListItemsGetDriveItemContentRequest) Execute() (*os.File, *_nethttp.Response, error) {
	return r.ApiService.DrivesListItemsGetDriveItemContentExecute(r)
}

/*
DrivesListItemsGetDriveItemContent Get media content for the navigation property driveItem from drives

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param listItemId key: id of listItem
 @return ApiDrivesListItemsGetDriveItemContentRequest
*/
func (a *DrivesListApiService) DrivesListItemsGetDriveItemContent(ctx _context.Context, driveId string, listItemId string) ApiDrivesListItemsGetDriveItemContentRequest {
	return ApiDrivesListItemsGetDriveItemContentRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		listItemId: listItemId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *DrivesListApiService) DrivesListItemsGetDriveItemContentExecute(r ApiDrivesListItemsGetDriveItemContentRequest) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListItemsGetDriveItemContent")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/items/{listItem-id}/driveItem/content"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesListItemsGetFieldsRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	listItemId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDrivesListItemsGetFieldsRequest) Select_(select_ []string) ApiDrivesListItemsGetFieldsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDrivesListItemsGetFieldsRequest) Expand(expand []string) ApiDrivesListItemsGetFieldsRequest {
	r.expand = &expand
	return r
}

func (r ApiDrivesListItemsGetFieldsRequest) Execute() (MicrosoftGraphFieldValueSet, *_nethttp.Response, error) {
	return r.ApiService.DrivesListItemsGetFieldsExecute(r)
}

/*
DrivesListItemsGetFields Get fields from drives

The values of the columns set on this list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param listItemId key: id of listItem
 @return ApiDrivesListItemsGetFieldsRequest
*/
func (a *DrivesListApiService) DrivesListItemsGetFields(ctx _context.Context, driveId string, listItemId string) ApiDrivesListItemsGetFieldsRequest {
	return ApiDrivesListItemsGetFieldsRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		listItemId: listItemId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphFieldValueSet
func (a *DrivesListApiService) DrivesListItemsGetFieldsExecute(r ApiDrivesListItemsGetFieldsRequest) (MicrosoftGraphFieldValueSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphFieldValueSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListItemsGetFields")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/items/{listItem-id}/fields"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesListItemsGetRefAnalyticsRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	listItemId string
}


func (r ApiDrivesListItemsGetRefAnalyticsRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.DrivesListItemsGetRefAnalyticsExecute(r)
}

/*
DrivesListItemsGetRefAnalytics Get ref of analytics from drives

Analytics about the view activities that took place on this item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param listItemId key: id of listItem
 @return ApiDrivesListItemsGetRefAnalyticsRequest
*/
func (a *DrivesListApiService) DrivesListItemsGetRefAnalytics(ctx _context.Context, driveId string, listItemId string) ApiDrivesListItemsGetRefAnalyticsRequest {
	return ApiDrivesListItemsGetRefAnalyticsRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		listItemId: listItemId,
	}
}

// Execute executes the request
//  @return string
func (a *DrivesListApiService) DrivesListItemsGetRefAnalyticsExecute(r ApiDrivesListItemsGetRefAnalyticsRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListItemsGetRefAnalytics")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/items/{listItem-id}/analytics/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesListItemsGetVersionsRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	listItemId string
	listItemVersionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDrivesListItemsGetVersionsRequest) Select_(select_ []string) ApiDrivesListItemsGetVersionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDrivesListItemsGetVersionsRequest) Expand(expand []string) ApiDrivesListItemsGetVersionsRequest {
	r.expand = &expand
	return r
}

func (r ApiDrivesListItemsGetVersionsRequest) Execute() (MicrosoftGraphListItemVersion, *_nethttp.Response, error) {
	return r.ApiService.DrivesListItemsGetVersionsExecute(r)
}

/*
DrivesListItemsGetVersions Get versions from drives

The list of previous versions of the list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param listItemId key: id of listItem
 @param listItemVersionId key: id of listItemVersion
 @return ApiDrivesListItemsGetVersionsRequest
*/
func (a *DrivesListApiService) DrivesListItemsGetVersions(ctx _context.Context, driveId string, listItemId string, listItemVersionId string) ApiDrivesListItemsGetVersionsRequest {
	return ApiDrivesListItemsGetVersionsRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		listItemId: listItemId,
		listItemVersionId: listItemVersionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphListItemVersion
func (a *DrivesListApiService) DrivesListItemsGetVersionsExecute(r ApiDrivesListItemsGetVersionsRequest) (MicrosoftGraphListItemVersion, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphListItemVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListItemsGetVersions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/items/{listItem-id}/versions/{listItemVersion-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItemVersion-id"+"}", _neturl.PathEscape(parameterToString(r.listItemVersionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesListItemsListVersionsRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	listItemId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiDrivesListItemsListVersionsRequest) Top(top int32) ApiDrivesListItemsListVersionsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiDrivesListItemsListVersionsRequest) Skip(skip int32) ApiDrivesListItemsListVersionsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiDrivesListItemsListVersionsRequest) Search(search string) ApiDrivesListItemsListVersionsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiDrivesListItemsListVersionsRequest) Filter(filter string) ApiDrivesListItemsListVersionsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiDrivesListItemsListVersionsRequest) Count(count bool) ApiDrivesListItemsListVersionsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiDrivesListItemsListVersionsRequest) Orderby(orderby []string) ApiDrivesListItemsListVersionsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiDrivesListItemsListVersionsRequest) Select_(select_ []string) ApiDrivesListItemsListVersionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDrivesListItemsListVersionsRequest) Expand(expand []string) ApiDrivesListItemsListVersionsRequest {
	r.expand = &expand
	return r
}

func (r ApiDrivesListItemsListVersionsRequest) Execute() (CollectionOfListItemVersion, *_nethttp.Response, error) {
	return r.ApiService.DrivesListItemsListVersionsExecute(r)
}

/*
DrivesListItemsListVersions Get versions from drives

The list of previous versions of the list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param listItemId key: id of listItem
 @return ApiDrivesListItemsListVersionsRequest
*/
func (a *DrivesListApiService) DrivesListItemsListVersions(ctx _context.Context, driveId string, listItemId string) ApiDrivesListItemsListVersionsRequest {
	return ApiDrivesListItemsListVersionsRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		listItemId: listItemId,
	}
}

// Execute executes the request
//  @return CollectionOfListItemVersion
func (a *DrivesListApiService) DrivesListItemsListVersionsExecute(r ApiDrivesListItemsListVersionsRequest) (CollectionOfListItemVersion, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfListItemVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListItemsListVersions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/items/{listItem-id}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesListItemsUpdateDriveItemRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	listItemId string
	microsoftGraphDriveItem *MicrosoftGraphDriveItem
}

// New navigation property values
func (r ApiDrivesListItemsUpdateDriveItemRequest) MicrosoftGraphDriveItem(microsoftGraphDriveItem MicrosoftGraphDriveItem) ApiDrivesListItemsUpdateDriveItemRequest {
	r.microsoftGraphDriveItem = &microsoftGraphDriveItem
	return r
}

func (r ApiDrivesListItemsUpdateDriveItemRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DrivesListItemsUpdateDriveItemExecute(r)
}

/*
DrivesListItemsUpdateDriveItem Update the navigation property driveItem in drives

For document libraries, the driveItem relationship exposes the listItem as a [driveItem][]

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param listItemId key: id of listItem
 @return ApiDrivesListItemsUpdateDriveItemRequest
*/
func (a *DrivesListApiService) DrivesListItemsUpdateDriveItem(ctx _context.Context, driveId string, listItemId string) ApiDrivesListItemsUpdateDriveItemRequest {
	return ApiDrivesListItemsUpdateDriveItemRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		listItemId: listItemId,
	}
}

// Execute executes the request
func (a *DrivesListApiService) DrivesListItemsUpdateDriveItemExecute(r ApiDrivesListItemsUpdateDriveItemRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListItemsUpdateDriveItem")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/items/{listItem-id}/driveItem"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphDriveItem == nil {
		return nil, reportError("microsoftGraphDriveItem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphDriveItem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDrivesListItemsUpdateDriveItemContentRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	listItemId string
	body **os.File
}

// New media content.
func (r ApiDrivesListItemsUpdateDriveItemContentRequest) Body(body *os.File) ApiDrivesListItemsUpdateDriveItemContentRequest {
	r.body = &body
	return r
}

func (r ApiDrivesListItemsUpdateDriveItemContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DrivesListItemsUpdateDriveItemContentExecute(r)
}

/*
DrivesListItemsUpdateDriveItemContent Update media content for the navigation property driveItem in drives

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param listItemId key: id of listItem
 @return ApiDrivesListItemsUpdateDriveItemContentRequest
*/
func (a *DrivesListApiService) DrivesListItemsUpdateDriveItemContent(ctx _context.Context, driveId string, listItemId string) ApiDrivesListItemsUpdateDriveItemContentRequest {
	return ApiDrivesListItemsUpdateDriveItemContentRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		listItemId: listItemId,
	}
}

// Execute executes the request
func (a *DrivesListApiService) DrivesListItemsUpdateDriveItemContentExecute(r ApiDrivesListItemsUpdateDriveItemContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListItemsUpdateDriveItemContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/items/{listItem-id}/driveItem/content"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDrivesListItemsUpdateFieldsRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	listItemId string
	microsoftGraphFieldValueSet *MicrosoftGraphFieldValueSet
}

// New navigation property values
func (r ApiDrivesListItemsUpdateFieldsRequest) MicrosoftGraphFieldValueSet(microsoftGraphFieldValueSet MicrosoftGraphFieldValueSet) ApiDrivesListItemsUpdateFieldsRequest {
	r.microsoftGraphFieldValueSet = &microsoftGraphFieldValueSet
	return r
}

func (r ApiDrivesListItemsUpdateFieldsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DrivesListItemsUpdateFieldsExecute(r)
}

/*
DrivesListItemsUpdateFields Update the navigation property fields in drives

The values of the columns set on this list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param listItemId key: id of listItem
 @return ApiDrivesListItemsUpdateFieldsRequest
*/
func (a *DrivesListApiService) DrivesListItemsUpdateFields(ctx _context.Context, driveId string, listItemId string) ApiDrivesListItemsUpdateFieldsRequest {
	return ApiDrivesListItemsUpdateFieldsRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		listItemId: listItemId,
	}
}

// Execute executes the request
func (a *DrivesListApiService) DrivesListItemsUpdateFieldsExecute(r ApiDrivesListItemsUpdateFieldsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListItemsUpdateFields")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/items/{listItem-id}/fields"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphFieldValueSet == nil {
		return nil, reportError("microsoftGraphFieldValueSet is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphFieldValueSet
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDrivesListItemsUpdateRefAnalyticsRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	listItemId string
	requestBody *map[string]map[string]interface{}
}

// New navigation property ref values
func (r ApiDrivesListItemsUpdateRefAnalyticsRequest) RequestBody(requestBody map[string]map[string]interface{}) ApiDrivesListItemsUpdateRefAnalyticsRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiDrivesListItemsUpdateRefAnalyticsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DrivesListItemsUpdateRefAnalyticsExecute(r)
}

/*
DrivesListItemsUpdateRefAnalytics Update the ref of navigation property analytics in drives

Analytics about the view activities that took place on this item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param listItemId key: id of listItem
 @return ApiDrivesListItemsUpdateRefAnalyticsRequest
*/
func (a *DrivesListApiService) DrivesListItemsUpdateRefAnalytics(ctx _context.Context, driveId string, listItemId string) ApiDrivesListItemsUpdateRefAnalyticsRequest {
	return ApiDrivesListItemsUpdateRefAnalyticsRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		listItemId: listItemId,
	}
}

// Execute executes the request
func (a *DrivesListApiService) DrivesListItemsUpdateRefAnalyticsExecute(r ApiDrivesListItemsUpdateRefAnalyticsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListItemsUpdateRefAnalytics")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/items/{listItem-id}/analytics/$ref"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDrivesListItemsUpdateVersionsRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	listItemId string
	listItemVersionId string
	microsoftGraphListItemVersion *MicrosoftGraphListItemVersion
}

// New navigation property values
func (r ApiDrivesListItemsUpdateVersionsRequest) MicrosoftGraphListItemVersion(microsoftGraphListItemVersion MicrosoftGraphListItemVersion) ApiDrivesListItemsUpdateVersionsRequest {
	r.microsoftGraphListItemVersion = &microsoftGraphListItemVersion
	return r
}

func (r ApiDrivesListItemsUpdateVersionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DrivesListItemsUpdateVersionsExecute(r)
}

/*
DrivesListItemsUpdateVersions Update the navigation property versions in drives

The list of previous versions of the list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param listItemId key: id of listItem
 @param listItemVersionId key: id of listItemVersion
 @return ApiDrivesListItemsUpdateVersionsRequest
*/
func (a *DrivesListApiService) DrivesListItemsUpdateVersions(ctx _context.Context, driveId string, listItemId string, listItemVersionId string) ApiDrivesListItemsUpdateVersionsRequest {
	return ApiDrivesListItemsUpdateVersionsRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		listItemId: listItemId,
		listItemVersionId: listItemVersionId,
	}
}

// Execute executes the request
func (a *DrivesListApiService) DrivesListItemsUpdateVersionsExecute(r ApiDrivesListItemsUpdateVersionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListItemsUpdateVersions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/items/{listItem-id}/versions/{listItemVersion-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItemVersion-id"+"}", _neturl.PathEscape(parameterToString(r.listItemVersionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphListItemVersion == nil {
		return nil, reportError("microsoftGraphListItemVersion is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphListItemVersion
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDrivesListItemsVersionsDeleteFieldsRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	listItemId string
	listItemVersionId string
	ifMatch *string
}

// ETag
func (r ApiDrivesListItemsVersionsDeleteFieldsRequest) IfMatch(ifMatch string) ApiDrivesListItemsVersionsDeleteFieldsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiDrivesListItemsVersionsDeleteFieldsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DrivesListItemsVersionsDeleteFieldsExecute(r)
}

/*
DrivesListItemsVersionsDeleteFields Delete navigation property fields for drives

A collection of the fields and values for this version of the list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param listItemId key: id of listItem
 @param listItemVersionId key: id of listItemVersion
 @return ApiDrivesListItemsVersionsDeleteFieldsRequest
*/
func (a *DrivesListApiService) DrivesListItemsVersionsDeleteFields(ctx _context.Context, driveId string, listItemId string, listItemVersionId string) ApiDrivesListItemsVersionsDeleteFieldsRequest {
	return ApiDrivesListItemsVersionsDeleteFieldsRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		listItemId: listItemId,
		listItemVersionId: listItemVersionId,
	}
}

// Execute executes the request
func (a *DrivesListApiService) DrivesListItemsVersionsDeleteFieldsExecute(r ApiDrivesListItemsVersionsDeleteFieldsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListItemsVersionsDeleteFields")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/items/{listItem-id}/versions/{listItemVersion-id}/fields"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItemVersion-id"+"}", _neturl.PathEscape(parameterToString(r.listItemVersionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDrivesListItemsVersionsGetFieldsRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	listItemId string
	listItemVersionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiDrivesListItemsVersionsGetFieldsRequest) Select_(select_ []string) ApiDrivesListItemsVersionsGetFieldsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDrivesListItemsVersionsGetFieldsRequest) Expand(expand []string) ApiDrivesListItemsVersionsGetFieldsRequest {
	r.expand = &expand
	return r
}

func (r ApiDrivesListItemsVersionsGetFieldsRequest) Execute() (MicrosoftGraphFieldValueSet, *_nethttp.Response, error) {
	return r.ApiService.DrivesListItemsVersionsGetFieldsExecute(r)
}

/*
DrivesListItemsVersionsGetFields Get fields from drives

A collection of the fields and values for this version of the list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param listItemId key: id of listItem
 @param listItemVersionId key: id of listItemVersion
 @return ApiDrivesListItemsVersionsGetFieldsRequest
*/
func (a *DrivesListApiService) DrivesListItemsVersionsGetFields(ctx _context.Context, driveId string, listItemId string, listItemVersionId string) ApiDrivesListItemsVersionsGetFieldsRequest {
	return ApiDrivesListItemsVersionsGetFieldsRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		listItemId: listItemId,
		listItemVersionId: listItemVersionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphFieldValueSet
func (a *DrivesListApiService) DrivesListItemsVersionsGetFieldsExecute(r ApiDrivesListItemsVersionsGetFieldsRequest) (MicrosoftGraphFieldValueSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphFieldValueSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListItemsVersionsGetFields")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/items/{listItem-id}/versions/{listItemVersion-id}/fields"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItemVersion-id"+"}", _neturl.PathEscape(parameterToString(r.listItemVersionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesListItemsVersionsUpdateFieldsRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	listItemId string
	listItemVersionId string
	microsoftGraphFieldValueSet *MicrosoftGraphFieldValueSet
}

// New navigation property values
func (r ApiDrivesListItemsVersionsUpdateFieldsRequest) MicrosoftGraphFieldValueSet(microsoftGraphFieldValueSet MicrosoftGraphFieldValueSet) ApiDrivesListItemsVersionsUpdateFieldsRequest {
	r.microsoftGraphFieldValueSet = &microsoftGraphFieldValueSet
	return r
}

func (r ApiDrivesListItemsVersionsUpdateFieldsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DrivesListItemsVersionsUpdateFieldsExecute(r)
}

/*
DrivesListItemsVersionsUpdateFields Update the navigation property fields in drives

A collection of the fields and values for this version of the list item.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param listItemId key: id of listItem
 @param listItemVersionId key: id of listItemVersion
 @return ApiDrivesListItemsVersionsUpdateFieldsRequest
*/
func (a *DrivesListApiService) DrivesListItemsVersionsUpdateFields(ctx _context.Context, driveId string, listItemId string, listItemVersionId string) ApiDrivesListItemsVersionsUpdateFieldsRequest {
	return ApiDrivesListItemsVersionsUpdateFieldsRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		listItemId: listItemId,
		listItemVersionId: listItemVersionId,
	}
}

// Execute executes the request
func (a *DrivesListApiService) DrivesListItemsVersionsUpdateFieldsExecute(r ApiDrivesListItemsVersionsUpdateFieldsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListItemsVersionsUpdateFields")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/items/{listItem-id}/versions/{listItemVersion-id}/fields"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItemVersion-id"+"}", _neturl.PathEscape(parameterToString(r.listItemVersionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphFieldValueSet == nil {
		return nil, reportError("microsoftGraphFieldValueSet is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphFieldValueSet
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDrivesListListColumnsRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiDrivesListListColumnsRequest) Top(top int32) ApiDrivesListListColumnsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiDrivesListListColumnsRequest) Skip(skip int32) ApiDrivesListListColumnsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiDrivesListListColumnsRequest) Search(search string) ApiDrivesListListColumnsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiDrivesListListColumnsRequest) Filter(filter string) ApiDrivesListListColumnsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiDrivesListListColumnsRequest) Count(count bool) ApiDrivesListListColumnsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiDrivesListListColumnsRequest) Orderby(orderby []string) ApiDrivesListListColumnsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiDrivesListListColumnsRequest) Select_(select_ []string) ApiDrivesListListColumnsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDrivesListListColumnsRequest) Expand(expand []string) ApiDrivesListListColumnsRequest {
	r.expand = &expand
	return r
}

func (r ApiDrivesListListColumnsRequest) Execute() (CollectionOfColumnDefinition, *_nethttp.Response, error) {
	return r.ApiService.DrivesListListColumnsExecute(r)
}

/*
DrivesListListColumns Get columns from drives

The collection of field definitions for this list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @return ApiDrivesListListColumnsRequest
*/
func (a *DrivesListApiService) DrivesListListColumns(ctx _context.Context, driveId string) ApiDrivesListListColumnsRequest {
	return ApiDrivesListListColumnsRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
	}
}

// Execute executes the request
//  @return CollectionOfColumnDefinition
func (a *DrivesListApiService) DrivesListListColumnsExecute(r ApiDrivesListListColumnsRequest) (CollectionOfColumnDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfColumnDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListListColumns")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/columns"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesListListContentTypesRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiDrivesListListContentTypesRequest) Top(top int32) ApiDrivesListListContentTypesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiDrivesListListContentTypesRequest) Skip(skip int32) ApiDrivesListListContentTypesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiDrivesListListContentTypesRequest) Search(search string) ApiDrivesListListContentTypesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiDrivesListListContentTypesRequest) Filter(filter string) ApiDrivesListListContentTypesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiDrivesListListContentTypesRequest) Count(count bool) ApiDrivesListListContentTypesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiDrivesListListContentTypesRequest) Orderby(orderby []string) ApiDrivesListListContentTypesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiDrivesListListContentTypesRequest) Select_(select_ []string) ApiDrivesListListContentTypesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDrivesListListContentTypesRequest) Expand(expand []string) ApiDrivesListListContentTypesRequest {
	r.expand = &expand
	return r
}

func (r ApiDrivesListListContentTypesRequest) Execute() (CollectionOfContentType, *_nethttp.Response, error) {
	return r.ApiService.DrivesListListContentTypesExecute(r)
}

/*
DrivesListListContentTypes Get contentTypes from drives

The collection of content types present in this list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @return ApiDrivesListListContentTypesRequest
*/
func (a *DrivesListApiService) DrivesListListContentTypes(ctx _context.Context, driveId string) ApiDrivesListListContentTypesRequest {
	return ApiDrivesListListContentTypesRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
	}
}

// Execute executes the request
//  @return CollectionOfContentType
func (a *DrivesListApiService) DrivesListListContentTypesExecute(r ApiDrivesListListContentTypesRequest) (CollectionOfContentType, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfContentType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListListContentTypes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/contentTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesListListItemsRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiDrivesListListItemsRequest) Top(top int32) ApiDrivesListListItemsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiDrivesListListItemsRequest) Skip(skip int32) ApiDrivesListListItemsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiDrivesListListItemsRequest) Search(search string) ApiDrivesListListItemsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiDrivesListListItemsRequest) Filter(filter string) ApiDrivesListListItemsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiDrivesListListItemsRequest) Count(count bool) ApiDrivesListListItemsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiDrivesListListItemsRequest) Orderby(orderby []string) ApiDrivesListListItemsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiDrivesListListItemsRequest) Select_(select_ []string) ApiDrivesListListItemsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDrivesListListItemsRequest) Expand(expand []string) ApiDrivesListListItemsRequest {
	r.expand = &expand
	return r
}

func (r ApiDrivesListListItemsRequest) Execute() (CollectionOfListItem, *_nethttp.Response, error) {
	return r.ApiService.DrivesListListItemsExecute(r)
}

/*
DrivesListListItems Get items from drives

All items contained in the list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @return ApiDrivesListListItemsRequest
*/
func (a *DrivesListApiService) DrivesListListItems(ctx _context.Context, driveId string) ApiDrivesListListItemsRequest {
	return ApiDrivesListListItemsRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
	}
}

// Execute executes the request
//  @return CollectionOfListItem
func (a *DrivesListApiService) DrivesListListItemsExecute(r ApiDrivesListListItemsRequest) (CollectionOfListItem, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfListItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListListItems")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/items"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesListListSubscriptionsRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiDrivesListListSubscriptionsRequest) Top(top int32) ApiDrivesListListSubscriptionsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiDrivesListListSubscriptionsRequest) Skip(skip int32) ApiDrivesListListSubscriptionsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiDrivesListListSubscriptionsRequest) Search(search string) ApiDrivesListListSubscriptionsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiDrivesListListSubscriptionsRequest) Filter(filter string) ApiDrivesListListSubscriptionsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiDrivesListListSubscriptionsRequest) Count(count bool) ApiDrivesListListSubscriptionsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiDrivesListListSubscriptionsRequest) Orderby(orderby []string) ApiDrivesListListSubscriptionsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiDrivesListListSubscriptionsRequest) Select_(select_ []string) ApiDrivesListListSubscriptionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiDrivesListListSubscriptionsRequest) Expand(expand []string) ApiDrivesListListSubscriptionsRequest {
	r.expand = &expand
	return r
}

func (r ApiDrivesListListSubscriptionsRequest) Execute() (CollectionOfSubscription, *_nethttp.Response, error) {
	return r.ApiService.DrivesListListSubscriptionsExecute(r)
}

/*
DrivesListListSubscriptions Get subscriptions from drives

The set of subscriptions on the list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @return ApiDrivesListListSubscriptionsRequest
*/
func (a *DrivesListApiService) DrivesListListSubscriptions(ctx _context.Context, driveId string) ApiDrivesListListSubscriptionsRequest {
	return ApiDrivesListListSubscriptionsRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
	}
}

// Execute executes the request
//  @return CollectionOfSubscription
func (a *DrivesListApiService) DrivesListListSubscriptionsExecute(r ApiDrivesListListSubscriptionsRequest) (CollectionOfSubscription, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfSubscription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListListSubscriptions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/subscriptions"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDrivesListUpdateColumnsRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	columnDefinitionId string
	microsoftGraphColumnDefinition *MicrosoftGraphColumnDefinition
}

// New navigation property values
func (r ApiDrivesListUpdateColumnsRequest) MicrosoftGraphColumnDefinition(microsoftGraphColumnDefinition MicrosoftGraphColumnDefinition) ApiDrivesListUpdateColumnsRequest {
	r.microsoftGraphColumnDefinition = &microsoftGraphColumnDefinition
	return r
}

func (r ApiDrivesListUpdateColumnsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DrivesListUpdateColumnsExecute(r)
}

/*
DrivesListUpdateColumns Update the navigation property columns in drives

The collection of field definitions for this list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param columnDefinitionId key: id of columnDefinition
 @return ApiDrivesListUpdateColumnsRequest
*/
func (a *DrivesListApiService) DrivesListUpdateColumns(ctx _context.Context, driveId string, columnDefinitionId string) ApiDrivesListUpdateColumnsRequest {
	return ApiDrivesListUpdateColumnsRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		columnDefinitionId: columnDefinitionId,
	}
}

// Execute executes the request
func (a *DrivesListApiService) DrivesListUpdateColumnsExecute(r ApiDrivesListUpdateColumnsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListUpdateColumns")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/columns/{columnDefinition-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"columnDefinition-id"+"}", _neturl.PathEscape(parameterToString(r.columnDefinitionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphColumnDefinition == nil {
		return nil, reportError("microsoftGraphColumnDefinition is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphColumnDefinition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDrivesListUpdateContentTypesRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	contentTypeId string
	microsoftGraphContentType *MicrosoftGraphContentType
}

// New navigation property values
func (r ApiDrivesListUpdateContentTypesRequest) MicrosoftGraphContentType(microsoftGraphContentType MicrosoftGraphContentType) ApiDrivesListUpdateContentTypesRequest {
	r.microsoftGraphContentType = &microsoftGraphContentType
	return r
}

func (r ApiDrivesListUpdateContentTypesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DrivesListUpdateContentTypesExecute(r)
}

/*
DrivesListUpdateContentTypes Update the navigation property contentTypes in drives

The collection of content types present in this list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param contentTypeId key: id of contentType
 @return ApiDrivesListUpdateContentTypesRequest
*/
func (a *DrivesListApiService) DrivesListUpdateContentTypes(ctx _context.Context, driveId string, contentTypeId string) ApiDrivesListUpdateContentTypesRequest {
	return ApiDrivesListUpdateContentTypesRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		contentTypeId: contentTypeId,
	}
}

// Execute executes the request
func (a *DrivesListApiService) DrivesListUpdateContentTypesExecute(r ApiDrivesListUpdateContentTypesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListUpdateContentTypes")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/contentTypes/{contentType-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contentType-id"+"}", _neturl.PathEscape(parameterToString(r.contentTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphContentType == nil {
		return nil, reportError("microsoftGraphContentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphContentType
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDrivesListUpdateDriveRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	microsoftGraphDrive *MicrosoftGraphDrive
}

// New navigation property values
func (r ApiDrivesListUpdateDriveRequest) MicrosoftGraphDrive(microsoftGraphDrive MicrosoftGraphDrive) ApiDrivesListUpdateDriveRequest {
	r.microsoftGraphDrive = &microsoftGraphDrive
	return r
}

func (r ApiDrivesListUpdateDriveRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DrivesListUpdateDriveExecute(r)
}

/*
DrivesListUpdateDrive Update the navigation property drive in drives

Only present on document libraries. Allows access to the list as a [drive][] resource with [driveItems][driveItem].

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @return ApiDrivesListUpdateDriveRequest
*/
func (a *DrivesListApiService) DrivesListUpdateDrive(ctx _context.Context, driveId string) ApiDrivesListUpdateDriveRequest {
	return ApiDrivesListUpdateDriveRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
	}
}

// Execute executes the request
func (a *DrivesListApiService) DrivesListUpdateDriveExecute(r ApiDrivesListUpdateDriveRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListUpdateDrive")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/drive"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphDrive == nil {
		return nil, reportError("microsoftGraphDrive is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphDrive
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDrivesListUpdateItemsRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	listItemId string
	microsoftGraphListItem *MicrosoftGraphListItem
}

// New navigation property values
func (r ApiDrivesListUpdateItemsRequest) MicrosoftGraphListItem(microsoftGraphListItem MicrosoftGraphListItem) ApiDrivesListUpdateItemsRequest {
	r.microsoftGraphListItem = &microsoftGraphListItem
	return r
}

func (r ApiDrivesListUpdateItemsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DrivesListUpdateItemsExecute(r)
}

/*
DrivesListUpdateItems Update the navigation property items in drives

All items contained in the list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param listItemId key: id of listItem
 @return ApiDrivesListUpdateItemsRequest
*/
func (a *DrivesListApiService) DrivesListUpdateItems(ctx _context.Context, driveId string, listItemId string) ApiDrivesListUpdateItemsRequest {
	return ApiDrivesListUpdateItemsRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		listItemId: listItemId,
	}
}

// Execute executes the request
func (a *DrivesListApiService) DrivesListUpdateItemsExecute(r ApiDrivesListUpdateItemsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListUpdateItems")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/items/{listItem-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listItem-id"+"}", _neturl.PathEscape(parameterToString(r.listItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphListItem == nil {
		return nil, reportError("microsoftGraphListItem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphListItem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDrivesListUpdateSubscriptionsRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	subscriptionId string
	microsoftGraphSubscription *MicrosoftGraphSubscription
}

// New navigation property values
func (r ApiDrivesListUpdateSubscriptionsRequest) MicrosoftGraphSubscription(microsoftGraphSubscription MicrosoftGraphSubscription) ApiDrivesListUpdateSubscriptionsRequest {
	r.microsoftGraphSubscription = &microsoftGraphSubscription
	return r
}

func (r ApiDrivesListUpdateSubscriptionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DrivesListUpdateSubscriptionsExecute(r)
}

/*
DrivesListUpdateSubscriptions Update the navigation property subscriptions in drives

The set of subscriptions on the list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @param subscriptionId key: id of subscription
 @return ApiDrivesListUpdateSubscriptionsRequest
*/
func (a *DrivesListApiService) DrivesListUpdateSubscriptions(ctx _context.Context, driveId string, subscriptionId string) ApiDrivesListUpdateSubscriptionsRequest {
	return ApiDrivesListUpdateSubscriptionsRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
		subscriptionId: subscriptionId,
	}
}

// Execute executes the request
func (a *DrivesListApiService) DrivesListUpdateSubscriptionsExecute(r ApiDrivesListUpdateSubscriptionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesListUpdateSubscriptions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list/subscriptions/{subscription-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscription-id"+"}", _neturl.PathEscape(parameterToString(r.subscriptionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphSubscription == nil {
		return nil, reportError("microsoftGraphSubscription is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphSubscription
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDrivesUpdateListRequest struct {
	ctx _context.Context
	ApiService *DrivesListApiService
	driveId string
	microsoftGraphList *MicrosoftGraphList
}

// New navigation property values
func (r ApiDrivesUpdateListRequest) MicrosoftGraphList(microsoftGraphList MicrosoftGraphList) ApiDrivesUpdateListRequest {
	r.microsoftGraphList = &microsoftGraphList
	return r
}

func (r ApiDrivesUpdateListRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DrivesUpdateListExecute(r)
}

/*
DrivesUpdateList Update the navigation property list in drives

For drives in SharePoint, the underlying document library list. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param driveId key: id of drive
 @return ApiDrivesUpdateListRequest
*/
func (a *DrivesListApiService) DrivesUpdateList(ctx _context.Context, driveId string) ApiDrivesUpdateListRequest {
	return ApiDrivesUpdateListRequest{
		ApiService: a,
		ctx: ctx,
		driveId: driveId,
	}
}

// Execute executes the request
func (a *DrivesListApiService) DrivesUpdateListExecute(r ApiDrivesUpdateListRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DrivesListApiService.DrivesUpdateList")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/drives/{drive-id}/list"
	localVarPath = strings.Replace(localVarPath, "{"+"drive-id"+"}", _neturl.PathEscape(parameterToString(r.driveId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphList == nil {
		return nil, reportError("microsoftGraphList is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphList
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
