/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package msgraph

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"os"
)

// Linger please
var (
	_ _context.Context
)

// UsersMessageApiService UsersMessageApi service
type UsersMessageApiService service

type ApiUsersCreateMessagesRequest struct {
	ctx _context.Context
	ApiService *UsersMessageApiService
	userId string
	microsoftGraphMessage *MicrosoftGraphMessage
}

// New navigation property
func (r ApiUsersCreateMessagesRequest) MicrosoftGraphMessage(microsoftGraphMessage MicrosoftGraphMessage) ApiUsersCreateMessagesRequest {
	r.microsoftGraphMessage = &microsoftGraphMessage
	return r
}

func (r ApiUsersCreateMessagesRequest) Execute() (MicrosoftGraphMessage, *_nethttp.Response, error) {
	return r.ApiService.UsersCreateMessagesExecute(r)
}

/*
UsersCreateMessages Create new navigation property to messages for users

The messages in a mailbox or folder. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @return ApiUsersCreateMessagesRequest
*/
func (a *UsersMessageApiService) UsersCreateMessages(ctx _context.Context, userId string) ApiUsersCreateMessagesRequest {
	return ApiUsersCreateMessagesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphMessage
func (a *UsersMessageApiService) UsersCreateMessagesExecute(r ApiUsersCreateMessagesRequest) (MicrosoftGraphMessage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersMessageApiService.UsersCreateMessages")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/messages"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphMessage == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphMessage is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphMessage
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersDeleteMessagesRequest struct {
	ctx _context.Context
	ApiService *UsersMessageApiService
	userId string
	messageId string
	ifMatch *string
}

// ETag
func (r ApiUsersDeleteMessagesRequest) IfMatch(ifMatch string) ApiUsersDeleteMessagesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersDeleteMessagesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersDeleteMessagesExecute(r)
}

/*
UsersDeleteMessages Delete navigation property messages for users

The messages in a mailbox or folder. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param messageId key: id of message
 @return ApiUsersDeleteMessagesRequest
*/
func (a *UsersMessageApiService) UsersDeleteMessages(ctx _context.Context, userId string, messageId string) ApiUsersDeleteMessagesRequest {
	return ApiUsersDeleteMessagesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		messageId: messageId,
	}
}

// Execute executes the request
func (a *UsersMessageApiService) UsersDeleteMessagesExecute(r ApiUsersDeleteMessagesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersMessageApiService.UsersDeleteMessages")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/messages/{message-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersGetMessagesRequest struct {
	ctx _context.Context
	ApiService *UsersMessageApiService
	userId string
	messageId string
	select_ *[]string
}

// Select properties to be returned
func (r ApiUsersGetMessagesRequest) Select_(select_ []string) ApiUsersGetMessagesRequest {
	r.select_ = &select_
	return r
}

func (r ApiUsersGetMessagesRequest) Execute() (MicrosoftGraphMessage, *_nethttp.Response, error) {
	return r.ApiService.UsersGetMessagesExecute(r)
}

/*
UsersGetMessages Get messages from users

The messages in a mailbox or folder. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param messageId key: id of message
 @return ApiUsersGetMessagesRequest
*/
func (a *UsersMessageApiService) UsersGetMessages(ctx _context.Context, userId string, messageId string) ApiUsersGetMessagesRequest {
	return ApiUsersGetMessagesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphMessage
func (a *UsersMessageApiService) UsersGetMessagesExecute(r ApiUsersGetMessagesRequest) (MicrosoftGraphMessage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersMessageApiService.UsersGetMessages")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/messages/{message-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersGetMessagesContentRequest struct {
	ctx _context.Context
	ApiService *UsersMessageApiService
	userId string
	messageId string
}


func (r ApiUsersGetMessagesContentRequest) Execute() (*os.File, *_nethttp.Response, error) {
	return r.ApiService.UsersGetMessagesContentExecute(r)
}

/*
UsersGetMessagesContent Get media content for the navigation property messages from users

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param messageId key: id of message
 @return ApiUsersGetMessagesContentRequest
*/
func (a *UsersMessageApiService) UsersGetMessagesContent(ctx _context.Context, userId string, messageId string) ApiUsersGetMessagesContentRequest {
	return ApiUsersGetMessagesContentRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *UsersMessageApiService) UsersGetMessagesContentExecute(r ApiUsersGetMessagesContentRequest) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersMessageApiService.UsersGetMessagesContent")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/messages/{message-id}/$value"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersListMessagesRequest struct {
	ctx _context.Context
	ApiService *UsersMessageApiService
	userId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
}

// Show only the first n items
func (r ApiUsersListMessagesRequest) Top(top int32) ApiUsersListMessagesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiUsersListMessagesRequest) Skip(skip int32) ApiUsersListMessagesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiUsersListMessagesRequest) Search(search string) ApiUsersListMessagesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiUsersListMessagesRequest) Filter(filter string) ApiUsersListMessagesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiUsersListMessagesRequest) Count(count bool) ApiUsersListMessagesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiUsersListMessagesRequest) Orderby(orderby []string) ApiUsersListMessagesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiUsersListMessagesRequest) Select_(select_ []string) ApiUsersListMessagesRequest {
	r.select_ = &select_
	return r
}

func (r ApiUsersListMessagesRequest) Execute() (CollectionOfMessage, *_nethttp.Response, error) {
	return r.ApiService.UsersListMessagesExecute(r)
}

/*
UsersListMessages Get messages from users

The messages in a mailbox or folder. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @return ApiUsersListMessagesRequest
*/
func (a *UsersMessageApiService) UsersListMessages(ctx _context.Context, userId string) ApiUsersListMessagesRequest {
	return ApiUsersListMessagesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return CollectionOfMessage
func (a *UsersMessageApiService) UsersListMessagesExecute(r ApiUsersListMessagesRequest) (CollectionOfMessage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersMessageApiService.UsersListMessages")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/messages"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersMessagesCreateAttachmentsRequest struct {
	ctx _context.Context
	ApiService *UsersMessageApiService
	userId string
	messageId string
	microsoftGraphAttachment *MicrosoftGraphAttachment
}

// New navigation property
func (r ApiUsersMessagesCreateAttachmentsRequest) MicrosoftGraphAttachment(microsoftGraphAttachment MicrosoftGraphAttachment) ApiUsersMessagesCreateAttachmentsRequest {
	r.microsoftGraphAttachment = &microsoftGraphAttachment
	return r
}

func (r ApiUsersMessagesCreateAttachmentsRequest) Execute() (MicrosoftGraphAttachment, *_nethttp.Response, error) {
	return r.ApiService.UsersMessagesCreateAttachmentsExecute(r)
}

/*
UsersMessagesCreateAttachments Create new navigation property to attachments for users

The fileAttachment and itemAttachment attachments for the message.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param messageId key: id of message
 @return ApiUsersMessagesCreateAttachmentsRequest
*/
func (a *UsersMessageApiService) UsersMessagesCreateAttachments(ctx _context.Context, userId string, messageId string) ApiUsersMessagesCreateAttachmentsRequest {
	return ApiUsersMessagesCreateAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphAttachment
func (a *UsersMessageApiService) UsersMessagesCreateAttachmentsExecute(r ApiUsersMessagesCreateAttachmentsRequest) (MicrosoftGraphAttachment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphAttachment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersMessageApiService.UsersMessagesCreateAttachments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/messages/{message-id}/attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphAttachment == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphAttachment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphAttachment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersMessagesCreateExtensionsRequest struct {
	ctx _context.Context
	ApiService *UsersMessageApiService
	userId string
	messageId string
	microsoftGraphExtension *MicrosoftGraphExtension
}

// New navigation property
func (r ApiUsersMessagesCreateExtensionsRequest) MicrosoftGraphExtension(microsoftGraphExtension MicrosoftGraphExtension) ApiUsersMessagesCreateExtensionsRequest {
	r.microsoftGraphExtension = &microsoftGraphExtension
	return r
}

func (r ApiUsersMessagesCreateExtensionsRequest) Execute() (MicrosoftGraphExtension, *_nethttp.Response, error) {
	return r.ApiService.UsersMessagesCreateExtensionsExecute(r)
}

/*
UsersMessagesCreateExtensions Create new navigation property to extensions for users

The collection of open extensions defined for the message. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param messageId key: id of message
 @return ApiUsersMessagesCreateExtensionsRequest
*/
func (a *UsersMessageApiService) UsersMessagesCreateExtensions(ctx _context.Context, userId string, messageId string) ApiUsersMessagesCreateExtensionsRequest {
	return ApiUsersMessagesCreateExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphExtension
func (a *UsersMessageApiService) UsersMessagesCreateExtensionsExecute(r ApiUsersMessagesCreateExtensionsRequest) (MicrosoftGraphExtension, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphExtension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersMessageApiService.UsersMessagesCreateExtensions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/messages/{message-id}/extensions"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphExtension == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphExtension is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphExtension
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersMessagesCreateMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *UsersMessageApiService
	userId string
	messageId string
	microsoftGraphMultiValueLegacyExtendedProperty *MicrosoftGraphMultiValueLegacyExtendedProperty
}

// New navigation property
func (r ApiUsersMessagesCreateMultiValueExtendedPropertiesRequest) MicrosoftGraphMultiValueLegacyExtendedProperty(microsoftGraphMultiValueLegacyExtendedProperty MicrosoftGraphMultiValueLegacyExtendedProperty) ApiUsersMessagesCreateMultiValueExtendedPropertiesRequest {
	r.microsoftGraphMultiValueLegacyExtendedProperty = &microsoftGraphMultiValueLegacyExtendedProperty
	return r
}

func (r ApiUsersMessagesCreateMultiValueExtendedPropertiesRequest) Execute() (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.UsersMessagesCreateMultiValueExtendedPropertiesExecute(r)
}

/*
UsersMessagesCreateMultiValueExtendedProperties Create new navigation property to multiValueExtendedProperties for users

The collection of multi-value extended properties defined for the message. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param messageId key: id of message
 @return ApiUsersMessagesCreateMultiValueExtendedPropertiesRequest
*/
func (a *UsersMessageApiService) UsersMessagesCreateMultiValueExtendedProperties(ctx _context.Context, userId string, messageId string) ApiUsersMessagesCreateMultiValueExtendedPropertiesRequest {
	return ApiUsersMessagesCreateMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphMultiValueLegacyExtendedProperty
func (a *UsersMessageApiService) UsersMessagesCreateMultiValueExtendedPropertiesExecute(r ApiUsersMessagesCreateMultiValueExtendedPropertiesRequest) (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphMultiValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersMessageApiService.UsersMessagesCreateMultiValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/messages/{message-id}/multiValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphMultiValueLegacyExtendedProperty == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphMultiValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphMultiValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersMessagesCreateSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *UsersMessageApiService
	userId string
	messageId string
	microsoftGraphSingleValueLegacyExtendedProperty *MicrosoftGraphSingleValueLegacyExtendedProperty
}

// New navigation property
func (r ApiUsersMessagesCreateSingleValueExtendedPropertiesRequest) MicrosoftGraphSingleValueLegacyExtendedProperty(microsoftGraphSingleValueLegacyExtendedProperty MicrosoftGraphSingleValueLegacyExtendedProperty) ApiUsersMessagesCreateSingleValueExtendedPropertiesRequest {
	r.microsoftGraphSingleValueLegacyExtendedProperty = &microsoftGraphSingleValueLegacyExtendedProperty
	return r
}

func (r ApiUsersMessagesCreateSingleValueExtendedPropertiesRequest) Execute() (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.UsersMessagesCreateSingleValueExtendedPropertiesExecute(r)
}

/*
UsersMessagesCreateSingleValueExtendedProperties Create new navigation property to singleValueExtendedProperties for users

The collection of single-value extended properties defined for the message. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param messageId key: id of message
 @return ApiUsersMessagesCreateSingleValueExtendedPropertiesRequest
*/
func (a *UsersMessageApiService) UsersMessagesCreateSingleValueExtendedProperties(ctx _context.Context, userId string, messageId string) ApiUsersMessagesCreateSingleValueExtendedPropertiesRequest {
	return ApiUsersMessagesCreateSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphSingleValueLegacyExtendedProperty
func (a *UsersMessageApiService) UsersMessagesCreateSingleValueExtendedPropertiesExecute(r ApiUsersMessagesCreateSingleValueExtendedPropertiesRequest) (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphSingleValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersMessageApiService.UsersMessagesCreateSingleValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/messages/{message-id}/singleValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphSingleValueLegacyExtendedProperty == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphSingleValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphSingleValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersMessagesDeleteAttachmentsRequest struct {
	ctx _context.Context
	ApiService *UsersMessageApiService
	userId string
	messageId string
	attachmentId string
	ifMatch *string
}

// ETag
func (r ApiUsersMessagesDeleteAttachmentsRequest) IfMatch(ifMatch string) ApiUsersMessagesDeleteAttachmentsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersMessagesDeleteAttachmentsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersMessagesDeleteAttachmentsExecute(r)
}

/*
UsersMessagesDeleteAttachments Delete navigation property attachments for users

The fileAttachment and itemAttachment attachments for the message.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param messageId key: id of message
 @param attachmentId key: id of attachment
 @return ApiUsersMessagesDeleteAttachmentsRequest
*/
func (a *UsersMessageApiService) UsersMessagesDeleteAttachments(ctx _context.Context, userId string, messageId string, attachmentId string) ApiUsersMessagesDeleteAttachmentsRequest {
	return ApiUsersMessagesDeleteAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		messageId: messageId,
		attachmentId: attachmentId,
	}
}

// Execute executes the request
func (a *UsersMessageApiService) UsersMessagesDeleteAttachmentsExecute(r ApiUsersMessagesDeleteAttachmentsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersMessageApiService.UsersMessagesDeleteAttachments")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/messages/{message-id}/attachments/{attachment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment-id"+"}", _neturl.PathEscape(parameterToString(r.attachmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersMessagesDeleteExtensionsRequest struct {
	ctx _context.Context
	ApiService *UsersMessageApiService
	userId string
	messageId string
	extensionId string
	ifMatch *string
}

// ETag
func (r ApiUsersMessagesDeleteExtensionsRequest) IfMatch(ifMatch string) ApiUsersMessagesDeleteExtensionsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersMessagesDeleteExtensionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersMessagesDeleteExtensionsExecute(r)
}

/*
UsersMessagesDeleteExtensions Delete navigation property extensions for users

The collection of open extensions defined for the message. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param messageId key: id of message
 @param extensionId key: id of extension
 @return ApiUsersMessagesDeleteExtensionsRequest
*/
func (a *UsersMessageApiService) UsersMessagesDeleteExtensions(ctx _context.Context, userId string, messageId string, extensionId string) ApiUsersMessagesDeleteExtensionsRequest {
	return ApiUsersMessagesDeleteExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		messageId: messageId,
		extensionId: extensionId,
	}
}

// Execute executes the request
func (a *UsersMessageApiService) UsersMessagesDeleteExtensionsExecute(r ApiUsersMessagesDeleteExtensionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersMessageApiService.UsersMessagesDeleteExtensions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/messages/{message-id}/extensions/{extension-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension-id"+"}", _neturl.PathEscape(parameterToString(r.extensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersMessagesDeleteMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *UsersMessageApiService
	userId string
	messageId string
	multiValueLegacyExtendedPropertyId string
	ifMatch *string
}

// ETag
func (r ApiUsersMessagesDeleteMultiValueExtendedPropertiesRequest) IfMatch(ifMatch string) ApiUsersMessagesDeleteMultiValueExtendedPropertiesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersMessagesDeleteMultiValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersMessagesDeleteMultiValueExtendedPropertiesExecute(r)
}

/*
UsersMessagesDeleteMultiValueExtendedProperties Delete navigation property multiValueExtendedProperties for users

The collection of multi-value extended properties defined for the message. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param messageId key: id of message
 @param multiValueLegacyExtendedPropertyId key: id of multiValueLegacyExtendedProperty
 @return ApiUsersMessagesDeleteMultiValueExtendedPropertiesRequest
*/
func (a *UsersMessageApiService) UsersMessagesDeleteMultiValueExtendedProperties(ctx _context.Context, userId string, messageId string, multiValueLegacyExtendedPropertyId string) ApiUsersMessagesDeleteMultiValueExtendedPropertiesRequest {
	return ApiUsersMessagesDeleteMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		messageId: messageId,
		multiValueLegacyExtendedPropertyId: multiValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *UsersMessageApiService) UsersMessagesDeleteMultiValueExtendedPropertiesExecute(r ApiUsersMessagesDeleteMultiValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersMessageApiService.UsersMessagesDeleteMultiValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/messages/{message-id}/multiValueExtendedProperties/{multiValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"multiValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.multiValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersMessagesDeleteSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *UsersMessageApiService
	userId string
	messageId string
	singleValueLegacyExtendedPropertyId string
	ifMatch *string
}

// ETag
func (r ApiUsersMessagesDeleteSingleValueExtendedPropertiesRequest) IfMatch(ifMatch string) ApiUsersMessagesDeleteSingleValueExtendedPropertiesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUsersMessagesDeleteSingleValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersMessagesDeleteSingleValueExtendedPropertiesExecute(r)
}

/*
UsersMessagesDeleteSingleValueExtendedProperties Delete navigation property singleValueExtendedProperties for users

The collection of single-value extended properties defined for the message. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param messageId key: id of message
 @param singleValueLegacyExtendedPropertyId key: id of singleValueLegacyExtendedProperty
 @return ApiUsersMessagesDeleteSingleValueExtendedPropertiesRequest
*/
func (a *UsersMessageApiService) UsersMessagesDeleteSingleValueExtendedProperties(ctx _context.Context, userId string, messageId string, singleValueLegacyExtendedPropertyId string) ApiUsersMessagesDeleteSingleValueExtendedPropertiesRequest {
	return ApiUsersMessagesDeleteSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		messageId: messageId,
		singleValueLegacyExtendedPropertyId: singleValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *UsersMessageApiService) UsersMessagesDeleteSingleValueExtendedPropertiesExecute(r ApiUsersMessagesDeleteSingleValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersMessageApiService.UsersMessagesDeleteSingleValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/messages/{message-id}/singleValueExtendedProperties/{singleValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"singleValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.singleValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersMessagesGetAttachmentsRequest struct {
	ctx _context.Context
	ApiService *UsersMessageApiService
	userId string
	messageId string
	attachmentId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiUsersMessagesGetAttachmentsRequest) Select_(select_ []string) ApiUsersMessagesGetAttachmentsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersMessagesGetAttachmentsRequest) Expand(expand []string) ApiUsersMessagesGetAttachmentsRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersMessagesGetAttachmentsRequest) Execute() (MicrosoftGraphAttachment, *_nethttp.Response, error) {
	return r.ApiService.UsersMessagesGetAttachmentsExecute(r)
}

/*
UsersMessagesGetAttachments Get attachments from users

The fileAttachment and itemAttachment attachments for the message.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param messageId key: id of message
 @param attachmentId key: id of attachment
 @return ApiUsersMessagesGetAttachmentsRequest
*/
func (a *UsersMessageApiService) UsersMessagesGetAttachments(ctx _context.Context, userId string, messageId string, attachmentId string) ApiUsersMessagesGetAttachmentsRequest {
	return ApiUsersMessagesGetAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		messageId: messageId,
		attachmentId: attachmentId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphAttachment
func (a *UsersMessageApiService) UsersMessagesGetAttachmentsExecute(r ApiUsersMessagesGetAttachmentsRequest) (MicrosoftGraphAttachment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphAttachment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersMessageApiService.UsersMessagesGetAttachments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/messages/{message-id}/attachments/{attachment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment-id"+"}", _neturl.PathEscape(parameterToString(r.attachmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersMessagesGetExtensionsRequest struct {
	ctx _context.Context
	ApiService *UsersMessageApiService
	userId string
	messageId string
	extensionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiUsersMessagesGetExtensionsRequest) Select_(select_ []string) ApiUsersMessagesGetExtensionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersMessagesGetExtensionsRequest) Expand(expand []string) ApiUsersMessagesGetExtensionsRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersMessagesGetExtensionsRequest) Execute() (MicrosoftGraphExtension, *_nethttp.Response, error) {
	return r.ApiService.UsersMessagesGetExtensionsExecute(r)
}

/*
UsersMessagesGetExtensions Get extensions from users

The collection of open extensions defined for the message. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param messageId key: id of message
 @param extensionId key: id of extension
 @return ApiUsersMessagesGetExtensionsRequest
*/
func (a *UsersMessageApiService) UsersMessagesGetExtensions(ctx _context.Context, userId string, messageId string, extensionId string) ApiUsersMessagesGetExtensionsRequest {
	return ApiUsersMessagesGetExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		messageId: messageId,
		extensionId: extensionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphExtension
func (a *UsersMessageApiService) UsersMessagesGetExtensionsExecute(r ApiUsersMessagesGetExtensionsRequest) (MicrosoftGraphExtension, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphExtension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersMessageApiService.UsersMessagesGetExtensions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/messages/{message-id}/extensions/{extension-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension-id"+"}", _neturl.PathEscape(parameterToString(r.extensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersMessagesGetMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *UsersMessageApiService
	userId string
	messageId string
	multiValueLegacyExtendedPropertyId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiUsersMessagesGetMultiValueExtendedPropertiesRequest) Select_(select_ []string) ApiUsersMessagesGetMultiValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersMessagesGetMultiValueExtendedPropertiesRequest) Expand(expand []string) ApiUsersMessagesGetMultiValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersMessagesGetMultiValueExtendedPropertiesRequest) Execute() (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.UsersMessagesGetMultiValueExtendedPropertiesExecute(r)
}

/*
UsersMessagesGetMultiValueExtendedProperties Get multiValueExtendedProperties from users

The collection of multi-value extended properties defined for the message. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param messageId key: id of message
 @param multiValueLegacyExtendedPropertyId key: id of multiValueLegacyExtendedProperty
 @return ApiUsersMessagesGetMultiValueExtendedPropertiesRequest
*/
func (a *UsersMessageApiService) UsersMessagesGetMultiValueExtendedProperties(ctx _context.Context, userId string, messageId string, multiValueLegacyExtendedPropertyId string) ApiUsersMessagesGetMultiValueExtendedPropertiesRequest {
	return ApiUsersMessagesGetMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		messageId: messageId,
		multiValueLegacyExtendedPropertyId: multiValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphMultiValueLegacyExtendedProperty
func (a *UsersMessageApiService) UsersMessagesGetMultiValueExtendedPropertiesExecute(r ApiUsersMessagesGetMultiValueExtendedPropertiesRequest) (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphMultiValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersMessageApiService.UsersMessagesGetMultiValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/messages/{message-id}/multiValueExtendedProperties/{multiValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"multiValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.multiValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersMessagesGetSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *UsersMessageApiService
	userId string
	messageId string
	singleValueLegacyExtendedPropertyId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiUsersMessagesGetSingleValueExtendedPropertiesRequest) Select_(select_ []string) ApiUsersMessagesGetSingleValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersMessagesGetSingleValueExtendedPropertiesRequest) Expand(expand []string) ApiUsersMessagesGetSingleValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersMessagesGetSingleValueExtendedPropertiesRequest) Execute() (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.UsersMessagesGetSingleValueExtendedPropertiesExecute(r)
}

/*
UsersMessagesGetSingleValueExtendedProperties Get singleValueExtendedProperties from users

The collection of single-value extended properties defined for the message. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param messageId key: id of message
 @param singleValueLegacyExtendedPropertyId key: id of singleValueLegacyExtendedProperty
 @return ApiUsersMessagesGetSingleValueExtendedPropertiesRequest
*/
func (a *UsersMessageApiService) UsersMessagesGetSingleValueExtendedProperties(ctx _context.Context, userId string, messageId string, singleValueLegacyExtendedPropertyId string) ApiUsersMessagesGetSingleValueExtendedPropertiesRequest {
	return ApiUsersMessagesGetSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		messageId: messageId,
		singleValueLegacyExtendedPropertyId: singleValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphSingleValueLegacyExtendedProperty
func (a *UsersMessageApiService) UsersMessagesGetSingleValueExtendedPropertiesExecute(r ApiUsersMessagesGetSingleValueExtendedPropertiesRequest) (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphSingleValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersMessageApiService.UsersMessagesGetSingleValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/messages/{message-id}/singleValueExtendedProperties/{singleValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"singleValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.singleValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersMessagesListAttachmentsRequest struct {
	ctx _context.Context
	ApiService *UsersMessageApiService
	userId string
	messageId string
	top *int32
	skip *int32
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiUsersMessagesListAttachmentsRequest) Top(top int32) ApiUsersMessagesListAttachmentsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiUsersMessagesListAttachmentsRequest) Skip(skip int32) ApiUsersMessagesListAttachmentsRequest {
	r.skip = &skip
	return r
}
// Filter items by property values
func (r ApiUsersMessagesListAttachmentsRequest) Filter(filter string) ApiUsersMessagesListAttachmentsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiUsersMessagesListAttachmentsRequest) Count(count bool) ApiUsersMessagesListAttachmentsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiUsersMessagesListAttachmentsRequest) Orderby(orderby []string) ApiUsersMessagesListAttachmentsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiUsersMessagesListAttachmentsRequest) Select_(select_ []string) ApiUsersMessagesListAttachmentsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersMessagesListAttachmentsRequest) Expand(expand []string) ApiUsersMessagesListAttachmentsRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersMessagesListAttachmentsRequest) Execute() (CollectionOfAttachment, *_nethttp.Response, error) {
	return r.ApiService.UsersMessagesListAttachmentsExecute(r)
}

/*
UsersMessagesListAttachments Get attachments from users

The fileAttachment and itemAttachment attachments for the message.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param messageId key: id of message
 @return ApiUsersMessagesListAttachmentsRequest
*/
func (a *UsersMessageApiService) UsersMessagesListAttachments(ctx _context.Context, userId string, messageId string) ApiUsersMessagesListAttachmentsRequest {
	return ApiUsersMessagesListAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return CollectionOfAttachment
func (a *UsersMessageApiService) UsersMessagesListAttachmentsExecute(r ApiUsersMessagesListAttachmentsRequest) (CollectionOfAttachment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfAttachment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersMessageApiService.UsersMessagesListAttachments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/messages/{message-id}/attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersMessagesListExtensionsRequest struct {
	ctx _context.Context
	ApiService *UsersMessageApiService
	userId string
	messageId string
	top *int32
	skip *int32
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiUsersMessagesListExtensionsRequest) Top(top int32) ApiUsersMessagesListExtensionsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiUsersMessagesListExtensionsRequest) Skip(skip int32) ApiUsersMessagesListExtensionsRequest {
	r.skip = &skip
	return r
}
// Filter items by property values
func (r ApiUsersMessagesListExtensionsRequest) Filter(filter string) ApiUsersMessagesListExtensionsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiUsersMessagesListExtensionsRequest) Count(count bool) ApiUsersMessagesListExtensionsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiUsersMessagesListExtensionsRequest) Orderby(orderby []string) ApiUsersMessagesListExtensionsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiUsersMessagesListExtensionsRequest) Select_(select_ []string) ApiUsersMessagesListExtensionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersMessagesListExtensionsRequest) Expand(expand []string) ApiUsersMessagesListExtensionsRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersMessagesListExtensionsRequest) Execute() (CollectionOfExtension, *_nethttp.Response, error) {
	return r.ApiService.UsersMessagesListExtensionsExecute(r)
}

/*
UsersMessagesListExtensions Get extensions from users

The collection of open extensions defined for the message. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param messageId key: id of message
 @return ApiUsersMessagesListExtensionsRequest
*/
func (a *UsersMessageApiService) UsersMessagesListExtensions(ctx _context.Context, userId string, messageId string) ApiUsersMessagesListExtensionsRequest {
	return ApiUsersMessagesListExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return CollectionOfExtension
func (a *UsersMessageApiService) UsersMessagesListExtensionsExecute(r ApiUsersMessagesListExtensionsRequest) (CollectionOfExtension, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfExtension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersMessageApiService.UsersMessagesListExtensions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/messages/{message-id}/extensions"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersMessagesListMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *UsersMessageApiService
	userId string
	messageId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiUsersMessagesListMultiValueExtendedPropertiesRequest) Top(top int32) ApiUsersMessagesListMultiValueExtendedPropertiesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiUsersMessagesListMultiValueExtendedPropertiesRequest) Skip(skip int32) ApiUsersMessagesListMultiValueExtendedPropertiesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiUsersMessagesListMultiValueExtendedPropertiesRequest) Search(search string) ApiUsersMessagesListMultiValueExtendedPropertiesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiUsersMessagesListMultiValueExtendedPropertiesRequest) Filter(filter string) ApiUsersMessagesListMultiValueExtendedPropertiesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiUsersMessagesListMultiValueExtendedPropertiesRequest) Count(count bool) ApiUsersMessagesListMultiValueExtendedPropertiesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiUsersMessagesListMultiValueExtendedPropertiesRequest) Orderby(orderby []string) ApiUsersMessagesListMultiValueExtendedPropertiesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiUsersMessagesListMultiValueExtendedPropertiesRequest) Select_(select_ []string) ApiUsersMessagesListMultiValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersMessagesListMultiValueExtendedPropertiesRequest) Expand(expand []string) ApiUsersMessagesListMultiValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersMessagesListMultiValueExtendedPropertiesRequest) Execute() (CollectionOfMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.UsersMessagesListMultiValueExtendedPropertiesExecute(r)
}

/*
UsersMessagesListMultiValueExtendedProperties Get multiValueExtendedProperties from users

The collection of multi-value extended properties defined for the message. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param messageId key: id of message
 @return ApiUsersMessagesListMultiValueExtendedPropertiesRequest
*/
func (a *UsersMessageApiService) UsersMessagesListMultiValueExtendedProperties(ctx _context.Context, userId string, messageId string) ApiUsersMessagesListMultiValueExtendedPropertiesRequest {
	return ApiUsersMessagesListMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return CollectionOfMultiValueLegacyExtendedProperty
func (a *UsersMessageApiService) UsersMessagesListMultiValueExtendedPropertiesExecute(r ApiUsersMessagesListMultiValueExtendedPropertiesRequest) (CollectionOfMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfMultiValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersMessageApiService.UsersMessagesListMultiValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/messages/{message-id}/multiValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersMessagesListSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *UsersMessageApiService
	userId string
	messageId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiUsersMessagesListSingleValueExtendedPropertiesRequest) Top(top int32) ApiUsersMessagesListSingleValueExtendedPropertiesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiUsersMessagesListSingleValueExtendedPropertiesRequest) Skip(skip int32) ApiUsersMessagesListSingleValueExtendedPropertiesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiUsersMessagesListSingleValueExtendedPropertiesRequest) Search(search string) ApiUsersMessagesListSingleValueExtendedPropertiesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiUsersMessagesListSingleValueExtendedPropertiesRequest) Filter(filter string) ApiUsersMessagesListSingleValueExtendedPropertiesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiUsersMessagesListSingleValueExtendedPropertiesRequest) Count(count bool) ApiUsersMessagesListSingleValueExtendedPropertiesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiUsersMessagesListSingleValueExtendedPropertiesRequest) Orderby(orderby []string) ApiUsersMessagesListSingleValueExtendedPropertiesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiUsersMessagesListSingleValueExtendedPropertiesRequest) Select_(select_ []string) ApiUsersMessagesListSingleValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiUsersMessagesListSingleValueExtendedPropertiesRequest) Expand(expand []string) ApiUsersMessagesListSingleValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiUsersMessagesListSingleValueExtendedPropertiesRequest) Execute() (CollectionOfSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.UsersMessagesListSingleValueExtendedPropertiesExecute(r)
}

/*
UsersMessagesListSingleValueExtendedProperties Get singleValueExtendedProperties from users

The collection of single-value extended properties defined for the message. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param messageId key: id of message
 @return ApiUsersMessagesListSingleValueExtendedPropertiesRequest
*/
func (a *UsersMessageApiService) UsersMessagesListSingleValueExtendedProperties(ctx _context.Context, userId string, messageId string) ApiUsersMessagesListSingleValueExtendedPropertiesRequest {
	return ApiUsersMessagesListSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return CollectionOfSingleValueLegacyExtendedProperty
func (a *UsersMessageApiService) UsersMessagesListSingleValueExtendedPropertiesExecute(r ApiUsersMessagesListSingleValueExtendedPropertiesRequest) (CollectionOfSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfSingleValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersMessageApiService.UsersMessagesListSingleValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/messages/{message-id}/singleValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersMessagesUpdateAttachmentsRequest struct {
	ctx _context.Context
	ApiService *UsersMessageApiService
	userId string
	messageId string
	attachmentId string
	microsoftGraphAttachment *MicrosoftGraphAttachment
}

// New navigation property values
func (r ApiUsersMessagesUpdateAttachmentsRequest) MicrosoftGraphAttachment(microsoftGraphAttachment MicrosoftGraphAttachment) ApiUsersMessagesUpdateAttachmentsRequest {
	r.microsoftGraphAttachment = &microsoftGraphAttachment
	return r
}

func (r ApiUsersMessagesUpdateAttachmentsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersMessagesUpdateAttachmentsExecute(r)
}

/*
UsersMessagesUpdateAttachments Update the navigation property attachments in users

The fileAttachment and itemAttachment attachments for the message.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param messageId key: id of message
 @param attachmentId key: id of attachment
 @return ApiUsersMessagesUpdateAttachmentsRequest
*/
func (a *UsersMessageApiService) UsersMessagesUpdateAttachments(ctx _context.Context, userId string, messageId string, attachmentId string) ApiUsersMessagesUpdateAttachmentsRequest {
	return ApiUsersMessagesUpdateAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		messageId: messageId,
		attachmentId: attachmentId,
	}
}

// Execute executes the request
func (a *UsersMessageApiService) UsersMessagesUpdateAttachmentsExecute(r ApiUsersMessagesUpdateAttachmentsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersMessageApiService.UsersMessagesUpdateAttachments")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/messages/{message-id}/attachments/{attachment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment-id"+"}", _neturl.PathEscape(parameterToString(r.attachmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphAttachment == nil {
		return nil, reportError("microsoftGraphAttachment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphAttachment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersMessagesUpdateExtensionsRequest struct {
	ctx _context.Context
	ApiService *UsersMessageApiService
	userId string
	messageId string
	extensionId string
	microsoftGraphExtension *MicrosoftGraphExtension
}

// New navigation property values
func (r ApiUsersMessagesUpdateExtensionsRequest) MicrosoftGraphExtension(microsoftGraphExtension MicrosoftGraphExtension) ApiUsersMessagesUpdateExtensionsRequest {
	r.microsoftGraphExtension = &microsoftGraphExtension
	return r
}

func (r ApiUsersMessagesUpdateExtensionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersMessagesUpdateExtensionsExecute(r)
}

/*
UsersMessagesUpdateExtensions Update the navigation property extensions in users

The collection of open extensions defined for the message. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param messageId key: id of message
 @param extensionId key: id of extension
 @return ApiUsersMessagesUpdateExtensionsRequest
*/
func (a *UsersMessageApiService) UsersMessagesUpdateExtensions(ctx _context.Context, userId string, messageId string, extensionId string) ApiUsersMessagesUpdateExtensionsRequest {
	return ApiUsersMessagesUpdateExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		messageId: messageId,
		extensionId: extensionId,
	}
}

// Execute executes the request
func (a *UsersMessageApiService) UsersMessagesUpdateExtensionsExecute(r ApiUsersMessagesUpdateExtensionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersMessageApiService.UsersMessagesUpdateExtensions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/messages/{message-id}/extensions/{extension-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension-id"+"}", _neturl.PathEscape(parameterToString(r.extensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphExtension == nil {
		return nil, reportError("microsoftGraphExtension is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphExtension
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersMessagesUpdateMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *UsersMessageApiService
	userId string
	messageId string
	multiValueLegacyExtendedPropertyId string
	microsoftGraphMultiValueLegacyExtendedProperty *MicrosoftGraphMultiValueLegacyExtendedProperty
}

// New navigation property values
func (r ApiUsersMessagesUpdateMultiValueExtendedPropertiesRequest) MicrosoftGraphMultiValueLegacyExtendedProperty(microsoftGraphMultiValueLegacyExtendedProperty MicrosoftGraphMultiValueLegacyExtendedProperty) ApiUsersMessagesUpdateMultiValueExtendedPropertiesRequest {
	r.microsoftGraphMultiValueLegacyExtendedProperty = &microsoftGraphMultiValueLegacyExtendedProperty
	return r
}

func (r ApiUsersMessagesUpdateMultiValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersMessagesUpdateMultiValueExtendedPropertiesExecute(r)
}

/*
UsersMessagesUpdateMultiValueExtendedProperties Update the navigation property multiValueExtendedProperties in users

The collection of multi-value extended properties defined for the message. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param messageId key: id of message
 @param multiValueLegacyExtendedPropertyId key: id of multiValueLegacyExtendedProperty
 @return ApiUsersMessagesUpdateMultiValueExtendedPropertiesRequest
*/
func (a *UsersMessageApiService) UsersMessagesUpdateMultiValueExtendedProperties(ctx _context.Context, userId string, messageId string, multiValueLegacyExtendedPropertyId string) ApiUsersMessagesUpdateMultiValueExtendedPropertiesRequest {
	return ApiUsersMessagesUpdateMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		messageId: messageId,
		multiValueLegacyExtendedPropertyId: multiValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *UsersMessageApiService) UsersMessagesUpdateMultiValueExtendedPropertiesExecute(r ApiUsersMessagesUpdateMultiValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersMessageApiService.UsersMessagesUpdateMultiValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/messages/{message-id}/multiValueExtendedProperties/{multiValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"multiValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.multiValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphMultiValueLegacyExtendedProperty == nil {
		return nil, reportError("microsoftGraphMultiValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphMultiValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersMessagesUpdateSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *UsersMessageApiService
	userId string
	messageId string
	singleValueLegacyExtendedPropertyId string
	microsoftGraphSingleValueLegacyExtendedProperty *MicrosoftGraphSingleValueLegacyExtendedProperty
}

// New navigation property values
func (r ApiUsersMessagesUpdateSingleValueExtendedPropertiesRequest) MicrosoftGraphSingleValueLegacyExtendedProperty(microsoftGraphSingleValueLegacyExtendedProperty MicrosoftGraphSingleValueLegacyExtendedProperty) ApiUsersMessagesUpdateSingleValueExtendedPropertiesRequest {
	r.microsoftGraphSingleValueLegacyExtendedProperty = &microsoftGraphSingleValueLegacyExtendedProperty
	return r
}

func (r ApiUsersMessagesUpdateSingleValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersMessagesUpdateSingleValueExtendedPropertiesExecute(r)
}

/*
UsersMessagesUpdateSingleValueExtendedProperties Update the navigation property singleValueExtendedProperties in users

The collection of single-value extended properties defined for the message. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param messageId key: id of message
 @param singleValueLegacyExtendedPropertyId key: id of singleValueLegacyExtendedProperty
 @return ApiUsersMessagesUpdateSingleValueExtendedPropertiesRequest
*/
func (a *UsersMessageApiService) UsersMessagesUpdateSingleValueExtendedProperties(ctx _context.Context, userId string, messageId string, singleValueLegacyExtendedPropertyId string) ApiUsersMessagesUpdateSingleValueExtendedPropertiesRequest {
	return ApiUsersMessagesUpdateSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		messageId: messageId,
		singleValueLegacyExtendedPropertyId: singleValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *UsersMessageApiService) UsersMessagesUpdateSingleValueExtendedPropertiesExecute(r ApiUsersMessagesUpdateSingleValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersMessageApiService.UsersMessagesUpdateSingleValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/messages/{message-id}/singleValueExtendedProperties/{singleValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"singleValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.singleValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphSingleValueLegacyExtendedProperty == nil {
		return nil, reportError("microsoftGraphSingleValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphSingleValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUpdateMessagesRequest struct {
	ctx _context.Context
	ApiService *UsersMessageApiService
	userId string
	messageId string
	microsoftGraphMessage *MicrosoftGraphMessage
}

// New navigation property values
func (r ApiUsersUpdateMessagesRequest) MicrosoftGraphMessage(microsoftGraphMessage MicrosoftGraphMessage) ApiUsersUpdateMessagesRequest {
	r.microsoftGraphMessage = &microsoftGraphMessage
	return r
}

func (r ApiUsersUpdateMessagesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUpdateMessagesExecute(r)
}

/*
UsersUpdateMessages Update the navigation property messages in users

The messages in a mailbox or folder. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param messageId key: id of message
 @return ApiUsersUpdateMessagesRequest
*/
func (a *UsersMessageApiService) UsersUpdateMessages(ctx _context.Context, userId string, messageId string) ApiUsersUpdateMessagesRequest {
	return ApiUsersUpdateMessagesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		messageId: messageId,
	}
}

// Execute executes the request
func (a *UsersMessageApiService) UsersUpdateMessagesExecute(r ApiUsersUpdateMessagesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersMessageApiService.UsersUpdateMessages")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/messages/{message-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphMessage == nil {
		return nil, reportError("microsoftGraphMessage is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphMessage
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUpdateMessagesContentRequest struct {
	ctx _context.Context
	ApiService *UsersMessageApiService
	userId string
	messageId string
	body **os.File
}

// New media content.
func (r ApiUsersUpdateMessagesContentRequest) Body(body *os.File) ApiUsersUpdateMessagesContentRequest {
	r.body = &body
	return r
}

func (r ApiUsersUpdateMessagesContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersUpdateMessagesContentExecute(r)
}

/*
UsersUpdateMessagesContent Update media content for the navigation property messages in users

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId key: id of user
 @param messageId key: id of message
 @return ApiUsersUpdateMessagesContentRequest
*/
func (a *UsersMessageApiService) UsersUpdateMessagesContent(ctx _context.Context, userId string, messageId string) ApiUsersUpdateMessagesContentRequest {
	return ApiUsersUpdateMessagesContentRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		messageId: messageId,
	}
}

// Execute executes the request
func (a *UsersMessageApiService) UsersUpdateMessagesContentExecute(r ApiUsersUpdateMessagesContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersMessageApiService.UsersUpdateMessagesContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user-id}/messages/{message-id}/$value"
	localVarPath = strings.Replace(localVarPath, "{"+"user-id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message-id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
