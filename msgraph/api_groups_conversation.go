/*
Partial Graph API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package msgraph

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// GroupsConversationApiService GroupsConversationApi service
type GroupsConversationApiService service

type ApiGroupsConversationsCreateThreadsRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationApiService
	groupId string
	conversationId string
	microsoftGraphConversationThread *MicrosoftGraphConversationThread
}

// New navigation property
func (r ApiGroupsConversationsCreateThreadsRequest) MicrosoftGraphConversationThread(microsoftGraphConversationThread MicrosoftGraphConversationThread) ApiGroupsConversationsCreateThreadsRequest {
	r.microsoftGraphConversationThread = &microsoftGraphConversationThread
	return r
}

func (r ApiGroupsConversationsCreateThreadsRequest) Execute() (MicrosoftGraphConversationThread, *_nethttp.Response, error) {
	return r.ApiService.GroupsConversationsCreateThreadsExecute(r)
}

/*
GroupsConversationsCreateThreads Create new navigation property to threads for groups

A collection of all the conversation threads in the conversation. A navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationId key: id of conversation
 @return ApiGroupsConversationsCreateThreadsRequest
*/
func (a *GroupsConversationApiService) GroupsConversationsCreateThreads(ctx _context.Context, groupId string, conversationId string) ApiGroupsConversationsCreateThreadsRequest {
	return ApiGroupsConversationsCreateThreadsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationId: conversationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphConversationThread
func (a *GroupsConversationApiService) GroupsConversationsCreateThreadsExecute(r ApiGroupsConversationsCreateThreadsRequest) (MicrosoftGraphConversationThread, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphConversationThread
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationApiService.GroupsConversationsCreateThreads")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/conversations/{conversation-id}/threads"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversation-id"+"}", _neturl.PathEscape(parameterToString(r.conversationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphConversationThread == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphConversationThread is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphConversationThread
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsConversationsDeleteThreadsRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationApiService
	groupId string
	conversationId string
	conversationThreadId string
	ifMatch *string
}

// ETag
func (r ApiGroupsConversationsDeleteThreadsRequest) IfMatch(ifMatch string) ApiGroupsConversationsDeleteThreadsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsConversationsDeleteThreadsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsConversationsDeleteThreadsExecute(r)
}

/*
GroupsConversationsDeleteThreads Delete navigation property threads for groups

A collection of all the conversation threads in the conversation. A navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationId key: id of conversation
 @param conversationThreadId key: id of conversationThread
 @return ApiGroupsConversationsDeleteThreadsRequest
*/
func (a *GroupsConversationApiService) GroupsConversationsDeleteThreads(ctx _context.Context, groupId string, conversationId string, conversationThreadId string) ApiGroupsConversationsDeleteThreadsRequest {
	return ApiGroupsConversationsDeleteThreadsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationId: conversationId,
		conversationThreadId: conversationThreadId,
	}
}

// Execute executes the request
func (a *GroupsConversationApiService) GroupsConversationsDeleteThreadsExecute(r ApiGroupsConversationsDeleteThreadsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationApiService.GroupsConversationsDeleteThreads")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversation-id"+"}", _neturl.PathEscape(parameterToString(r.conversationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsConversationsGetThreadsRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationApiService
	groupId string
	conversationId string
	conversationThreadId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiGroupsConversationsGetThreadsRequest) Select_(select_ []string) ApiGroupsConversationsGetThreadsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsConversationsGetThreadsRequest) Expand(expand []string) ApiGroupsConversationsGetThreadsRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsConversationsGetThreadsRequest) Execute() (MicrosoftGraphConversationThread, *_nethttp.Response, error) {
	return r.ApiService.GroupsConversationsGetThreadsExecute(r)
}

/*
GroupsConversationsGetThreads Get threads from groups

A collection of all the conversation threads in the conversation. A navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationId key: id of conversation
 @param conversationThreadId key: id of conversationThread
 @return ApiGroupsConversationsGetThreadsRequest
*/
func (a *GroupsConversationApiService) GroupsConversationsGetThreads(ctx _context.Context, groupId string, conversationId string, conversationThreadId string) ApiGroupsConversationsGetThreadsRequest {
	return ApiGroupsConversationsGetThreadsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationId: conversationId,
		conversationThreadId: conversationThreadId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphConversationThread
func (a *GroupsConversationApiService) GroupsConversationsGetThreadsExecute(r ApiGroupsConversationsGetThreadsRequest) (MicrosoftGraphConversationThread, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphConversationThread
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationApiService.GroupsConversationsGetThreads")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversation-id"+"}", _neturl.PathEscape(parameterToString(r.conversationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsConversationsListThreadsRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationApiService
	groupId string
	conversationId string
	top *int32
	skip *int32
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiGroupsConversationsListThreadsRequest) Top(top int32) ApiGroupsConversationsListThreadsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsConversationsListThreadsRequest) Skip(skip int32) ApiGroupsConversationsListThreadsRequest {
	r.skip = &skip
	return r
}
// Filter items by property values
func (r ApiGroupsConversationsListThreadsRequest) Filter(filter string) ApiGroupsConversationsListThreadsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsConversationsListThreadsRequest) Count(count bool) ApiGroupsConversationsListThreadsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsConversationsListThreadsRequest) Orderby(orderby []string) ApiGroupsConversationsListThreadsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiGroupsConversationsListThreadsRequest) Select_(select_ []string) ApiGroupsConversationsListThreadsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsConversationsListThreadsRequest) Expand(expand []string) ApiGroupsConversationsListThreadsRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsConversationsListThreadsRequest) Execute() (CollectionOfConversationThread, *_nethttp.Response, error) {
	return r.ApiService.GroupsConversationsListThreadsExecute(r)
}

/*
GroupsConversationsListThreads Get threads from groups

A collection of all the conversation threads in the conversation. A navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationId key: id of conversation
 @return ApiGroupsConversationsListThreadsRequest
*/
func (a *GroupsConversationApiService) GroupsConversationsListThreads(ctx _context.Context, groupId string, conversationId string) ApiGroupsConversationsListThreadsRequest {
	return ApiGroupsConversationsListThreadsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationId: conversationId,
	}
}

// Execute executes the request
//  @return CollectionOfConversationThread
func (a *GroupsConversationApiService) GroupsConversationsListThreadsExecute(r ApiGroupsConversationsListThreadsRequest) (CollectionOfConversationThread, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfConversationThread
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationApiService.GroupsConversationsListThreads")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/conversations/{conversation-id}/threads"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversation-id"+"}", _neturl.PathEscape(parameterToString(r.conversationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsConversationsThreadsCreatePostsRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationApiService
	groupId string
	conversationId string
	conversationThreadId string
	microsoftGraphPost *MicrosoftGraphPost
}

// New navigation property
func (r ApiGroupsConversationsThreadsCreatePostsRequest) MicrosoftGraphPost(microsoftGraphPost MicrosoftGraphPost) ApiGroupsConversationsThreadsCreatePostsRequest {
	r.microsoftGraphPost = &microsoftGraphPost
	return r
}

func (r ApiGroupsConversationsThreadsCreatePostsRequest) Execute() (MicrosoftGraphPost, *_nethttp.Response, error) {
	return r.ApiService.GroupsConversationsThreadsCreatePostsExecute(r)
}

/*
GroupsConversationsThreadsCreatePosts Create new navigation property to posts for groups

Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationId key: id of conversation
 @param conversationThreadId key: id of conversationThread
 @return ApiGroupsConversationsThreadsCreatePostsRequest
*/
func (a *GroupsConversationApiService) GroupsConversationsThreadsCreatePosts(ctx _context.Context, groupId string, conversationId string, conversationThreadId string) ApiGroupsConversationsThreadsCreatePostsRequest {
	return ApiGroupsConversationsThreadsCreatePostsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationId: conversationId,
		conversationThreadId: conversationThreadId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPost
func (a *GroupsConversationApiService) GroupsConversationsThreadsCreatePostsExecute(r ApiGroupsConversationsThreadsCreatePostsRequest) (MicrosoftGraphPost, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPost
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationApiService.GroupsConversationsThreadsCreatePosts")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversation-id"+"}", _neturl.PathEscape(parameterToString(r.conversationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPost == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphPost is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPost
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsConversationsThreadsDeletePostsRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationApiService
	groupId string
	conversationId string
	conversationThreadId string
	postId string
	ifMatch *string
}

// ETag
func (r ApiGroupsConversationsThreadsDeletePostsRequest) IfMatch(ifMatch string) ApiGroupsConversationsThreadsDeletePostsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsConversationsThreadsDeletePostsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsConversationsThreadsDeletePostsExecute(r)
}

/*
GroupsConversationsThreadsDeletePosts Delete navigation property posts for groups

Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationId key: id of conversation
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @return ApiGroupsConversationsThreadsDeletePostsRequest
*/
func (a *GroupsConversationApiService) GroupsConversationsThreadsDeletePosts(ctx _context.Context, groupId string, conversationId string, conversationThreadId string, postId string) ApiGroupsConversationsThreadsDeletePostsRequest {
	return ApiGroupsConversationsThreadsDeletePostsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationId: conversationId,
		conversationThreadId: conversationThreadId,
		postId: postId,
	}
}

// Execute executes the request
func (a *GroupsConversationApiService) GroupsConversationsThreadsDeletePostsExecute(r ApiGroupsConversationsThreadsDeletePostsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationApiService.GroupsConversationsThreadsDeletePosts")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversation-id"+"}", _neturl.PathEscape(parameterToString(r.conversationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsConversationsThreadsGetPostsRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationApiService
	groupId string
	conversationId string
	conversationThreadId string
	postId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiGroupsConversationsThreadsGetPostsRequest) Select_(select_ []string) ApiGroupsConversationsThreadsGetPostsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsConversationsThreadsGetPostsRequest) Expand(expand []string) ApiGroupsConversationsThreadsGetPostsRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsConversationsThreadsGetPostsRequest) Execute() (MicrosoftGraphPost, *_nethttp.Response, error) {
	return r.ApiService.GroupsConversationsThreadsGetPostsExecute(r)
}

/*
GroupsConversationsThreadsGetPosts Get posts from groups

Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationId key: id of conversation
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @return ApiGroupsConversationsThreadsGetPostsRequest
*/
func (a *GroupsConversationApiService) GroupsConversationsThreadsGetPosts(ctx _context.Context, groupId string, conversationId string, conversationThreadId string, postId string) ApiGroupsConversationsThreadsGetPostsRequest {
	return ApiGroupsConversationsThreadsGetPostsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationId: conversationId,
		conversationThreadId: conversationThreadId,
		postId: postId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPost
func (a *GroupsConversationApiService) GroupsConversationsThreadsGetPostsExecute(r ApiGroupsConversationsThreadsGetPostsRequest) (MicrosoftGraphPost, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPost
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationApiService.GroupsConversationsThreadsGetPosts")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversation-id"+"}", _neturl.PathEscape(parameterToString(r.conversationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsConversationsThreadsListPostsRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationApiService
	groupId string
	conversationId string
	conversationThreadId string
	top *int32
	skip *int32
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiGroupsConversationsThreadsListPostsRequest) Top(top int32) ApiGroupsConversationsThreadsListPostsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsConversationsThreadsListPostsRequest) Skip(skip int32) ApiGroupsConversationsThreadsListPostsRequest {
	r.skip = &skip
	return r
}
// Filter items by property values
func (r ApiGroupsConversationsThreadsListPostsRequest) Filter(filter string) ApiGroupsConversationsThreadsListPostsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsConversationsThreadsListPostsRequest) Count(count bool) ApiGroupsConversationsThreadsListPostsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsConversationsThreadsListPostsRequest) Orderby(orderby []string) ApiGroupsConversationsThreadsListPostsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiGroupsConversationsThreadsListPostsRequest) Select_(select_ []string) ApiGroupsConversationsThreadsListPostsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsConversationsThreadsListPostsRequest) Expand(expand []string) ApiGroupsConversationsThreadsListPostsRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsConversationsThreadsListPostsRequest) Execute() (CollectionOfPost, *_nethttp.Response, error) {
	return r.ApiService.GroupsConversationsThreadsListPostsExecute(r)
}

/*
GroupsConversationsThreadsListPosts Get posts from groups

Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationId key: id of conversation
 @param conversationThreadId key: id of conversationThread
 @return ApiGroupsConversationsThreadsListPostsRequest
*/
func (a *GroupsConversationApiService) GroupsConversationsThreadsListPosts(ctx _context.Context, groupId string, conversationId string, conversationThreadId string) ApiGroupsConversationsThreadsListPostsRequest {
	return ApiGroupsConversationsThreadsListPostsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationId: conversationId,
		conversationThreadId: conversationThreadId,
	}
}

// Execute executes the request
//  @return CollectionOfPost
func (a *GroupsConversationApiService) GroupsConversationsThreadsListPostsExecute(r ApiGroupsConversationsThreadsListPostsRequest) (CollectionOfPost, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfPost
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationApiService.GroupsConversationsThreadsListPosts")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversation-id"+"}", _neturl.PathEscape(parameterToString(r.conversationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsConversationsThreadsPostsCreateAttachmentsRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationApiService
	groupId string
	conversationId string
	conversationThreadId string
	postId string
	microsoftGraphAttachment *MicrosoftGraphAttachment
}

// New navigation property
func (r ApiGroupsConversationsThreadsPostsCreateAttachmentsRequest) MicrosoftGraphAttachment(microsoftGraphAttachment MicrosoftGraphAttachment) ApiGroupsConversationsThreadsPostsCreateAttachmentsRequest {
	r.microsoftGraphAttachment = &microsoftGraphAttachment
	return r
}

func (r ApiGroupsConversationsThreadsPostsCreateAttachmentsRequest) Execute() (MicrosoftGraphAttachment, *_nethttp.Response, error) {
	return r.ApiService.GroupsConversationsThreadsPostsCreateAttachmentsExecute(r)
}

/*
GroupsConversationsThreadsPostsCreateAttachments Create new navigation property to attachments for groups

Read-only. Nullable. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationId key: id of conversation
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @return ApiGroupsConversationsThreadsPostsCreateAttachmentsRequest
*/
func (a *GroupsConversationApiService) GroupsConversationsThreadsPostsCreateAttachments(ctx _context.Context, groupId string, conversationId string, conversationThreadId string, postId string) ApiGroupsConversationsThreadsPostsCreateAttachmentsRequest {
	return ApiGroupsConversationsThreadsPostsCreateAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationId: conversationId,
		conversationThreadId: conversationThreadId,
		postId: postId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphAttachment
func (a *GroupsConversationApiService) GroupsConversationsThreadsPostsCreateAttachmentsExecute(r ApiGroupsConversationsThreadsPostsCreateAttachmentsRequest) (MicrosoftGraphAttachment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphAttachment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationApiService.GroupsConversationsThreadsPostsCreateAttachments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}/attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversation-id"+"}", _neturl.PathEscape(parameterToString(r.conversationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphAttachment == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphAttachment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphAttachment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsConversationsThreadsPostsCreateExtensionsRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationApiService
	groupId string
	conversationId string
	conversationThreadId string
	postId string
	microsoftGraphExtension *MicrosoftGraphExtension
}

// New navigation property
func (r ApiGroupsConversationsThreadsPostsCreateExtensionsRequest) MicrosoftGraphExtension(microsoftGraphExtension MicrosoftGraphExtension) ApiGroupsConversationsThreadsPostsCreateExtensionsRequest {
	r.microsoftGraphExtension = &microsoftGraphExtension
	return r
}

func (r ApiGroupsConversationsThreadsPostsCreateExtensionsRequest) Execute() (MicrosoftGraphExtension, *_nethttp.Response, error) {
	return r.ApiService.GroupsConversationsThreadsPostsCreateExtensionsExecute(r)
}

/*
GroupsConversationsThreadsPostsCreateExtensions Create new navigation property to extensions for groups

The collection of open extensions defined for the post. Read-only. Nullable. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationId key: id of conversation
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @return ApiGroupsConversationsThreadsPostsCreateExtensionsRequest
*/
func (a *GroupsConversationApiService) GroupsConversationsThreadsPostsCreateExtensions(ctx _context.Context, groupId string, conversationId string, conversationThreadId string, postId string) ApiGroupsConversationsThreadsPostsCreateExtensionsRequest {
	return ApiGroupsConversationsThreadsPostsCreateExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationId: conversationId,
		conversationThreadId: conversationThreadId,
		postId: postId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphExtension
func (a *GroupsConversationApiService) GroupsConversationsThreadsPostsCreateExtensionsExecute(r ApiGroupsConversationsThreadsPostsCreateExtensionsRequest) (MicrosoftGraphExtension, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphExtension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationApiService.GroupsConversationsThreadsPostsCreateExtensions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}/extensions"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversation-id"+"}", _neturl.PathEscape(parameterToString(r.conversationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphExtension == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphExtension is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphExtension
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsConversationsThreadsPostsCreateMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationApiService
	groupId string
	conversationId string
	conversationThreadId string
	postId string
	microsoftGraphMultiValueLegacyExtendedProperty *MicrosoftGraphMultiValueLegacyExtendedProperty
}

// New navigation property
func (r ApiGroupsConversationsThreadsPostsCreateMultiValueExtendedPropertiesRequest) MicrosoftGraphMultiValueLegacyExtendedProperty(microsoftGraphMultiValueLegacyExtendedProperty MicrosoftGraphMultiValueLegacyExtendedProperty) ApiGroupsConversationsThreadsPostsCreateMultiValueExtendedPropertiesRequest {
	r.microsoftGraphMultiValueLegacyExtendedProperty = &microsoftGraphMultiValueLegacyExtendedProperty
	return r
}

func (r ApiGroupsConversationsThreadsPostsCreateMultiValueExtendedPropertiesRequest) Execute() (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.GroupsConversationsThreadsPostsCreateMultiValueExtendedPropertiesExecute(r)
}

/*
GroupsConversationsThreadsPostsCreateMultiValueExtendedProperties Create new navigation property to multiValueExtendedProperties for groups

The collection of multi-value extended properties defined for the post. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationId key: id of conversation
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @return ApiGroupsConversationsThreadsPostsCreateMultiValueExtendedPropertiesRequest
*/
func (a *GroupsConversationApiService) GroupsConversationsThreadsPostsCreateMultiValueExtendedProperties(ctx _context.Context, groupId string, conversationId string, conversationThreadId string, postId string) ApiGroupsConversationsThreadsPostsCreateMultiValueExtendedPropertiesRequest {
	return ApiGroupsConversationsThreadsPostsCreateMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationId: conversationId,
		conversationThreadId: conversationThreadId,
		postId: postId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphMultiValueLegacyExtendedProperty
func (a *GroupsConversationApiService) GroupsConversationsThreadsPostsCreateMultiValueExtendedPropertiesExecute(r ApiGroupsConversationsThreadsPostsCreateMultiValueExtendedPropertiesRequest) (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphMultiValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationApiService.GroupsConversationsThreadsPostsCreateMultiValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}/multiValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversation-id"+"}", _neturl.PathEscape(parameterToString(r.conversationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphMultiValueLegacyExtendedProperty == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphMultiValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphMultiValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsConversationsThreadsPostsCreateSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationApiService
	groupId string
	conversationId string
	conversationThreadId string
	postId string
	microsoftGraphSingleValueLegacyExtendedProperty *MicrosoftGraphSingleValueLegacyExtendedProperty
}

// New navigation property
func (r ApiGroupsConversationsThreadsPostsCreateSingleValueExtendedPropertiesRequest) MicrosoftGraphSingleValueLegacyExtendedProperty(microsoftGraphSingleValueLegacyExtendedProperty MicrosoftGraphSingleValueLegacyExtendedProperty) ApiGroupsConversationsThreadsPostsCreateSingleValueExtendedPropertiesRequest {
	r.microsoftGraphSingleValueLegacyExtendedProperty = &microsoftGraphSingleValueLegacyExtendedProperty
	return r
}

func (r ApiGroupsConversationsThreadsPostsCreateSingleValueExtendedPropertiesRequest) Execute() (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.GroupsConversationsThreadsPostsCreateSingleValueExtendedPropertiesExecute(r)
}

/*
GroupsConversationsThreadsPostsCreateSingleValueExtendedProperties Create new navigation property to singleValueExtendedProperties for groups

The collection of single-value extended properties defined for the post. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationId key: id of conversation
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @return ApiGroupsConversationsThreadsPostsCreateSingleValueExtendedPropertiesRequest
*/
func (a *GroupsConversationApiService) GroupsConversationsThreadsPostsCreateSingleValueExtendedProperties(ctx _context.Context, groupId string, conversationId string, conversationThreadId string, postId string) ApiGroupsConversationsThreadsPostsCreateSingleValueExtendedPropertiesRequest {
	return ApiGroupsConversationsThreadsPostsCreateSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationId: conversationId,
		conversationThreadId: conversationThreadId,
		postId: postId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphSingleValueLegacyExtendedProperty
func (a *GroupsConversationApiService) GroupsConversationsThreadsPostsCreateSingleValueExtendedPropertiesExecute(r ApiGroupsConversationsThreadsPostsCreateSingleValueExtendedPropertiesRequest) (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphSingleValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationApiService.GroupsConversationsThreadsPostsCreateSingleValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}/singleValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversation-id"+"}", _neturl.PathEscape(parameterToString(r.conversationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphSingleValueLegacyExtendedProperty == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphSingleValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphSingleValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsConversationsThreadsPostsDeleteAttachmentsRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationApiService
	groupId string
	conversationId string
	conversationThreadId string
	postId string
	attachmentId string
	ifMatch *string
}

// ETag
func (r ApiGroupsConversationsThreadsPostsDeleteAttachmentsRequest) IfMatch(ifMatch string) ApiGroupsConversationsThreadsPostsDeleteAttachmentsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsConversationsThreadsPostsDeleteAttachmentsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsConversationsThreadsPostsDeleteAttachmentsExecute(r)
}

/*
GroupsConversationsThreadsPostsDeleteAttachments Delete navigation property attachments for groups

Read-only. Nullable. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationId key: id of conversation
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @param attachmentId key: id of attachment
 @return ApiGroupsConversationsThreadsPostsDeleteAttachmentsRequest
*/
func (a *GroupsConversationApiService) GroupsConversationsThreadsPostsDeleteAttachments(ctx _context.Context, groupId string, conversationId string, conversationThreadId string, postId string, attachmentId string) ApiGroupsConversationsThreadsPostsDeleteAttachmentsRequest {
	return ApiGroupsConversationsThreadsPostsDeleteAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationId: conversationId,
		conversationThreadId: conversationThreadId,
		postId: postId,
		attachmentId: attachmentId,
	}
}

// Execute executes the request
func (a *GroupsConversationApiService) GroupsConversationsThreadsPostsDeleteAttachmentsExecute(r ApiGroupsConversationsThreadsPostsDeleteAttachmentsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationApiService.GroupsConversationsThreadsPostsDeleteAttachments")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}/attachments/{attachment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversation-id"+"}", _neturl.PathEscape(parameterToString(r.conversationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment-id"+"}", _neturl.PathEscape(parameterToString(r.attachmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsConversationsThreadsPostsDeleteExtensionsRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationApiService
	groupId string
	conversationId string
	conversationThreadId string
	postId string
	extensionId string
	ifMatch *string
}

// ETag
func (r ApiGroupsConversationsThreadsPostsDeleteExtensionsRequest) IfMatch(ifMatch string) ApiGroupsConversationsThreadsPostsDeleteExtensionsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsConversationsThreadsPostsDeleteExtensionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsConversationsThreadsPostsDeleteExtensionsExecute(r)
}

/*
GroupsConversationsThreadsPostsDeleteExtensions Delete navigation property extensions for groups

The collection of open extensions defined for the post. Read-only. Nullable. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationId key: id of conversation
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @param extensionId key: id of extension
 @return ApiGroupsConversationsThreadsPostsDeleteExtensionsRequest
*/
func (a *GroupsConversationApiService) GroupsConversationsThreadsPostsDeleteExtensions(ctx _context.Context, groupId string, conversationId string, conversationThreadId string, postId string, extensionId string) ApiGroupsConversationsThreadsPostsDeleteExtensionsRequest {
	return ApiGroupsConversationsThreadsPostsDeleteExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationId: conversationId,
		conversationThreadId: conversationThreadId,
		postId: postId,
		extensionId: extensionId,
	}
}

// Execute executes the request
func (a *GroupsConversationApiService) GroupsConversationsThreadsPostsDeleteExtensionsExecute(r ApiGroupsConversationsThreadsPostsDeleteExtensionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationApiService.GroupsConversationsThreadsPostsDeleteExtensions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}/extensions/{extension-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversation-id"+"}", _neturl.PathEscape(parameterToString(r.conversationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension-id"+"}", _neturl.PathEscape(parameterToString(r.extensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsConversationsThreadsPostsDeleteInReplyToRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationApiService
	groupId string
	conversationId string
	conversationThreadId string
	postId string
	ifMatch *string
}

// ETag
func (r ApiGroupsConversationsThreadsPostsDeleteInReplyToRequest) IfMatch(ifMatch string) ApiGroupsConversationsThreadsPostsDeleteInReplyToRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsConversationsThreadsPostsDeleteInReplyToRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsConversationsThreadsPostsDeleteInReplyToExecute(r)
}

/*
GroupsConversationsThreadsPostsDeleteInReplyTo Delete navigation property inReplyTo for groups

Read-only. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationId key: id of conversation
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @return ApiGroupsConversationsThreadsPostsDeleteInReplyToRequest
*/
func (a *GroupsConversationApiService) GroupsConversationsThreadsPostsDeleteInReplyTo(ctx _context.Context, groupId string, conversationId string, conversationThreadId string, postId string) ApiGroupsConversationsThreadsPostsDeleteInReplyToRequest {
	return ApiGroupsConversationsThreadsPostsDeleteInReplyToRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationId: conversationId,
		conversationThreadId: conversationThreadId,
		postId: postId,
	}
}

// Execute executes the request
func (a *GroupsConversationApiService) GroupsConversationsThreadsPostsDeleteInReplyToExecute(r ApiGroupsConversationsThreadsPostsDeleteInReplyToRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationApiService.GroupsConversationsThreadsPostsDeleteInReplyTo")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}/inReplyTo"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversation-id"+"}", _neturl.PathEscape(parameterToString(r.conversationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsConversationsThreadsPostsDeleteMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationApiService
	groupId string
	conversationId string
	conversationThreadId string
	postId string
	multiValueLegacyExtendedPropertyId string
	ifMatch *string
}

// ETag
func (r ApiGroupsConversationsThreadsPostsDeleteMultiValueExtendedPropertiesRequest) IfMatch(ifMatch string) ApiGroupsConversationsThreadsPostsDeleteMultiValueExtendedPropertiesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsConversationsThreadsPostsDeleteMultiValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsConversationsThreadsPostsDeleteMultiValueExtendedPropertiesExecute(r)
}

/*
GroupsConversationsThreadsPostsDeleteMultiValueExtendedProperties Delete navigation property multiValueExtendedProperties for groups

The collection of multi-value extended properties defined for the post. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationId key: id of conversation
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @param multiValueLegacyExtendedPropertyId key: id of multiValueLegacyExtendedProperty
 @return ApiGroupsConversationsThreadsPostsDeleteMultiValueExtendedPropertiesRequest
*/
func (a *GroupsConversationApiService) GroupsConversationsThreadsPostsDeleteMultiValueExtendedProperties(ctx _context.Context, groupId string, conversationId string, conversationThreadId string, postId string, multiValueLegacyExtendedPropertyId string) ApiGroupsConversationsThreadsPostsDeleteMultiValueExtendedPropertiesRequest {
	return ApiGroupsConversationsThreadsPostsDeleteMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationId: conversationId,
		conversationThreadId: conversationThreadId,
		postId: postId,
		multiValueLegacyExtendedPropertyId: multiValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *GroupsConversationApiService) GroupsConversationsThreadsPostsDeleteMultiValueExtendedPropertiesExecute(r ApiGroupsConversationsThreadsPostsDeleteMultiValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationApiService.GroupsConversationsThreadsPostsDeleteMultiValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}/multiValueExtendedProperties/{multiValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversation-id"+"}", _neturl.PathEscape(parameterToString(r.conversationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"multiValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.multiValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsConversationsThreadsPostsDeleteSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationApiService
	groupId string
	conversationId string
	conversationThreadId string
	postId string
	singleValueLegacyExtendedPropertyId string
	ifMatch *string
}

// ETag
func (r ApiGroupsConversationsThreadsPostsDeleteSingleValueExtendedPropertiesRequest) IfMatch(ifMatch string) ApiGroupsConversationsThreadsPostsDeleteSingleValueExtendedPropertiesRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsConversationsThreadsPostsDeleteSingleValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsConversationsThreadsPostsDeleteSingleValueExtendedPropertiesExecute(r)
}

/*
GroupsConversationsThreadsPostsDeleteSingleValueExtendedProperties Delete navigation property singleValueExtendedProperties for groups

The collection of single-value extended properties defined for the post. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationId key: id of conversation
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @param singleValueLegacyExtendedPropertyId key: id of singleValueLegacyExtendedProperty
 @return ApiGroupsConversationsThreadsPostsDeleteSingleValueExtendedPropertiesRequest
*/
func (a *GroupsConversationApiService) GroupsConversationsThreadsPostsDeleteSingleValueExtendedProperties(ctx _context.Context, groupId string, conversationId string, conversationThreadId string, postId string, singleValueLegacyExtendedPropertyId string) ApiGroupsConversationsThreadsPostsDeleteSingleValueExtendedPropertiesRequest {
	return ApiGroupsConversationsThreadsPostsDeleteSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationId: conversationId,
		conversationThreadId: conversationThreadId,
		postId: postId,
		singleValueLegacyExtendedPropertyId: singleValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *GroupsConversationApiService) GroupsConversationsThreadsPostsDeleteSingleValueExtendedPropertiesExecute(r ApiGroupsConversationsThreadsPostsDeleteSingleValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationApiService.GroupsConversationsThreadsPostsDeleteSingleValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}/singleValueExtendedProperties/{singleValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversation-id"+"}", _neturl.PathEscape(parameterToString(r.conversationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"singleValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.singleValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsConversationsThreadsPostsGetAttachmentsRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationApiService
	groupId string
	conversationId string
	conversationThreadId string
	postId string
	attachmentId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiGroupsConversationsThreadsPostsGetAttachmentsRequest) Select_(select_ []string) ApiGroupsConversationsThreadsPostsGetAttachmentsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsConversationsThreadsPostsGetAttachmentsRequest) Expand(expand []string) ApiGroupsConversationsThreadsPostsGetAttachmentsRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsConversationsThreadsPostsGetAttachmentsRequest) Execute() (MicrosoftGraphAttachment, *_nethttp.Response, error) {
	return r.ApiService.GroupsConversationsThreadsPostsGetAttachmentsExecute(r)
}

/*
GroupsConversationsThreadsPostsGetAttachments Get attachments from groups

Read-only. Nullable. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationId key: id of conversation
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @param attachmentId key: id of attachment
 @return ApiGroupsConversationsThreadsPostsGetAttachmentsRequest
*/
func (a *GroupsConversationApiService) GroupsConversationsThreadsPostsGetAttachments(ctx _context.Context, groupId string, conversationId string, conversationThreadId string, postId string, attachmentId string) ApiGroupsConversationsThreadsPostsGetAttachmentsRequest {
	return ApiGroupsConversationsThreadsPostsGetAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationId: conversationId,
		conversationThreadId: conversationThreadId,
		postId: postId,
		attachmentId: attachmentId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphAttachment
func (a *GroupsConversationApiService) GroupsConversationsThreadsPostsGetAttachmentsExecute(r ApiGroupsConversationsThreadsPostsGetAttachmentsRequest) (MicrosoftGraphAttachment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphAttachment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationApiService.GroupsConversationsThreadsPostsGetAttachments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}/attachments/{attachment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversation-id"+"}", _neturl.PathEscape(parameterToString(r.conversationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment-id"+"}", _neturl.PathEscape(parameterToString(r.attachmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsConversationsThreadsPostsGetExtensionsRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationApiService
	groupId string
	conversationId string
	conversationThreadId string
	postId string
	extensionId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiGroupsConversationsThreadsPostsGetExtensionsRequest) Select_(select_ []string) ApiGroupsConversationsThreadsPostsGetExtensionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsConversationsThreadsPostsGetExtensionsRequest) Expand(expand []string) ApiGroupsConversationsThreadsPostsGetExtensionsRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsConversationsThreadsPostsGetExtensionsRequest) Execute() (MicrosoftGraphExtension, *_nethttp.Response, error) {
	return r.ApiService.GroupsConversationsThreadsPostsGetExtensionsExecute(r)
}

/*
GroupsConversationsThreadsPostsGetExtensions Get extensions from groups

The collection of open extensions defined for the post. Read-only. Nullable. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationId key: id of conversation
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @param extensionId key: id of extension
 @return ApiGroupsConversationsThreadsPostsGetExtensionsRequest
*/
func (a *GroupsConversationApiService) GroupsConversationsThreadsPostsGetExtensions(ctx _context.Context, groupId string, conversationId string, conversationThreadId string, postId string, extensionId string) ApiGroupsConversationsThreadsPostsGetExtensionsRequest {
	return ApiGroupsConversationsThreadsPostsGetExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationId: conversationId,
		conversationThreadId: conversationThreadId,
		postId: postId,
		extensionId: extensionId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphExtension
func (a *GroupsConversationApiService) GroupsConversationsThreadsPostsGetExtensionsExecute(r ApiGroupsConversationsThreadsPostsGetExtensionsRequest) (MicrosoftGraphExtension, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphExtension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationApiService.GroupsConversationsThreadsPostsGetExtensions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}/extensions/{extension-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversation-id"+"}", _neturl.PathEscape(parameterToString(r.conversationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension-id"+"}", _neturl.PathEscape(parameterToString(r.extensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsConversationsThreadsPostsGetInReplyToRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationApiService
	groupId string
	conversationId string
	conversationThreadId string
	postId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiGroupsConversationsThreadsPostsGetInReplyToRequest) Select_(select_ []string) ApiGroupsConversationsThreadsPostsGetInReplyToRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsConversationsThreadsPostsGetInReplyToRequest) Expand(expand []string) ApiGroupsConversationsThreadsPostsGetInReplyToRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsConversationsThreadsPostsGetInReplyToRequest) Execute() (MicrosoftGraphPost, *_nethttp.Response, error) {
	return r.ApiService.GroupsConversationsThreadsPostsGetInReplyToExecute(r)
}

/*
GroupsConversationsThreadsPostsGetInReplyTo Get inReplyTo from groups

Read-only. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationId key: id of conversation
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @return ApiGroupsConversationsThreadsPostsGetInReplyToRequest
*/
func (a *GroupsConversationApiService) GroupsConversationsThreadsPostsGetInReplyTo(ctx _context.Context, groupId string, conversationId string, conversationThreadId string, postId string) ApiGroupsConversationsThreadsPostsGetInReplyToRequest {
	return ApiGroupsConversationsThreadsPostsGetInReplyToRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationId: conversationId,
		conversationThreadId: conversationThreadId,
		postId: postId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphPost
func (a *GroupsConversationApiService) GroupsConversationsThreadsPostsGetInReplyToExecute(r ApiGroupsConversationsThreadsPostsGetInReplyToRequest) (MicrosoftGraphPost, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphPost
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationApiService.GroupsConversationsThreadsPostsGetInReplyTo")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}/inReplyTo"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversation-id"+"}", _neturl.PathEscape(parameterToString(r.conversationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsConversationsThreadsPostsGetMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationApiService
	groupId string
	conversationId string
	conversationThreadId string
	postId string
	multiValueLegacyExtendedPropertyId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiGroupsConversationsThreadsPostsGetMultiValueExtendedPropertiesRequest) Select_(select_ []string) ApiGroupsConversationsThreadsPostsGetMultiValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsConversationsThreadsPostsGetMultiValueExtendedPropertiesRequest) Expand(expand []string) ApiGroupsConversationsThreadsPostsGetMultiValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsConversationsThreadsPostsGetMultiValueExtendedPropertiesRequest) Execute() (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.GroupsConversationsThreadsPostsGetMultiValueExtendedPropertiesExecute(r)
}

/*
GroupsConversationsThreadsPostsGetMultiValueExtendedProperties Get multiValueExtendedProperties from groups

The collection of multi-value extended properties defined for the post. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationId key: id of conversation
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @param multiValueLegacyExtendedPropertyId key: id of multiValueLegacyExtendedProperty
 @return ApiGroupsConversationsThreadsPostsGetMultiValueExtendedPropertiesRequest
*/
func (a *GroupsConversationApiService) GroupsConversationsThreadsPostsGetMultiValueExtendedProperties(ctx _context.Context, groupId string, conversationId string, conversationThreadId string, postId string, multiValueLegacyExtendedPropertyId string) ApiGroupsConversationsThreadsPostsGetMultiValueExtendedPropertiesRequest {
	return ApiGroupsConversationsThreadsPostsGetMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationId: conversationId,
		conversationThreadId: conversationThreadId,
		postId: postId,
		multiValueLegacyExtendedPropertyId: multiValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphMultiValueLegacyExtendedProperty
func (a *GroupsConversationApiService) GroupsConversationsThreadsPostsGetMultiValueExtendedPropertiesExecute(r ApiGroupsConversationsThreadsPostsGetMultiValueExtendedPropertiesRequest) (MicrosoftGraphMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphMultiValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationApiService.GroupsConversationsThreadsPostsGetMultiValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}/multiValueExtendedProperties/{multiValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversation-id"+"}", _neturl.PathEscape(parameterToString(r.conversationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"multiValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.multiValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsConversationsThreadsPostsGetSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationApiService
	groupId string
	conversationId string
	conversationThreadId string
	postId string
	singleValueLegacyExtendedPropertyId string
	select_ *[]string
	expand *[]string
}

// Select properties to be returned
func (r ApiGroupsConversationsThreadsPostsGetSingleValueExtendedPropertiesRequest) Select_(select_ []string) ApiGroupsConversationsThreadsPostsGetSingleValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsConversationsThreadsPostsGetSingleValueExtendedPropertiesRequest) Expand(expand []string) ApiGroupsConversationsThreadsPostsGetSingleValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsConversationsThreadsPostsGetSingleValueExtendedPropertiesRequest) Execute() (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.GroupsConversationsThreadsPostsGetSingleValueExtendedPropertiesExecute(r)
}

/*
GroupsConversationsThreadsPostsGetSingleValueExtendedProperties Get singleValueExtendedProperties from groups

The collection of single-value extended properties defined for the post. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationId key: id of conversation
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @param singleValueLegacyExtendedPropertyId key: id of singleValueLegacyExtendedProperty
 @return ApiGroupsConversationsThreadsPostsGetSingleValueExtendedPropertiesRequest
*/
func (a *GroupsConversationApiService) GroupsConversationsThreadsPostsGetSingleValueExtendedProperties(ctx _context.Context, groupId string, conversationId string, conversationThreadId string, postId string, singleValueLegacyExtendedPropertyId string) ApiGroupsConversationsThreadsPostsGetSingleValueExtendedPropertiesRequest {
	return ApiGroupsConversationsThreadsPostsGetSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationId: conversationId,
		conversationThreadId: conversationThreadId,
		postId: postId,
		singleValueLegacyExtendedPropertyId: singleValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphSingleValueLegacyExtendedProperty
func (a *GroupsConversationApiService) GroupsConversationsThreadsPostsGetSingleValueExtendedPropertiesExecute(r ApiGroupsConversationsThreadsPostsGetSingleValueExtendedPropertiesRequest) (MicrosoftGraphSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphSingleValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationApiService.GroupsConversationsThreadsPostsGetSingleValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}/singleValueExtendedProperties/{singleValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversation-id"+"}", _neturl.PathEscape(parameterToString(r.conversationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"singleValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.singleValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsConversationsThreadsPostsListAttachmentsRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationApiService
	groupId string
	conversationId string
	conversationThreadId string
	postId string
	top *int32
	skip *int32
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiGroupsConversationsThreadsPostsListAttachmentsRequest) Top(top int32) ApiGroupsConversationsThreadsPostsListAttachmentsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsConversationsThreadsPostsListAttachmentsRequest) Skip(skip int32) ApiGroupsConversationsThreadsPostsListAttachmentsRequest {
	r.skip = &skip
	return r
}
// Filter items by property values
func (r ApiGroupsConversationsThreadsPostsListAttachmentsRequest) Filter(filter string) ApiGroupsConversationsThreadsPostsListAttachmentsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsConversationsThreadsPostsListAttachmentsRequest) Count(count bool) ApiGroupsConversationsThreadsPostsListAttachmentsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsConversationsThreadsPostsListAttachmentsRequest) Orderby(orderby []string) ApiGroupsConversationsThreadsPostsListAttachmentsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiGroupsConversationsThreadsPostsListAttachmentsRequest) Select_(select_ []string) ApiGroupsConversationsThreadsPostsListAttachmentsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsConversationsThreadsPostsListAttachmentsRequest) Expand(expand []string) ApiGroupsConversationsThreadsPostsListAttachmentsRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsConversationsThreadsPostsListAttachmentsRequest) Execute() (CollectionOfAttachment, *_nethttp.Response, error) {
	return r.ApiService.GroupsConversationsThreadsPostsListAttachmentsExecute(r)
}

/*
GroupsConversationsThreadsPostsListAttachments Get attachments from groups

Read-only. Nullable. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationId key: id of conversation
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @return ApiGroupsConversationsThreadsPostsListAttachmentsRequest
*/
func (a *GroupsConversationApiService) GroupsConversationsThreadsPostsListAttachments(ctx _context.Context, groupId string, conversationId string, conversationThreadId string, postId string) ApiGroupsConversationsThreadsPostsListAttachmentsRequest {
	return ApiGroupsConversationsThreadsPostsListAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationId: conversationId,
		conversationThreadId: conversationThreadId,
		postId: postId,
	}
}

// Execute executes the request
//  @return CollectionOfAttachment
func (a *GroupsConversationApiService) GroupsConversationsThreadsPostsListAttachmentsExecute(r ApiGroupsConversationsThreadsPostsListAttachmentsRequest) (CollectionOfAttachment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfAttachment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationApiService.GroupsConversationsThreadsPostsListAttachments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}/attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversation-id"+"}", _neturl.PathEscape(parameterToString(r.conversationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsConversationsThreadsPostsListExtensionsRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationApiService
	groupId string
	conversationId string
	conversationThreadId string
	postId string
	top *int32
	skip *int32
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiGroupsConversationsThreadsPostsListExtensionsRequest) Top(top int32) ApiGroupsConversationsThreadsPostsListExtensionsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsConversationsThreadsPostsListExtensionsRequest) Skip(skip int32) ApiGroupsConversationsThreadsPostsListExtensionsRequest {
	r.skip = &skip
	return r
}
// Filter items by property values
func (r ApiGroupsConversationsThreadsPostsListExtensionsRequest) Filter(filter string) ApiGroupsConversationsThreadsPostsListExtensionsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsConversationsThreadsPostsListExtensionsRequest) Count(count bool) ApiGroupsConversationsThreadsPostsListExtensionsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsConversationsThreadsPostsListExtensionsRequest) Orderby(orderby []string) ApiGroupsConversationsThreadsPostsListExtensionsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiGroupsConversationsThreadsPostsListExtensionsRequest) Select_(select_ []string) ApiGroupsConversationsThreadsPostsListExtensionsRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsConversationsThreadsPostsListExtensionsRequest) Expand(expand []string) ApiGroupsConversationsThreadsPostsListExtensionsRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsConversationsThreadsPostsListExtensionsRequest) Execute() (CollectionOfExtension, *_nethttp.Response, error) {
	return r.ApiService.GroupsConversationsThreadsPostsListExtensionsExecute(r)
}

/*
GroupsConversationsThreadsPostsListExtensions Get extensions from groups

The collection of open extensions defined for the post. Read-only. Nullable. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationId key: id of conversation
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @return ApiGroupsConversationsThreadsPostsListExtensionsRequest
*/
func (a *GroupsConversationApiService) GroupsConversationsThreadsPostsListExtensions(ctx _context.Context, groupId string, conversationId string, conversationThreadId string, postId string) ApiGroupsConversationsThreadsPostsListExtensionsRequest {
	return ApiGroupsConversationsThreadsPostsListExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationId: conversationId,
		conversationThreadId: conversationThreadId,
		postId: postId,
	}
}

// Execute executes the request
//  @return CollectionOfExtension
func (a *GroupsConversationApiService) GroupsConversationsThreadsPostsListExtensionsExecute(r ApiGroupsConversationsThreadsPostsListExtensionsRequest) (CollectionOfExtension, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfExtension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationApiService.GroupsConversationsThreadsPostsListExtensions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}/extensions"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversation-id"+"}", _neturl.PathEscape(parameterToString(r.conversationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsConversationsThreadsPostsListMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationApiService
	groupId string
	conversationId string
	conversationThreadId string
	postId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiGroupsConversationsThreadsPostsListMultiValueExtendedPropertiesRequest) Top(top int32) ApiGroupsConversationsThreadsPostsListMultiValueExtendedPropertiesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsConversationsThreadsPostsListMultiValueExtendedPropertiesRequest) Skip(skip int32) ApiGroupsConversationsThreadsPostsListMultiValueExtendedPropertiesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiGroupsConversationsThreadsPostsListMultiValueExtendedPropertiesRequest) Search(search string) ApiGroupsConversationsThreadsPostsListMultiValueExtendedPropertiesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiGroupsConversationsThreadsPostsListMultiValueExtendedPropertiesRequest) Filter(filter string) ApiGroupsConversationsThreadsPostsListMultiValueExtendedPropertiesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsConversationsThreadsPostsListMultiValueExtendedPropertiesRequest) Count(count bool) ApiGroupsConversationsThreadsPostsListMultiValueExtendedPropertiesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsConversationsThreadsPostsListMultiValueExtendedPropertiesRequest) Orderby(orderby []string) ApiGroupsConversationsThreadsPostsListMultiValueExtendedPropertiesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiGroupsConversationsThreadsPostsListMultiValueExtendedPropertiesRequest) Select_(select_ []string) ApiGroupsConversationsThreadsPostsListMultiValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsConversationsThreadsPostsListMultiValueExtendedPropertiesRequest) Expand(expand []string) ApiGroupsConversationsThreadsPostsListMultiValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsConversationsThreadsPostsListMultiValueExtendedPropertiesRequest) Execute() (CollectionOfMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.GroupsConversationsThreadsPostsListMultiValueExtendedPropertiesExecute(r)
}

/*
GroupsConversationsThreadsPostsListMultiValueExtendedProperties Get multiValueExtendedProperties from groups

The collection of multi-value extended properties defined for the post. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationId key: id of conversation
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @return ApiGroupsConversationsThreadsPostsListMultiValueExtendedPropertiesRequest
*/
func (a *GroupsConversationApiService) GroupsConversationsThreadsPostsListMultiValueExtendedProperties(ctx _context.Context, groupId string, conversationId string, conversationThreadId string, postId string) ApiGroupsConversationsThreadsPostsListMultiValueExtendedPropertiesRequest {
	return ApiGroupsConversationsThreadsPostsListMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationId: conversationId,
		conversationThreadId: conversationThreadId,
		postId: postId,
	}
}

// Execute executes the request
//  @return CollectionOfMultiValueLegacyExtendedProperty
func (a *GroupsConversationApiService) GroupsConversationsThreadsPostsListMultiValueExtendedPropertiesExecute(r ApiGroupsConversationsThreadsPostsListMultiValueExtendedPropertiesRequest) (CollectionOfMultiValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfMultiValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationApiService.GroupsConversationsThreadsPostsListMultiValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}/multiValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversation-id"+"}", _neturl.PathEscape(parameterToString(r.conversationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsConversationsThreadsPostsListSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationApiService
	groupId string
	conversationId string
	conversationThreadId string
	postId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
	expand *[]string
}

// Show only the first n items
func (r ApiGroupsConversationsThreadsPostsListSingleValueExtendedPropertiesRequest) Top(top int32) ApiGroupsConversationsThreadsPostsListSingleValueExtendedPropertiesRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsConversationsThreadsPostsListSingleValueExtendedPropertiesRequest) Skip(skip int32) ApiGroupsConversationsThreadsPostsListSingleValueExtendedPropertiesRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiGroupsConversationsThreadsPostsListSingleValueExtendedPropertiesRequest) Search(search string) ApiGroupsConversationsThreadsPostsListSingleValueExtendedPropertiesRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiGroupsConversationsThreadsPostsListSingleValueExtendedPropertiesRequest) Filter(filter string) ApiGroupsConversationsThreadsPostsListSingleValueExtendedPropertiesRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsConversationsThreadsPostsListSingleValueExtendedPropertiesRequest) Count(count bool) ApiGroupsConversationsThreadsPostsListSingleValueExtendedPropertiesRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsConversationsThreadsPostsListSingleValueExtendedPropertiesRequest) Orderby(orderby []string) ApiGroupsConversationsThreadsPostsListSingleValueExtendedPropertiesRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiGroupsConversationsThreadsPostsListSingleValueExtendedPropertiesRequest) Select_(select_ []string) ApiGroupsConversationsThreadsPostsListSingleValueExtendedPropertiesRequest {
	r.select_ = &select_
	return r
}
// Expand related entities
func (r ApiGroupsConversationsThreadsPostsListSingleValueExtendedPropertiesRequest) Expand(expand []string) ApiGroupsConversationsThreadsPostsListSingleValueExtendedPropertiesRequest {
	r.expand = &expand
	return r
}

func (r ApiGroupsConversationsThreadsPostsListSingleValueExtendedPropertiesRequest) Execute() (CollectionOfSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	return r.ApiService.GroupsConversationsThreadsPostsListSingleValueExtendedPropertiesExecute(r)
}

/*
GroupsConversationsThreadsPostsListSingleValueExtendedProperties Get singleValueExtendedProperties from groups

The collection of single-value extended properties defined for the post. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationId key: id of conversation
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @return ApiGroupsConversationsThreadsPostsListSingleValueExtendedPropertiesRequest
*/
func (a *GroupsConversationApiService) GroupsConversationsThreadsPostsListSingleValueExtendedProperties(ctx _context.Context, groupId string, conversationId string, conversationThreadId string, postId string) ApiGroupsConversationsThreadsPostsListSingleValueExtendedPropertiesRequest {
	return ApiGroupsConversationsThreadsPostsListSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationId: conversationId,
		conversationThreadId: conversationThreadId,
		postId: postId,
	}
}

// Execute executes the request
//  @return CollectionOfSingleValueLegacyExtendedProperty
func (a *GroupsConversationApiService) GroupsConversationsThreadsPostsListSingleValueExtendedPropertiesExecute(r ApiGroupsConversationsThreadsPostsListSingleValueExtendedPropertiesRequest) (CollectionOfSingleValueLegacyExtendedProperty, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfSingleValueLegacyExtendedProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationApiService.GroupsConversationsThreadsPostsListSingleValueExtendedProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}/singleValueExtendedProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversation-id"+"}", _neturl.PathEscape(parameterToString(r.conversationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsConversationsThreadsPostsUpdateAttachmentsRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationApiService
	groupId string
	conversationId string
	conversationThreadId string
	postId string
	attachmentId string
	microsoftGraphAttachment *MicrosoftGraphAttachment
}

// New navigation property values
func (r ApiGroupsConversationsThreadsPostsUpdateAttachmentsRequest) MicrosoftGraphAttachment(microsoftGraphAttachment MicrosoftGraphAttachment) ApiGroupsConversationsThreadsPostsUpdateAttachmentsRequest {
	r.microsoftGraphAttachment = &microsoftGraphAttachment
	return r
}

func (r ApiGroupsConversationsThreadsPostsUpdateAttachmentsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsConversationsThreadsPostsUpdateAttachmentsExecute(r)
}

/*
GroupsConversationsThreadsPostsUpdateAttachments Update the navigation property attachments in groups

Read-only. Nullable. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationId key: id of conversation
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @param attachmentId key: id of attachment
 @return ApiGroupsConversationsThreadsPostsUpdateAttachmentsRequest
*/
func (a *GroupsConversationApiService) GroupsConversationsThreadsPostsUpdateAttachments(ctx _context.Context, groupId string, conversationId string, conversationThreadId string, postId string, attachmentId string) ApiGroupsConversationsThreadsPostsUpdateAttachmentsRequest {
	return ApiGroupsConversationsThreadsPostsUpdateAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationId: conversationId,
		conversationThreadId: conversationThreadId,
		postId: postId,
		attachmentId: attachmentId,
	}
}

// Execute executes the request
func (a *GroupsConversationApiService) GroupsConversationsThreadsPostsUpdateAttachmentsExecute(r ApiGroupsConversationsThreadsPostsUpdateAttachmentsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationApiService.GroupsConversationsThreadsPostsUpdateAttachments")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}/attachments/{attachment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversation-id"+"}", _neturl.PathEscape(parameterToString(r.conversationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment-id"+"}", _neturl.PathEscape(parameterToString(r.attachmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphAttachment == nil {
		return nil, reportError("microsoftGraphAttachment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphAttachment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsConversationsThreadsPostsUpdateExtensionsRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationApiService
	groupId string
	conversationId string
	conversationThreadId string
	postId string
	extensionId string
	microsoftGraphExtension *MicrosoftGraphExtension
}

// New navigation property values
func (r ApiGroupsConversationsThreadsPostsUpdateExtensionsRequest) MicrosoftGraphExtension(microsoftGraphExtension MicrosoftGraphExtension) ApiGroupsConversationsThreadsPostsUpdateExtensionsRequest {
	r.microsoftGraphExtension = &microsoftGraphExtension
	return r
}

func (r ApiGroupsConversationsThreadsPostsUpdateExtensionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsConversationsThreadsPostsUpdateExtensionsExecute(r)
}

/*
GroupsConversationsThreadsPostsUpdateExtensions Update the navigation property extensions in groups

The collection of open extensions defined for the post. Read-only. Nullable. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationId key: id of conversation
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @param extensionId key: id of extension
 @return ApiGroupsConversationsThreadsPostsUpdateExtensionsRequest
*/
func (a *GroupsConversationApiService) GroupsConversationsThreadsPostsUpdateExtensions(ctx _context.Context, groupId string, conversationId string, conversationThreadId string, postId string, extensionId string) ApiGroupsConversationsThreadsPostsUpdateExtensionsRequest {
	return ApiGroupsConversationsThreadsPostsUpdateExtensionsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationId: conversationId,
		conversationThreadId: conversationThreadId,
		postId: postId,
		extensionId: extensionId,
	}
}

// Execute executes the request
func (a *GroupsConversationApiService) GroupsConversationsThreadsPostsUpdateExtensionsExecute(r ApiGroupsConversationsThreadsPostsUpdateExtensionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationApiService.GroupsConversationsThreadsPostsUpdateExtensions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}/extensions/{extension-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversation-id"+"}", _neturl.PathEscape(parameterToString(r.conversationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension-id"+"}", _neturl.PathEscape(parameterToString(r.extensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphExtension == nil {
		return nil, reportError("microsoftGraphExtension is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphExtension
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsConversationsThreadsPostsUpdateInReplyToRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationApiService
	groupId string
	conversationId string
	conversationThreadId string
	postId string
	microsoftGraphPost *MicrosoftGraphPost
}

// New navigation property values
func (r ApiGroupsConversationsThreadsPostsUpdateInReplyToRequest) MicrosoftGraphPost(microsoftGraphPost MicrosoftGraphPost) ApiGroupsConversationsThreadsPostsUpdateInReplyToRequest {
	r.microsoftGraphPost = &microsoftGraphPost
	return r
}

func (r ApiGroupsConversationsThreadsPostsUpdateInReplyToRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsConversationsThreadsPostsUpdateInReplyToExecute(r)
}

/*
GroupsConversationsThreadsPostsUpdateInReplyTo Update the navigation property inReplyTo in groups

Read-only. Supports $expand.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationId key: id of conversation
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @return ApiGroupsConversationsThreadsPostsUpdateInReplyToRequest
*/
func (a *GroupsConversationApiService) GroupsConversationsThreadsPostsUpdateInReplyTo(ctx _context.Context, groupId string, conversationId string, conversationThreadId string, postId string) ApiGroupsConversationsThreadsPostsUpdateInReplyToRequest {
	return ApiGroupsConversationsThreadsPostsUpdateInReplyToRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationId: conversationId,
		conversationThreadId: conversationThreadId,
		postId: postId,
	}
}

// Execute executes the request
func (a *GroupsConversationApiService) GroupsConversationsThreadsPostsUpdateInReplyToExecute(r ApiGroupsConversationsThreadsPostsUpdateInReplyToRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationApiService.GroupsConversationsThreadsPostsUpdateInReplyTo")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}/inReplyTo"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversation-id"+"}", _neturl.PathEscape(parameterToString(r.conversationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPost == nil {
		return nil, reportError("microsoftGraphPost is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPost
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsConversationsThreadsPostsUpdateMultiValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationApiService
	groupId string
	conversationId string
	conversationThreadId string
	postId string
	multiValueLegacyExtendedPropertyId string
	microsoftGraphMultiValueLegacyExtendedProperty *MicrosoftGraphMultiValueLegacyExtendedProperty
}

// New navigation property values
func (r ApiGroupsConversationsThreadsPostsUpdateMultiValueExtendedPropertiesRequest) MicrosoftGraphMultiValueLegacyExtendedProperty(microsoftGraphMultiValueLegacyExtendedProperty MicrosoftGraphMultiValueLegacyExtendedProperty) ApiGroupsConversationsThreadsPostsUpdateMultiValueExtendedPropertiesRequest {
	r.microsoftGraphMultiValueLegacyExtendedProperty = &microsoftGraphMultiValueLegacyExtendedProperty
	return r
}

func (r ApiGroupsConversationsThreadsPostsUpdateMultiValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsConversationsThreadsPostsUpdateMultiValueExtendedPropertiesExecute(r)
}

/*
GroupsConversationsThreadsPostsUpdateMultiValueExtendedProperties Update the navigation property multiValueExtendedProperties in groups

The collection of multi-value extended properties defined for the post. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationId key: id of conversation
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @param multiValueLegacyExtendedPropertyId key: id of multiValueLegacyExtendedProperty
 @return ApiGroupsConversationsThreadsPostsUpdateMultiValueExtendedPropertiesRequest
*/
func (a *GroupsConversationApiService) GroupsConversationsThreadsPostsUpdateMultiValueExtendedProperties(ctx _context.Context, groupId string, conversationId string, conversationThreadId string, postId string, multiValueLegacyExtendedPropertyId string) ApiGroupsConversationsThreadsPostsUpdateMultiValueExtendedPropertiesRequest {
	return ApiGroupsConversationsThreadsPostsUpdateMultiValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationId: conversationId,
		conversationThreadId: conversationThreadId,
		postId: postId,
		multiValueLegacyExtendedPropertyId: multiValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *GroupsConversationApiService) GroupsConversationsThreadsPostsUpdateMultiValueExtendedPropertiesExecute(r ApiGroupsConversationsThreadsPostsUpdateMultiValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationApiService.GroupsConversationsThreadsPostsUpdateMultiValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}/multiValueExtendedProperties/{multiValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversation-id"+"}", _neturl.PathEscape(parameterToString(r.conversationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"multiValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.multiValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphMultiValueLegacyExtendedProperty == nil {
		return nil, reportError("microsoftGraphMultiValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphMultiValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsConversationsThreadsPostsUpdateSingleValueExtendedPropertiesRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationApiService
	groupId string
	conversationId string
	conversationThreadId string
	postId string
	singleValueLegacyExtendedPropertyId string
	microsoftGraphSingleValueLegacyExtendedProperty *MicrosoftGraphSingleValueLegacyExtendedProperty
}

// New navigation property values
func (r ApiGroupsConversationsThreadsPostsUpdateSingleValueExtendedPropertiesRequest) MicrosoftGraphSingleValueLegacyExtendedProperty(microsoftGraphSingleValueLegacyExtendedProperty MicrosoftGraphSingleValueLegacyExtendedProperty) ApiGroupsConversationsThreadsPostsUpdateSingleValueExtendedPropertiesRequest {
	r.microsoftGraphSingleValueLegacyExtendedProperty = &microsoftGraphSingleValueLegacyExtendedProperty
	return r
}

func (r ApiGroupsConversationsThreadsPostsUpdateSingleValueExtendedPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsConversationsThreadsPostsUpdateSingleValueExtendedPropertiesExecute(r)
}

/*
GroupsConversationsThreadsPostsUpdateSingleValueExtendedProperties Update the navigation property singleValueExtendedProperties in groups

The collection of single-value extended properties defined for the post. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationId key: id of conversation
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @param singleValueLegacyExtendedPropertyId key: id of singleValueLegacyExtendedProperty
 @return ApiGroupsConversationsThreadsPostsUpdateSingleValueExtendedPropertiesRequest
*/
func (a *GroupsConversationApiService) GroupsConversationsThreadsPostsUpdateSingleValueExtendedProperties(ctx _context.Context, groupId string, conversationId string, conversationThreadId string, postId string, singleValueLegacyExtendedPropertyId string) ApiGroupsConversationsThreadsPostsUpdateSingleValueExtendedPropertiesRequest {
	return ApiGroupsConversationsThreadsPostsUpdateSingleValueExtendedPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationId: conversationId,
		conversationThreadId: conversationThreadId,
		postId: postId,
		singleValueLegacyExtendedPropertyId: singleValueLegacyExtendedPropertyId,
	}
}

// Execute executes the request
func (a *GroupsConversationApiService) GroupsConversationsThreadsPostsUpdateSingleValueExtendedPropertiesExecute(r ApiGroupsConversationsThreadsPostsUpdateSingleValueExtendedPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationApiService.GroupsConversationsThreadsPostsUpdateSingleValueExtendedProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}/singleValueExtendedProperties/{singleValueLegacyExtendedProperty-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversation-id"+"}", _neturl.PathEscape(parameterToString(r.conversationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"singleValueLegacyExtendedProperty-id"+"}", _neturl.PathEscape(parameterToString(r.singleValueLegacyExtendedPropertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphSingleValueLegacyExtendedProperty == nil {
		return nil, reportError("microsoftGraphSingleValueLegacyExtendedProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphSingleValueLegacyExtendedProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsConversationsThreadsUpdatePostsRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationApiService
	groupId string
	conversationId string
	conversationThreadId string
	postId string
	microsoftGraphPost *MicrosoftGraphPost
}

// New navigation property values
func (r ApiGroupsConversationsThreadsUpdatePostsRequest) MicrosoftGraphPost(microsoftGraphPost MicrosoftGraphPost) ApiGroupsConversationsThreadsUpdatePostsRequest {
	r.microsoftGraphPost = &microsoftGraphPost
	return r
}

func (r ApiGroupsConversationsThreadsUpdatePostsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsConversationsThreadsUpdatePostsExecute(r)
}

/*
GroupsConversationsThreadsUpdatePosts Update the navigation property posts in groups

Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationId key: id of conversation
 @param conversationThreadId key: id of conversationThread
 @param postId key: id of post
 @return ApiGroupsConversationsThreadsUpdatePostsRequest
*/
func (a *GroupsConversationApiService) GroupsConversationsThreadsUpdatePosts(ctx _context.Context, groupId string, conversationId string, conversationThreadId string, postId string) ApiGroupsConversationsThreadsUpdatePostsRequest {
	return ApiGroupsConversationsThreadsUpdatePostsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationId: conversationId,
		conversationThreadId: conversationThreadId,
		postId: postId,
	}
}

// Execute executes the request
func (a *GroupsConversationApiService) GroupsConversationsThreadsUpdatePostsExecute(r ApiGroupsConversationsThreadsUpdatePostsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationApiService.GroupsConversationsThreadsUpdatePosts")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversation-id"+"}", _neturl.PathEscape(parameterToString(r.conversationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post-id"+"}", _neturl.PathEscape(parameterToString(r.postId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphPost == nil {
		return nil, reportError("microsoftGraphPost is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphPost
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsConversationsUpdateThreadsRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationApiService
	groupId string
	conversationId string
	conversationThreadId string
	microsoftGraphConversationThread *MicrosoftGraphConversationThread
}

// New navigation property values
func (r ApiGroupsConversationsUpdateThreadsRequest) MicrosoftGraphConversationThread(microsoftGraphConversationThread MicrosoftGraphConversationThread) ApiGroupsConversationsUpdateThreadsRequest {
	r.microsoftGraphConversationThread = &microsoftGraphConversationThread
	return r
}

func (r ApiGroupsConversationsUpdateThreadsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsConversationsUpdateThreadsExecute(r)
}

/*
GroupsConversationsUpdateThreads Update the navigation property threads in groups

A collection of all the conversation threads in the conversation. A navigation property. Read-only. Nullable.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationId key: id of conversation
 @param conversationThreadId key: id of conversationThread
 @return ApiGroupsConversationsUpdateThreadsRequest
*/
func (a *GroupsConversationApiService) GroupsConversationsUpdateThreads(ctx _context.Context, groupId string, conversationId string, conversationThreadId string) ApiGroupsConversationsUpdateThreadsRequest {
	return ApiGroupsConversationsUpdateThreadsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationId: conversationId,
		conversationThreadId: conversationThreadId,
	}
}

// Execute executes the request
func (a *GroupsConversationApiService) GroupsConversationsUpdateThreadsExecute(r ApiGroupsConversationsUpdateThreadsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationApiService.GroupsConversationsUpdateThreads")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversation-id"+"}", _neturl.PathEscape(parameterToString(r.conversationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversationThread-id"+"}", _neturl.PathEscape(parameterToString(r.conversationThreadId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphConversationThread == nil {
		return nil, reportError("microsoftGraphConversationThread is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphConversationThread
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsCreateConversationsRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationApiService
	groupId string
	microsoftGraphConversation *MicrosoftGraphConversation
}

// New navigation property
func (r ApiGroupsCreateConversationsRequest) MicrosoftGraphConversation(microsoftGraphConversation MicrosoftGraphConversation) ApiGroupsCreateConversationsRequest {
	r.microsoftGraphConversation = &microsoftGraphConversation
	return r
}

func (r ApiGroupsCreateConversationsRequest) Execute() (MicrosoftGraphConversation, *_nethttp.Response, error) {
	return r.ApiService.GroupsCreateConversationsExecute(r)
}

/*
GroupsCreateConversations Create new navigation property to conversations for groups

The group's conversations.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsCreateConversationsRequest
*/
func (a *GroupsConversationApiService) GroupsCreateConversations(ctx _context.Context, groupId string) ApiGroupsCreateConversationsRequest {
	return ApiGroupsCreateConversationsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphConversation
func (a *GroupsConversationApiService) GroupsCreateConversationsExecute(r ApiGroupsCreateConversationsRequest) (MicrosoftGraphConversation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphConversation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationApiService.GroupsCreateConversations")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/conversations"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphConversation == nil {
		return localVarReturnValue, nil, reportError("microsoftGraphConversation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphConversation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsDeleteConversationsRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationApiService
	groupId string
	conversationId string
	ifMatch *string
}

// ETag
func (r ApiGroupsDeleteConversationsRequest) IfMatch(ifMatch string) ApiGroupsDeleteConversationsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiGroupsDeleteConversationsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsDeleteConversationsExecute(r)
}

/*
GroupsDeleteConversations Delete navigation property conversations for groups

The group's conversations.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationId key: id of conversation
 @return ApiGroupsDeleteConversationsRequest
*/
func (a *GroupsConversationApiService) GroupsDeleteConversations(ctx _context.Context, groupId string, conversationId string) ApiGroupsDeleteConversationsRequest {
	return ApiGroupsDeleteConversationsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationId: conversationId,
	}
}

// Execute executes the request
func (a *GroupsConversationApiService) GroupsDeleteConversationsExecute(r ApiGroupsDeleteConversationsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationApiService.GroupsDeleteConversations")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/conversations/{conversation-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversation-id"+"}", _neturl.PathEscape(parameterToString(r.conversationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsGetConversationsRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationApiService
	groupId string
	conversationId string
	select_ *[]string
}

// Select properties to be returned
func (r ApiGroupsGetConversationsRequest) Select_(select_ []string) ApiGroupsGetConversationsRequest {
	r.select_ = &select_
	return r
}

func (r ApiGroupsGetConversationsRequest) Execute() (MicrosoftGraphConversation, *_nethttp.Response, error) {
	return r.ApiService.GroupsGetConversationsExecute(r)
}

/*
GroupsGetConversations Get conversations from groups

The group's conversations.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationId key: id of conversation
 @return ApiGroupsGetConversationsRequest
*/
func (a *GroupsConversationApiService) GroupsGetConversations(ctx _context.Context, groupId string, conversationId string) ApiGroupsGetConversationsRequest {
	return ApiGroupsGetConversationsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationId: conversationId,
	}
}

// Execute executes the request
//  @return MicrosoftGraphConversation
func (a *GroupsConversationApiService) GroupsGetConversationsExecute(r ApiGroupsGetConversationsRequest) (MicrosoftGraphConversation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MicrosoftGraphConversation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationApiService.GroupsGetConversations")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/conversations/{conversation-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversation-id"+"}", _neturl.PathEscape(parameterToString(r.conversationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsListConversationsRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationApiService
	groupId string
	top *int32
	skip *int32
	search *string
	filter *string
	count *bool
	orderby *[]string
	select_ *[]string
}

// Show only the first n items
func (r ApiGroupsListConversationsRequest) Top(top int32) ApiGroupsListConversationsRequest {
	r.top = &top
	return r
}
// Skip the first n items
func (r ApiGroupsListConversationsRequest) Skip(skip int32) ApiGroupsListConversationsRequest {
	r.skip = &skip
	return r
}
// Search items by search phrases
func (r ApiGroupsListConversationsRequest) Search(search string) ApiGroupsListConversationsRequest {
	r.search = &search
	return r
}
// Filter items by property values
func (r ApiGroupsListConversationsRequest) Filter(filter string) ApiGroupsListConversationsRequest {
	r.filter = &filter
	return r
}
// Include count of items
func (r ApiGroupsListConversationsRequest) Count(count bool) ApiGroupsListConversationsRequest {
	r.count = &count
	return r
}
// Order items by property values
func (r ApiGroupsListConversationsRequest) Orderby(orderby []string) ApiGroupsListConversationsRequest {
	r.orderby = &orderby
	return r
}
// Select properties to be returned
func (r ApiGroupsListConversationsRequest) Select_(select_ []string) ApiGroupsListConversationsRequest {
	r.select_ = &select_
	return r
}

func (r ApiGroupsListConversationsRequest) Execute() (CollectionOfConversation, *_nethttp.Response, error) {
	return r.ApiService.GroupsListConversationsExecute(r)
}

/*
GroupsListConversations Get conversations from groups

The group's conversations.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @return ApiGroupsListConversationsRequest
*/
func (a *GroupsConversationApiService) GroupsListConversations(ctx _context.Context, groupId string) ApiGroupsListConversationsRequest {
	return ApiGroupsListConversationsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return CollectionOfConversation
func (a *GroupsConversationApiService) GroupsListConversationsExecute(r ApiGroupsListConversationsRequest) (CollectionOfConversation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionOfConversation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationApiService.GroupsListConversations")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/conversations"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("$search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, "csv"))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsUpdateConversationsRequest struct {
	ctx _context.Context
	ApiService *GroupsConversationApiService
	groupId string
	conversationId string
	microsoftGraphConversation *MicrosoftGraphConversation
}

// New navigation property values
func (r ApiGroupsUpdateConversationsRequest) MicrosoftGraphConversation(microsoftGraphConversation MicrosoftGraphConversation) ApiGroupsUpdateConversationsRequest {
	r.microsoftGraphConversation = &microsoftGraphConversation
	return r
}

func (r ApiGroupsUpdateConversationsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GroupsUpdateConversationsExecute(r)
}

/*
GroupsUpdateConversations Update the navigation property conversations in groups

The group's conversations.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId key: id of group
 @param conversationId key: id of conversation
 @return ApiGroupsUpdateConversationsRequest
*/
func (a *GroupsConversationApiService) GroupsUpdateConversations(ctx _context.Context, groupId string, conversationId string) ApiGroupsUpdateConversationsRequest {
	return ApiGroupsUpdateConversationsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		conversationId: conversationId,
	}
}

// Execute executes the request
func (a *GroupsConversationApiService) GroupsUpdateConversationsExecute(r ApiGroupsUpdateConversationsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsConversationApiService.GroupsUpdateConversations")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group-id}/conversations/{conversation-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group-id"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"conversation-id"+"}", _neturl.PathEscape(parameterToString(r.conversationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.microsoftGraphConversation == nil {
		return nil, reportError("microsoftGraphConversation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftGraphConversation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v OdataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
